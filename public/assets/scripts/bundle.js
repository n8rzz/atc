(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":2,"core-js/shim":295,"regenerator-runtime/runtime":518}],2:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;
},{"../../modules/_core":23,"../../modules/core.regexp.escape":119}],3:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],4:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};
},{"./_cof":18}],5:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":40,"./_wks":117}],6:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],7:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":49}],8:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};
},{"./_to-index":105,"./_to-length":108,"./_to-object":109}],9:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};
},{"./_to-index":105,"./_to-length":108,"./_to-object":109}],10:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":37}],11:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":105,"./_to-iobject":107,"./_to-length":108}],12:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":15,"./_ctx":25,"./_iobject":45,"./_to-length":108,"./_to-object":109}],13:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":3,"./_iobject":45,"./_to-length":108,"./_to-object":109}],14:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":47,"./_is-object":49,"./_wks":117}],15:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":14}],16:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":3,"./_invoke":44,"./_is-object":49}],17:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":18,"./_wks":117}],18:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],19:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":6,"./_ctx":25,"./_defined":27,"./_descriptors":28,"./_for-of":37,"./_iter-define":53,"./_iter-step":55,"./_meta":62,"./_object-create":66,"./_object-dp":67,"./_redefine-all":86,"./_set-species":91}],20:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":10,"./_classof":17}],21:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":6,"./_an-object":7,"./_array-methods":12,"./_for-of":37,"./_has":39,"./_is-object":49,"./_meta":62,"./_redefine-all":86}],22:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":6,"./_export":32,"./_fails":34,"./_for-of":37,"./_global":38,"./_inherit-if-required":43,"./_is-object":49,"./_iter-detect":54,"./_meta":62,"./_redefine":87,"./_redefine-all":86,"./_set-to-string-tag":92}],23:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],24:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":67,"./_property-desc":85}],25:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":3}],26:[function(require,module,exports){
'use strict';
var anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive')
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
},{"./_an-object":7,"./_to-primitive":110}],27:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],28:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":34}],29:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":38,"./_is-object":49}],30:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],31:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":73,"./_object-keys":76,"./_object-pie":77}],32:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":23,"./_ctx":25,"./_global":38,"./_hide":40,"./_redefine":87}],33:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":117}],34:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],35:[function(require,module,exports){
'use strict';
var hide     = require('./_hide')
  , redefine = require('./_redefine')
  , fails    = require('./_fails')
  , defined  = require('./_defined')
  , wks      = require('./_wks');

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};
},{"./_defined":27,"./_fails":34,"./_hide":40,"./_redefine":87,"./_wks":117}],36:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};
},{"./_an-object":7}],37:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":7,"./_ctx":25,"./_is-array-iter":46,"./_iter-call":51,"./_to-length":108,"./core.get-iterator-method":118}],38:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],39:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],40:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":28,"./_object-dp":67,"./_property-desc":85}],41:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":38}],42:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":28,"./_dom-create":29,"./_fails":34}],43:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":49,"./_set-proto":90}],44:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],45:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":18}],46:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":56,"./_wks":117}],47:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":18}],48:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./_is-object":49}],49:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],50:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":18,"./_is-object":49,"./_wks":117}],51:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":7}],52:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":40,"./_object-create":66,"./_property-desc":85,"./_set-to-string-tag":92,"./_wks":117}],53:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":32,"./_has":39,"./_hide":40,"./_iter-create":52,"./_iterators":56,"./_library":58,"./_object-gpo":74,"./_redefine":87,"./_set-to-string-tag":92,"./_wks":117}],54:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":117}],55:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],56:[function(require,module,exports){
module.exports = {};
},{}],57:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":76,"./_to-iobject":107}],58:[function(require,module,exports){
module.exports = false;
},{}],59:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
},{}],60:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],61:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],62:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":34,"./_has":39,"./_is-object":49,"./_object-dp":67,"./_uid":114}],63:[function(require,module,exports){
var Map     = require('./es6.map')
  , $export = require('./_export')
  , shared  = require('./_shared')('metadata')
  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};
},{"./_export":32,"./_shared":94,"./es6.map":149,"./es6.weak-map":255}],64:[function(require,module,exports){
var global    = require('./_global')
  , macrotask = require('./_task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./_cof')(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};
},{"./_cof":18,"./_global":38,"./_task":104}],65:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":34,"./_iobject":45,"./_object-gops":73,"./_object-keys":76,"./_object-pie":77,"./_to-object":109}],66:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":7,"./_dom-create":29,"./_enum-bug-keys":30,"./_html":41,"./_object-dps":68,"./_shared-key":93}],67:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":7,"./_descriptors":28,"./_ie8-dom-define":42,"./_to-primitive":110}],68:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":7,"./_descriptors":28,"./_object-dp":67,"./_object-keys":76}],69:[function(require,module,exports){
// Forced replacement prototype accessors methods
module.exports = require('./_library')|| !require('./_fails')(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete require('./_global')[K];
});
},{"./_fails":34,"./_global":38,"./_library":58}],70:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":28,"./_has":39,"./_ie8-dom-define":42,"./_object-pie":77,"./_property-desc":85,"./_to-iobject":107,"./_to-primitive":110}],71:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":72,"./_to-iobject":107}],72:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":30,"./_object-keys-internal":75}],73:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],74:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":39,"./_shared-key":93,"./_to-object":109}],75:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":11,"./_has":39,"./_shared-key":93,"./_to-iobject":107}],76:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":30,"./_object-keys-internal":75}],77:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],78:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":23,"./_export":32,"./_fails":34}],79:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":76,"./_object-pie":77,"./_to-iobject":107}],80:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN     = require('./_object-gopn')
  , gOPS     = require('./_object-gops')
  , anObject = require('./_an-object')
  , Reflect  = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./_an-object":7,"./_global":38,"./_object-gopn":72,"./_object-gops":73}],81:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat
  , $trim       = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
},{"./_global":38,"./_string-trim":102,"./_string-ws":103}],82:[function(require,module,exports){
var $parseInt = require('./_global').parseInt
  , $trim     = require('./_string-trim').trim
  , ws        = require('./_string-ws')
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;
},{"./_global":38,"./_string-trim":102,"./_string-ws":103}],83:[function(require,module,exports){
'use strict';
var path      = require('./_path')
  , invoke    = require('./_invoke')
  , aFunction = require('./_a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./_a-function":3,"./_invoke":44,"./_path":84}],84:[function(require,module,exports){
module.exports = require('./_global');
},{"./_global":38}],85:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],86:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":87}],87:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":23,"./_global":38,"./_has":39,"./_hide":40,"./_uid":114}],88:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],89:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],90:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":7,"./_ctx":25,"./_is-object":49,"./_object-gopd":70}],91:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":28,"./_global":38,"./_object-dp":67,"./_wks":117}],92:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":39,"./_object-dp":67,"./_wks":117}],93:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":94,"./_uid":114}],94:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":38}],95:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./_an-object')
  , aFunction = require('./_a-function')
  , SPECIES   = require('./_wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./_a-function":3,"./_an-object":7,"./_wks":117}],96:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":34}],97:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":27,"./_to-integer":106}],98:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":27,"./_is-regexp":50}],99:[function(require,module,exports){
var $export = require('./_export')
  , fails   = require('./_fails')
  , defined = require('./_defined')
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
},{"./_defined":27,"./_export":32,"./_fails":34}],100:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length')
  , repeat   = require('./_string-repeat')
  , defined  = require('./_defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":27,"./_string-repeat":101,"./_to-length":108}],101:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./_defined":27,"./_to-integer":106}],102:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":27,"./_export":32,"./_fails":34,"./_string-ws":103}],103:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],104:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":18,"./_ctx":25,"./_dom-create":29,"./_global":38,"./_html":41,"./_invoke":44}],105:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":106}],106:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],107:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":27,"./_iobject":45}],108:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":106}],109:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":27}],110:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":49}],111:[function(require,module,exports){
'use strict';
if(require('./_descriptors')){
  var LIBRARY             = require('./_library')
    , global              = require('./_global')
    , fails               = require('./_fails')
    , $export             = require('./_export')
    , $typed              = require('./_typed')
    , $buffer             = require('./_typed-buffer')
    , ctx                 = require('./_ctx')
    , anInstance          = require('./_an-instance')
    , propertyDesc        = require('./_property-desc')
    , hide                = require('./_hide')
    , redefineAll         = require('./_redefine-all')
    , toInteger           = require('./_to-integer')
    , toLength            = require('./_to-length')
    , toIndex             = require('./_to-index')
    , toPrimitive         = require('./_to-primitive')
    , has                 = require('./_has')
    , same                = require('./_same-value')
    , classof             = require('./_classof')
    , isObject            = require('./_is-object')
    , toObject            = require('./_to-object')
    , isArrayIter         = require('./_is-array-iter')
    , create              = require('./_object-create')
    , getPrototypeOf      = require('./_object-gpo')
    , gOPN                = require('./_object-gopn').f
    , getIterFn           = require('./core.get-iterator-method')
    , uid                 = require('./_uid')
    , wks                 = require('./_wks')
    , createArrayMethod   = require('./_array-methods')
    , createArrayIncludes = require('./_array-includes')
    , speciesConstructor  = require('./_species-constructor')
    , ArrayIterators      = require('./es6.array.iterator')
    , Iterators           = require('./_iterators')
    , $iterDetect         = require('./_iter-detect')
    , setSpecies          = require('./_set-species')
    , arrayFill           = require('./_array-fill')
    , arrayCopyWithin     = require('./_array-copy-within')
    , $DP                 = require('./_object-dp')
    , $GOPD               = require('./_object-gopd')
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };
},{"./_an-instance":6,"./_array-copy-within":8,"./_array-fill":9,"./_array-includes":11,"./_array-methods":12,"./_classof":17,"./_ctx":25,"./_descriptors":28,"./_export":32,"./_fails":34,"./_global":38,"./_has":39,"./_hide":40,"./_is-array-iter":46,"./_is-object":49,"./_iter-detect":54,"./_iterators":56,"./_library":58,"./_object-create":66,"./_object-dp":67,"./_object-gopd":70,"./_object-gopn":72,"./_object-gpo":74,"./_property-desc":85,"./_redefine-all":86,"./_same-value":89,"./_set-species":91,"./_species-constructor":95,"./_to-index":105,"./_to-integer":106,"./_to-length":108,"./_to-object":109,"./_to-primitive":110,"./_typed":113,"./_typed-buffer":112,"./_uid":114,"./_wks":117,"./core.get-iterator-method":118,"./es6.array.iterator":130}],112:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , DESCRIPTORS    = require('./_descriptors')
  , LIBRARY        = require('./_library')
  , $typed         = require('./_typed')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , fails          = require('./_fails')
  , anInstance     = require('./_an-instance')
  , toInteger      = require('./_to-integer')
  , toLength       = require('./_to-length')
  , gOPN           = require('./_object-gopn').f
  , dP             = require('./_object-dp').f
  , arrayFill      = require('./_array-fill')
  , setToStringTag = require('./_set-to-string-tag')
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
},{"./_an-instance":6,"./_array-fill":9,"./_descriptors":28,"./_fails":34,"./_global":38,"./_hide":40,"./_library":58,"./_object-dp":67,"./_object-gopn":72,"./_redefine-all":86,"./_set-to-string-tag":92,"./_to-integer":106,"./_to-length":108,"./_typed":113}],113:[function(require,module,exports){
var global = require('./_global')
  , hide   = require('./_hide')
  , uid    = require('./_uid')
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};
},{"./_global":38,"./_hide":40,"./_uid":114}],114:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],115:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":23,"./_global":38,"./_library":58,"./_object-dp":67,"./_wks-ext":116}],116:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":117}],117:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":38,"./_shared":94,"./_uid":114}],118:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":17,"./_core":23,"./_iterators":56,"./_wks":117}],119:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export')
  , $re     = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./_export":32,"./_replacer":88}],120:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});

require('./_add-to-unscopables')('copyWithin');
},{"./_add-to-unscopables":5,"./_array-copy-within":8,"./_export":32}],121:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $every  = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":12,"./_export":32,"./_strict-method":96}],122:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {fill: require('./_array-fill')});

require('./_add-to-unscopables')('fill');
},{"./_add-to-unscopables":5,"./_array-fill":9,"./_export":32}],123:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":12,"./_export":32,"./_strict-method":96}],124:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":5,"./_array-methods":12,"./_export":32}],125:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":5,"./_array-methods":12,"./_export":32}],126:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":12,"./_export":32,"./_strict-method":96}],127:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":24,"./_ctx":25,"./_export":32,"./_is-array-iter":46,"./_iter-call":51,"./_iter-detect":54,"./_to-length":108,"./_to-object":109,"./core.get-iterator-method":118}],128:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , $indexOf      = require('./_array-includes')(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});
},{"./_array-includes":11,"./_export":32,"./_strict-method":96}],129:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', {isArray: require('./_is-array')});
},{"./_export":32,"./_is-array":47}],130:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":5,"./_iter-define":53,"./_iter-step":55,"./_iterators":56,"./_to-iobject":107}],131:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
},{"./_export":32,"./_iobject":45,"./_strict-method":96,"./_to-iobject":107}],132:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , toIObject     = require('./_to-iobject')
  , toInteger     = require('./_to-integer')
  , toLength      = require('./_to-length')
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});
},{"./_export":32,"./_strict-method":96,"./_to-integer":106,"./_to-iobject":107,"./_to-length":108}],133:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $map    = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":12,"./_export":32,"./_strict-method":96}],134:[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":24,"./_export":32,"./_fails":34}],135:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
},{"./_array-reduce":13,"./_export":32,"./_strict-method":96}],136:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":13,"./_export":32,"./_strict-method":96}],137:[function(require,module,exports){
'use strict';
var $export    = require('./_export')
  , html       = require('./_html')
  , cof        = require('./_cof')
  , toIndex    = require('./_to-index')
  , toLength   = require('./_to-length')
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
},{"./_cof":18,"./_export":32,"./_fails":34,"./_html":41,"./_to-index":105,"./_to-length":108}],138:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $some   = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":12,"./_export":32,"./_strict-method":96}],139:[function(require,module,exports){
'use strict';
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , fails     = require('./_fails')
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});
},{"./_a-function":3,"./_export":32,"./_fails":34,"./_strict-method":96,"./_to-object":109}],140:[function(require,module,exports){
require('./_set-species')('Array');
},{"./_set-species":91}],141:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});
},{"./_export":32}],142:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export')
  , fails   = require('./_fails')
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./_export":32,"./_fails":34}],143:[function(require,module,exports){
'use strict';
var $export     = require('./_export')
  , toObject    = require('./_to-object')
  , toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
},{"./_export":32,"./_fails":34,"./_to-object":109,"./_to-primitive":110}],144:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));
},{"./_date-to-primitive":26,"./_hide":40,"./_wks":117}],145:[function(require,module,exports){
var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  require('./_redefine')(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
},{"./_redefine":87}],146:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":16,"./_export":32}],147:[function(require,module,exports){
'use strict';
var isObject       = require('./_is-object')
  , getPrototypeOf = require('./_object-gpo')
  , HAS_INSTANCE   = require('./_wks')('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});
},{"./_is-object":49,"./_object-dp":67,"./_object-gpo":74,"./_wks":117}],148:[function(require,module,exports){
var dP         = require('./_object-dp').f
  , createDesc = require('./_property-desc')
  , has        = require('./_has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});
},{"./_descriptors":28,"./_has":39,"./_object-dp":67,"./_property-desc":85}],149:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":22,"./_collection-strong":19}],150:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export')
  , log1p   = require('./_math-log1p')
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./_export":32,"./_math-log1p":60}],151:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export')
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});
},{"./_export":32}],152:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export')
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./_export":32}],153:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export')
  , sign    = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./_export":32,"./_math-sign":61}],154:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./_export":32}],155:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./_export":32}],156:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export')
  , $expm1  = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});
},{"./_export":32,"./_math-expm1":59}],157:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export   = require('./_export')
  , sign      = require('./_math-sign')
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./_export":32,"./_math-sign":61}],158:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export')
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./_export":32}],159:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export')
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./_export":32,"./_fails":34}],160:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./_export":32}],161:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', {log1p: require('./_math-log1p')});
},{"./_export":32,"./_math-log1p":60}],162:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./_export":32}],163:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":32,"./_math-sign":61}],164:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./_export":32,"./_fails":34,"./_math-expm1":59}],165:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./_export":32,"./_math-expm1":59}],166:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":32}],167:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":18,"./_descriptors":28,"./_fails":34,"./_global":38,"./_has":39,"./_inherit-if-required":43,"./_object-create":66,"./_object-dp":67,"./_object-gopd":70,"./_object-gopn":72,"./_redefine":87,"./_string-trim":102,"./_to-primitive":110}],168:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./_export":32}],169:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export   = require('./_export')
  , _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./_export":32,"./_global":38}],170:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', {isInteger: require('./_is-integer')});
},{"./_export":32,"./_is-integer":48}],171:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":32}],172:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export   = require('./_export')
  , isInteger = require('./_is-integer')
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./_export":32,"./_is-integer":48}],173:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":32}],174:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./_export":32}],175:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});
},{"./_export":32,"./_parse-float":81}],176:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});
},{"./_export":32,"./_parse-int":82}],177:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , toInteger    = require('./_to-integer')
  , aNumberValue = require('./_a-number-value')
  , repeat       = require('./_string-repeat')
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});
},{"./_a-number-value":4,"./_export":32,"./_fails":34,"./_string-repeat":101,"./_to-integer":106}],178:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $fails       = require('./_fails')
  , aNumberValue = require('./_a-number-value')
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});
},{"./_a-number-value":4,"./_export":32,"./_fails":34}],179:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":32,"./_object-assign":65}],180:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":32,"./_object-create":66}],181:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});
},{"./_descriptors":28,"./_export":32,"./_object-dps":68}],182:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":28,"./_export":32,"./_object-dp":67}],183:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
},{"./_is-object":49,"./_meta":62,"./_object-sap":78}],184:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":70,"./_object-sap":78,"./_to-iobject":107}],185:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function(){
  return require('./_object-gopn-ext').f;
});
},{"./_object-gopn-ext":71,"./_object-sap":78}],186:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":74,"./_object-sap":78,"./_to-object":109}],187:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./_is-object":49,"./_object-sap":78}],188:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./_is-object":49,"./_object-sap":78}],189:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./_is-object":49,"./_object-sap":78}],190:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":32,"./_same-value":89}],191:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":76,"./_object-sap":78,"./_to-object":109}],192:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
},{"./_is-object":49,"./_meta":62,"./_object-sap":78}],193:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
},{"./_is-object":49,"./_meta":62,"./_object-sap":78}],194:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":32,"./_set-proto":90}],195:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":17,"./_redefine":87,"./_wks":117}],196:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});
},{"./_export":32,"./_parse-float":81}],197:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});
},{"./_export":32,"./_parse-int":82}],198:[function(require,module,exports){
'use strict';
var LIBRARY            = require('./_library')
  , global             = require('./_global')
  , ctx                = require('./_ctx')
  , classof            = require('./_classof')
  , $export            = require('./_export')
  , isObject           = require('./_is-object')
  , aFunction          = require('./_a-function')
  , anInstance         = require('./_an-instance')
  , forOf              = require('./_for-of')
  , speciesConstructor = require('./_species-constructor')
  , task               = require('./_task').set
  , microtask          = require('./_microtask')()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./_a-function":3,"./_an-instance":6,"./_classof":17,"./_core":23,"./_ctx":25,"./_export":32,"./_for-of":37,"./_global":38,"./_is-object":49,"./_iter-detect":54,"./_library":58,"./_microtask":64,"./_redefine-all":86,"./_set-species":91,"./_set-to-string-tag":92,"./_species-constructor":95,"./_task":104,"./_wks":117}],199:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , anObject  = require('./_an-object')
  , rApply    = (require('./_global').Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
},{"./_a-function":3,"./_an-object":7,"./_export":32,"./_fails":34,"./_global":38}],200:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = require('./_export')
  , create     = require('./_object-create')
  , aFunction  = require('./_a-function')
  , anObject   = require('./_an-object')
  , isObject   = require('./_is-object')
  , fails      = require('./_fails')
  , bind       = require('./_bind')
  , rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./_a-function":3,"./_an-object":7,"./_bind":16,"./_export":32,"./_fails":34,"./_global":38,"./_is-object":49,"./_object-create":66}],201:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = require('./_object-dp')
  , $export     = require('./_export')
  , anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":7,"./_export":32,"./_fails":34,"./_object-dp":67,"./_to-primitive":110}],202:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = require('./_export')
  , gOPD     = require('./_object-gopd').f
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./_an-object":7,"./_export":32,"./_object-gopd":70}],203:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export  = require('./_export')
  , anObject = require('./_an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./_an-object":7,"./_export":32,"./_iter-create":52}],204:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = require('./_object-gopd')
  , $export  = require('./_export')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});
},{"./_an-object":7,"./_export":32,"./_object-gopd":70}],205:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = require('./_export')
  , getProto = require('./_object-gpo')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./_an-object":7,"./_export":32,"./_object-gpo":74}],206:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , isObject       = require('./_is-object')
  , anObject       = require('./_an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});
},{"./_an-object":7,"./_export":32,"./_has":39,"./_is-object":49,"./_object-gopd":70,"./_object-gpo":74}],207:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./_export":32}],208:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export       = require('./_export')
  , anObject      = require('./_an-object')
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./_an-object":7,"./_export":32}],209:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});
},{"./_export":32,"./_own-keys":80}],210:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export            = require('./_export')
  , anObject           = require('./_an-object')
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":7,"./_export":32}],211:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = require('./_export')
  , setProto = require('./_set-proto');

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_export":32,"./_set-proto":90}],212:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = require('./_object-dp')
  , gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , createDesc     = require('./_property-desc')
  , anObject       = require('./_an-object')
  , isObject       = require('./_is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});
},{"./_an-object":7,"./_export":32,"./_has":39,"./_is-object":49,"./_object-dp":67,"./_object-gopd":70,"./_object-gpo":74,"./_property-desc":85}],213:[function(require,module,exports){
var global            = require('./_global')
  , inheritIfRequired = require('./_inherit-if-required')
  , dP                = require('./_object-dp').f
  , gOPN              = require('./_object-gopn').f
  , isRegExp          = require('./_is-regexp')
  , $flags            = require('./_flags')
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');
},{"./_descriptors":28,"./_fails":34,"./_flags":36,"./_global":38,"./_inherit-if-required":43,"./_is-regexp":50,"./_object-dp":67,"./_object-gopn":72,"./_redefine":87,"./_set-species":91,"./_wks":117}],214:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});
},{"./_descriptors":28,"./_flags":36,"./_object-dp":67}],215:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
},{"./_fix-re-wks":35}],216:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
},{"./_fix-re-wks":35}],217:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
},{"./_fix-re-wks":35}],218:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = require('./_is-regexp')
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
},{"./_fix-re-wks":35,"./_is-regexp":50}],219:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject    = require('./_an-object')
  , $flags      = require('./_flags')
  , DESCRIPTORS = require('./_descriptors')
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}
},{"./_an-object":7,"./_descriptors":28,"./_fails":34,"./_flags":36,"./_redefine":87,"./es6.regexp.flags":214}],220:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":22,"./_collection-strong":19}],221:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});
},{"./_string-html":99}],222:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});
},{"./_string-html":99}],223:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});
},{"./_string-html":99}],224:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});
},{"./_string-html":99}],225:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $at     = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./_export":32,"./_string-at":97}],226:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export   = require('./_export')
  , toLength  = require('./_to-length')
  , context   = require('./_string-context')
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});
},{"./_export":32,"./_fails-is-regexp":33,"./_string-context":98,"./_to-length":108}],227:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});
},{"./_string-html":99}],228:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});
},{"./_string-html":99}],229:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});
},{"./_string-html":99}],230:[function(require,module,exports){
var $export        = require('./_export')
  , toIndex        = require('./_to-index')
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./_export":32,"./_to-index":105}],231:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":32,"./_fails-is-regexp":33,"./_string-context":98}],232:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});
},{"./_string-html":99}],233:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":53,"./_string-at":97}],234:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});
},{"./_string-html":99}],235:[function(require,module,exports){
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./_export":32,"./_to-iobject":107,"./_to-length":108}],236:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});
},{"./_export":32,"./_string-repeat":101}],237:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});
},{"./_string-html":99}],238:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export     = require('./_export')
  , toLength    = require('./_to-length')
  , context     = require('./_string-context')
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});
},{"./_export":32,"./_fails-is-regexp":33,"./_string-context":98,"./_to-length":108}],239:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});
},{"./_string-html":99}],240:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});
},{"./_string-html":99}],241:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});
},{"./_string-html":99}],242:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./_string-trim":102}],243:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":7,"./_descriptors":28,"./_enum-keys":31,"./_export":32,"./_fails":34,"./_global":38,"./_has":39,"./_hide":40,"./_is-array":47,"./_keyof":57,"./_library":58,"./_meta":62,"./_object-create":66,"./_object-dp":67,"./_object-gopd":70,"./_object-gopn":72,"./_object-gopn-ext":71,"./_object-gops":73,"./_object-keys":76,"./_object-pie":77,"./_property-desc":85,"./_redefine":87,"./_set-to-string-tag":92,"./_shared":94,"./_to-iobject":107,"./_to-primitive":110,"./_uid":114,"./_wks":117,"./_wks-define":115,"./_wks-ext":116}],244:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $typed       = require('./_typed')
  , buffer       = require('./_typed-buffer')
  , anObject     = require('./_an-object')
  , toIndex      = require('./_to-index')
  , toLength     = require('./_to-length')
  , isObject     = require('./_is-object')
  , ArrayBuffer  = require('./_global').ArrayBuffer
  , speciesConstructor = require('./_species-constructor')
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);
},{"./_an-object":7,"./_export":32,"./_fails":34,"./_global":38,"./_is-object":49,"./_set-species":91,"./_species-constructor":95,"./_to-index":105,"./_to-length":108,"./_typed":113,"./_typed-buffer":112}],245:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});
},{"./_export":32,"./_typed":113,"./_typed-buffer":112}],246:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],247:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],248:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],249:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],250:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],251:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],252:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],253:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":111}],254:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);
},{"./_typed-array":111}],255:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":12,"./_collection":22,"./_collection-weak":21,"./_is-object":49,"./_meta":62,"./_object-assign":65,"./_redefine":87}],256:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');

// 23.4 WeakSet Objects
require('./_collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./_collection":22,"./_collection-weak":21}],257:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export   = require('./_export')
  , $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');
},{"./_add-to-unscopables":5,"./_array-includes":11,"./_export":32}],258:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = require('./_export')
  , microtask = require('./_microtask')()
  , process   = require('./_global').process
  , isNode    = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});
},{"./_cof":18,"./_export":32,"./_global":38,"./_microtask":64}],259:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export')
  , cof     = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});
},{"./_cof":18,"./_export":32}],260:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":20,"./_export":32}],261:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
},{"./_export":32}],262:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
},{"./_export":32}],263:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
},{"./_export":32}],264:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
},{"./_export":32}],265:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":3,"./_descriptors":28,"./_export":32,"./_object-dp":67,"./_object-forced-pam":69,"./_to-object":109}],266:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":3,"./_descriptors":28,"./_export":32,"./_object-dp":67,"./_object-forced-pam":69,"./_to-object":109}],267:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":32,"./_object-to-array":79}],268:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = require('./_export')
  , ownKeys        = require('./_own-keys')
  , toIObject      = require('./_to-iobject')
  , gOPD           = require('./_object-gopd')
  , createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});
},{"./_create-property":24,"./_export":32,"./_object-gopd":70,"./_own-keys":80,"./_to-iobject":107}],269:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":28,"./_export":32,"./_object-forced-pam":69,"./_object-gopd":70,"./_object-gpo":74,"./_to-object":109,"./_to-primitive":110}],270:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":28,"./_export":32,"./_object-forced-pam":69,"./_object-gopd":70,"./_object-gpo":74,"./_to-object":109,"./_to-primitive":110}],271:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export')
  , $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./_export":32,"./_object-to-array":79}],272:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export     = require('./_export')
  , global      = require('./_global')
  , core        = require('./_core')
  , microtask   = require('./_microtask')()
  , OBSERVABLE  = require('./_wks')('observable')
  , aFunction   = require('./_a-function')
  , anObject    = require('./_an-object')
  , anInstance  = require('./_an-instance')
  , redefineAll = require('./_redefine-all')
  , hide        = require('./_hide')
  , forOf       = require('./_for-of')
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

require('./_set-species')('Observable');
},{"./_a-function":3,"./_an-instance":6,"./_an-object":7,"./_core":23,"./_export":32,"./_for-of":37,"./_global":38,"./_hide":40,"./_microtask":64,"./_redefine-all":86,"./_set-species":91,"./_wks":117}],273:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});
},{"./_an-object":7,"./_metadata":63}],274:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});
},{"./_an-object":7,"./_metadata":63}],275:[function(require,module,exports){
var Set                     = require('./es6.set')
  , from                    = require('./_array-from-iterable')
  , metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , getPrototypeOf          = require('./_object-gpo')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":7,"./_array-from-iterable":10,"./_metadata":63,"./_object-gpo":74,"./es6.set":220}],276:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":7,"./_metadata":63,"./_object-gpo":74}],277:[function(require,module,exports){
var metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":7,"./_metadata":63}],278:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":7,"./_metadata":63}],279:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":7,"./_metadata":63,"./_object-gpo":74}],280:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":7,"./_metadata":63}],281:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , aFunction                 = require('./_a-function')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});
},{"./_a-function":3,"./_an-object":7,"./_metadata":63}],282:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":20,"./_export":32}],283:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export')
  , $at     = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./_export":32,"./_string-at":97}],284:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export     = require('./_export')
  , defined     = require('./_defined')
  , toLength    = require('./_to-length')
  , isRegExp    = require('./_is-regexp')
  , getFlags    = require('./_flags')
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});
},{"./_defined":27,"./_export":32,"./_flags":36,"./_is-regexp":50,"./_iter-create":52,"./_to-length":108}],285:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});
},{"./_export":32,"./_string-pad":100}],286:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});
},{"./_export":32,"./_string-pad":100}],287:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');
},{"./_string-trim":102}],288:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');
},{"./_string-trim":102}],289:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":115}],290:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":115}],291:[function(require,module,exports){
// https://github.com/ljharb/proposal-global
var $export = require('./_export');

$export($export.S, 'System', {global: require('./_global')});
},{"./_export":32,"./_global":38}],292:[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":38,"./_hide":40,"./_iterators":56,"./_redefine":87,"./_wks":117,"./es6.array.iterator":130}],293:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":32,"./_task":104}],294:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./_global')
  , $export    = require('./_export')
  , invoke     = require('./_invoke')
  , partial    = require('./_partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./_export":32,"./_global":38,"./_invoke":44,"./_partial":83}],295:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.umulh');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');
},{"./modules/_core":23,"./modules/es6.array.copy-within":120,"./modules/es6.array.every":121,"./modules/es6.array.fill":122,"./modules/es6.array.filter":123,"./modules/es6.array.find":125,"./modules/es6.array.find-index":124,"./modules/es6.array.for-each":126,"./modules/es6.array.from":127,"./modules/es6.array.index-of":128,"./modules/es6.array.is-array":129,"./modules/es6.array.iterator":130,"./modules/es6.array.join":131,"./modules/es6.array.last-index-of":132,"./modules/es6.array.map":133,"./modules/es6.array.of":134,"./modules/es6.array.reduce":136,"./modules/es6.array.reduce-right":135,"./modules/es6.array.slice":137,"./modules/es6.array.some":138,"./modules/es6.array.sort":139,"./modules/es6.array.species":140,"./modules/es6.date.now":141,"./modules/es6.date.to-iso-string":142,"./modules/es6.date.to-json":143,"./modules/es6.date.to-primitive":144,"./modules/es6.date.to-string":145,"./modules/es6.function.bind":146,"./modules/es6.function.has-instance":147,"./modules/es6.function.name":148,"./modules/es6.map":149,"./modules/es6.math.acosh":150,"./modules/es6.math.asinh":151,"./modules/es6.math.atanh":152,"./modules/es6.math.cbrt":153,"./modules/es6.math.clz32":154,"./modules/es6.math.cosh":155,"./modules/es6.math.expm1":156,"./modules/es6.math.fround":157,"./modules/es6.math.hypot":158,"./modules/es6.math.imul":159,"./modules/es6.math.log10":160,"./modules/es6.math.log1p":161,"./modules/es6.math.log2":162,"./modules/es6.math.sign":163,"./modules/es6.math.sinh":164,"./modules/es6.math.tanh":165,"./modules/es6.math.trunc":166,"./modules/es6.number.constructor":167,"./modules/es6.number.epsilon":168,"./modules/es6.number.is-finite":169,"./modules/es6.number.is-integer":170,"./modules/es6.number.is-nan":171,"./modules/es6.number.is-safe-integer":172,"./modules/es6.number.max-safe-integer":173,"./modules/es6.number.min-safe-integer":174,"./modules/es6.number.parse-float":175,"./modules/es6.number.parse-int":176,"./modules/es6.number.to-fixed":177,"./modules/es6.number.to-precision":178,"./modules/es6.object.assign":179,"./modules/es6.object.create":180,"./modules/es6.object.define-properties":181,"./modules/es6.object.define-property":182,"./modules/es6.object.freeze":183,"./modules/es6.object.get-own-property-descriptor":184,"./modules/es6.object.get-own-property-names":185,"./modules/es6.object.get-prototype-of":186,"./modules/es6.object.is":190,"./modules/es6.object.is-extensible":187,"./modules/es6.object.is-frozen":188,"./modules/es6.object.is-sealed":189,"./modules/es6.object.keys":191,"./modules/es6.object.prevent-extensions":192,"./modules/es6.object.seal":193,"./modules/es6.object.set-prototype-of":194,"./modules/es6.object.to-string":195,"./modules/es6.parse-float":196,"./modules/es6.parse-int":197,"./modules/es6.promise":198,"./modules/es6.reflect.apply":199,"./modules/es6.reflect.construct":200,"./modules/es6.reflect.define-property":201,"./modules/es6.reflect.delete-property":202,"./modules/es6.reflect.enumerate":203,"./modules/es6.reflect.get":206,"./modules/es6.reflect.get-own-property-descriptor":204,"./modules/es6.reflect.get-prototype-of":205,"./modules/es6.reflect.has":207,"./modules/es6.reflect.is-extensible":208,"./modules/es6.reflect.own-keys":209,"./modules/es6.reflect.prevent-extensions":210,"./modules/es6.reflect.set":212,"./modules/es6.reflect.set-prototype-of":211,"./modules/es6.regexp.constructor":213,"./modules/es6.regexp.flags":214,"./modules/es6.regexp.match":215,"./modules/es6.regexp.replace":216,"./modules/es6.regexp.search":217,"./modules/es6.regexp.split":218,"./modules/es6.regexp.to-string":219,"./modules/es6.set":220,"./modules/es6.string.anchor":221,"./modules/es6.string.big":222,"./modules/es6.string.blink":223,"./modules/es6.string.bold":224,"./modules/es6.string.code-point-at":225,"./modules/es6.string.ends-with":226,"./modules/es6.string.fixed":227,"./modules/es6.string.fontcolor":228,"./modules/es6.string.fontsize":229,"./modules/es6.string.from-code-point":230,"./modules/es6.string.includes":231,"./modules/es6.string.italics":232,"./modules/es6.string.iterator":233,"./modules/es6.string.link":234,"./modules/es6.string.raw":235,"./modules/es6.string.repeat":236,"./modules/es6.string.small":237,"./modules/es6.string.starts-with":238,"./modules/es6.string.strike":239,"./modules/es6.string.sub":240,"./modules/es6.string.sup":241,"./modules/es6.string.trim":242,"./modules/es6.symbol":243,"./modules/es6.typed.array-buffer":244,"./modules/es6.typed.data-view":245,"./modules/es6.typed.float32-array":246,"./modules/es6.typed.float64-array":247,"./modules/es6.typed.int16-array":248,"./modules/es6.typed.int32-array":249,"./modules/es6.typed.int8-array":250,"./modules/es6.typed.uint16-array":251,"./modules/es6.typed.uint32-array":252,"./modules/es6.typed.uint8-array":253,"./modules/es6.typed.uint8-clamped-array":254,"./modules/es6.weak-map":255,"./modules/es6.weak-set":256,"./modules/es7.array.includes":257,"./modules/es7.asap":258,"./modules/es7.error.is-error":259,"./modules/es7.map.to-json":260,"./modules/es7.math.iaddh":261,"./modules/es7.math.imulh":262,"./modules/es7.math.isubh":263,"./modules/es7.math.umulh":264,"./modules/es7.object.define-getter":265,"./modules/es7.object.define-setter":266,"./modules/es7.object.entries":267,"./modules/es7.object.get-own-property-descriptors":268,"./modules/es7.object.lookup-getter":269,"./modules/es7.object.lookup-setter":270,"./modules/es7.object.values":271,"./modules/es7.observable":272,"./modules/es7.reflect.define-metadata":273,"./modules/es7.reflect.delete-metadata":274,"./modules/es7.reflect.get-metadata":276,"./modules/es7.reflect.get-metadata-keys":275,"./modules/es7.reflect.get-own-metadata":278,"./modules/es7.reflect.get-own-metadata-keys":277,"./modules/es7.reflect.has-metadata":279,"./modules/es7.reflect.has-own-metadata":280,"./modules/es7.reflect.metadata":281,"./modules/es7.set.to-json":282,"./modules/es7.string.at":283,"./modules/es7.string.match-all":284,"./modules/es7.string.pad-end":285,"./modules/es7.string.pad-start":286,"./modules/es7.string.trim-left":287,"./modules/es7.string.trim-right":288,"./modules/es7.symbol.async-iterator":289,"./modules/es7.symbol.observable":290,"./modules/es7.system.global":291,"./modules/web.dom.iterable":292,"./modules/web.immediate":293,"./modules/web.timers":294}],296:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.1.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-09-22T22:30Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( jQuery.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}





return jQuery;
} );

},{}],297:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":397,"./_root":442}],298:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":407,"./_hashDelete":408,"./_hashGet":409,"./_hashHas":410,"./_hashSet":411}],299:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":422,"./_listCacheDelete":423,"./_listCacheGet":424,"./_listCacheHas":425,"./_listCacheSet":426}],300:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":397,"./_root":442}],301:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":427,"./_mapCacheDelete":428,"./_mapCacheGet":429,"./_mapCacheHas":430,"./_mapCacheSet":431}],302:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":397,"./_root":442}],303:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":397,"./_root":442}],304:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":301,"./_setCacheAdd":443,"./_setCacheHas":444}],305:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":299,"./_stackClear":448,"./_stackDelete":449,"./_stackGet":450,"./_stackHas":451,"./_stackSet":452}],306:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":442}],307:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":442}],308:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":397,"./_root":442}],309:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],310:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],311:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],312:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],313:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":340}],314:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],315:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":361,"./_isIndex":415,"./isArguments":475,"./isArray":476,"./isBuffer":479,"./isTypedArray":491}],316:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],317:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],318:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],319:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],320:[function(require,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],321:[function(require,module,exports){
/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;

},{}],322:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":326,"./eq":465}],323:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":465}],324:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":378,"./keys":492}],325:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":378,"./keysIn":493}],326:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":388}],327:[function(require,module,exports){
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;

},{}],328:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":305,"./_arrayEach":312,"./_assignValue":322,"./_baseAssign":324,"./_baseAssignIn":325,"./_cloneBuffer":370,"./_copyArray":377,"./_copySymbols":379,"./_copySymbolsIn":380,"./_getAllKeys":393,"./_getAllKeysIn":394,"./_getTag":402,"./_initCloneArray":412,"./_initCloneByTag":413,"./_initCloneObject":414,"./isArray":476,"./isBuffer":479,"./isObject":487,"./keys":492}],329:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":487}],330:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":304,"./_arrayIncludes":313,"./_arrayIncludesWith":314,"./_arrayMap":316,"./_baseUnary":363,"./_cacheHas":365}],331:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":334,"./_createBaseEach":382}],332:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],333:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":383}],334:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":333,"./keys":492}],335:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":367,"./_toKey":456}],336:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":317,"./isArray":476}],337:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  value = Object(value);
  return (symToStringTag && symToStringTag in value)
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":306,"./_getRawTag":399,"./_objectToString":439}],338:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

},{}],339:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],340:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":332,"./_baseIsNaN":345,"./_strictIndexOf":453}],341:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":337,"./isObjectLike":488}],342:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObject = require('./isObject'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":343,"./isObject":487,"./isObjectLike":488}],343:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":305,"./_equalArrays":389,"./_equalByTag":390,"./_equalObjects":391,"./_getTag":402,"./isArray":476,"./isBuffer":479,"./isTypedArray":491}],344:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":305,"./_baseIsEqual":342}],345:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],346:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":419,"./_toSource":457,"./isFunction":482,"./isObject":487}],347:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":337,"./isLength":483,"./isObjectLike":488}],348:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":352,"./_baseMatchesProperty":353,"./identity":473,"./isArray":476,"./property":499}],349:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":420,"./_nativeKeys":436}],350:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":420,"./_nativeKeysIn":437,"./isObject":487}],351:[function(require,module,exports){
var baseEach = require('./_baseEach'),
    isArrayLike = require('./isArrayLike');

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":331,"./isArrayLike":477}],352:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":344,"./_getMatchData":396,"./_matchesStrictComparable":433}],353:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":342,"./_isKey":417,"./_isStrictComparable":421,"./_matchesStrictComparable":433,"./_toKey":456,"./get":469,"./hasIn":471}],354:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],355:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":335}],356:[function(require,module,exports){
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;

},{}],357:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

},{}],358:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":441,"./_setToString":446,"./identity":473}],359:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":388,"./constant":463,"./identity":473}],360:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],361:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],362:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":306,"./_arrayMap":316,"./isArray":476,"./isSymbol":490}],363:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],364:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":316}],365:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],366:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":473}],367:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":417,"./_stringToPath":455,"./isArray":476,"./toString":509}],368:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":360}],369:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":307}],370:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":442}],371:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":369}],372:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":309,"./_arrayReduce":318,"./_mapToArray":432}],373:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],374:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":310,"./_arrayReduce":318,"./_setToArray":445}],375:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":306}],376:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":369}],377:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],378:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":322,"./_baseAssignValue":326}],379:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":378,"./_getSymbols":400}],380:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":378,"./_getSymbolsIn":401}],381:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":442}],382:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":477}],383:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],384:[function(require,module,exports){
var castSlice = require('./_castSlice'),
    hasUnicode = require('./_hasUnicode'),
    stringToArray = require('./_stringToArray'),
    toString = require('./toString');

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;

},{"./_castSlice":368,"./_hasUnicode":405,"./_stringToArray":454,"./toString":509}],385:[function(require,module,exports){
var arrayReduce = require('./_arrayReduce'),
    deburr = require('./deburr'),
    words = require('./words');

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;

},{"./_arrayReduce":318,"./deburr":464,"./words":514}],386:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    isArrayLike = require('./isArrayLike'),
    keys = require('./keys');

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;

},{"./_baseIteratee":348,"./isArrayLike":477,"./keys":492}],387:[function(require,module,exports){
var basePropertyOf = require('./_basePropertyOf');

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;

},{"./_basePropertyOf":356}],388:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":397}],389:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":304,"./_arraySome":319,"./_cacheHas":365}],390:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":306,"./_Uint8Array":307,"./_equalArrays":389,"./_mapToArray":432,"./_setToArray":445,"./eq":465}],391:[function(require,module,exports){
var keys = require('./keys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./keys":492}],392:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],393:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":336,"./_getSymbols":400,"./keys":492}],394:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":336,"./_getSymbolsIn":401,"./keysIn":493}],395:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":418}],396:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":421,"./keys":492}],397:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":346,"./_getValue":403}],398:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":440}],399:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":306}],400:[function(require,module,exports){
var overArg = require('./_overArg'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

module.exports = getSymbols;

},{"./_overArg":440,"./stubArray":503}],401:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":317,"./_getPrototype":398,"./_getSymbols":400,"./stubArray":503}],402:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":297,"./_Map":300,"./_Promise":302,"./_Set":303,"./_WeakMap":308,"./_baseGetTag":337,"./_toSource":457}],403:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],404:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":367,"./_isIndex":415,"./_toKey":456,"./isArguments":475,"./isArray":476,"./isLength":483}],405:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],406:[function(require,module,exports){
/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;

},{}],407:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":435}],408:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],409:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":435}],410:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":435}],411:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":435}],412:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],413:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":369,"./_cloneDataView":371,"./_cloneMap":372,"./_cloneRegExp":373,"./_cloneSet":374,"./_cloneSymbol":375,"./_cloneTypedArray":376}],414:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":329,"./_getPrototype":398,"./_isPrototype":420}],415:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],416:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":415,"./eq":465,"./isArrayLike":477,"./isObject":487}],417:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":476,"./isSymbol":490}],418:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],419:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":381}],420:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],421:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":487}],422:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],423:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":323}],424:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":323}],425:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":323}],426:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":323}],427:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":298,"./_ListCache":299,"./_Map":300}],428:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":395}],429:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":395}],430:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":395}],431:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":395}],432:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],433:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],434:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":498}],435:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":397}],436:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":440}],437:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],438:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":392}],439:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],440:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],441:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":311}],442:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":392}],443:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],444:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],445:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],446:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":359,"./_shortOut":447}],447:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],448:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":299}],449:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],450:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],451:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],452:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":299,"./_Map":300,"./_MapCache":301}],453:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],454:[function(require,module,exports){
var asciiToArray = require('./_asciiToArray'),
    hasUnicode = require('./_hasUnicode'),
    unicodeToArray = require('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":320,"./_hasUnicode":405,"./_unicodeToArray":458}],455:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":434}],456:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":490}],457:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],458:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],459:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
    rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;

},{}],460:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":328}],461:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":328}],462:[function(require,module,exports){
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = compact;

},{}],463:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],464:[function(require,module,exports){
var deburrLetter = require('./_deburrLetter'),
    toString = require('./toString');

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;

},{"./_deburrLetter":387,"./toString":509}],465:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],466:[function(require,module,exports){
var createFind = require('./_createFind'),
    findIndex = require('./findIndex');

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;

},{"./_createFind":386,"./findIndex":467}],467:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIteratee = require('./_baseIteratee'),
    toInteger = require('./toInteger');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

},{"./_baseFindIndex":332,"./_baseIteratee":348,"./toInteger":507}],468:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":312,"./_baseEach":331,"./_castFunction":366,"./isArray":476}],469:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":335}],470:[function(require,module,exports){
var baseHas = require('./_baseHas'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

},{"./_baseHas":338,"./_hasPath":404}],471:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":339,"./_hasPath":404}],472:[function(require,module,exports){
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;

},{}],473:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],474:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":340,"./isArrayLike":477,"./isString":489,"./toInteger":507,"./values":512}],475:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":341,"./isObjectLike":488}],476:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],477:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":482,"./isLength":483}],478:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":477,"./isObjectLike":488}],479:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":442,"./stubFalse":504}],480:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":349,"./_getTag":402,"./_isPrototype":420,"./isArguments":475,"./isArray":476,"./isArrayLike":477,"./isBuffer":479,"./isTypedArray":491}],481:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":342}],482:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":337,"./isObject":487}],483:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],484:[function(require,module,exports){
var isNumber = require('./isNumber');

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is based on
 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
 * `undefined` and other non-number values.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */
function isNaN(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value) && value != +value;
}

module.exports = isNaN;

},{"./isNumber":486}],485:[function(require,module,exports){
/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

module.exports = isNil;

},{}],486:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":337,"./isObjectLike":488}],487:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],488:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],489:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":337,"./isArray":476,"./isObjectLike":488}],490:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":337,"./isObjectLike":488}],491:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":347,"./_baseUnary":363,"./_nodeUtil":438}],492:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":315,"./_baseKeys":349,"./isArrayLike":477}],493:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":315,"./_baseKeysIn":350,"./isArrayLike":477}],494:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],495:[function(require,module,exports){
var createCompounder = require('./_createCompounder');

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

module.exports = lowerCase;

},{"./_createCompounder":385}],496:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    isArray = require('./isArray');

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

},{"./_arrayMap":316,"./_baseIteratee":348,"./_baseMap":351,"./isArray":476}],497:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;

},{"./_baseAssignValue":326,"./_baseForOwn":334,"./_baseIteratee":348}],498:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":301}],499:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":354,"./_basePropertyDeep":355,"./_isKey":417,"./_toKey":456}],500:[function(require,module,exports){
var baseRandom = require('./_baseRandom'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/** Built-in method references without a dependency on `root`. */
var freeParseFloat = parseFloat;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min,
    nativeRandom = Math.random;

/**
 * Produces a random number between the inclusive `lower` and `upper` bounds.
 * If only one argument is provided a number between `0` and the given number
 * is returned. If `floating` is `true`, or either `lower` or `upper` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @example
 *
 * _.random(0, 5);
 * // => an integer between 0 and 5
 *
 * _.random(5);
 * // => also an integer between 0 and 5
 *
 * _.random(5, true);
 * // => a floating-point number between 0 and 5
 *
 * _.random(1.2, 5.2);
 * // => a floating-point number between 1.2 and 5.2
 */
function random(lower, upper, floating) {
  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
    upper = floating = undefined;
  }
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper;
      upper = undefined;
    }
    else if (typeof lower == 'boolean') {
      floating = lower;
      lower = undefined;
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0;
    upper = 1;
  }
  else {
    lower = toFinite(lower);
    if (upper === undefined) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  }
  return baseRandom(lower, upper);
}

module.exports = random;

},{"./_baseRandom":357,"./_isIterateeCall":416,"./toFinite":506}],501:[function(require,module,exports){
var createCompounder = require('./_createCompounder'),
    upperFirst = require('./upperFirst');

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst(word);
});

module.exports = startCase;

},{"./_createCompounder":385,"./upperFirst":511}],502:[function(require,module,exports){
var baseClamp = require('./_baseClamp'),
    baseToString = require('./_baseToString'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = baseClamp(toInteger(position), 0, string.length);
  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

module.exports = startsWith;

},{"./_baseClamp":327,"./_baseToString":362,"./toInteger":507,"./toString":509}],503:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],504:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],505:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice(array, 1, length) : [];
}

module.exports = tail;

},{"./_baseSlice":360}],506:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":508}],507:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":506}],508:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":487,"./isSymbol":490}],509:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":362}],510:[function(require,module,exports){
var toString = require('./toString');

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;

},{"./toString":509}],511:[function(require,module,exports){
var createCaseFirst = require('./_createCaseFirst');

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;

},{"./_createCaseFirst":384}],512:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":364,"./keys":492}],513:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;

},{"./_baseDifference":330,"./_baseRest":358,"./isArrayLikeObject":478}],514:[function(require,module,exports){
var asciiWords = require('./_asciiWords'),
    hasUnicodeWord = require('./_hasUnicodeWord'),
    toString = require('./toString'),
    unicodeWords = require('./_unicodeWords');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;

},{"./_asciiWords":321,"./_hasUnicodeWord":406,"./_unicodeWords":459,"./toString":509}],515:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":516}],516:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],517:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":515}],518:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":516}],519:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _ContentQueue = require('./contentQueue/ContentQueue');

var _ContentQueue2 = _interopRequireDefault(_ContentQueue);

var _LoadingView = require('./LoadingView');

var _LoadingView2 = _interopRequireDefault(_LoadingView);

var _AirportController = require('./airport/AirportController');

var _AirportController2 = _interopRequireDefault(_AirportController);

var _GameController = require('./game/GameController');

var _GameController2 = _interopRequireDefault(_GameController);

var _TutorialView = require('./tutorial/TutorialView');

var _TutorialView2 = _interopRequireDefault(_TutorialView);

var _InputController = require('./InputController');

var _InputController2 = _interopRequireDefault(_InputController);

var _UiController = require('./UiController');

var _UiController2 = _interopRequireDefault(_UiController);

var _CanvasController = require('./canvas/CanvasController');

var _CanvasController2 = _interopRequireDefault(_CanvasController);

var _GameClockView = require('./game/GameClockView');

var _GameClockView2 = _interopRequireDefault(_GameClockView);

var _speech = require('./speech');

var _timeHelpers = require('./utilities/timeHelpers');

var _logLevel = require('./constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

window.zlsa = {};
window.zlsa.atc = {};
var prop = {};

// IIEFs are pulled in here to add functions to the global space.
//
// This will need to be re-worked, and current global functions should be exported and
// imported as needed in each file.
require('./util');

// saved as this.prop.version and this.prop.version_string
var VERSION = [3, 2, 0];

// are you using a main loop? (you must call update() afterward disable/re-enable)
var UPDATE = true;

// the framerate is updated this often (seconds)
var FRAME_DELAY = 1;

// is this a release build?
var RELEASE = false;

/**
 * @class App
 */

var App = function () {
    /**
     * @for App
     * @constructor
     * @param $element {HTML Element|null}
     * @param airportLoadList {array<object>}  List of airports to load
     */
    function App(element, airportLoadList) {
        var _this = this;

        _classCallCheck(this, App);

        this.getDeltaTime = function () {
            return _this.prop.time.frame.delta;
        };

        this.updateRun = function (shouldUpdate) {
            // console.warn('updateRun: ', shouldUpdate);
            if (!UPDATE && shouldUpdate) {
                requestAnimationFrame(function () {
                    return _this.update();
                });
            }

            UPDATE = shouldUpdate;
        };

        /**
         * Root DOM element.
         *
         * @property $element
         * @type {jQuery|HTML Element}
         * @default body
         */
        this.$element = (0, _jquery2.default)(element);
        this.loadingView = null;
        this.contentQueue = null;
        this.airportController = null;
        this.tutorialView = null;
        this.inputController = null;
        this.uiController = null;
        this.canvasController = null;

        window.prop = prop;

        this.prop = prop;
        this.prop.complete = false;
        this.prop.temp = 'nothing here';
        this.prop.version = VERSION;
        this.prop.version_string = 'v' + VERSION.join('.');
        this.prop.time = {};
        this.prop.time.start = (0, _timeHelpers.time)();
        this.prop.time.frames = 0;
        this.prop.time.frame = {};
        this.prop.time.frame.start = (0, _timeHelpers.time)();
        this.prop.time.frame.delay = FRAME_DELAY;
        this.prop.time.frame.count = 0;
        this.prop.time.frame.last = (0, _timeHelpers.time)();
        this.prop.time.frame.delta = 0;
        this.prop.time.fps = 0;
        this.prop.log = _logLevel.LOG.DEBUG;
        this.prop.loaded = false;

        if (RELEASE) {
            this.prop.log = _logLevel.LOG.WARNING;
        }

        return this.setupChildren(airportLoadList).enable();
    }

    /**
     * Lifecycle method. Should be called only once on initialization.
     *
     * Used to setup properties and initialize dependant classes.
     *
     * @for App
     * @method setupChildren
     * @param airportLoadList {array<object>}  List of airports to load
     */


    _createClass(App, [{
        key: 'setupChildren',
        value: function setupChildren(airportLoadList) {
            this.loadingView = new _LoadingView2.default();
            this.contentQueue = new _ContentQueue2.default(this.loadingView);
            this.airportController = new _AirportController2.default(airportLoadList, this.updateRun);
            this.gameController = new _GameController2.default(this.getDeltaTime);
            this.tutorialView = new _TutorialView2.default(this.$element);
            this.inputController = new _InputController2.default(this.$element);
            this.uiController = new _UiController2.default(this.$element);
            this.canvasController = new _CanvasController2.default(this.$element);
            this.gameClockView = new _GameClockView2.default(this.$element);

            return this;
        }

        /**
         * Lifecycle method. Should be called only once on initialization.
         *
         * Used to fire off `init` and `init_pre` methods and also start the game loop
         *
         * @for App
         * @method enable
         */

    }, {
        key: 'enable',
        value: function enable() {
            var _this2 = this;

            zlsa.atc.loadAsset = function (options) {
                return _this2.contentQueue.add(options);
            };
            // TEMPORARY!
            // these instances are attached to the window here as an intermediate step away from global functions.
            // this allows for any module file to call window.{module}.{method} and will make the transition to
            // explicit instance parameters easier.
            window.airportController = this.airportController;
            window.gameController = this.gameController;
            window.tutorialView = this.tutorialView;
            window.inputController = this.inputController;
            window.uiController = this.uiController;
            window.canvasController = this.canvasController;

            log('Version ' + this.prop.version_string);

            return this.init_pre().init().done();
        }

        /**
         * @for App
         * @method disable
         */

    }, {
        key: 'disable',
        value: function disable() {
            return this.destroy();
        }

        /**
         * Tear down the application
         *
         * Should never be called directly, only cia `this.disable()`
         *
         * @for App
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$element = null;
            this.contentQueue = null;
            this.loadingView = null;
            this.airportController = null;
            this.gameController = null;
            this.tutorialView = null;
            this.inputController = null;
            this.uiController = null;
            this.canvasController = null;

            return this;
        }

        // === CALLBACKS (all optional and do not need to be defined) ===
        // INIT:
        // module_init_pre()
        // module_init()
        // module_init_post()

        // module_done()
        // -- wait until all async has finished (could take a long time)
        // module_ready()
        // -- wait until first frame is ready (only triggered if UPDATE == true)
        // module_complete()

        // UPDATE:
        // module_update_pre()
        // module_update()
        // module_update_post()

        // RESIZE (called at least once during init and whenever page changes size)
        // module_resize()

        /**
         * @for App
         * @method init_pre
         */

    }, {
        key: 'init_pre',
        value: function init_pre() {
            this.tutorialView.tutorial_init_pre();
            this.gameController.init_pre();
            this.inputController.input_init_pre();
            this.airportController.init_pre();
            this.canvasController.canvas_init_pre();
            this.uiController.ui_init_pre();

            return this;
        }

        /**
         * @for App
         * @method init
         */

    }, {
        key: 'init',
        value: function init() {
            (0, _speech.speech_init)();

            this.airportController.init();
            this.canvasController.canvas_init();
            this.uiController.ui_init();

            return this;
        }

        /**
         * @for App
         * @method init_post
         */

    }, {
        key: 'init_post',
        value: function init_post() {
            return this;
        }

        /**
         * @for App
         * @method done
         */

    }, {
        key: 'done',
        value: function done() {
            var _this3 = this;

            (0, _jquery2.default)(window).resize(this.resize);
            this.resize();

            this.prop.loaded = true;

            this.ready();

            if (UPDATE) {
                requestAnimationFrame(function () {
                    return _this3.update();
                });
            }

            return this;
        }

        /**
         * @for App
         * @method ready
         */

    }, {
        key: 'ready',
        value: function ready() {
            this.airportController.ready();

            return this;
        }

        /**
         * @for App
         * @method resize
         */

    }, {
        key: 'resize',
        value: function resize() {
            this.canvasController.canvas_resize();

            return this;
        }

        /**
         * @for App
         * @method complete
         */

    }, {
        key: 'complete',
        value: function complete() {
            this.gameController.complete();
            this.canvasController.canvas_complete();
            this.uiController.ui_complete();

            return this;
        }

        /**
         * @for App
         * @method updatePre
         */

    }, {
        key: 'updatePre',
        value: function updatePre() {
            this.gameController.update_pre();

            return this;
        }

        /**
         * @for App
         * @method updatePost
         */

    }, {
        key: 'updatePost',
        value: function updatePost() {
            this.canvasController.canvas_update_post();

            return this;
        }

        /**
         * @for App
         * @method update
         */

    }, {
        key: 'update',
        value: function update() {
            var _this4 = this;

            if (!this.prop.complete) {
                this.complete();
                this.loadingView.complete();

                this.prop.complete = true;
            }

            if (!UPDATE) {
                return this;
            }

            requestAnimationFrame(function () {
                return _this4.update();
            });

            this.updatePre();
            this.airportController.recalculate();
            this.updatePost();
            this.incrementFrame();
            this.gameClockView.update();

            return this;
        }

        /**
         * @for App
         * @method incrementFrame
         */

    }, {
        key: 'incrementFrame',
        value: function incrementFrame() {
            var currentTime = (0, _timeHelpers.time)();
            var elapsed = currentTime - this.prop.time.frame.start;

            this.prop.time.frames += 1;
            this.prop.time.frame.count += 1;

            if (elapsed > this.prop.time.frame.delay) {
                this.prop.time.fps = this.prop.time.frame.count / elapsed;
                this.prop.time.frame.count = 0;
                this.prop.time.frame.start = currentTime;
            }

            this.prop.time.frame.delta = (0, _timeHelpers.calculateDeltaTime)(this.prop.time.frame.last);
            this.prop.time.frame.last = currentTime;
        }

        /**
         * @for App
         * @method getDeltaTime
         * @return {number}
         */


        /**
         * @for App
         * @method updateRun
         * @param shouldUpdate {boolean}
         */

    }]);

    return App;
}();

exports.default = App;

},{"./InputController":520,"./LoadingView":521,"./UiController":522,"./airport/AirportController":534,"./canvas/CanvasController":562,"./constants/logLevel":574,"./contentQueue/ContentQueue":577,"./game/GameClockView":579,"./game/GameController":580,"./speech":588,"./tutorial/TutorialView":590,"./util":591,"./utilities/timeHelpers":594,"jquery":296}],520:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase, no-mixed-operators, object-shorthand, class-methods-use-this, no-undef, expected-return*/


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _CommandParser = require('./commandParser/CommandParser');

var _CommandParser2 = _interopRequireDefault(_CommandParser);

var _core = require('./math/core');

var _gameOptionConstants = require('./constants/gameOptionConstants');

var _selectors = require('./constants/selectors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal propert
var input = {};

/**
 * Name of a command returned from the Parser
 *
 * @property PARSED_COMMAND_NAME
 * @type {Object}
 * @final
 */
var PARSED_COMMAND_NAME = {
    VERSION: 'version',
    TUTORIAL: 'tutorial',
    AUTO: 'auto',
    PAUSE: 'pause',
    TIMEWARP: 'timewarp',
    CLEAR: 'clear',
    AIRPORT: 'airport',
    RATE: 'rate',
    TRANSMIT: 'transmit'
};

/**
 * Enumeration of mouse events returned from $event.which
 *
 * These codes can only be used with jQuery event object.
 *
 * @property MOUSE_EVENT_CODE
 * @type {Object}
 * @final
 */
var MOUSE_EVENT_CODE = {
    LEFT_PRESS: 1,
    MIDDLE_PESS: 2,
    RIGHT_PRESS: 3
};

/**
 * Enumeration of key codes used for inputs.
 *
 * @property KEY_CODES
 * @type {Object}
 * @final
 */
var KEY_CODES = {
    // +
    ADD: 107,
    // -
    DASH: 189,
    DASH_FIREFOX: 173,
    DIVIDE: 111,
    DOWN_ARROW: 40,
    ENTER: 13,
    // =
    EQUALS: 187,
    EQUALS_FIREFOX: 61,
    // esc
    ESCAPE: 27,
    LEFT_ARROW: 37,
    MULTIPLY: 106,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    RIGHT_ARROW: 39,
    SUBTRACT: 109,
    TAB: 9,
    UP_ARROW: 38,
    // `
    BAT_TICK: 192
};

/**
 * @class InputController
 */

var InputController = function () {
    /**
     * @constructor
     */
    function InputController($element) {
        _classCallCheck(this, InputController);

        this.$element = $element;
        this.$window = null;
        this.$commandInput = null;
        this.$canvases = null;
        this.$sidebar = null;

        this.input = input;
        this.input.command = '';
        this.input.callsign = '';
        this.input.data = '';
        this.input.history = [];
        this.input.history_item = null;
        this.input.click = [0, 0];
        this.input.positions = '';
        this.input.tab_compl = {};
        this.input.mouseDelta = [0, 0];
        this.input.mouseDown = [0, 0];
        this.input.isMouseDown = false;

        this._init().setupHandlers().enable();
    }

    /**
     * @for InputController
     * @method _init
     */


    _createClass(InputController, [{
        key: '_init',
        value: function _init() {
            this.$window = (0, _jquery2.default)(window);
            this.$commandInput = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.COMMAND);
            this.$canvases = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.CANVASES);
            this.$sidebar = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.SIDEBAR);

            return this;
        }

        /**
         * @for InputController
         * @method setupHandlers
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers() {
            return this;
        }

        /**
         * @for InputController
         * @method enable
         */

    }, {
        key: 'enable',
        value: function enable() {
            var _this = this;

            this.$window.on('keydown', function (event) {
                return _this.onKeydownHandler(event);
            });
            this.$commandInput.on('keydown', function (event) {
                return _this.onCommandInputKeydownHandler(event);
            });
            this.$commandInput.on('input', function (event) {
                return _this.onCommandInputChangeHandler(event);
            });
            // FIXME: these are non-standard events and will be deprecated soon. this should be moved
            // over to the `wheel` event. This should also be moved over to `.on()` instead of `.bind()`
            // https://developer.mozilla.org/en-US/docs/Web/Events/wheel
            // this.$commandInput.on('DOMMouseScroll mousewheel', (event) => this.onMouseScrollHandler(event));
            this.$canvases.bind('DOMMouseScroll mousewheel', function (event) {
                return _this.onMouseScrollHandler(event);
            });
            this.$canvases.on('mousemove', function (event) {
                return _this.onMouseMoveHandler(event);
            });
            this.$canvases.on('mouseup', function (event) {
                return _this.onMouseUpHandler(event);
            });
            this.$canvases.on('mousedown', function (event) {
                return _this.onMouseDownHandler(event);
            });

            return this;
        }

        /**
         * @for InputController
         * @method disable
         */

    }, {
        key: 'disable',
        value: function disable() {
            var _this2 = this;

            this.$window.off('keydown', function (event) {
                return _this2.onKeydownHandler(event);
            });
            this.$commandInput.off('keydown', function (event) {
                return _this2.onCommandInputKeydownHandler(event);
            });
            this.$commandInput.off('input', function (event) {
                return _this2.onCommandInputChangeHandler(event);
            });
            // uncomment only after `.on()` for this event has been implemented.
            // this.$commandInput.off('DOMMouseScroll mousewheel', (event) => this.onMouseScrollHandler(event));
            this.$canvases.off('mousemove', function (event) {
                return _this2.onMouseMoveHandler(event);
            });
            this.$canvases.off('mouseup', function (event) {
                return _this2.onMouseUpHandler(event);
            });
            this.$canvases.off('mousedown', function (event) {
                return _this2.onMouseDownHandler(event);
            });

            return this.destroy();
        }

        /**
         * @for InputController
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$element = null;
            this.$window = null;
            this.$commandInput = null;
            this.$canvases = null;
            this.$sidebar = null;

            this.input = input;
            this.input.command = '';
            this.input.callsign = '';
            // this.input.data = '';
            this.input.history = [];
            this.input.history_item = null;
            this.input.click = [0, 0];
            this.input.positions = '';
            this.input.tab_compl = {};
            this.input.mouseDelta = [0, 0];
            this.input.mouseDown = [0, 0];
            this.input.isMouseDown = false;

            return this;
        }

        /**
         * @for InputController
         * @method input_init_pre
         */

    }, {
        key: 'input_init_pre',
        value: function input_init_pre() {
            // TODO: these prop properties can be removed except for `prop.input`
            prop.input = input;
            prop.input.command = '';
            prop.input.callsign = '';
            prop.input.data = '';
            prop.input.history = [];
            prop.input.history_item = null;
            prop.input.click = [0, 0];
            prop.input.positions = '';
            prop.input.tab_compl = {};
            prop.input.mouseDelta = [0, 0];
            prop.input.mouseDown = [0, 0];
            prop.input.isMouseDown = false;
        }

        /**
         * @for InputController
         * @method onMouseScrollHandler
         * @param event {jquery Event}
         */

    }, {
        key: 'onMouseScrollHandler',
        value: function onMouseScrollHandler(event) {
            if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
                window.uiController.ui_zoom_in();
            } else {
                window.uiController.ui_zoom_out();
            }
        }

        /**
         * @for InputController
         * @method onMouseMoveHandler
         * @param event {jquery Event}
         */

    }, {
        key: 'onMouseMoveHandler',
        value: function onMouseMoveHandler(event) {
            if (!prop.input.isMouseDown) {
                return this;
            }

            prop.input.mouseDelta = [event.pageX - prop.input.mouseDown[0], event.pageY - prop.input.mouseDown[1]];
            prop.canvas.panX = prop.input.mouseDelta[0];
            prop.canvas.panY = prop.input.mouseDelta[1];
            prop.canvas.dirty = true;
        }

        /**
         * @for InputController
         * @method onMouseUpHandler
         * @param event {jquery Event}
         */

    }, {
        key: 'onMouseUpHandler',
        value: function onMouseUpHandler(event) {
            prop.input.isMouseDown = false;
        }

        /**
         * @for InputController
         * @method onMouseDownHandler
         * @param event {jquery Event}
         */

    }, {
        key: 'onMouseDownHandler',
        value: function onMouseDownHandler(event) {
            event.preventDefault();

            if (event.which === MOUSE_EVENT_CODE.MIDDLE_PESS) {
                window.uiController.ui_zoom_reset();
            } else if (event.which === MOUSE_EVENT_CODE.LEFT_PRESS) {
                // Record mouse down position for panning
                prop.input.mouseDown = [event.pageX - prop.canvas.panX, event.pageY - prop.canvas.panY];
                prop.input.isMouseDown = true;

                // Aircraft label selection
                var position = [event.pageX, -event.pageY];
                position[0] -= prop.canvas.size.width / 2;
                position[1] += prop.canvas.size.height / 2;

                var nearest = window.aircraftController.aircraft_get_nearest([window.uiController.px_to_km(position[0] - prop.canvas.panX), window.uiController.px_to_km(position[1] + prop.canvas.panY)]);

                if (nearest[0]) {
                    if (nearest[1] < window.uiController.px_to_km(80)) {
                        this.input.callsign = nearest[0].getCallsign().toUpperCase();

                        this.input_select(this.input.callsign);
                    } else {
                        this.input_select();
                    }
                }

                position = [window.uiController.px_to_km(position[0]), window.uiController.px_to_km(position[1])];

                position[0] = parseFloat(position[0].toFixed(2));
                position[1] = parseFloat(position[1].toFixed(2));
                prop.input.positions += '[' + position.join(',') + ']';

                return false;
            }
        }

        /**
         * @for InputController
         * @method onKeydownHandler
         * @param event {jQuery Event}
         * @private
         */

    }, {
        key: 'onKeydownHandler',
        value: function onKeydownHandler(event) {
            // For firefox see: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
            var is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

            if (!window.gameController.game_paused()) {
                this.$commandInput.focus();
            }

            if (event.which === KEY_CODES.ESCAPE) {
                if (prop.tutorial.open) {
                    window.tutorialView.tutorial_close();
                } else if ((0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_SWITCH).hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN)) {
                    window.uiController.ui_airport_close();
                }
            }

            if (event.which === KEY_CODES.DASH || is_firefox && event.which === KEY_CODES.DASH_FIREFOX) {
                // Minus key to zoom out, plus to zoom in
                window.uiController.ui_zoom_out();
                return false;
            } else if (event.which === KEY_CODES.EQUALS || is_firefox && event.which === KEY_CODES.EQUALS_FIREFOX) {
                if (event.shiftKey) {
                    window.uiController.ui_zoom_in();
                } else {
                    window.uiController.ui_zoom_reset();
                }

                return false;
            }

            if (!prop.tutorial.open) {
                return;
            }

            if (event.which === KEY_CODES.PAGE_UP) {
                window.tutorialView.tutorial_prev();
                event.preventDefault();
            } else if (event.which === KEY_CODES.PAGE_DOWN) {
                window.tutorialView.tutorial_next();
                event.preventDefault();
            }
        }

        /**
         * @for InputController
         * @method input_parse
         */

    }, {
        key: 'input_parse',
        value: function input_parse() {
            var $strip = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.STRIP);
            $strip.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

            prop.input.callsign = '';
            prop.input.data = '';

            if (prop.input.command.length === 0) {
                return;
            }

            // TODO: move to master REGEX constant
            var match = /^\s*(\w+)/.exec(prop.input.command);

            if (!match) {
                return;
            }

            prop.input.callsign = match[1];
            var number = 0;
            // FIXME: this is a very mutable property. perhaps it should be something else?
            match = null;
            prop.canvas.dirty = true;

            for (var i = 0; i < prop.aircraft.list.length; i++) {
                var aircraft = prop.aircraft.list[i];

                if (aircraft.matchCallsign(prop.input.callsign)) {
                    number += 1;
                    match = aircraft;
                    // TODO: this should be from an encapsulated class on the window.
                    aircraft.$html.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
                }
            }

            // TODO: this logic block should be either abstracted or simplified.
            if (number === 1 && (match.$html.offset().top < 0 || match.$html.offset().top + match.$html.height() - this.$sidebar.offset().top > this.$sidebar.height())) {
                this.$sidebar.scrollTop(this.$sidebar.scrollTop() + match.$html.offset().top - this.$sidebar.height() / 2);
            }
        }

        /**
         * @for InputController
         * @method onCommandInputChangeHandler
         */

    }, {
        key: 'onCommandInputChangeHandler',
        value: function onCommandInputChangeHandler() {
            this.tab_completion_reset();

            prop.input.command = this.$commandInput.val();

            this.input_parse();
        }

        /**
         * @for InputController
         * @method input_select
         * @param callsign {string}
         */

    }, {
        key: 'input_select',
        value: function input_select(callsign) {
            if (callsign) {
                this.$commandInput.val(callsign + ' ');
            } else {
                this.$commandInput.val('');
            }

            this.$commandInput.focus();

            this.onCommandInputChangeHandler();
        }

        /**
         * @for InputController
         * @method onCommandInputKeydownHandler
         */

    }, {
        key: 'onCommandInputKeydownHandler',
        value: function onCommandInputKeydownHandler(e) {
            var currentCommandInputValue = this.$commandInput.val();

            // TODO: this swtich can be simplified, there is a lot of repetition here
            switch (e.which) {
                case KEY_CODES.BAT_TICK:
                    this.$commandInput.val(currentCommandInputValue + '` ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;
                case KEY_CODES.ENTER:
                    this.input_parse();

                    if (this.input_run()) {
                        prop.input.history.unshift(prop.input.callsign);
                        this.$commandInput.val('');
                        prop.input.command = '';

                        this.tab_completion_reset();
                        this.input_parse();
                    }

                    prop.input.history_item = null;

                    break;

                case KEY_CODES.PAGE_UP:
                    // recall previous callsign
                    this.input_history_prev();
                    e.preventDefault();
                    break;

                case KEY_CODES.PAGE_DOWN:
                    // recall subsequent callsign
                    this.input_history_next();
                    e.preventDefault();
                    break;

                case KEY_CODES.LEFT_ARROW:
                    // shortKeys in use
                    if (this._isArrowControlMethod()) {
                        this.$commandInput.val(currentCommandInputValue + ' t l ');
                        e.preventDefault();
                        this.onCommandInputChangeHandler();
                    }

                    break;

                case KEY_CODES.UP_ARROW:
                    if (this._isArrowControlMethod()) {
                        this.$commandInput.val(currentCommandInputValue + ' \u2B61 ');
                        e.preventDefault();
                        this.onCommandInputChangeHandler();
                    } else {
                        // recall previous callsign
                        this.input_history_prev();
                        e.preventDefault();
                    }
                    break;

                case KEY_CODES.RIGHT_ARROW:
                    // shortKeys in use
                    if (this._isArrowControlMethod()) {
                        this.$commandInput.val(currentCommandInputValue + ' t r ');
                        e.preventDefault();
                        this.onCommandInputChangeHandler();
                    }

                    break;

                case KEY_CODES.DOWN_ARROW:
                    if (this._isArrowControlMethod()) {
                        this.$commandInput.val(currentCommandInputValue + ' \u2B63 ');
                        e.preventDefault();
                        this.onCommandInputChangeHandler();
                    } else {
                        // recall previous callsign
                        this.input_history_prev();
                        e.preventDefault();
                    }

                    break;

                case KEY_CODES.MULTIPLY:
                    this.$commandInput.val(currentCommandInputValue + ' \u2B50 ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.ADD:
                    this.$commandInput.val(currentCommandInputValue + ' + ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.EQUALS:
                    // mac + (actually `=`)
                    this.$commandInput.val(currentCommandInputValue + ' + ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.SUBTRACT:
                    this.$commandInput.val(currentCommandInputValue + ' - ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.DASH:
                    // mac -
                    this.$commandInput.val(currentCommandInputValue + ' - ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.DIVIDE:
                    this.$commandInput.val(currentCommandInputValue + ' takeoff ');
                    e.preventDefault();
                    this.onCommandInputChangeHandler();

                    break;

                case KEY_CODES.TAB:
                    if (!prop.input.tab_compl.matches) {
                        this.tab_completion_match();
                    }

                    this.tab_completion_cycle({ backwards: e.shiftKey });
                    e.preventDefault();

                    break;

                case KEY_CODES.ESCAPE:
                    var currentCommandValue = this.$commandInput.val();

                    // if the current commandInput value contains a callsign and commands, only clear the commands
                    if (currentCommandValue.trim() !== this.input.callsign) {
                        this.$commandInput.val(this.input.callsign + ' ');

                        return;
                    }

                    this.$commandInput.val('');

                    break;
                default:
                    break;
            }
        }

        /**
         * @for InputController
         * @method tab_completion_cycle
         * @param opt
         */

    }, {
        key: 'tab_completion_cycle',
        value: function tab_completion_cycle(opt) {
            var matches = prop.input.tab_compl.matches;

            if (!matches || matches.length === 0) {
                return;
            }

            // TODO: this block needs some work. this initial assignment looks to be overwritten every time.
            var i = prop.input.tab_compl.cycle_item;
            if (opt.backwards) {
                i = i <= 0 ? matches.length - 1 : i - 1;
            } else {
                i = i >= matches.length - 1 ? 0 : i + 1;
            }

            this.$commandInput.val(matches[i] + ' ');

            prop.input.command = matches[i];
            prop.input.tab_compl.cycle_item = i;

            this.input_parse();
        }

        /**
         * @for InputController
         * @method tab_completion_match
         */

    }, {
        key: 'tab_completion_match',
        value: function tab_completion_match() {
            var matches = void 0;
            var val = this.$commandInput.val();
            var aircrafts = prop.aircraft.list;

            if (prop.input.callsign) {
                aircrafts = aircrafts.filter(function (a) {
                    return a.matchCallsign(prop.input.callsign);
                });
            }

            matches = (0, _map3.default)(aircrafts, function (aircraft) {
                return aircraft.getCallsign();
            });

            if (aircrafts.length === 1 && (prop.input.data || val[val.length - 1] === ' ')) {
                // TODO: update inline functions
                matches = aircrafts[0].COMMANDS.filter(function (c) {
                    return c.toLowerCase().indexOf(prop.input.data.toLowerCase()) === 0;
                }).map(function (c) {
                    return val.substring(0, prop.input.callsign.length + 1) + c;
                });
            }

            this.tab_completion_reset();

            prop.input.tab_compl.matches = matches;
            prop.input.tab_compl.cycle_item = -1;
        }

        /**
         * @for InputController
         * @method tab_completion_reset
         */

    }, {
        key: 'tab_completion_reset',
        value: function tab_completion_reset() {
            prop.input.tab_compl = {};
        }

        /**
         * @for InputController
         * @method input_history_clamp
         */

    }, {
        key: 'input_history_clamp',
        value: function input_history_clamp() {
            prop.input.history_item = (0, _core.clamp)(0, prop.input.history_item, prop.input.history.length - 1);
        }

        /**
         * @for InputController
         * @method input_history_prev
         */

    }, {
        key: 'input_history_prev',
        value: function input_history_prev() {
            if (prop.input.history.length === 0) {
                return;
            }

            if (prop.input.history_item == null) {
                prop.input.history.unshift(prop.input.command);
                prop.input.history_item = 0;
            }

            prop.input.history_item += 1;
            this.input_history_clamp();

            var command = prop.input.history[prop.input.history_item] + ' ';
            this.$commandInput.val(command.toUpperCase());

            this.onCommandInputChangeHandler();
        }

        /**
         * @for InputController
         * @method input_history_next
         */

    }, {
        key: 'input_history_next',
        value: function input_history_next() {
            if (prop.input.history.length === 0 || !prop.input.history_item) {
                return;
            }

            prop.input.history_item -= 1;

            if (prop.input.history_item <= 0) {
                this.$commandInput.val(prop.input.history[0]);

                this.onCommandInputChangeHandler();

                prop.input.history.splice(0, 1);
                prop.input.history_item = null;

                return;
            }

            this.input_history_clamp();

            var command = prop.input.history[prop.input.history_item] + ' ';

            this.$commandInput.val(command.toUpperCase());
            this.onCommandInputChangeHandler();
        }

        /**
         * Encapsulation of repeated boolean logic
         *
         * @for InputController
         * @method _isArrowControlMethod
         * @return {boolean}
         */

    }, {
        key: '_isArrowControlMethod',
        value: function _isArrowControlMethod() {
            return window.gameController.game.option.get(_gameOptionConstants.GAME_OPTION_NAMES.CONTROL_METHOD) === 'arrows';
        }

        /**
         * @for InputController
         * @method _parseUserCommand
         * @return result {CommandParser}
         */

    }, {
        key: '_parseUserCommand',
        value: function _parseUserCommand() {
            var result = void 0;
            // this could use $commandInput.val() as an alternative
            var userCommand = prop.input.command.trim().toLowerCase();

            // Using try/catch here very much on purpose. the `CommandParser` will throw when it encounters any kind
            // of error; invalid length, validation, parse, etc. Here we catch those errors, log them to the screen
            // and then throw them all at once
            try {
                result = new _CommandParser2.default(userCommand);
            } catch (error) {
                window.uiController.ui_log('Command not understood');

                throw error;
            }

            return result;
        }

        /**
         * @for InputController
         * @method input_run
         */

    }, {
        key: 'input_run',
        value: function input_run() {
            var commandParser = this._parseUserCommand();

            if (commandParser.command !== 'transmit') {
                return this.processSystemCommand(commandParser);
            }

            return this.processTransmitCommand(commandParser);
        }

        /**
         * @for InputController
         * @method processSystemCommand
         * @param commandParser {CommandParser}
         * @return {boolean}
         */

    }, {
        key: 'processSystemCommand',
        value: function processSystemCommand(commandParser) {
            switch (commandParser.command) {
                case PARSED_COMMAND_NAME.VERSION:
                    window.uiController.ui_log('Air Traffic Control simulator version ' + prop.version.join('.'));

                    return true;

                case PARSED_COMMAND_NAME.TUTORIAL:
                    window.tutorialView.tutorial_toggle();

                    return true;

                case PARSED_COMMAND_NAME.AUTO:
                    // FIXME: does this function exist anywhere?
                    // aircraft_toggle_auto();
                    //
                    // if (prop.aircraft.auto.enabled) {
                    //     window.uiController.ui_log('automatic controller ENGAGED');
                    // } else {
                    //     window.uiController.ui_log('automatic controller OFF');
                    // }

                    return true;

                case PARSED_COMMAND_NAME.PAUSE:
                    window.gameController.game_pause_toggle();

                    return true;

                case PARSED_COMMAND_NAME.TIMEWARP:
                    if (commandParser.args) {
                        window.gameController.game.speedup = commandParser.args;
                    } else {
                        window.gameController.game_timewarp_toggle();
                    }

                    return true;

                case PARSED_COMMAND_NAME.CLEAR:
                    localStorage.clear();
                    location.reload();

                case PARSED_COMMAND_NAME.AIRPORT:
                    // TODO: it may be better to do this in the parser
                    var airportIcao = commandParser.args[0];

                    if ((0, _has3.default)(prop.airport.airports, airportIcao)) {
                        window.airportController.airport_set(airportIcao);
                    }

                    return true;

                case PARSED_COMMAND_NAME.RATE:
                    // TODO: is this if even needed?
                    if (commandParser.args) {
                        window.gameController.game.frequency = commandParser.args;
                    }

                    return true;
                default:
                    return true;
            }
        }

        /**
         * @for InputController
         * @method processTransmitCommand
         * @param commandParser {CommandParser}
         * @return {boolean}
         */

    }, {
        key: 'processTransmitCommand',
        value: function processTransmitCommand(commandParser) {
            // TODO: abstract the aircraft callsign matching
            var matches = 0;
            var match = -1;

            for (var i = 0; i < prop.aircraft.list.length; i++) {
                var _aircraft = prop.aircraft.list[i];

                if (_aircraft.matchCallsign(commandParser.callsign)) {
                    matches += 1;
                    match = i;
                }
            }

            if (matches > 1) {
                window.uiController.ui_log('multiple aircraft match the callsign, say again');

                return true;
            }

            if (match === -1) {
                window.uiController.ui_log('no such aircraft, say again');

                return true;
            }

            var aircraft = prop.aircraft.list[match];

            return aircraft.runCommands(commandParser.args);
        }
    }]);

    return InputController;
}();

exports.default = InputController;

},{"./commandParser/CommandParser":564,"./constants/gameOptionConstants":572,"./constants/selectors":575,"./math/core":584,"jquery":296,"lodash/get":469,"lodash/has":470,"lodash/map":496}],521:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _timeHelpers = require('./utilities/timeHelpers');

var _selectors = require('./constants/selectors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @property MIN_DISPLAY_SECONDS
 * @type {number}
 * @final
 */
var MIN_DISPLAY_SECONDS = 2;

/**
 * Provides an encapsulated class that displays a truncated filename for a file currently being loaded.
 *
 * Only used once the entire view has loaded.
 * ex: a user changes airports after initalizing the simulator.
 *
 * @class LoadingView
 */

var LoadingView = function () {
  /**
   * @for LoadingView
   * @constructor
   */
  function LoadingView() {
    _classCallCheck(this, LoadingView);

    /**
     * @property $element
     * @type {jquery|null}
     */
    this.$element = null;

    /**
     * @property $loadingIndicator
     * @type {jquery|null}
     */
    this.$loadingIdicator = null;

    /**
     * @property $loadingMessage
     * @type {jquery|null}
     */
    this.$loadingMessage = null;

    /**
     * @property loadingState
     * @type {Object}
     * @final
     */
    this.loadingState = {
      /**
       *
       * @property callback
       * @method callback
       * @return {Function}
       */
      callback: function callback() {},

      /**
       * @property loadingState
       * @type {Boolean}
       */
      loading: false,

      /**
       * @property startTime
       * @type {number}
       */
      startTime: -1
    };

    this._setupChildren();
  }

  /**
   * @for LoadingView
   * @method _setupChildren
   * @chainable
   * @private
   */


  _createClass(LoadingView, [{
    key: '_setupChildren',
    value: function _setupChildren() {
      this.$element = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.LOADING);
      this.$loadingIdicator = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.LOADING_INDICATOR);
      this.$loadingMessage = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.MESSAGE);

      return this;
    }

    /**
     * @for LoadingView
     * @method _disable
     * @chainable
     * @private
     */

  }, {
    key: '_disable',
    value: function _disable() {
      this.loadingState.callback = function () {};
      this.loadingState.loading = false;
      this.loadingState.startTime = -1;

      return this;
    }

    /**
     * @for LoadingView
     * @method _resetCallback
     * @chainable
     * @private
     */

  }, {
    key: '_resetCallback',
    value: function _resetCallback() {
      if (this.callback === null) {
        return this;
      }

      clearTimeout(this.callback);

      this.callback = null;

      return this;
    }

    /**
     * @for LoadingView
     * @method _didExceedMinimumWaitTime
     * @return {boolean}
     * @chainable
     * @private
     */

  }, {
    key: '_didExceedMinimumWaitTime',
    value: function _didExceedMinimumWaitTime() {
      var timeNow = (0, _timeHelpers.time)();

      return timeNow - this.loadingState.startTime > MIN_DISPLAY_SECONDS;
    }

    /**
     * @for LoadingView
     * @method _formatLoadingMessage
     * @param message {string}  a string to be formatted
     * @return {string}
     * @private
     */

  }, {
    key: '_formatLoadingMessage',
    value: function _formatLoadingMessage(message) {
      var minimumTruncationLength = 15;

      if (message.length <= minimumTruncationLength) {
        return message;
      }

      return '...' + message.substr(-12);
    }

    /**
     * @for LoadingView
     * @method startLoad
     * @param url {string}  the url for a file being loaded
     */

  }, {
    key: 'startLoad',
    value: function startLoad(url) {
      if (!this.loading) {
        (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.LOADING_INDICATOR).show();
        this.loadingState.startTime = (0, _timeHelpers.time)();
      }

      var msg = this._formatLoadingMessage(url);
      this.$loadingMessage.text(msg);

      this._resetCallback();
    }

    /**
     * @for LoadingView
     * @method stopLoad
     */

  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var _this = this;

      var timeNow = (0, _timeHelpers.time)();

      if (this._didExceedMinimumWaitTime()) {
        this.$loadingIdicator.hide();

        this._disable();
      } else {
        if (this.callback !== null) {
          return;
        }

        var delayTime = (MIN_DISPLAY_SECONDS - (timeNow - this.start)) * 1000;
        this.callback = setTimeout(function () {
          (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.LOADING_INDICATOR).hide();

          _this._disable();
        }, delayTime);
      }
    }

    /**
     * @for LoadingView
     * @method complete
     */

  }, {
    key: 'complete',
    value: function complete() {
      this.$element.fadeOut(1000);
      this.$element.css('pointerEvents', 'none');
    }
  }]);

  return LoadingView;
}();

exports.default = LoadingView;

},{"./constants/selectors":575,"./utilities/timeHelpers":594,"jquery":296}],522:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand, no-undef,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     no-param-reassign, class-methods-use-this */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _startCase2 = require('lodash/startCase');

var _startCase3 = _interopRequireDefault(_startCase2);

var _speech = require('./speech');

var _core = require('./math/core');

var _selectors = require('./constants/selectors');

var _storageKeys = require('./constants/storageKeys');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var ui = {};

/**
 * @property TERRAIN_COLORS
 * @type {Object}
 * @final
 */
var TERRAIN_COLORS = {
    1000: '26, 150, 65',
    2000: '119, 194, 92',
    3000: '255, 255, 192',
    4000: '253, 201, 128',
    5000: '240, 124, 74',
    6000: '156, 81, 31'
};

/**
 * @property UI_OPTIONS_TEMPLATE
 * @type {string}
 * @final
 */
var UI_OPTIONS_TEMPLATE = '<div id="options-dialog" class="dialog"></div>';

/**
 * @property UI_OPTION_CONTAINER_TEMPLATE
 * @type {string}
 * @final
 */
var UI_OPTION_CONTAINER_TEMPLATE = '<div class="option"></div>';

/**
 * @property UI_OPTION_SELECTOR_TEMPLATE
 * @type {string}
 * @final
 */
var UI_OPTION_SELECTOR_TEMPLATE = '<span class="option-selector option-type-select"></span>';

/**
 * @class UiController
 */

var UiView = function () {
    /**
     * @constructor
     */
    function UiView($element) {
        _classCallCheck(this, UiView);

        this.$element = $element;
        this.$airportList = null;
        this.$airportListNotes = null;
        this.$toggleTutorial = null;
        this.$fastForwards = null;
        this.$pauseToggle = null;
        this.$pausedImg = null;
        this.$speechToggle = null;
        this.$switchAirport = null;
        this.$toggleLabels = null;
        this.$toggleRestrictedAreas = null;
        this.$toggleSids = null;
        this.$toggleTerrain = null;
        this.$toggleOptions = null;

        this.ui = ui;
        this.ui.scale_default = 8; // pixels per km
        this.ui.scale_max = 80; // max scale
        this.ui.scale_min = 1; // min scale
        this.ui.scale = this.ui.scale_default;
        this.ui.terrain = {
            colors: TERRAIN_COLORS,
            border_opacity: 1,
            fill_opacity: 0.1
        };

        return this._init().enable();
    }

    /**
     * @for UiController
     * @method _init
     */


    _createClass(UiView, [{
        key: '_init',
        value: function _init() {
            this.$airportList = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_LIST);
            this.$airportListNotes = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_LIST_NOTES);
            this.$airportSwitch = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.AIRPORT_SWITCH);
            this.$toggleTutorial = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TUTORIAL);
            this.$fastForwards = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.FAST_FORWARDS);
            this.$pauseToggle = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.PAUSE_TOGGLE);
            this.$pausedImg = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.PAUSED + ' img');
            this.$speechToggle = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.SPEECH_TOGGLE);
            this.$switchAirport = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.SWITCH_AIRPORT);
            this.$toggleLabels = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_LABELS);
            this.$toggleRestrictedAreas = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_RESTRICTED_AREAS);
            this.$toggleSids = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SIDS);
            this.$toggleTerrain = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TERRAIN);
            this.$toggleOptions = this.$element.find(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_OPTIONS);

            return this;
        }

        /**
         * @for UiController
         * @method enable
         */

    }, {
        key: 'enable',
        value: function enable() {
            var _this = this;

            this.$toggleTutorial.on('click', function (event) {
                return window.tutorialView.tutorial_toggle(event);
            });
            this.$fastForwards.on('click', function (event) {
                return window.gameController.game_timewarp_toggle(event);
            });
            this.$pauseToggle.on('click', function (event) {
                return window.gameController.game_pause_toggle(event);
            });
            this.$pausedImg.on('click', function (event) {
                return window.gameController.game_unpause(event);
            });
            this.$speechToggle.on('click', function (event) {
                return (0, _speech.speech_toggle)(event);
            });
            this.$switchAirport.on('click', function (event) {
                return _this.ui_airport_toggle(event);
            });
            this.$toggleLabels.on('click', function (event) {
                return _this.canvas_labels_toggle(event);
            });
            this.$toggleRestrictedAreas.on('click', function (event) {
                return _this.canvas_restricted_toggle(event);
            });
            this.$toggleSids.on('click', function (event) {
                return _this.canvas_sids_toggle(event);
            });
            this.$toggleTerrain.on('click', function (event) {
                return _this.canvas_terrain_toggle(event);
            });
            this.$toggleOptions.on('click', function (event) {
                return _this.ui_options_toggle(event);
            });

            return this;
        }

        /**
         * @for UiController
         * @method disable
         */

    }, {
        key: 'diable',
        value: function diable() {
            var _this2 = this;

            this.$toggleTutorial.off('click', function (event) {
                return window.tutorialView.tutorial_toggle(event);
            });
            this.$fastForwards.off('click', function (event) {
                return window.gameController.game_timewarp_toggle(event);
            });
            this.$pauseToggle.off('click', function (event) {
                return window.gameController.game_pause_toggle(event);
            });
            this.$pausedImg.off('click', function (event) {
                return window.gameController.game_unpause(event);
            });
            this.$speechToggle.off('click', function (event) {
                return (0, _speech.speech_toggle)(event);
            });
            this.$switchAirport.off('click', function (event) {
                return _this2.ui_airport_toggle(event);
            });
            this.$toggleLabels.off('click', function (event) {
                return _this2.canvas_labels_toggle(event);
            });
            this.$toggleRestrictedAreas.off('click', function (event) {
                return _this2.canvas_restricted_toggle(event);
            });
            this.$toggleSids.off('click', function (event) {
                return _this2.canvas_sids_toggle(event);
            });
            this.$toggleTerrain.off('click', function (event) {
                return _this2.canvas_terrain_toggle(event);
            });
            this.$toggleOptions.off('click', function (event) {
                return _this2.ui_options_toggle(event);
            });

            return this.destroy();
        }

        /**
         * @for UiController
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$element = null;
            this.$airportList = null;
            this.$airportListNotes = null;
            this.$toggleTutorial = null;
            this.$fastForwards = null;
            this.$pauseToggle = null;
            this.$pausedImg = null;
            this.$speechToggle = null;
            this.$switchAirport = null;
            this.$toggleLabels = null;
            this.$toggleRestrictedAreas = null;
            this.$toggleSids = null;
            this.$toggleTerrain = null;
            this.$toggleOptions = null;

            this.ui = {};
            this.ui.scale_default = -1;
            this.ui.scale_max = -1;
            this.ui.scale_min = -1;
            this.ui.scale = -1;
            this.ui.terrain = {};

            return this;
        }

        /**
         * @for UiController
         * @method ui_init_pre
         */

    }, {
        key: 'ui_init_pre',
        value: function ui_init_pre() {
            prop.ui = ui;
            prop.ui.scale_default = 8; // pixels per km
            prop.ui.scale_max = 80; // max scale
            prop.ui.scale_min = 1; // min scale
            prop.ui.scale = prop.ui.scale_default;
            prop.ui.terrain = {
                colors: {
                    1000: '26, 150, 65',
                    2000: '119, 194, 92',
                    3000: '255, 255, 192',
                    4000: '253, 201, 128',
                    5000: '240, 124, 74',
                    6000: '156, 81, 31'
                },
                border_opacity: 1,
                fill_opacity: 0.1
            };

            this.ui_set_scale_from_storage();
        }

        /**
         * @for uiController
         * @method ui_init
         */

    }, {
        key: 'ui_init',
        value: function ui_init() {
            var _this3 = this;

            this.$fastForwards.prop('title', 'Set time warp to 2');

            var $options = (0, _jquery2.default)(UI_OPTIONS_TEMPLATE);
            var descriptions = window.gameController.game.option.getDescriptions();

            (0, _forEach3.default)(descriptions, function (opt) {
                if (opt.type !== 'select') {
                    return;
                }

                var $container = _this3._buildOptionTemplate(opt);
                $options.append($container);
            });

            (0, _jquery2.default)('body').append($options);
        }

        /**
         * Build the html for a game option and its cooresponding value elements.
         *
         * @for UiController
         * @method _buildOptionTemplate
         * @param option {object}
         * @return $container {jquery Element}
         * @private
         */

    }, {
        key: '_buildOptionTemplate',
        value: function _buildOptionTemplate(option) {
            var $container = (0, _jquery2.default)(UI_OPTION_CONTAINER_TEMPLATE);
            $container.append('<span class="option-description">' + option.description + '</span>');

            var $optionSelector = (0, _jquery2.default)(UI_OPTION_SELECTOR_TEMPLATE);
            var $selector = (0, _jquery2.default)('<select id="opt-' + option.name + '" name="' + option.name + '"></select>');
            var selectedOption = window.gameController.game.option.get(option.name);

            // this could me done with a _map(), but verbosity here makes the code easier to read
            for (var i = 0; i < option.data.length; i++) {
                var $optionSelectTempalate = this._buildOptionSelectTemplate(option.data[i][1], selectedOption);

                $selector.append($optionSelectTempalate);
            }

            // TODO: this should be moved to a `setupHandlers()` or a click handler
            $selector.change(function (event) {
                var $currentTarget = (0, _jquery2.default)(event.currentTarget);

                window.gameController.game.option.set($currentTarget.attr('name'), $currentTarget.val());
            });

            $optionSelector.append($selector);
            $container.append($optionSelector);

            return $container;
        }

        /**
         * Build the html for a select option.
         *
         * @for UiController
         * @method _buildOptionTemplate
         * @param optionData
         * @param selectedOption {string}
         * @return optionSelectTempalate {string}
         * @private
         */

    }, {
        key: '_buildOptionSelectTemplate',
        value: function _buildOptionSelectTemplate(optionData, selectedOption) {
            var optionSelectTempalate = '<option value="' + optionData + '">' + (0, _startCase3.default)(optionData) + '</option>';

            if (optionData === selectedOption) {
                optionSelectTempalate = '<option value="' + optionData + '" selected="selected">' + (0, _startCase3.default)(optionData) + '</option>';
            }

            return optionSelectTempalate;
        }

        /**
         * @for uiController
         * @method onClickAirportListItemHandler
         * @paam event {jquery event}
         */

    }, {
        key: 'onClickAirportListItemHandler',
        value: function onClickAirportListItemHandler(event) {
            if (event.data !== window.airportController.airport_get().icao) {
                window.airportController.airport_set(event.data);
                this.ui_airport_close();
            }
        }

        /**
         * @for uiController
         * @method buildAirportListItemTemplate
         * @param icao {string}
         * @param difficulty {string}
         * @param name {string}
         * @return {DOM element|string}
         */

    }, {
        key: 'buildAirportListItemTemplate',
        value: function buildAirportListItemTemplate(icao, difficulty, name) {
            return '<li class="airport icao-' + icao.toLowerCase() + '">' + ('<span style="font-size: 7pt" class="difficulty">' + difficulty + '</span>') + ('<span class="icao">' + icao.toUpperCase() + '</span>') + ('<span class="name">' + name + '</span>') + '</li>';
        }

        /**
         * @for UiController
         * @method ui_complete
         */

    }, {
        key: 'ui_complete',
        value: function ui_complete() {
            var _this4 = this;

            var airports = (0, _keys3.default)(prop.airport.airports).sort();
            var icon = '&#9992;';
            var difficulty = '';
            var airport = void 0;

            for (var i = 0; i < airports.length; i++) {
                airport = prop.airport.airports[airports[i]];

                switch (airport.level) {
                    case 'beginner':
                        difficulty = icon;
                        break;
                    case 'easy':
                        difficulty = icon.repeat(2);
                        break;
                    case 'medium':
                        difficulty = icon.repeat(3);
                        break;
                    case 'hard':
                        difficulty = icon.repeat(4);
                        break;
                    case 'expert':
                        difficulty = icon.repeat(5);
                        break;
                    default:
                        difficulty = '?';
                        break;
                }

                // TODO: move to a template const
                var _airport = airport,
                    name = _airport.name,
                    icao = _airport.icao;

                var $airportListItem = (0, _jquery2.default)(this.buildAirportListItemTemplate(icao, difficulty, name));

                // TODO: replace with an onClick() handler
                $airportListItem.click(airport.icao.toLowerCase(), function (event) {
                    if (event.data !== window.airportController.airport_get().icao) {
                        window.airportController.airport_set(event.data);
                        _this4.ui_airport_close();
                    }
                });

                this.$airportList.append($airportListItem);
            }

            this.drawAirportListFooter();
        }

        /**
         * @for UiController
         * @method drawAirportListFooter
         */

    }, {
        key: 'drawAirportListFooter',
        value: function drawAirportListFooter() {
            var symbol = (0, _jquery2.default)('<span class="symbol">&#9983</span>');
            this.$airportListNotes.append(symbol);

            var notes = (0, _jquery2.default)('<span class="words">indicates airport is a work in progress</span>');
            this.$airportListNotes.append(notes);
        }

        //TODO: this function should live in a helper file somewhere
        /**
         * @for UiController
         * @method px_to_km
         * @param pixels {number}
         * @return {number}
         */

    }, {
        key: 'px_to_km',
        value: function px_to_km(pixels) {
            return pixels / prop.ui.scale;
        }

        //TODO: this function should live in a helper file somewhere
        /**
         * @for UiController
         * @method km_to_px
         * @param kilometers {number}
         * @return {number}
         */

    }, {
        key: 'km_to_px',
        value: function km_to_px(kilometers) {
            return kilometers * prop.ui.scale;
        }

        /**
         * @for UiController
         * @method ui_after_zoom
         */

    }, {
        key: 'ui_after_zoom',
        value: function ui_after_zoom() {
            localStorage[_storageKeys.STORAGE_KEY.ATC_SCALE] = prop.ui.scale;

            prop.canvas.dirty = true;
        }

        /**
         * @for UiController
         * @method ui_zoom_out
         */

    }, {
        key: 'ui_zoom_out',
        value: function ui_zoom_out() {
            var lastpos = [(0, _core.round)(this.px_to_km(prop.canvas.panX)), (0, _core.round)(this.px_to_km(prop.canvas.panY))];

            prop.ui.scale *= 0.9;

            if (prop.ui.scale < prop.ui.scale_min) {
                prop.ui.scale = prop.ui.scale_min;
            }

            this.ui_after_zoom();

            prop.canvas.panX = (0, _core.round)(this.km_to_px(lastpos[0]));
            prop.canvas.panY = (0, _core.round)(this.km_to_px(lastpos[1]));
        }

        /**
         * @for UiController
         * @method ui_zoom_in
         */

    }, {
        key: 'ui_zoom_in',
        value: function ui_zoom_in() {
            var lastpos = [(0, _core.round)(this.px_to_km(prop.canvas.panX)), (0, _core.round)(this.px_to_km(prop.canvas.panY))];

            prop.ui.scale /= 0.9;
            if (prop.ui.scale > prop.ui.scale_max) {
                prop.ui.scale = prop.ui.scale_max;
            }

            this.ui_after_zoom();

            prop.canvas.panX = (0, _core.round)(this.km_to_px(lastpos[0]));
            prop.canvas.panY = (0, _core.round)(this.km_to_px(lastpos[1]));
        }

        /**
         * @for UiController
         * @method ui_zoom_reset
         */

    }, {
        key: 'ui_zoom_reset',
        value: function ui_zoom_reset() {
            prop.ui.scale = prop.ui.scale_default;

            this.ui_after_zoom();
        }

        /**
         * @for UiController
         * @method ui_log
         */

    }, {
        key: 'ui_log',
        value: function ui_log(message) {
            var warn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var html = (0, _jquery2.default)('<span class="item"><span class="message">' + message + '</span></span>');

            if (warn) {
                html.addClass(_selectors.SELECTORS.CLASSNAMES.WARN);
            }

            var $log = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.LOG);
            $log.append(html);
            $log.scrollTop($log.get(0).scrollHeight);

            window.gameController.game_timeout(function (uiLogView) {
                uiLogView.addClass(_selectors.SELECTORS.CLASSNAMES.HIDDEN);

                setTimeout(function () {
                    uiLogView.remove();
                }, 10000);
            }, 3, window, html);
        }

        /**
         * @for UiController
         * @method ui_airport_open
         */

    }, {
        key: 'ui_airport_open',
        value: function ui_airport_open() {
            this.$airportSwitch.addClass(_selectors.SELECTORS.CLASSNAMES.OPEN);

            var $previousActiveAirport = this.$airportList.find(_selectors.SELECTORS.DOM_SELECTORS.ACTIVE);

            // Remove the active class from a no-longer-selected airport in the list.
            if ($previousActiveAirport.length !== 0) {
                $previousActiveAirport.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            }

            var icao = window.airportController.airport_get().icao.toLowerCase();
            (0, _jquery2.default)('.airport.icao-' + icao).addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

            this.$switchAirport.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
        }

        /**
         * @for UiController
         * @method ui_airport_close
         */

    }, {
        key: 'ui_airport_close',
        value: function ui_airport_close() {
            this.$airportSwitch.removeClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
            this.$switchAirport.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
        }

        /**
         * @for UiController
         * @method ui_airport_toggle
         */

    }, {
        key: 'ui_airport_toggle',
        value: function ui_airport_toggle() {
            if (this.$airportSwitch.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN)) {
                this.ui_airport_close();
            } else {
                this.ui_airport_open();
            }
        }

        /**
         * @for UiController
         * @method canvas_labels_toggle
         * @param {jquery event}
         */

    }, {
        key: 'canvas_labels_toggle',
        value: function canvas_labels_toggle(event) {
            (0, _jquery2.default)(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL).toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

            prop.canvas.draw_labels = !prop.canvas.draw_labels;
        }

        /**
         * @for UiController
         * @method canvas_restricted_toggle
         */

    }, {
        key: 'canvas_restricted_toggle',
        value: function canvas_restricted_toggle(event) {
            (0, _jquery2.default)(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL).toggleClass(_selectors.SELECTORS.DOM_SELECTORS.WARNING_BUTTON + ' ' + _selectors.SELECTORS.CLASSNAMES.ACTIVE);

            prop.canvas.draw_restricted = !prop.canvas.draw_restricted;
        }

        /**
         * @for UiController
         * @method canvas_sids_toggle
         * @param event {jquery event}
         */

    }, {
        key: 'canvas_sids_toggle',
        value: function canvas_sids_toggle(event) {
            (0, _jquery2.default)(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL).toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);

            prop.canvas.draw_sids = !prop.canvas.draw_sids;
        }

        /**
         * @for UiController
         * @method canvas_terrain_toggle
         * @param event {jquery event}
         */

    }, {
        key: 'canvas_terrain_toggle',
        value: function canvas_terrain_toggle(event) {
            (0, _jquery2.default)(event.target).closest(_selectors.SELECTORS.DOM_SELECTORS.CONTROL).toggleClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            prop.canvas.draw_terrain = !prop.canvas.draw_terrain;
        }

        /**
         * @for UiController
         * @method ui_options_toggle
         */

    }, {
        key: 'ui_options_toggle',
        value: function ui_options_toggle() {
            var $optionsDialog = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.OPTIONS_DIALOG);

            if ($optionsDialog.hasClass(_selectors.SELECTORS.CLASSNAMES.OPEN)) {
                $optionsDialog.removeClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
                $optionsDialog.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            } else {
                $optionsDialog.addClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
                $optionsDialog.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            }
        }

        /**
         * @for UiController
         * @method ui_set_scale_from_storage
         */

    }, {
        key: 'ui_set_scale_from_storage',
        value: function ui_set_scale_from_storage() {
            if (!(0, _has3.default)(localStorage, _storageKeys.STORAGE_KEY.ATC_SCALE)) {
                return;
            }

            prop.ui.scale = localStorage[_storageKeys.STORAGE_KEY.ATC_SCALE];
        }
    }]);

    return UiView;
}();

exports.default = UiView;

},{"./constants/selectors":575,"./constants/storageKeys":576,"./math/core":584,"./speech":588,"jquery":296,"lodash/forEach":468,"lodash/has":470,"lodash/keys":492,"lodash/startCase":501}],523:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand, no-param-reassign, no-undef */


var _core = require('../math/core');

var _circle = require('../math/circle');

var _vector = require('../math/vector');

var _unitConverters = require('../utilities/unitConverters');

var _GameController = require('../game/GameController');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// TODO: move these to a constants file
// 14.816km = 8nm (max possible sep minmum)
var MAXIMUM_SEPARATION_KM = 14.816;
// Standard Basic Lateral Separation Minimum
var STANDARD_LATERAL_SEPARATION_MINIMUM_KM = 5.556; // 3nm
// Minimum vertical separation in feet
var MIN_VERTICAL_SEPARATION_FT = 1000;

/**
 * Details about aircraft in close proximity in relation to 'the rules'
 *
 * @class AircraftConflict
 */

var AircraftConflict = function () {
    function AircraftConflict(first, second) {
        _classCallCheck(this, AircraftConflict);

        this.aircraft = [first, second];
        this.distance = (0, _vector.vlen)((0, _vector.vsub)(first.position, second.position));
        this.distance_delta = 0;
        this.altitude = (0, _core.abs)(first.altitude - second.altitude);

        this.collided = false;

        this.conflicts = {};
        this.violations = {};

        this.aircraft[0].addConflict(this, second);
        this.aircraft[1].addConflict(this, first);

        this.update();
    }

    /**
     * Is there anything which should be brought to the controllers attention
     *
     * @returns {Array of Boolean} First element true if any conflicts/warnings,
     *                             Second element true if any violations.
     */


    _createClass(AircraftConflict, [{
        key: 'hasAlerts',
        value: function hasAlerts() {
            return [this.hasConflict(), this.hasViolation()];
        }

        /**
         *  Whether any conflicts are currently active
         */

    }, {
        key: 'hasConflict',
        value: function hasConflict() {
            for (var i in this.conflicts) {
                if (this.conflicts[i]) {
                    return true;
                }
            }

            return false;
        }

        /**
         *  Whether any violations are currently active
         */

    }, {
        key: 'hasViolation',
        value: function hasViolation() {
            for (var i in this.violations) {
                if (this.violations[i]) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Update conflict and violation checks, potentially removing this conflict.
         */

    }, {
        key: 'update',
        value: function update() {
            // Avoid triggering any more conflicts if the two aircraft have collided
            if (this.collided) {
                return;
            }

            var d = this.distance;
            this.distance = (0, _vector.vlen)((0, _vector.vsub)(this.aircraft[0].position, this.aircraft[1].position));
            this.distance_delta = this.distance - d;
            this.altitude = (0, _core.abs)(this.aircraft[0].altitude - this.aircraft[1].altitude);

            // Check if the separation is now beyond the bounding box check
            if (this.distance > MAXIMUM_SEPARATION_KM) {
                this.remove();
                return;
            }

            this.checkCollision();
            this.checkRunwayCollision();

            // Ignore aircraft below about 1000 feet
            var airportElevation = window.airportController.airport_get().elevation;
            if (this.aircraft[0].altitude - airportElevation < 990 || this.aircraft[1].altitude - airportElevation < 990) {
                return;
            }

            // Ignore aircraft in the first minute of their flight
            if (window.gameController.game_time() - this.aircraft[0].takeoffTime < 60 || window.gameController.game_time() - this.aircraft[0].takeoffTime < 60) {
                return;
            }

            this.checkProximity();
        }

        /**
         * Remove conflict for both aircraft
         */

    }, {
        key: 'remove',
        value: function remove() {
            this.aircraft[0].removeConflict(this.aircraft[1]);
            this.aircraft[1].removeConflict(this.aircraft[0]);
        }

        /**
         * Check for collision
         */

    }, {
        key: 'checkCollision',
        value: function checkCollision() {
            if (this.aircraft[0].isOnGround() || this.aircraft[1].isOnGround()) {
                return; // TEMPORARY FIX FOR CRASHES BTWN ARRIVALS AND TAXIIED A/C
            }

            // TODO: enumerate the magic numbers.
            // Collide within 160 feet
            var airport = window.airportController.airport_get();

            if (this.distance < 0.05 && this.altitude < 160 && this.aircraft[0].isInsideAirspace(airport) && this.aircraft[1].isInsideAirspace(airport)) {
                this.collided = true;
                var _isWarning = true;
                window.uiController.ui_log(this.aircraft[0].getCallsign() + ' collided with ' + this.aircraft[1].getCallsign(), _isWarning);

                window.gameController.events_recordNew(_GameController.GAME_EVENTS.COLLISION);
                this.aircraft[0].hit = true;
                this.aircraft[1].hit = true;

                // If either are in a runway queue, remove them from it
                window.airportController.removeAircraftFromAllRunwayQueues(this.aircraft[0]);
                window.airportController.removeAircraftFromAllRunwayQueues(this.aircraft[1]);
            }
        }

        /**
         * Check for a potential head-on collision on a runway
         */

    }, {
        key: 'checkRunwayCollision',
        value: function checkRunwayCollision() {
            // Check if the aircraft are on a potential collision course
            // on the runway
            var airport = window.airportController.airport_get();

            // TODO: this logic block needs its own method.
            // Check for the same runway, different ends and under about 6 miles
            if (!this.aircraft[0].isTaxiing() && !this.aircraft[1].isTaxiing() && this.aircraft[0].rwy_dep !== null && this.aircraft[0].rwy_dep !== this.aircraft[1].rwy_dep && airport.getRunway(this.aircraft[1].rwy_dep) === airport.getRunway(this.aircraft[0].rwy_dep) && this.distance < 10) {
                if (!this.conflicts.runwayCollision) {
                    this.conflicts.runwayCollision = true;
                    window.uiController.ui_log(this.aircraft[0].getCallsign() + ' appears on a collision course with' + (' ' + this.aircraft[1].getCallsign() + ' on the same runway"'), isWarning);
                }
            } else {
                this.conflicts.runwayCollision = false;
            }
        }

        // TODO: this method is ripe for refactor. lots of logic that can be pulled out to
        // helper functions or other class methods.
        /**
         * Check for physical proximity and trigger crashes if necessary
         */

    }, {
        key: 'checkProximity',
        value: function checkProximity() {
            // No conflict or warning if vertical separation is present
            if (this.altitude >= MIN_VERTICAL_SEPARATION_FT) {
                this.conflicts.proximityConflict = false;
                this.conflicts.proximityViolation = false;

                return;
            }

            var conflict = false;
            var violation = false;
            var disableNotices = false;
            var a1 = this.aircraft[0];
            var a2 = this.aircraft[1];
            var applicableLatSepMin = STANDARD_LATERAL_SEPARATION_MINIMUM_KM;

            // Established on precision guided approaches && both are following different instrument approaches
            if (a1.isPrecisionGuided() && a2.isPrecisionGuided() && a1.rwy_arr !== a2.rwy_arr) {
                var runwayRelationship = window.airportController.airport_get().metadata.rwy[a1.rwy_arr][a2.rwy_arr];

                // Determine applicable lateral separation minima for conducting
                // parallel simultaneous dependent approaches on these runways:
                if (runwayRelationship.parallel) {
                    // hide notices for aircraft on adjacent final approach courses
                    disableNotices = true;

                    // TODO: this should be a helper function: findSeparationMinimum = (feetBetween) => {};
                    var feetBetween = (0, _unitConverters.km_ft)(runwayRelationship.lateral_dist);
                    if (feetBetween < 2500) {
                        // Runways separated by <2500'
                        applicableLatSepMin = STANDARD_LATERAL_SEPARATION_MINIMUM_KM; // 3.0nm
                    } else if (feetBetween >= 2500 && feetBetween <= 3600) {
                        // 2500'-3600'
                        applicableLatSepMin = 1.852; // 1.0nm
                    } else if (feetBetween > 3600 && feetBetween <= 4300) {
                        // 3600'-4300'
                        applicableLatSepMin = 2.778; // 1.5nm
                    } else if (feetBetween > 4300 && feetBetween <= 9000) {
                        // 4300'-9000'
                        applicableLatSepMin = 3.704; // 2.0nm
                    } else if (feetBetween > 9000) {
                        // Runways separated by >9000'
                        applicableLatSepMin = STANDARD_LATERAL_SEPARATION_MINIMUM_KM; // 3.0nm
                    }
                    // Note: The above does not take into account the (more complicated)
                    // rules for dual/triple simultaneous parallel dependent approaches as
                    // outlined by FAA JO 7110.65, para 5-9-7. Users playing at any of our
                    // airports that have triple parallels may be able to "get away with"
                    // the less restrictive rules, whilst their traffic may not be 100%
                    // legal. It's just complicated and not currently worthwhile to add
                    // rules for running trips at this point... maybe later. -@erikquinn
                    // Reference: FAA JO 7110.65, section 5-9-6
                }
            }

            // TODO: this should be another class method: hasSeparationViolation(applicableLatSepMin)
            // Considering all of the above cases,...
            violation = this.distance < applicableLatSepMin;
            // TODO: enumerate the magic number.
            // TODO: this should be another class method
            conflict = this.distance < applicableLatSepMin + 1.852 && !disableNotices || violation; // +1.0nm

            // "Passing & Diverging" Rules (the "exception" to all of the above rules)
            // test the below only if separation is currently considered insufficient
            if (conflict) {
                var hdg_difference = (0, _core.abs)((0, _circle.angle_offset)(a1.groundTrack, a2.groundTrack));

                // FIXME: couldnt these two ifs be combined to something like:
                // if (hdg_difference >= degreesToRadians(15) && hdg_difference > degreesToRadians(165)) {}
                if (hdg_difference >= (0, _unitConverters.degreesToRadians)(15)) {
                    if (hdg_difference > (0, _unitConverters.degreesToRadians)(165)) {
                        // 'opposite' courses
                        if (this.distance_delta > 0) {
                            // OKAY IF the distance is increasing
                            conflict = false;
                            violation = false;
                        }
                    } else {
                        // TODO: this should definitely be a helper function that lives in one of the math/ files
                        // 'same' or 'crossing' courses
                        // Ray intersection from http://stackoverflow.com/a/2932601
                        var ad = (0, _vector.vturn)(a1.groundTrack);
                        var bd = (0, _vector.vturn)(a2.groundTrack);
                        var dx = a2.position[0] - a1.position[0];
                        var dy = a2.position[1] - a1.position[1];
                        var det = bd[0] * ad[1] - bd[1] * ad[0];
                        var u = (dy * bd[0] - dx * bd[1]) / det; // a1's distance from point of convergence
                        var v = (dy * ad[0] - dx * ad[1]) / det; // a2's distance from point of convergence

                        // TODO: this should be a helper function that live in one of the math/ files
                        if (u < 0 || v < 0) {
                            // check if either a/c has passed the point of convergence
                            conflict = false; // targets are diverging
                            violation = false; // targets are diverging
                        }
                        // Reference: FAA JO 7110.65, section 5-5-7-a-1:
                        // (a) Aircraft are on opposite/reciprocal courses and you have observed
                        // that they have passed each other; or aircraft are on same or crossing
                        // courses/assigned radar vectors and one aircraft has crossed the
                        // projected course of the other, and the angular difference between
                        // their courses/assigned radar vectors is at least 15 degrees.
                    }
                }
            }

            // Update Conflicts
            if (conflict) {
                this.conflicts.proximityConflict = true;
            } else {
                this.conflicts.proximityConflict = false;
            }

            if (violation) {
                this.violations.proximityViolation = true;
                // TODO: Add score penalty for 'SEPARATION_LOSS', but only ONCE
            } else {
                this.violations.proximityViolation = false;
            }
        }
    }]);

    return AircraftConflict;
}();

exports.default = AircraftConflict;

},{"../game/GameController":580,"../math/circle":583,"../math/core":584,"../math/vector":587,"../utilities/unitConverters":595}],524:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle, no-unused-vars, no-undef, global-require */


var _without2 = require('lodash/without');

var _without3 = _interopRequireDefault(_without2);

var _AircraftConflict = require('./AircraftConflict');

var _AircraftConflict2 = _interopRequireDefault(_AircraftConflict);

var _AircraftModel = require('./AircraftModel');

var _AircraftModel2 = _interopRequireDefault(_AircraftModel);

var _speech = require('../speech');

var _core = require('../math/core');

var _distance = require('../math/distance');

var _vector = require('../math/vector');

var _unitConverters = require('../utilities/unitConverters');

var _flightMath = require('../math/flightMath');

var _circle = require('../math/circle');

var _GameController = require('../game/GameController');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var aircraft = {};

// TODO: this should be renamed to `AircraftCollection`
/**
 * @class AircraftController
 */

var AircraftController = function () {
    /**
     * @constructor
     */
    function AircraftController() {
        _classCallCheck(this, AircraftController);

        this.aircraft = aircraft;
        this.aircraft.models = {};
        this.aircraft.callsigns = [];
        this.aircraft.list = [];
        this.aircraft.current = null;
        this.aircraft.auto = { enabled: false };
        prop.aircraft = aircraft;
    }

    /**
     * @for AircraftController
     * @method aircraft_auto_toggle
     */


    _createClass(AircraftController, [{
        key: 'aircraft_auto_toggle',
        value: function aircraft_auto_toggle() {
            prop.aircraft.auto.enabled = !this.aircraft.auto.enabled;
        }

        /**
         * @for AircraftController
         * @method isCallsignInList
         * @param callsign {string}
         * return {boolean}
         */

    }, {
        key: 'isCallsignInList',
        value: function isCallsignInList(callsign) {
            return this.aircraft.callsigns.indexOf(callsign) !== -1;
        }

        /**
         * Add a new callsign to `aircraft.callsigns`
         *
         * @for AircraftController
         * @method addCallsignToList
         * @param callsign {string}
         */

    }, {
        key: 'addCallsignToList',
        value: function addCallsignToList(callsign) {
            if (this.isCallsignInList(callsign)) {
                // if you've made it here something has gone very wrong. generation of a callsign/flightNumber should
                // also include verification that the callsign/flightNumber is unique
                console.warn(callsign + ' already exists within the callsigns list!');

                return;
            }

            this.aircraft.callsigns.push(callsign);
        }

        /**
         * @for AircraftController
         * @method aircraft_new
         * @param options {object}
         */

    }, {
        key: 'aircraft_new',
        value: function aircraft_new(options) {
            var airline = window.airlineController.airline_get(options.airline);

            return airline.generateAircraft(options);
        }

        /**
         * @for AircraftController
         * @method aircraft_get_nearest
         * @param position
         */

    }, {
        key: 'aircraft_get_nearest',
        value: function aircraft_get_nearest(position) {
            var nearest = null;
            var distance = Infinity;

            for (var i = 0; i < this.aircraft.list.length; i++) {
                var _aircraft = this.aircraft.list[i];
                var d = (0, _distance.distance2d)(_aircraft.position, position);

                if (d < distance && _aircraft.isVisible() && !_aircraft.hit) {
                    distance = d;
                    nearest = i;
                }
            }

            return [this.aircraft.list[nearest], distance];
        }

        /**
         * @for AircraftController
         * @method aircraft_add
         * @param model {AircraftModel|object}
         */

    }, {
        key: 'aircraft_add',
        value: function aircraft_add(model) {
            this.aircraft.models[model.icao.toLowerCase()] = model;
        }

        /**
         * @for AircraftController
         * @method aircraft_visible
         * @param aircraft
         * @param factor
         */

    }, {
        key: 'aircraft_visible',
        value: function aircraft_visible(aircraft) {
            var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            return (0, _vector.vlen)(aircraft.position) < window.airportController.airport_get().ctr_radius * factor;
        }

        /**
         * @for AircraftController
         * @method aircraft_remove_all
         */

    }, {
        key: 'aircraft_remove_all',
        value: function aircraft_remove_all() {
            for (var i = 0; i < this.aircraft.list.length; i++) {
                this.aircraft.list[i].cleanup();
            }

            this.aircraft.list = [];
        }

        /**
         * @for AircraftController
         * @method aircraft_remove
         */

    }, {
        key: 'aircraft_remove',
        value: function aircraft_remove(aircraft) {
            window.airportController.removeAircraftFromAllRunwayQueues(aircraft);
            this.removeCallsignFromList(aircraft.callsign);
            this.removeAircraftInstanceModelFromList(aircraft);
            aircraft.cleanup();
        }

        /**
         * @for AircraftController
         * @method aircraft_update
         */

    }, {
        key: 'aircraft_update',
        value: function aircraft_update() {
            // TODO: change to _forEach()
            for (var i = 0; i < this.aircraft.list.length; i++) {
                this.aircraft.list[i].update();
                this.aircraft.list[i].updateWarning();

                // TODO: move this InnerLoop thing to a function so we can get rid of the continue InnerLoop thing.
                for (var j = i + 1; j < this.aircraft.list.length; j++) {
                    // TODO: need better names here. what is `that`?  what is `other`?
                    var _aircraft2 = this.aircraft.list[i];
                    var otherAircraft = this.aircraft.list[j];

                    if (_aircraft2.checkConflict(otherAircraft)) {
                        continue;
                    }

                    // Fast 2D bounding box check, there are no conflicts over 8nm apart (14.816km)
                    // no violation can occur in this case.
                    // Variation of:
                    // http://gamedev.stackexchange.com/questions/586/what-is-the-fastest-way-to-work-out-2d-bounding-box-intersection
                    var dx = (0, _core.abs)(_aircraft2.position[0] - otherAircraft.position[0]);
                    var dy = (0, _core.abs)(_aircraft2.position[1] - otherAircraft.position[1]);

                    // TODO: move this value to a constant
                    // TODO: this if/else doesn't make sense
                    if (dx > 14.816 || dy > 14.816) {
                        continue;
                    } else {
                        // TODO: this should go somewhere and not just be instantiated
                        new _AircraftConflict2.default(_aircraft2, otherAircraft);
                    }
                }
            }

            for (var _i = this.aircraft.list.length - 1; _i >= 0; _i--) {
                var remove = false;
                var _aircraft3 = this.aircraft.list[_i];
                // let is_visible = aircraft_visible(aircraft);

                if (_aircraft3.isStopped() && _aircraft3.category === 'arrival') {
                    _aircraft3.scoreWind('landed');

                    window.uiController.ui_log(_aircraft3.getCallsign() + ' switching to ground, good day');
                    (0, _speech.speech_say)([{ type: 'callsign', content: _aircraft3 }, { type: 'text', content: ', switching to ground, good day' }]);

                    window.gameController.events_recordNew(_GameController.GAME_EVENTS.ARRIVAL);
                    remove = true;
                }

                if (_aircraft3.hit && _aircraft3.isOnGround()) {
                    window.uiController.ui_log('Lost radar contact with ' + _aircraft3.getCallsign());
                    (0, _speech.speech_say)([{ type: 'callsign', content: _aircraft3 }, { type: 'text', content: ', radar contact lost' }]);

                    remove = true;
                }

                // Clean up the screen from aircraft that are too far
                if (!this.aircraft_visible(_aircraft3, 2) && !_aircraft3.inside_ctr && _aircraft3.fms.currentWaypoint.navmode === 'heading') {
                    if (_aircraft3.category === 'arrival' || _aircraft3.category === 'departure') {
                        remove = true;
                    }
                }

                if (remove) {
                    this.aircraft_remove(_aircraft3);
                    _i -= 1;
                }
            }
        }

        /**
         * Calculate the turn initiation distance for an aircraft to navigate between two fixes.
         *
         * References:
         * - http://www.ohio.edu/people/uijtdeha/ee6900_fms_00_overview.pdf, Fly-by waypoint
         * - The Avionics Handbook, ch 15
         *
         * @for AircraftController
         * @method aircraft_turn_initiation_distance
         * @param aircraft {AircraftInstanceModel}
         * @param fix
         */

    }, {
        key: 'aircraft_turn_initiation_distance',
        value: function aircraft_turn_initiation_distance(aircraft, fix) {
            // TODO: this function is ripe for refactor. there is a lot of inline logic that can be abstracted and/or pulled out
            var index = aircraft.fms.indexOfCurrentWaypoint().wp;
            if (index >= aircraft.fms.waypoints().length - 1) {
                // if there are no subsequent fixes, fly over 'fix'
                return 0;
            }

            // convert knots to m/s
            var speed = (0, _unitConverters.kn_ms)(aircraft.speed);
            // assume nominal bank angle of 25 degrees for all aircraft
            var bank_angle = (0, _unitConverters.degreesToRadians)(25);

            // TODO: is there a getNextWaypoint() function?
            var nextfix = aircraft.fms.waypoint(aircraft.fms.indexOfCurrentWaypoint().wp + 1).location;
            if (!nextfix) {
                return 0;
            }

            var nominal_new_course = (0, _vector.vradial)((0, _vector.vsub)(nextfix, fix));
            if (nominal_new_course < 0) {
                // TODO: what is this doing? this should go in a new method.
                nominal_new_course += (0, _circle.tau)();
            }

            var current_heading = aircraft.heading;
            if (current_heading < 0) {
                current_heading += (0, _circle.tau)();
            }

            // TODO: move to function
            var course_change = (0, _core.abs)((0, _unitConverters.radiansToDegrees)(current_heading) - (0, _unitConverters.radiansToDegrees)(nominal_new_course));
            if (course_change > 180) {
                course_change = 360 - course_change;
            }

            course_change = (0, _unitConverters.degreesToRadians)(course_change);
            // meters, bank establishment in 1s
            var turn_initiation_distance = (0, _flightMath.calcTurnInitiationDistance)(speed, bank_angle, course_change);

            return turn_initiation_distance / 1000; // convert m to km
        }

        /**
         * @for AircraftController
         * @method aircraft_get
         * @param eid
         */

    }, {
        key: 'aircraft_get',
        value: function aircraft_get() {
            var eid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (eid === null) {
                return null;
            }

            // prevent out-of-range error
            if (this.aircraft.list.length > eid && eid >= 0) {
                return this.aircraft.list[eid];
            }

            return null;
        }

        /**
         * @for AircraftController
         * @method aircraft_get_by_callsign
         * @param callsign {string}
         */

    }, {
        key: 'aircraft_get_by_callsign',
        value: function aircraft_get_by_callsign(callsign) {
            callsign = String(callsign);

            for (var i = 0; i < this.aircraft.list.length; i++) {
                if (this.aircraft.list[i].callsign === callsign.toLowerCase()) {
                    return this.aircraft.list[i];
                }
            }

            return null;
        }

        /**
         * @for AircraftController
         * @method aircraft_get_eid_by_callsign
         * @param callsign {string}
         */

    }, {
        key: 'aircraft_get_eid_by_callsign',
        value: function aircraft_get_eid_by_callsign(callsign) {
            for (var i = 0; i < this.aircraft.list.length; i++) {
                var _aircraft4 = this.aircraft.list[i];

                if (_aircraft4.callsign === callsign.toLowerCase()) {
                    return _aircraft4.eid;
                }
            }

            return null;
        }

        /**
         * @for AircraftController
         * @method aircraft_model_get
         * @param icao {string}
         */

    }, {
        key: 'aircraft_model_get',
        value: function aircraft_model_get(icao) {
            if (!this.aircraft.models[icao]) {
                var model = new _AircraftModel2.default({
                    icao: icao,
                    url: 'assets/aircraft/' + icao + '.json'
                });

                this.aircraft.models[icao] = model;
            }

            return this.aircraft.models[icao];
        }

        /**
         * Remove the specified aircraft from `AircraftController.aircraft`
         * @method removeAircraftInstanceModelFromList
         * @param  {Aircraft} aircraft the aircraft to remove
         */

    }, {
        key: 'removeAircraftInstanceModelFromList',
        value: function removeAircraftInstanceModelFromList(aircraft) {
            this.aircraft.list = (0, _without3.default)(this.aircraft.list, aircraft);
        }

        /**
         * Remove a flight number from the list stored in `AircraftController.aircraft.callsigns`
         * @for AircraftController
         * @method removeCallsignFromList
         * @param  {string} callsign the flight number to remove
         */

    }, {
        key: 'removeCallsignFromList',
        value: function removeCallsignFromList(callsign) {
            this.aircraft.callsigns = (0, _without3.default)(this.aircraft.callsigns, callsign);
        }

        // TODO: what is an `eid` and why would it beed to be updated?
        /**
         * Adjust all aircraft's eid values
         *
         * @for AircraftController
         * @method update_aircraft_eids
         */

    }, {
        key: 'update_aircraft_eids',
        value: function update_aircraft_eids() {
            for (var i = 0; i < this.aircraft.list.length; i++) {
                // update eid in aircraft
                this.aircraft.list[i].eid = i;
                // update eid in aircraft's fms
                this.aircraft.list[i].fms.my_aircrafts_eid = i;
            }
        }
    }]);

    return AircraftController;
}();

exports.default = AircraftController;

},{"../game/GameController":580,"../math/circle":583,"../math/core":584,"../math/distance":585,"../math/flightMath":586,"../math/vector":587,"../speech":588,"../utilities/unitConverters":595,"./AircraftConflict":523,"./AircraftModel":526,"lodash/without":513}],525:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable max-len */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _isNaN2 = require('lodash/isNaN');

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _AircraftFlightManagementSystem = require('./FlightManagementSystem/AircraftFlightManagementSystem');

var _AircraftFlightManagementSystem2 = _interopRequireDefault(_AircraftFlightManagementSystem);

var _AircraftStripView = require('./AircraftStripView');

var _AircraftStripView2 = _interopRequireDefault(_AircraftStripView);

var _Waypoint = require('./FlightManagementSystem/Waypoint');

var _Waypoint2 = _interopRequireDefault(_Waypoint);

var _RouteModel = require('../airport/Route/RouteModel');

var _RouteModel2 = _interopRequireDefault(_RouteModel);

var _speech = require('../speech');

var _circle = require('../math/circle');

var _core = require('../math/core');

var _distance = require('../math/distance');

var _flightMath = require('../math/flightMath');

var _vector = require('../math/vector');

var _radioUtilities = require('../utilities/radioUtilities');

var _unitConverters = require('../utilities/unitConverters');

var _aircraftConstants = require('../constants/aircraftConstants');

var _selectors = require('../constants/selectors');

var _GameController = require('../game/GameController');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Enum of commands and thier corresponding function.
 *
 * Used to build a call to the correct function when a UI command, or commands,
 * for an aircraft have been issued.
 *
 * @property COMMANDS
 * @type {Object}
 * @final
 */
var COMMANDS = {
    abort: 'runAbort',
    altitude: 'runAltitude',
    clearedAsFiled: 'runClearedAsFiled',
    climbViaSID: 'runClimbViaSID',
    debug: 'runDebug',
    delete: 'runDelete',
    descendViaSTAR: 'runDescendViaSTAR',
    direct: 'runDirect',
    fix: 'runFix',
    flyPresentHeading: 'runFlyPresentHeading',
    heading: 'runHeading',
    hold: 'runHold',
    land: 'runLanding',
    moveDataBlock: 'runMoveDataBlock',
    route: 'runRoute',
    reroute: 'runReroute',
    sayRoute: 'runSayRoute',
    sid: 'runSID',
    speed: 'runSpeed',
    star: 'runSTAR',
    takeoff: 'runTakeoff',
    taxi: 'runTaxi'
};

/**
 * @property FLIGHT_RULES
 * @type {Object}
 * @final
 */
var FLIGHT_RULES = {
    VFR: 'vfr',
    IFR: 'ifr'
};

/**
 * Each simulated aircraft in the game. Contains a model, fms, and conflicts.
 *
 * @class AircraftInstanceModel
 */

var Aircraft = function () {
    /**
     * @for AircraftInstanceModel
     * @constructor
     * @param options {object}
     */
    function Aircraft() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Aircraft);

        /* eslint-disable no-multi-spaces*/
        this.eid = prop.aircraft.list.length; // entity ID
        this.position = [0, 0]; // Aircraft Position, in km, relative to airport position
        this.model = null; // Aircraft type
        this.airline = ''; // Airline Identifier (eg. 'AAL')
        this.callsign = ''; // Flight Number ONLY (eg. '551')
        this.heading = 0; // Magnetic Heading
        this.altitude = 0; // Altitude, ft MSL
        this.speed = 0; // Indicated Airspeed (IAS), knots
        this.groundSpeed = 0; // Groundspeed (GS), knots
        this.groundTrack = 0; //
        this.ds = 0; //
        this.takeoffTime = 0; //
        this.rwy_dep = null; // Departure Runway (to use, currently using, or used)
        this.rwy_arr = null; // Arrival Runway (to use, currently using, or used)
        this.approachOffset = 0; // Distance laterally from the approach path
        this.approachDistance = 0; // Distance longitudinally from the threshold
        this.radial = 0; // Angle from airport center to aircraft
        this.distance = 0; //
        this.destination = null; // Destination they're flying to
        this.trend = 0; // Indicator of descent/level/climb (1, 0, or 1)
        this.history = []; // Array of previous positions
        this.restricted = { list: [] };
        this.notice = false; // Whether aircraft
        this.warning = false; //
        this.hit = false; // Whether aircraft has crashed
        this.taxi_next = false; //
        this.taxi_start = 0; //
        this.taxi_time = 3; // Time spent taxiing to the runway. *NOTE* this should be INCREASED to around 60 once the taxi vs LUAW issue is resolved (#406)
        this.rules = FLIGHT_RULES.IFR; // Either IFR or VFR (Instrument/Visual Flight Rules)
        this.inside_ctr = false; // Inside ATC Airspace
        this.datablockDir = -1; // Direction the data block points (-1 means to ignore)
        this.conflicts = {}; // List of aircraft that MAY be in conflict (bounding box)
        this.terrain_ranges = false;
        // FIXME: change name, and update refs in `InputController`. perhaps change to be a ref to the AircraftStripView class instead of directly accessing the html?
        this.aircraftStripView = null;
        this.$html = null;

        this.$strips = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.STRIPS);
        /* eslint-enable multi-spaces*/

        // Set to true when simulating future movements of the aircraft
        // Should be checked before updating global state such as score
        // or HTML.
        this.projected = false;
        this.position_history = [];

        this.category = options.category; // 'arrival' or 'departure'
        this.mode = _aircraftConstants.FLIGHT_MODES.CRUISE;

        /*
         * the following diagram illustrates all allowed mode transitions:
         *
         * apron -> taxi -> waiting -> takeoff -> cruise <-> landing
         *   ^                                       ^
         *   |                                       |
         * new planes with                      new planes with
         * category 'departure'                 category 'arrival'
         */

        // Initialize the FMS
        this.fms = new _AircraftFlightManagementSystem2.default({
            aircraft: this,
            model: options.model
        });

        // target represents what the pilot makes of the tower's commands. It is
        // most important when the plane is in a 'guided' situation, that is it is
        // not given a heading directly, but has a fix or is following an ILS path
        this.target = {
            heading: null,
            turn: null,
            altitude: 0,
            expedite: false,
            speed: 0
        };

        this.emergency = {};
        this.takeoffTime = options.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL ? window.gameController.game_time() : null;

        this.buildCurrentTerrainRanges();
        this.buildRestrictedAreaLinks();
        this.assignInitialRunway(options);
        this.parse(options);
        this.updateFmsAfterInitialLoad(options);
        this.createStrip();
        this.updateStrip();
    }

    /**
     * @for AircraftInstanceModel
     * @method buildCurrentTerrainRanges
     */


    _createClass(Aircraft, [{
        key: 'buildCurrentTerrainRanges',
        value: function buildCurrentTerrainRanges() {
            var _this = this;

            var terrain = (0, _get3.default)(prop, 'airport.current.terrain', null);

            if (!terrain) {
                return;
            }

            this.terrain_ranges = {};
            this.terrain_level = 0;

            (0, _forEach3.default)(terrain, function (terrainRange, k) {
                _this.terrain_ranges[k] = {};

                (0, _forEach3.default)(terrainRange, function (range, j) {
                    _this.terrain_ranges[k][j] = Infinity;
                });
            });
        }

        /**
         * Set up links to restricted areas
         *
         * @for AircraftInstanceModel
         * @method buildRestrictedAreaLinks
         */

    }, {
        key: 'buildRestrictedAreaLinks',
        value: function buildRestrictedAreaLinks() {
            var _this2 = this;

            var restrictedAreas = prop.airport.current.restricted_areas;

            (0, _forEach3.default)(restrictedAreas, function (area) {
                _this2.restricted.list.push({
                    data: area,
                    range: null,
                    inside: false
                });
            });
        }

        /**
         * Initial Runway Assignment
         *
         * @for AircraftInstanceModel
         * @method assignInitialRunway
         * @param options {object}
         */

    }, {
        key: 'assignInitialRunway',
        value: function assignInitialRunway(options) {
            if (options.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                this.setArrivalRunway(window.airportController.airport_get().runway);
            } else if (options.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                this.setDepartureRunway(window.airportController.airport_get().runway);
            }
        }
    }, {
        key: 'parse',
        value: function parse(data) {
            this.position = (0, _get3.default)(data, 'position', this.position);
            this.model = (0, _get3.default)(data, 'model', this.model);
            this.airline = (0, _get3.default)(data, 'airline', this.airline);
            this.callsign = (0, _get3.default)(data, 'callsign', this.callsign);
            this.category = (0, _get3.default)(data, 'category', this.category);
            this.heading = (0, _get3.default)(data, 'heading', this.heading);
            this.altitude = (0, _get3.default)(data, 'altitude', this.altitude);
            this.speed = (0, _get3.default)(data, 'speed', this.speed);
        }
    }, {
        key: 'updateFmsAfterInitialLoad',
        value: function updateFmsAfterInitialLoad(data) {
            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                if (data.waypoints.length > 0) {
                    this.setArrivalWaypoints(data.waypoints);
                }

                this.destination = data.destination;
                this.setArrivalRunway(window.airportController.airport_get(this.destination).runway);
            } else if (this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                var airport = window.airportController.airport_get();
                this.mode = _aircraftConstants.FLIGHT_MODES.APRON;
                this.destination = data.destination;
                this.setDepartureRunway(airport.runway);
                this.altitude = airport.position.elevation;
                this.speed = 0;
            }

            // TODO: combine these two to asingle constant
            if (data.heading) {
                this.fms.setCurrent({ heading: data.heading });
            }

            if (data.altitude) {
                this.fms.setCurrent({ altitude: data.altitude });
            }

            var speed = (0, _get3.default)(data, 'speed', this.model.speed.cruise);
            this.fms.setCurrent({ speed: speed });

            if (data.route) {
                var route = this.fms.formatRoute(data.route);

                this.fms.customRoute(route, true);
                this.fms.descendViaSTAR();
            }

            if (data.nextFix) {
                this.fms.skipToFix(data.nextFix);
            }
        }
    }, {
        key: 'setArrivalWaypoints',
        value: function setArrivalWaypoints(waypoints) {
            // add arrival fixes to fms
            for (var i = 0; i < waypoints.length; i++) {
                this.fms.appendLeg({
                    type: 'fix',
                    route: waypoints[i].fix
                });
            }

            // TODO: this could be another class method for FMS
            if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HEADING) {
                // aim aircraft at airport
                this.fms.setCurrent({
                    heading: (0, _vector.vradial)(this.position) + Math.PI
                });
            }

            if (this.fms.legs.length > 0) {
                // go to the first fix!
                this.fms.nextWaypoint();
            }
        }
    }, {
        key: 'setArrivalRunway',
        value: function setArrivalRunway(rwy) {
            this.rwy_arr = rwy;

            // Update the assigned STAR to use the fixes for the specified runway, if they exist
        }
    }, {
        key: 'setDepartureRunway',
        value: function setDepartureRunway(rwy) {
            this.rwy_dep = rwy;

            // Update the assigned SID to use the portion for the new runway
            var leg = this.fms.currentLeg;

            // TODO: this should return early
            // TODO: use existing enumeration for `sid`
            if (leg.type === 'sid') {
                var a = (0, _map3.default)(leg.waypoints, function (v) {
                    return v.altitude;
                });
                var cvs = !a.every(function (v) {
                    return v === window.airportController.airport_get().initial_alt;
                });
                this.fms.followSID(leg.route.routeCode);

                if (cvs) {
                    this.fms.climbViaSID();
                }
            }
        }
    }, {
        key: 'cleanup',
        value: function cleanup() {
            this.$html.remove();
        }

        /**
         * Create the aircraft's flight strip and add to strip bay
         */

    }, {
        key: 'createStrip',
        value: function createStrip() {
            this.aircraftStripView = new _AircraftStripView2.default(this.getCallsign(), this);

            this.$html = this.aircraftStripView.$element;
            // Add the strip to the html
            var scrollPos = this.$strips.scrollTop();
            this.$strips.prepend(this.aircraftStripView.$element);
            // shift scroll down one strip's height
            this.$strips.scrollTop(scrollPos + this.aircraftStripView.height);

            // Determine whether or not to show the strip in our bay
            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                this.aircraftStripView.hide();
            }

            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                // TODO: does this have anything to do with the aircraft strip? if not this should live somewhere else.
                this.inside_ctr = true;
            }
        }

        // Called when the aircraft crosses the center boundary (ie, leaving our airspace)
        /**
         * @for AircraftInstanceModel
         * @method crossBoundary
         * @param inbound {}
         */

    }, {
        key: 'crossBoundary',
        value: function crossBoundary(inbound) {
            this.inside_ctr = inbound;

            if (this.projected) {
                return;
            }

            // Crossing into the center
            if (inbound) {
                this.showStrip();
                this.callUp();
            } else {
                // leaving airspace
                this.onAirspaceExit();
            }
        }

        /**
         * @for AircraftInstanceModel
         * @method onAirspaceExit
         */

    }, {
        key: 'onAirspaceExit',
        value: function onAirspaceExit() {
            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                this.arrivalExit();
            }

            // Leaving the facility's airspace
            this.hideStrip();

            // TODO: is this supposed to be `typeof === 'number'` or is destination a literal string 'number' here?
            if (this.destination === 'number') {
                // an aircraft was given a radial  clearance
                if (this.isHeadingInsideDepartureWindow()) {
                    this.radioCall('switching to center, good day', 'dep');
                    window.gameController.events_recordNew(_GameController.GAME_EVENTS.DEPARTURE);
                } else {
                    this.radioCall('leaving radar coverage outside departure window', 'dep', true);
                    window.gameController.events_recordNew(_GameController.GAME_EVENTS.NOT_CLEARED_ON_ROUTE);
                }
            } else {
                // following a Standard Instrument Departure procedure
                // Find the desired SID exitPoint
                var exit = void 0;

                // TODO: if we just need the last fix in the list, why loop through all the legs?
                (0, _forEach3.default)(this.fms.legs, function (leg) {
                    if (leg.type === 'sid') {
                        // TODO: use lodash `_last()` here
                        exit = leg.waypoints[leg.waypoints.length - 1].fix;
                        return;
                    }
                });

                // Verify aircraft was cleared to departure fix
                var ok = this.fms.hasWaypoint(exit);

                if (ok) {
                    this.radioCall('switching to center, good day', 'dep');
                    window.gameController.events_recordNew(_GameController.GAME_EVENTS.DEPARTURE);
                } else {
                    // TODO: this is a temporary fix for `release/3.0.0`. this will need to be refactored
                    var fmsDestination = this.fms.fp.route[1].indexOf('.') !== -1 ? this.fms.fp.route[1].split('.')[1] : this.fms.fp.route[1];

                    // TODO: add helper method to FMS class for this
                    this.radioCall('leaving radar coverage without being cleared to ' + fmsDestination, 'dep', true);
                    window.gameController.events_recordNew(_GameController.GAME_EVENTS.NOT_CLEARED_ON_ROUTE);
                }
            }

            this.fms.setCurrent({
                altitude: this.fms.fp.altitude,
                speed: this.model.speed.cruise
            });
        }

        /**
         * An arriving aircraft is exiting the airpsace
         *
         * @for AircraftInstanceModel
         * @method arrivalExit
         */

    }, {
        key: 'arrivalExit',
        value: function arrivalExit() {
            this.radioCall('leaving radar coverage as arrival', 'app', true);
            window.gameController.events_recordNew(_GameController.GAME_EVENTS.AIRSPACE_BUST);
        }

        /**
         * Is an aircraft's current heading within a specific range
         *
         * @for AircraftInstanceModel
         * @method isHeadingInsideDepartureWindow
         */

    }, {
        key: 'isHeadingInsideDepartureWindow',
        value: function isHeadingInsideDepartureWindow() {
            // TODO: enumerate the magic number
            // Within 5 degrees of destination heading
            return (0, _core.abs)(this.radial - this.destination) < 0.08726;
        }

        /**
         * @for AircraftInstanceModel
         * @method matchCallsign
         * @param callsign {string}
         */

    }, {
        key: 'matchCallsign',
        value: function matchCallsign(callsignToMatch) {
            if (callsignToMatch === '*') {
                return true;
            }

            return (0, _isEqual3.default)(callsignToMatch.toUpperCase(), this.getCallsign());
        }

        // TODO: this could be a getter
        /**
         * @for AircraftInstanceModel
         * @method getCallsign
         * @return {string}
         */

    }, {
        key: 'getCallsign',
        value: function getCallsign() {
            return (this.getAirline().icao + this.callsign).toUpperCase();
        }

        // TODO: this could be a getter
        /**
         * @for AircraftInstanceModel
         * @method getAirline
         * @return {string}
         */

    }, {
        key: 'getAirline',
        value: function getAirline() {
            return window.airlineController.airline_get(this.airline);
        }

        /**
         * @for AircraftInstanceModel
         * @method getRadioCallsign
         * @param condensed
         */

    }, {
        key: 'getRadioCallsign',
        value: function getRadioCallsign(condensed) {
            var heavy = '';

            if (this.model.weightclass === 'H') {
                heavy = ' heavy';
            }

            if (this.model.weightclass === 'U') {
                heavy = ' super';
            }

            var callsign = this.callsign;
            if (condensed) {
                var length = 2;
                callsign = callsign.substr(callsign.length - length);
            }

            var cs = window.airlineController.airline_get(this.airline).callsign;

            if (cs === 'November') {
                cs += ' ' + (0, _radioUtilities.radio_spellOut)(callsign) + ' ' + heavy;
            } else {
                cs += ' ' + (0, _radioUtilities.groupNumbers)(callsign, this.airline) + ' ' + heavy;
            }

            return cs;
        }

        /**
         * @for AircraftInstanceModel
         * @method getClimbRate
         * @return {number}
         */

    }, {
        key: 'getClimbRate',
        value: function getClimbRate() {
            var altitude = this.altitude;
            var rate = this.model.rate.climb;
            var ceiling = this.model.ceiling;
            var serviceCeilingClimbRate = void 0;
            var cr_uncorr = void 0;
            var cr_current = void 0;

            if (this.model.engines.type === 'J') {
                serviceCeilingClimbRate = 500;
            } else {
                serviceCeilingClimbRate = 100;
            }

            // TODO: enumerate the magic number
            // in troposphere
            if (this.altitude < 36152) {
                // TODO: break this assignemnt up into smaller parts and holy magic numbers! enumerate the magic numbers
                cr_uncorr = rate * 420.7 * (1.232 * Math.pow((518.6 - 0.00356 * altitude) / 518.6, 5.256) / (518.6 - 0.00356 * altitude));
                cr_current = cr_uncorr - altitude / ceiling * cr_uncorr + altitude / ceiling * serviceCeilingClimbRate;
            } else {
                // in lower stratosphere
                // re-do for lower stratosphere
                // Reference: https://www.grc.nasa.gov/www/k-12/rocket/atmos.html
                // also recommend using graphing calc from desmos.com
                return this.model.rate.climb; // <-- NOT VALID! Just a placeholder!
            }

            return cr_current;
        }

        /**
         * @for AircraftInstanceModel
         * @method hideStrip
         */

    }, {
        key: 'hideStrip',
        value: function hideStrip() {
            this.$html.hide(600);
        }

        // TODO: move aircraftCommands to a new class
        /**
         * @for AircraftInstanceModel
         * @method runCommands
         * @param commands
         */

    }, {
        key: 'runCommands',
        value: function runCommands(commands) {
            if (!this.inside_ctr) {
                return true;
            }

            var response = [];
            var response_end = '';
            var deferred = [];

            for (var i = 0; i < commands.length; i++) {
                var command = commands[i][0];
                var args = commands[i].splice(1);

                if (command === _aircraftConstants.FLIGHT_MODES.TAKEOFF) {
                    deferred.push([command, args]);
                    continue;
                }

                var retval = this.run(command, args);

                if (retval) {
                    if (!(0, _has3.default)(retval[1], 'log') || !(0, _has3.default)(retval[1], 'say')) {
                        // TODO: reassigning a value using itself is dangerous. this should be re-wroked
                        retval = [retval[0], {
                            log: retval[1],
                            say: retval[1]
                        }];
                    }

                    response.push(retval[1]);

                    if (retval[2]) {
                        response_end = retval[2];
                    }
                }
            }

            for (var _i = 0; _i < deferred.length; _i += 1) {
                var _command = deferred[_i][0];
                var _args = deferred[_i][1];
                var _retval = this.run(_command, _args);

                if (_retval) {
                    // TODO: fix the logic here this very purposly using `!=`. length is not an object and thus,
                    // never null but by using coercion it evaluates to falsey if its not an array
                    // true if array, and not log/say object
                    if (_retval[1].length != null) {
                        // make into log/say object
                        _retval[1] = {
                            say: _retval[1],
                            log: _retval[1]
                        };
                    }

                    response.push(_retval[1]);
                }
            }

            if (commands.length === 0) {
                response = [{
                    say: 'not understood',
                    log: 'not understood'
                }];
                response_end = 'say again';
            }

            if (response.length >= 1) {
                if (response_end) {
                    response_end = ', ' + response_end;
                }

                var r_log = (0, _map3.default)(response, function (r) {
                    return r.log;
                }).join(', ');
                var r_say = (0, _map3.default)(response, function (r) {
                    return r.say;
                }).join(', ');

                window.uiController.ui_log(this.getCallsign() + ', ' + r_log + ' ' + response_end);
                (0, _speech.speech_say)([{ type: 'callsign', content: this }, { type: 'text', content: r_say + ' ' + response_end }]);
            }

            this.updateStrip();

            return true;
        }

        /**
         * @for AircraftInstanceModel
         * @method run
         * @param command
         * @param data
         * @return {function}
         */

    }, {
        key: 'run',
        value: function run(command, data) {
            var call_func = void 0;

            if (COMMANDS[command]) {
                call_func = COMMANDS[command];
            }

            if (!call_func) {
                return ['fail', 'not understood'];
            }

            return this[call_func](data);
        }

        /**
         * @for AircraftInstanceModel
         * @method runHeading
         * @param data
         */

    }, {
        key: 'runHeading',
        value: function runHeading(data) {
            var airport = window.airportController.airport_get();
            var direction = data[0];
            var heading = data[1];
            var incremental = data[2];
            var amount = 0;
            var instruction = void 0;

            if ((0, _isNaN3.default)(heading)) {
                return ['fail', 'heading not understood'];
            }

            if (incremental) {
                amount = heading;

                if (direction === 'left') {
                    heading = (0, _unitConverters.radiansToDegrees)(this.heading) - amount;
                } else if (direction === 'right') {
                    heading = (0, _unitConverters.radiansToDegrees)(this.heading) + amount;
                }
            }

            // TODO: this probably shouldn't be the AircraftInstanceModel's job. this logic should belong somewhere else.
            // Update the FMS
            var wp = this.fms.currentWaypoint;
            var leg = this.fms.currentLeg;
            var f = this.fms.following;

            if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.RWY) {
                this.cancelLanding();
            }

            // already being vectored or holding. Will now just change the assigned heading.
            if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HEADING) {
                this.fms.setCurrent({
                    altitude: wp.altitude,
                    navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                    heading: (0, _unitConverters.degreesToRadians)(heading),
                    speed: wp.speed,
                    turn: direction,
                    hold: false
                });
            } else if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HOLD) {
                // in hold. Should leave the hold, and add leg for vectors
                var index = this.fms.current[0] + 1;
                var waypointToAdd = new _Waypoint2.default({
                    altitude: wp.altitude,
                    navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                    heading: (0, _unitConverters.degreesToRadians)(heading),
                    speed: wp.speed,
                    turn: direction,
                    hold: false
                }, airport);

                // add new Leg after hold leg
                this.fms.insertLeg({
                    firstIndex: index,
                    waypoints: [waypointToAdd]
                });

                // move from hold leg to vector leg.
                this.fms.nextWaypoint();
            } else if (f.sid || f.star || f.awy) {
                var _waypointToAdd = new _Waypoint2.default({
                    altitude: wp.altitude,
                    navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                    heading: (0, _unitConverters.degreesToRadians)(heading),
                    speed: wp.speed,
                    turn: direction,
                    hold: false
                }, airport);

                // TODO: this should be an FMS class method that accepts a new `waypointToAdd`
                // insert wp with heading at current position within the already active leg
                leg.waypoints.splice(this.fms.current[1], 0, _waypointToAdd);
            } else if (leg.route !== '[radar vectors]') {
                // needs new leg added
                if (this.fms.atLastWaypoint()) {
                    var _waypointToAdd2 = new _Waypoint2.default({
                        altitude: wp.altitude,
                        navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                        heading: (0, _unitConverters.degreesToRadians)(heading),
                        speed: wp.speed,
                        turn: direction,
                        hold: false
                    }, airport);

                    this.fms.appendLeg({
                        waypoints: [_waypointToAdd2]
                    });

                    this.fms.nextLeg();
                } else {
                    var _waypointToAdd3 = new _Waypoint2.default({
                        altitude: wp.altitude,
                        navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                        heading: (0, _unitConverters.degreesToRadians)(heading),
                        speed: wp.speed,
                        turn: direction,
                        hold: false
                    }, airport);

                    this.fms.insertLegHere({
                        waypoints: [_waypointToAdd3]
                    });
                }
            }

            wp = this.fms.currentWaypoint; // update 'wp'

            // Construct the readback
            instruction = 'fly heading';
            if (direction) {
                instruction = 'turn ' + direction + ' heading';
            }

            var readback = {};
            readback.log = instruction + ' ' + (0, _unitConverters.heading_to_string)(wp.heading);
            readback.say = instruction + ' ' + (0, _radioUtilities.radio_heading)((0, _unitConverters.heading_to_string)(wp.heading));

            if (incremental) {
                readback.log = 'turn ' + amount + ' degrees ' + direction;
                readback.say = 'turn ' + (0, _radioUtilities.groupNumbers)(amount) + ' degrees ' + direction;
            }

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runAltitude
         * @param data
         */

    }, {
        key: 'runAltitude',
        value: function runAltitude(data) {
            var altitude = data[0];
            var expedite = data[1];
            var airport = window.airportController.airport_get();
            var radioTrendAltitude = (0, _radioUtilities.radio_trend)('altitude', this.altitude, this.fms.altitudeForCurrentWaypoint());
            var currentWaypointRadioAltitude = (0, _radioUtilities.radio_altitude)(this.fms.altitudeForCurrentWaypoint());

            if (altitude == null || isNaN(altitude)) {
                // FIXME: move this to it's own command. if expedite can be passed as a sole command it should be its own command
                if (expedite) {
                    this.fms.setCurrent({ expedite: true });

                    return ['ok', radioTrendAltitude + ' ' + this.fms.altitudeForCurrentWaypoint() + ' expedite'];
                }

                return ['fail', 'altitude not understood'];
            }

            if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                this.cancelLanding();
            }

            var ceiling = airport.ctr_ceiling;
            if (window.gameController.game.option.get('softCeiling') === 'yes') {
                ceiling += 1000;
            }

            this.fms.setAll({
                // TODO: enumerate the magic numbers
                altitude: (0, _core.clamp)((0, _core.round)(airport.elevation / 100) * 100 + 1000, altitude, ceiling),
                expedite: expedite
            });

            var isExpeditingString = '';
            if (expedite) {
                isExpeditingString = 'and expedite';
            }

            var readback = {
                log: radioTrendAltitude + ' ' + this.fms.altitudeForCurrentWaypoint() + ' ' + isExpeditingString,
                say: radioTrendAltitude + ' ' + currentWaypointRadioAltitude + ' ' + isExpeditingString
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runClearedAsFiled
         * @return {array}
         */

    }, {
        key: 'runClearedAsFiled',
        value: function runClearedAsFiled() {
            if (!this.runSID([this.destination])) {
                return [true, 'unable to clear as filed'];
            }

            var airport = window.airportController.airport_get();

            var _airport$sidCollectio = airport.sidCollection.findRouteByIcao(this.destination),
                procedureName = _airport$sidCollectio.name;

            var readback = {};

            readback.log = 'cleared to destination via the ' + this.destination + ' departure, then as filed. Climb and ' + ('maintain ' + airport.initial_alt + ', expect ' + this.fms.fp.altitude + ' 10 minutes after departure ');
            readback.say = 'cleared to destination via the ' + procedureName + ' ' + ('departure, then as filed. Climb and maintain ' + (0, _radioUtilities.radio_altitude)(airport.initial_alt) + ', ') + ('expect ' + (0, _radioUtilities.radio_altitude)(this.fms.fp.altitude) + ', ' + (0, _radioUtilities.radio_spellOut)('10') + ' minutes after departure\'');

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runClimbViaSID
         */

    }, {
        key: 'runClimbViaSID',
        value: function runClimbViaSID() {
            if (this.fms.currentLeg.type !== _aircraftConstants.FP_LEG_TYPE.SID || !this.fms.climbViaSID()) {
                var isWarning = true;

                window.uiController.ui_log(this.getCallsign() + ' unable to climb via SID', isWarning);

                return;
            }

            var airport = window.airportController.airport_get();

            var _airport$sidCollectio2 = airport.sidCollection.findRouteByIcao(this.fms.currentLeg.route.procedure),
                procedureName = _airport$sidCollectio2.name;

            var readback = {
                log: 'climb via the ' + this.fms.currentLeg.route.procedure + ' departure',
                say: 'climb via the ' + procedureName + ' departure'
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runDescendViaSTAR
         * @param data
         * @return {boolean|undefined}
         */

    }, {
        key: 'runDescendViaSTAR',
        value: function runDescendViaSTAR() {
            if (!this.fms.descendViaSTAR() || !this.fms.following.star) {
                var isWarning = true;
                window.uiController.ui_log(this.getCallsign() + ', unable to descend via STAR', isWarning);

                return;
            }

            var airport = window.airportController.airport_get();

            var _airport$starCollecti = airport.starCollection.findRouteByIcao(this.fms.currentLeg.route.procedure),
                procedureName = _airport$starCollecti.name;

            var readback = {
                log: 'descend via the ' + this.fms.following.star + ' arrival',
                say: 'descend via the ' + procedureName + ' arrival'
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runSpeed
         * @param data
         */

    }, {
        key: 'runSpeed',
        value: function runSpeed(data) {
            var speed = data[0];

            if ((0, _isNaN3.default)(speed)) {
                return ['fail', 'speed not understood'];
            }

            var clampedSpeed = (0, _core.clamp)(this.model.speed.min, speed, this.model.speed.max);
            this.fms.setAll({ speed: clampedSpeed });

            var radioTrendSpeed = (0, _radioUtilities.radio_trend)('speed', this.speed, this.fms.currentWaypoint.speed);
            var readback = {
                log: radioTrendSpeed + ' ' + this.fms.currentWaypoint.speed,
                say: radioTrendSpeed + ' ' + (0, _radioUtilities.radio_spellOut)(this.fms.currentWaypoint.speed)
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runHold
         * @param data
         */

    }, {
        key: 'runHold',
        value: function runHold(data) {
            var airport = window.airportController.airport_get();
            var dirTurns = data[0];
            var legLength = data[1];
            var holdFix = data[2];
            var holdFixLocation = null;
            var inboundHdg = void 0;
            // let inboundDir;

            // TODO: this might be better handled from within the parser
            if (dirTurns == null) {
                // standard for holding patterns is right-turns
                dirTurns = 'right';
            }

            // TODO: this might be better handled from within the parser
            if (legLength == null) {
                legLength = '1min';
            }

            // TODO: simplify this nested if.
            if (holdFix !== null) {
                holdFix = holdFix.toUpperCase();
                holdFixLocation = airport.getFixPosition(holdFix);

                if (!holdFixLocation) {
                    return ['fail', 'unable to find fix ' + holdFix];
                }
            }

            if (this.isTakeoff() && !holdFix) {
                return ['fail', 'where do you want us to hold?'];
            }

            // Determine whether or not to enter the hold from present position
            if (holdFix) {
                // holding over a specific fix (currently only able to do so on inbound course)
                inboundHdg = (0, _vector.vradial)((0, _vector.vsub)(this.position, holdFixLocation));

                if (holdFix !== this.fms.currentWaypoint.fix) {
                    // not yet headed to the hold fix
                    this.fms.insertLegHere({
                        type: 'fix',
                        route: '[GPS/RNAV]',
                        waypoints: [
                        // proceed direct to holding fix
                        new _Waypoint2.default({
                            fix: holdFix,
                            altitude: this.fms.altitudeForCurrentWaypoint(),
                            speed: this.fms.currentWaypoint.speed
                        }, airport),
                        // then enter the hold
                        new _Waypoint2.default({
                            navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HOLD,
                            speed: this.fms.currentWaypoint.speed,
                            altitude: this.fms.altitudeForCurrentWaypoint(),
                            fix: null,
                            hold: {
                                fixName: holdFix,
                                fixPos: holdFixLocation,
                                dirTurns: dirTurns,
                                legLength: legLength,
                                inboundHdg: inboundHdg,
                                timer: null
                            }
                        }, airport)]
                    });
                } else {
                    // TODO: this should be a `Waypoint`
                    // already currently going to the hold fix
                    // Force the initial turn to outbound heading when entering the hold
                    this.fms.appendWaypoint({
                        navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HOLD,
                        speed: this.fms.currentWaypoint.speed,
                        altitude: this.fms.altitudeForCurrentWaypoint(),
                        fix: null,
                        hold: {
                            fixName: holdFix,
                            fixPos: holdFixLocation,
                            dirTurns: dirTurns,
                            legLength: legLength,
                            inboundHdg: inboundHdg,
                            timer: null
                        }
                    });
                }
            } else {
                // holding over present position (currently only able to do so on present course)
                holdFixLocation = this.position; // make a/c hold over their present position
                inboundHdg = this.heading;

                // TODO: these aren't `Waypoints` and they should be
                this.fms.insertLegHere({
                    type: 'fix',
                    waypoints: [{ // document the present position as the 'fix' we're holding over
                        navmode: _aircraftConstants.WAYPOINT_NAV_MODE.FIX,
                        fix: '[custom]',
                        location: holdFixLocation,
                        altitude: this.fms.altitudeForCurrentWaypoint(),
                        speed: this.fms.currentWaypoint.speed
                    }, { // Force the initial turn to outbound heading when entering the hold
                        navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HOLD,
                        speed: this.fms.currentWaypoint.speed,
                        altitude: this.fms.altitudeForCurrentWaypoint(),
                        fix: null,
                        hold: {
                            fixName: holdFix,
                            fixPos: holdFixLocation,
                            dirTurns: dirTurns,
                            legLength: legLength,
                            inboundHdg: inboundHdg,
                            timer: null
                        }
                    }]
                });
            }

            // TODO: abstract to method `.getInboundCardinalDirection()`
            var inboundDir = _radioUtilities.radio_cardinalDir_names[(0, _radioUtilities.getCardinalDirection)((0, _circle.radians_normalize)(inboundHdg + Math.PI)).toLowerCase()];

            if (holdFix) {
                return ['ok', 'proceed direct ' + holdFix + ' and hold inbound, ' + dirTurns + ' turns, ' + legLength + ' legs'];
            }

            return ['ok', 'hold ' + inboundDir + ' of present position, ' + dirTurns + ' turns, ' + legLength + ' legs'];
        }

        /**
         * @for AircraftInstanceModel
         * @method runDirect
         * @param data
         */

    }, {
        key: 'runDirect',
        value: function runDirect(data) {
            var fixname = data[0].toUpperCase();
            // TODO replace with FixCollection
            var fix = window.airportController.airport_get().getFixPosition(fixname);

            if (!fix) {
                return ['fail', 'unable to find fix called ' + fixname];
            }

            // remove intermediate fixes
            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAKEOFF) {
                this.fms.skipToFix(fixname);
            } else if (!this.fms.skipToFix(fixname)) {
                return ['fail', fixname + ' is not in our flightplan'];
            }

            return ['ok', 'proceed direct ' + fixname];
        }
    }, {
        key: 'runFix',
        value: function runFix(data) {
            var last_fix = void 0;
            var fail = void 0;
            var fixes = (0, _map3.default)(data, function (fixname) {
                // TODO: this may beed to be the FixCollection
                var fix = window.airportController.airport_get().getFixPosition(fixname);

                if (!fix) {
                    fail = ['fail', 'unable to find fix called ' + fixname];

                    return;
                }

                // to avoid repetition, compare name with the previous fix
                if (fixname === last_fix) {
                    return;
                }

                last_fix = fixname;

                return fixname;
            });

            if (fail) {
                return fail;
            }

            for (var i = 0; i < fixes.length; i++) {
                // FIXME: use enumerated constant for type
                this.fms.insertLegHere({ type: 'fix', route: fixes[i] });
            }

            if (this.mode !== _aircraftConstants.FLIGHT_MODES.WAITING && this.mode !== _aircraftConstants.FLIGHT_MODES.TAKEOFF && this.mode !== _aircraftConstants.FLIGHT_MODES.APRON && this.mode !== _aircraftConstants.FLIGHT_MODES.TAXI) {
                this.cancelLanding();
            }

            return ['ok', 'proceed direct ' + fixes.join(', ')];
        }

        /**
         * @for AircraftInstanceModel
         * @method runFlyPresentHeading
         * @param data
         */

    }, {
        key: 'runFlyPresentHeading',
        value: function runFlyPresentHeading(data) {
            this.cancelFix();
            this.runHeading([null, (0, _unitConverters.radiansToDegrees)(this.heading)]);

            return ['ok', 'fly present heading'];
        }

        /**
         * @for AircraftInstanceModel
         * @method runSayRoute
         * @param data
         */

    }, {
        key: 'runSayRoute',
        value: function runSayRoute(data) {
            return ['ok', {
                log: 'route: ' + this.fms.fp.route.join(' '),
                say: 'here\'s our route'
            }];
        }

        /**
         * @for AircraftInstanceModel
         * @method runSID
         */

    }, {
        key: 'runSID',
        value: function runSID(data) {
            var airport = window.airportController.airport_get();
            var sidCollection = airport.sidCollection;

            var sidId = data[0];
            var standardRouteModel = sidCollection.findRouteByIcao(sidId);
            var exit = airport.getSIDExitPoint(sidId);
            // TODO: perhaps this should use the `RouteModel`?
            var route = airport.icao + '.' + sidId + '.' + exit;

            if ((0, _isNil3.default)(standardRouteModel)) {
                return ['fail', 'SID name not understood'];
            }

            if (this.category !== _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                return ['fail', 'unable to fly SID, we are an inbound'];
            }

            if (!this.rwy_dep) {
                this.setDepartureRunway(airportController.airport_get().runway);
            }

            if (!standardRouteModel.hasFixName(this.rwy_dep)) {
                return ['fail', 'unable, the ' + standardRouteModel.name + ' departure not valid from Runway ' + this.rwy_dep];
            }

            // TODO: this is the wrong place for this `.toUpperCase()`
            this.fms.followSID(route.toUpperCase());

            var readback = {
                log: 'cleared to destination via the ' + sidId + ' departure, then as filed',
                say: 'cleared to destination via the ' + standardRouteModel.name + ' departure, then as filed'
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runSTAR
         * @param data {array<string>} a string representation of the STAR, ex: `QUINN.BDEGA2.KSFO`
         */

    }, {
        key: 'runSTAR',
        value: function runSTAR(data) {
            var routeModel = new _RouteModel2.default(data[0]);
            var airport = window.airportController.airport_get();

            var _airport$starCollecti2 = airport.starCollection.findRouteByIcao(routeModel.procedure),
                starName = _airport$starCollecti2.name;

            if (this.category !== _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                return ['fail', 'unable to fly STAR, we are a departure!'];
            }

            // TODO: the data[0].length check might not be needed. this is covered via the CommandParser when
            // this method runs as the result of a command.
            if (data[0].length === 0 || !airport.starCollection.hasRoute(routeModel.procedure)) {
                return ['fail', 'STAR name not understood'];
            }

            this.fms.followSTAR(routeModel.routeCode);

            // TODO: casing may be an issue here.
            var readback = {
                log: 'cleared to the ' + airport.name + ' via the ' + routeModel.procedure + ' arrival',
                say: 'cleared to the ' + airport.name + ' via the ' + starName + ' arrival'
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runMoveDataBlock
         * @param data
         */

    }, {
        key: 'runMoveDataBlock',
        value: function runMoveDataBlock(dir) {
            // TODO: what do all these numbers mean?
            var positions = { 8: 360, 9: 45, 6: 90, 3: 135, 2: 180, 1: 225, 4: 270, 7: 315, 5: 'ctr' };

            if (!(0, _has3.default)(positions, dir[0])) {
                return;
            }

            this.datablockDir = positions[dir[0]];
        }

        /**
         * Adds a new Leg to fms with a user specified route
         * Note: See notes on 'runReroute' for how to format input for this command
         *
         * @for AircraftInstanceModel
         * @method runRoute
         * @param data
         */

    }, {
        key: 'runRoute',
        value: function runRoute(data) {
            // capitalize everything
            data = data[0].toUpperCase();
            var worked = true;
            var route = this.fms.formatRoute(data);

            if (worked && route) {
                // Add to fms
                worked = this.fms.customRoute(route, false);
            }

            if (!route || !data || data.indexOf(' ') > -1) {
                worked = false;
            }

            // Build the response
            if (worked) {
                var _readback = {
                    log: 'rerouting to :' + this.fms.fp.route.join(' '),
                    say: 'rerouting as requested'
                };

                return ['ok', _readback];
            }

            var readback = {
                log: 'your route "' + data + '" is invalid!',
                say: 'that route is invalid!'
            };

            return ['fail', readback];
        }

        /**
          * Removes all legs, and replaces them with the specified route
          * Note: Input data needs to be provided with single dots connecting all
          * procedurally-linked points (eg KSFO.OFFSH9.SXC or SGD.V87.MOVER), and
          * all other points that will be simply a fix direct to another fix need
          * to be connected with double-dots (eg HLI..SQS..BERRA..JAN..KJAN)
          *
          * @for AircraftInstanceModel
          * @method runReroute
          * @param data
          */

    }, {
        key: 'runReroute',
        value: function runReroute(data) {
            // TODO: capitalize everything?
            data = data[0].toUpperCase();
            var worked = true;
            var route = this.fms.formatRoute(data);

            if (worked && route) {
                // Reset fms
                worked = this.fms.customRoute(route, true);
            }

            // TODO: what exactly are we checking here?
            if (!route || !data || data.indexOf(' ') > -1) {
                worked = false;
            }

            // Build the response
            if (worked) {
                var _readback2 = {
                    log: 'rerouting to: ' + this.fms.fp.route.join(' '),
                    say: 'rerouting as requested'
                };

                return ['ok', _readback2];
            }

            var readback = {
                log: 'your route "' + data + '" is invalid!',
                say: 'that route is invalid!'
            };

            return ['fail', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runTaxi
         * @param data
         */

    }, {
        key: 'runTaxi',
        value: function runTaxi(data) {
            // TODO: all this if logic should be simplified or abstracted
            if (this.category !== _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                return ['fail', 'inbound'];
            }

            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAXI) {
                return ['fail', 'already taxiing to ' + (0, _radioUtilities.radio_runway)(this.rwy_dep)];
            }

            if (this.mode === _aircraftConstants.FLIGHT_MODES.WAITING) {
                return ['fail', 'already waiting'];
            }

            if (this.mode !== _aircraftConstants.FLIGHT_MODES.APRON) {
                return ['fail', 'wrong mode'];
            }

            // Set the runway to taxi to
            if (data[0]) {
                if (window.airportController.airport_get().getRunway(data[0].toUpperCase())) {
                    this.setDepartureRunway(data[0].toUpperCase());
                } else {
                    return ['fail', 'no runway ' + data[0].toUpperCase()];
                }
            }

            // Start the taxi
            this.taxi_start = window.gameController.game_time();
            var runway = window.airportController.airport_get().getRunway(this.rwy_dep);

            runway.addQueue(this);
            this.mode = _aircraftConstants.FLIGHT_MODES.TAXI;

            var readback = {
                log: 'taxi to runway ' + runway.name,
                say: 'taxi to runway ' + (0, _radioUtilities.radio_runway)(runway.name)
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runTakeoff
         * @param data
         */

    }, {
        key: 'runTakeoff',
        value: function runTakeoff(data) {
            // TODO: all this if logic should be simplified or abstracted
            if (this.category !== 'departure') {
                return ['fail', 'inbound'];
            }

            if (!this.isOnGround()) {
                return ['fail', 'already airborne'];
            }
            if (this.mode === _aircraftConstants.FLIGHT_MODES.APRON) {
                return ['fail', 'unable, we\'re still in the parking area'];
            }
            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAXI) {
                return ['fail', 'taxi to runway ' + (0, _radioUtilities.radio_runway)(this.rwy_dep) + ' not yet complete'];
            }
            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAKEOFF) {
                // FIXME: this is showing immediately after a to clearance.
                return ['fail', 'already taking off'];
            }

            if (this.fms.altitudeForCurrentWaypoint() <= 0) {
                return ['fail', 'no altitude assigned'];
            }

            var runway = window.airportController.airport_get().getRunway(this.rwy_dep);

            if (runway.removeQueue(this)) {
                this.mode = _aircraftConstants.FLIGHT_MODES.TAKEOFF;
                this.scoreWind('taking off');
                this.takeoffTime = window.gameController.game_time();

                if (this.fms.currentWaypoint.speed == null) {
                    this.fms.setCurrent({ speed: this.model.speed.cruise });
                }

                var wind = window.airportController.airport_get().getWind();
                var wind_dir = (0, _core.round)((0, _unitConverters.radiansToDegrees)(wind.angle));
                var readback = {
                    // TODO: the wind_dir calculation should be abstracted
                    log: 'wind ' + (0, _core.round)(wind_dir / 10) * 10 + ' ' + (0, _core.round)(wind.speed) + ', runway ' + this.rwy_dep + ' , cleared for takeoff',
                    say: 'wind ' + (0, _radioUtilities.radio_spellOut)((0, _core.round)(wind_dir / 10) * 10) + ' at ' + (0, _radioUtilities.radio_spellOut)((0, _core.round)(wind.speed)) + ', runway ' + (0, _radioUtilities.radio_runway)(this.rwy_dep) + ', cleared for takeoff'
                };

                return ['ok', readback];
            }

            var waiting = runway.inQueue(this);

            return ['fail', 'number ' + waiting + ' behind ' + runway.queue[waiting - 1].getRadioCallsign(), ''];
        }
    }, {
        key: 'runLanding',
        value: function runLanding(data) {
            var variant = data[0];
            var runway = window.airportController.airport_get().getRunway(data[1]);

            if (!runway) {
                return ['fail', 'there is no runway ' + (0, _radioUtilities.radio_runway)(data[1])];
            }

            this.setArrivalRunway(data[1].toUpperCase());
            // tell fms to follow ILS approach
            this.fms.followApproach('ils', this.rwy_arr, variant);

            var readback = {
                log: 'cleared ILS runway ' + this.rwy_arr + ' approach',
                say: 'cleared ILS runway ' + (0, _radioUtilities.radio_runway)(this.rwy_arr) + ' approach'
            };

            return ['ok', readback];
        }

        /**
         * @for AircraftInstanceModel
         * @method runAbort
         * @param data
         */

    }, {
        key: 'runAbort',
        value: function runAbort(data) {
            // TODO: these ifs on `mode` should be converted to a switch
            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAXI) {
                this.mode = _aircraftConstants.FLIGHT_MODES.APRON;
                this.taxi_start = 0;

                console.log('aborted taxi to runway');

                var isWarning = true;
                window.uiController.ui_log(this.getCallsign() + ' aborted taxi to runway', isWarning);

                return ['ok', 'taxiing back to terminal'];
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.WAITING) {
                return ['fail', 'unable to return to the terminal'];
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                this.cancelLanding();

                var readback = {
                    log: 'go around, fly present heading, maintain ' + this.fms.altitudeForCurrentWaypoint(),
                    say: 'go around, fly present heading, maintain ' + (0, _radioUtilities.radio_altitude)(this.fms.altitudeForCurrentWaypoint())
                };

                return ['ok', readback];
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.CRUISE && this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.RWY) {
                this.cancelLanding();

                var _readback3 = {
                    log: 'cancel approach clearance, fly present heading, maintain ' + this.fms.altitudeForCurrentWaypoint(),
                    say: 'cancel approach clearance, fly present heading, maintain ' + (0, _radioUtilities.radio_altitude)(this.fms.altitudeForCurrentWaypoint())
                };

                return ['ok', _readback3];
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.CRUISE && this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.FIX) {
                this.cancelFix();

                if (this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                    return ['ok', 'fly present heading, vector to final approach course'];
                } else if (this.category === 'departure') {
                    return ['ok', 'fly present heading, vector for entrail spacing'];
                }
            }

            // modes 'apron', 'takeoff', ('cruise' for some navmodes)
            return ['fail', 'unable to abort'];
        }

        // FIXME: is this in use?
        /**
         * @for AircraftInstanceModel
         * @method runDebug
         */

    }, {
        key: 'runDebug',
        value: function runDebug() {
            window.aircraft = this;
            return ['ok', { log: 'in the console, look at the variable &lsquo;aircraft&rsquo;', say: '' }];
        }

        // FIXME: is this in use?
        /**
         * @for AircraftInstanceModel
         * @method runDelete
         */

    }, {
        key: 'runDelete',
        value: function runDelete() {
            window.aircraftController.aircraft_remove(this);
        }

        // TODO: move to `fms.cancelFix()`
        /**
         * @for AircraftInstanceModel
         * @method cancelFix
         */

    }, {
        key: 'cancelFix',
        value: function cancelFix() {
            // TODO: this logic could be simplified. do an early return instead of wrapping the entire function in an if.
            if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.FIX) {
                var curr = this.fms.currentWaypoint;

                this.fms.appendLeg({
                    altitude: curr.altitude,
                    navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                    heading: this.heading,
                    speed: curr.speed
                });

                this.fms.nextLeg();
                this.updateStrip();

                return true;
            }

            return false;
        }

        /**
         * @for AircraftInstanceModel
         * @method cancelLanding
         */

    }, {
        key: 'cancelLanding',
        value: function cancelLanding() {
            // TODO: this logic could be simplified. do an early return instead of wrapping the entire function in an if.
            if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.RWY) {
                var runway = window.airportController.airport_get().getRunway(this.rwy_arr);

                if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                    // TODO: enumerate the magic numbers
                    this.fms.setCurrent({
                        altitude: Math.max(2000, (0, _core.round)(this.altitude / 1000) * 1000),
                        heading: runway.angle
                    });
                }

                this.fms.setCurrent({
                    navmode: _aircraftConstants.WAYPOINT_NAV_MODE.HEADING,
                    runway: null
                });

                this.mode = _aircraftConstants.FLIGHT_MODES.CRUISE;
                this.updateStrip();

                return true;
            }

            this.fms.setCurrent({ runway: null });

            return false;
        }

        // FIXME: is this method still in use?
        /**
         * @for AircraftInstanceModel
         * @method pushHistory
         */

    }, {
        key: 'pushHistory',
        value: function pushHistory() {
            this.history.push([this.position[0], this.position[1]]);

            if (this.history.length > 10) {
                this.history.splice(0, this.history.length - 10);
            }
        }

        /**
         * @for AircraftInstanceModel
         * @method moveForward
         */

    }, {
        key: 'moveForward',
        value: function moveForward() {
            this.mode = _aircraftConstants.FLIGHT_MODES.TAXI;
            this.taxi_next = true;
        }

        /**
         * Aircraft is established on FINAL APPROACH COURSE
         * @for AircraftInstanceModel
         * @method runTakeoff
         */

    }, {
        key: 'isEstablished',
        value: function isEstablished() {
            if (this.mode !== _aircraftConstants.FLIGHT_MODES.LANDING) {
                return false;
            }

            // TODO: why 48m?  whats the significance of that number?
            // 160 feet or 48 meters
            return this.approachOffset <= 0.048;
        }

        /**
         * Checks if the aircraft is inside the airspace of a specified airport
         *
         * @for AircraftInstanceModel
         * @method isInsideAirspace
         * @param  {airport} airport the airport whose airspace we are checking
         * @return {Boolean}
         * @private
         */

    }, {
        key: 'isInsideAirspace',
        value: function isInsideAirspace(airport) {
            var withinAirspaceLateralBoundaries = this.distance <= airport.ctr_radius;
            var withinAirspaceAltitudeRange = this.altitude <= airport.ctr_ceiling;

            if (!(0, _isNil3.default)(airport.perimeter)) {
                // polygonal airspace boundary
                withinAirspaceLateralBoundaries = (0, _vector.point_in_area)(this.position, airport.perimeter);
            }

            return withinAirspaceAltitudeRange && withinAirspaceLateralBoundaries;
        }

        /**
         * Aircraft has "weight-on-wheels" (on the ground)
         * @for AircraftInstanceModel
         * @method isOnGround
         */

    }, {
        key: 'isOnGround',
        value: function isOnGround() {
            var error_allowance_ft = 5;
            var airport = window.airportController.airport_get();
            var runway = airport.getRunway(this.rwy_dep || this.rwy_arr);
            var nearRunwayAltitude = (0, _core.abs)(this.altitude - runway.elevation) < error_allowance_ft;
            var nearAirportAltitude = (0, _core.abs)(this.altitude - airport.position.elevation) < error_allowance_ft;

            return nearRunwayAltitude || nearAirportAltitude;
        }

        /**
         * Aircraft is actively following an instrument approach and is elegible for reduced separation
         *
         * If the game ever distinguishes between ILS/MLS/LAAS
         * approaches and visual/localizer/VOR/etc. this should
         * distinguish between them.  Until then, presume landing is via
         * ILS with appropriate procedures in place.
         *
         * @for AircraftInstanceModel
         * @method runTakeoff
         */

    }, {
        key: 'isPrecisionGuided',
        value: function isPrecisionGuided() {
            return this.mode === _aircraftConstants.FLIGHT_MODES.LANDING;
        }

        /**
         * @for AircraftInstanceModel
         * @method isStopped
         */

    }, {
        key: 'isStopped',
        value: function isStopped() {
            // TODO: enumerate the magic number.
            return this.isOnGround() && this.speed < 5;
        }

        /**
         * @for AircraftInstanceModel
         * @method isTaxiing
         */

    }, {
        key: 'isTaxiing',
        value: function isTaxiing() {
            return this.mode === _aircraftConstants.FLIGHT_MODES.APRON || this.mode === _aircraftConstants.FLIGHT_MODES.TAXI || this.mode === _aircraftConstants.FLIGHT_MODES.WAITING;
        }

        /**
         * @for AircraftInstanceModel
         * @method isTakeoff
         */

    }, {
        key: 'isTakeoff',
        value: function isTakeoff() {
            return this.isTaxiing() || this.mode === _aircraftConstants.FLIGHT_MODES.TAKEOFF;
        }

        // TODO: the logic in this method can be cleaned up and simplified
        /**
         * @for AircraftInstanceModel
         * @method isVisible
         */

    }, {
        key: 'isVisible',
        value: function isVisible() {
            // TODO: this if/else if would be cleaner with just if (this.mode === FLIGHT_MODES.WAITING) {}
            // hide aircraft on twys
            if (this.mode === _aircraftConstants.FLIGHT_MODES.APRON || this.mode === _aircraftConstants.FLIGHT_MODES.TAXI) {
                return false;
            }

            if (this.isTaxiing()) {
                // show only the first aircraft in the takeoff queue
                var runway = window.airportController.airport_get().getRunway(this.rwy_dep);
                var waiting = runway.inQueue(this);

                return this.mode === _aircraftConstants.FLIGHT_MODES.WAITING && waiting === 0;
            }

            return true;
        }

        /**
         * @for AircraftInstanceModel
         * @method getWind
         */

    }, {
        key: 'getWind',
        value: function getWind() {
            var windForRunway = {
                cross: 0,
                head: 0
            };

            if (this.rwy_dep) {
                var airport = window.airportController.airport_get();
                var wind = airport.wind;
                var runway = airport.getRunway(this.rwy_dep);
                var angle = (0, _core.abs)((0, _circle.angle_offset)(runway.angle, wind.angle));

                // TODO: these two bits of math should be abstracted to a helper function
                windForRunway.cross = (0, _core.sin)(angle) * wind.speed;
                windForRunway.head = (0, _core.cos)(angle) * wind.speed;
            }

            return windForRunway;
        }

        /**
         * @for AircraftInstanceModel
         * @method radioCall
         * @param msg {string}
         * @param sectorType {string}
         * @param alert {string}
         */

    }, {
        key: 'radioCall',
        value: function radioCall(msg, sectorType, alert) {
            if (this.projected) {
                return;
            }

            // var is unused
            var call = '';
            var callsign_L = this.getCallsign();
            var callsign_S = this.getRadioCallsign();

            if (sectorType) {
                call += window.airportController.airport_get().radio[sectorType];
            }

            // call += ", " + this.getCallsign() + " " + msg;

            // TODO: quick abstraction, this doesn't belong here.
            var logMessage = function logMessage(callsign) {
                return window.airportController.airport_get().radio[sectorType] + ', ' + callsign + ' ' + msg;
            };

            if (alert) {
                var isWarning = true;
                window.uiController.ui_log(logMessage(callsign_L), isWarning);
            } else {
                window.uiController.ui_log(logMessage(callsign_L));
            }

            (0, _speech.speech_say)([{
                type: 'text',
                content: logMessage(callsign_S)
            }]);
        }

        /**
         * @for AircraftInstanceModel
         * @method callUp
         */

    }, {
        key: 'callUp',
        value: function callUp() {
            var alt_log = void 0;
            var alt_say = void 0;

            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
                var altdiff = this.altitude - this.fms.altitudeForCurrentWaypoint();
                var alt = (0, _radioUtilities.digits_decimal)(this.altitude, -2);

                if (Math.abs(altdiff) > 200) {
                    if (altdiff > 0) {
                        alt_log = 'descending through ' + alt + ' for ' + this.target.altitude;
                        alt_say = 'descending through ' + (0, _radioUtilities.radio_altitude)(alt) + ' for ' + (0, _radioUtilities.radio_altitude)(this.target.altitude);
                    } else if (altdiff < 0) {
                        alt_log = ' climbing through ' + alt + ' for ' + this.target.altitude;
                        alt_say = ' climbing through ' + (0, _radioUtilities.radio_altitude)(alt) + ' for ' + (0, _radioUtilities.radio_altitude)(this.target.altitude);
                    }
                } else {
                    alt_log = 'at ' + alt;
                    alt_say = 'at ' + (0, _radioUtilities.radio_altitude)(alt);
                }

                window.uiController.ui_log(window.airportController.airport_get().radio.app + ', ' + this.getCallsign() + ' with you ' + alt_log);
                (0, _speech.speech_say)([{ type: 'text', content: window.airportController.airport_get().radio.app + ', ' }, { type: 'callsign', content: this }, { type: 'text', content: 'with you ' + alt_say }]);
            }

            if (this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                window.uiController.ui_log(window.airportController.airport_get().radio.twr + ', ' + this.getCallsign() + ', ready to taxi');
                (0, _speech.speech_say)([{ type: 'text', content: window.airportController.airport_get().radio.twr }, { type: 'callsign', content: this }, { type: 'text', content: ', ready to taxi' }]);
            }
        }

        // TODO: This method should be moved elsewhere, since it doesn't really belong to the aircraft itself
        /**
         * @for AircraftInstanceModel
         * @method scoreWind
         * @param action
         */

    }, {
        key: 'scoreWind',
        value: function scoreWind(action) {
            var score = 0;
            var components = this.getWind();
            var isWarning = true;

            // TODO: these two if blocks could be done in a single switch statement
            if (components.cross >= 20) {
                window.gameController.events_recordNew(_GameController.GAME_EVENTS.EXTREME_CROSSWIND_OPERATION);
                window.uiController.ui_log(this.getCallsign() + ' ' + action + ' with major crosswind\'', isWarning);
            } else if (components.cross >= 10) {
                window.gameController.events_recordNew(_GameController.GAME_EVENTS.HIGH_CROSSWIND_OPERATION);
                window.uiController.ui_log(this.getCallsign() + ' ' + action + ' with crosswind\'', isWarning);
            }

            if (components.head <= -10) {
                window.gameController.events_recordNew(_GameController.GAME_EVENTS.EXTREME_TAILWIND_OPERATION);
                window.uiController.ui_log(this.getCallsign() + ' ' + action + ' with major tailwind\'', isWarning);
            } else if (components.head <= -1) {
                window.gameController.events_recordNew(_GameController.GAME_EVENTS.HIGH_TAILWIND_OPERATION);
                window.uiController.ui_log(this.getCallsign() + ' ' + action + ' with tailwind\'', isWarning);
            }

            return score;
        }

        /**
         * @for AircraftInstanceModel
         * @method showStrip
         */

    }, {
        key: 'showStrip',
        value: function showStrip() {
            this.$html.detach();

            var scrollPos = this.$strips.scrollTop();

            this.$strips.prepend(this.$html);
            this.$html.show();
            // TODO enumerate the magic number
            // shift scroll down one strip's height
            this.$strips.scrollTop(scrollPos + 45);
        }

        // TODO: this method needs a lot of love. its much too long with waaay too many nested if/else ifs.
        /**
         * @for AircraftInstanceModel
         * @method updateTarget
         */

    }, {
        key: 'updateTarget',
        value: function updateTarget() {
            var airport = window.airportController.airport_get();
            var runway = null;
            var offset = null;
            var offset_angle = null;
            var glideslope_altitude = null;
            var angle = null;
            var runway_elevation = 0;
            var position = void 0;

            if (this.rwy_arr !== null) {
                runway_elevation = airport.getRunway(this.rwy_arr).elevation;
            }

            if (this.fms.altitudeForCurrentWaypoint() > 0) {
                this.fms.setCurrent({
                    altitude: Math.max(1000, this.fms.altitudeForCurrentWaypoint())
                });
            }

            if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.RWY) {
                runway = airport.getRunway(this.rwy_arr);
                offset = (0, _flightMath.getOffset)(this, runway.position, runway.angle);
                offset_angle = (0, _vector.vradial)(offset);
                angle = (0, _circle.radians_normalize)(runway.angle);
                glideslope_altitude = (0, _core.clamp)(runway.elevation, runway.getGlideslopeAltitude(offset[1]), this.altitude);
                var assignedHdg = this.fms.currentWaypoint.heading;
                var localizerRange = runway.ils.enabled ? runway.ils.loc_maxDist : 40;
                this.offset_angle = offset_angle;
                this.approachOffset = (0, _core.abs)(offset[0]);
                this.approachDistance = offset[1];
                this.target.heading = assignedHdg;
                this.target.turn = this.fms.currentWaypoint.turn;
                this.target.altitude = this.fms.currentWaypoint.altitude;
                this.target.speed = this.fms.currentWaypoint.speed;

                // Established on ILS
                if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                    // Final Approach Heading Control
                    var severity_of_correction = 25; // controls steepness of heading adjustments during localizer tracking
                    var tgtHdg = angle + offset_angle * -severity_of_correction;
                    var minHdg = angle - (0, _unitConverters.degreesToRadians)(30);
                    var maxHdg = angle + (0, _unitConverters.degreesToRadians)(30);
                    this.target.heading = (0, _core.clamp)(tgtHdg, minHdg, maxHdg);

                    // Final Approach Altitude Control
                    this.target.altitude = Math.min(this.fms.currentWaypoint.altitude, glideslope_altitude);

                    // Final Approach Speed Control
                    if (this.fms.currentWaypoint.speed > 0) {
                        this.fms.setCurrent({ start_speed: this.fms.currentWaypoint.speed });
                    }

                    if (this.isOnGround()) {
                        this.target.altitude = runway.elevation;
                        this.target.speed = 0;
                    } else {
                        var dist_final_app_spd = 3.5; // 3.5km ~= 2nm
                        var dist_assigned_spd = 9.5; // 9.5km ~= 5nm
                        this.target.speed = (0, _core.extrapolate_range_clamp)(dist_final_app_spd, offset[1], dist_assigned_spd, this.model.speed.landing, this.fms.currentWaypoint.start_speed);
                    }

                    // Failed Approach
                    if ((0, _core.abs)(offset[0]) > 0.100) {
                        if (!this.projected) {
                            this.updateStrip();
                            this.cancelLanding();
                            var isWarning = true;
                            window.uiController.ui_log(this.getRadioCallsign() + ' aborting landing, lost ILS', isWarning);
                            (0, _speech.speech_say)([{ type: 'callsign', content: this }, { type: 'text', content: ' going around' }]);
                            window.gameController.events_recordNew(_GameController.GAME_EVENTS.GO_AROUND);
                        }
                    }
                } else if (offset[1] < localizerRange) {
                    // Joining the ILS
                    // Check if aircraft has just become established on the localizer
                    var alignedWithRunway = (0, _core.abs)(offset[0]) < 0.050; // within 50m
                    var onRunwayHeading = (0, _core.abs)(this.heading - angle) < (0, _unitConverters.degreesToRadians)(5);
                    var runwayNominalHeading = (0, _unitConverters.degreesToRadians)(parseInt(this.rwy_arr.substr(0, 2), 10) * 10, 10);
                    var maxInterceptAngle = (0, _unitConverters.degreesToRadians)(30);
                    var maxAboveGlideslope = 250;
                    var interceptAngle = (0, _core.abs)((0, _circle.angle_offset)(assignedHdg, runwayNominalHeading));
                    var courseDifference = (0, _core.abs)((0, _circle.angle_offset)(this.heading, runwayNominalHeading));
                    if (alignedWithRunway && onRunwayHeading && this.mode !== _aircraftConstants.FLIGHT_MODES.LANDING) {
                        this.mode = _aircraftConstants.FLIGHT_MODES.LANDING;
                        this.target.heading = angle;
                        // Check legality of localizer interception
                        if (!this.projected) {
                            // do not give penalty during a future projection
                            // TODO: Abstraction on the below, to remove duplicate code
                            // Intercept Angle
                            if (!assignedHdg && courseDifference > maxInterceptAngle) {
                                // intercept via fixes
                                var _isWarning = true;
                                window.uiController.ui_log(this.getCallsign() + ' approach course intercept angle was greater than 30 degrees', _isWarning);
                                window.gameController.events_recordNew(_GameController.GAME_EVENTS.ILLEGAL_APPROACH_CLEARANCE);
                            } else if (interceptAngle > maxInterceptAngle) {
                                // intercept via vectors
                                var _isWarning2 = true;
                                window.uiController.ui_log(this.getCallsign() + ' approach course intercept angle was greater than 30 degrees', _isWarning2);
                                window.gameController.events_recordNew(_GameController.GAME_EVENTS.ILLEGAL_APPROACH_CLEARANCE);
                            }

                            // Glideslope intercept
                            if (this.altitude > glideslope_altitude + maxAboveGlideslope) {
                                var _isWarning3 = true;
                                window.uiController.ui_log(this.getRadioCallsign() + ' joined localizer above glideslope altitude', _isWarning3);
                                window.gameController.events_recordNew(_GameController.GAME_EVENTS.ILLEGAL_APPROACH_CLEARANCE);
                            }
                        }

                        this.updateStrip();
                        this.target.turn = null;
                    }

                    // TODO: this math section should be absctracted to a helper function
                    // Guide aircraft onto the localizer
                    var angle_diff = (0, _circle.angle_offset)(angle, this.heading);
                    var turning_time = Math.abs((0, _unitConverters.radiansToDegrees)(angle_diff)) / 3; // time to turn angle_diff degrees at 3 deg/s
                    var turning_radius = (0, _unitConverters.km)(this.speed) / 3600 * turning_time; // dist covered in the turn, km
                    var dist_to_localizer = offset[0] / (0, _core.sin)(angle_diff); // dist from the localizer intercept point, km
                    var turn_early_km = 1; // start turn 1km early, to avoid overshoots from tailwind
                    var should_attempt_intercept = 0 < dist_to_localizer && dist_to_localizer <= turning_radius + turn_early_km;
                    var in_the_window = (0, _core.abs)(offset_angle) < (0, _unitConverters.degreesToRadians)(1.5); // if true, aircraft will move to localizer, regardless of assigned heading

                    if (should_attempt_intercept || in_the_window) {
                        // time to begin turn
                        var _severity_of_correction = 50; // controls steepness of heading adjustments during localizer tracking
                        var _tgtHdg = angle + offset_angle * -_severity_of_correction;
                        var _minHdg = angle - (0, _unitConverters.degreesToRadians)(30);
                        var _maxHdg = angle + (0, _unitConverters.degreesToRadians)(30);
                        this.target.heading = (0, _core.clamp)(_tgtHdg, _minHdg, _maxHdg);
                    }
                }
            } else if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.FIX) {
                var fix = this.fms.currentWaypoint.location;
                if (!fix) {
                    console.error(this.getCallsign() + ' using "fix" navmode, but no fix location!');
                    console.log(this.fms);
                    console.log(this.fms.currentWaypoint);
                }

                var vector_to_fix = (0, _vector.vsub)(this.position, fix);
                var distance_to_fix = (0, _distance.distance2d)(this.position, fix);

                if (distance_to_fix < 1 || distance_to_fix < 10 && distance_to_fix < window.aircraftController.aircraft_turn_initiation_distance(this, fix)) {
                    // if there are more waypoints available
                    if (!this.fms.atLastWaypoint()) {
                        this.fms.nextWaypoint();
                    } else {
                        this.cancelFix();
                    }

                    this.updateStrip();
                } else {
                    this.target.heading = (0, _vector.vradial)(vector_to_fix) - Math.PI;
                    this.target.turn = null;
                }
            } else if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HOLD) {
                var hold = this.fms.currentWaypoint.hold;
                var angle_off_of_leg_hdg = (0, _core.abs)((0, _circle.angle_offset)(this.heading, this.target.heading));

                // within ~2° of upwd/dnwd
                if (angle_off_of_leg_hdg < 0.035) {
                    offset = (0, _flightMath.getOffset)(this, hold.fixPos);

                    // entering hold, just passed the fix
                    if (hold.timer === null && offset[1] < 0 && offset[2] < 2) {
                        // Force aircraft to enter the hold immediately
                        hold.timer = -999;
                    }

                    // Holding Logic
                    // time-based hold legs
                    if (hold.timer && hold.legLength.includes('min')) {
                        if (hold.timer === -1) {
                            // save the time
                            hold.timer = window.gameController.game.time;
                        } else if (window.gameController.game.time >= hold.timer + parseInt(hold.legLength.replace('min', ''), 10) * 60) {
                            // time to turn
                            this.target.heading += Math.PI; // turn to other leg
                            this.target.turn = hold.dirTurns;
                            hold.timer = -1; // reset the timer
                        } else if (hold.legLength.includes('nm')) {
                            // distance-based hold legs
                            // not yet implemented
                        }
                    }
                }
            } else {
                this.target.heading = this.fms.currentWaypoint.heading;
                this.target.turn = this.fms.currentWaypoint.turn;
            }

            if (this.mode !== _aircraftConstants.FLIGHT_MODES.LANDING) {
                this.target.altitude = this.fms.altitudeForCurrentWaypoint();
                this.target.expedite = this.fms.currentWaypoint.expedite;
                this.target.altitude = Math.max(1000, this.target.altitude);
                this.target.speed = (0, _get3.default)(this, 'fms.currentWaypoint.speed', this.speed);
                this.target.speed = (0, _core.clamp)(this.model.speed.min, this.target.speed, this.model.speed.max);
            }

            // If stalling, make like a meteorite and fall to the earth!
            if (this.speed < this.model.speed.min && !this.isOnGround()) {
                this.target.altitude = Math.min(0, this.target.altitude);
            }

            // finally, taxi overrides everything
            var was_taxi = false;

            if (this.mode === _aircraftConstants.FLIGHT_MODES.TAXI) {
                var elapsed = window.gameController.game_time() - this.taxi_start;

                if (elapsed > this.taxi_time) {
                    this.mode = _aircraftConstants.FLIGHT_MODES.WAITING;
                    was_taxi = true;

                    this.updateStrip();
                }
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.WAITING) {
                runway = window.airportController.airport_get().getRunway(this.rwy_dep);

                position = runway.position;
                this.position[0] = position[0];
                this.position[1] = position[1];
                this.heading = runway.angle;
                this.altitude = runway.elevation;

                if (!this.projected && runway.inQueue(this) === 0 && was_taxi === true) {
                    window.uiController.ui_log(this.getCallsign() + ', holding short of runway ' + this.rwy_dep);
                    (0, _speech.speech_say)([{ type: 'callsign', content: this }, { type: 'text', content: 'holding short of runway ' + (0, _radioUtilities.radio_runway)(this.rwy_dep) }]);

                    this.updateStrip();
                }
            } else if (this.mode === _aircraftConstants.FLIGHT_MODES.TAKEOFF) {
                runway = window.airportController.airport_get().getRunway(this.rwy_dep);

                // Altitude Control
                if (this.speed < this.model.speed.min) {
                    this.target.altitude = runway.elevation;
                } else {
                    this.target.altitude = this.fms.altitudeForCurrentWaypoint();
                }

                // Heading Control
                var rwyHdg = window.airportController.airport_get().getRunway(this.rwy_dep).angle;
                if (this.altitude - runway.elevation < 400) {
                    this.target.heading = rwyHdg;
                } else {
                    if (!this.fms.followCheck().sid && this.fms.currentWaypoint.heading === null) {
                        // if no directional instructions available after takeoff
                        // fly runway heading
                        this.fms.setCurrent({ heading: rwyHdg });
                    }

                    this.mode = _aircraftConstants.FLIGHT_MODES.CRUISE;
                    this.updateStrip();
                }

                // Speed Control
                // go fast!
                this.target.speed = this.model.speed.cruise;
            }

            // Limit speed to 250 knots while under 10,000 feet MSL (it's the law!)
            if (this.altitude < 10000) {
                if (this.isPrecisionGuided()) {
                    // btwn 0 and 250
                    this.target.speed = Math.min(this.target.speed, 250);
                } else {
                    // btwn scheduled speed and 250
                    this.target.speed = Math.min(this.fms.currentWaypoint.speed, 250);
                }
            }
        }

        // TODO: this method needs a lot of love. its much too long with waaay too many nested if/else ifs.
        /**
         * @for AircraftInstanceModel
         * @method updatePhysics
         */

    }, {
        key: 'updatePhysics',
        value: function updatePhysics() {
            if (this.isTaxiing()) {
                return;
            }

            if (this.hit) {
                // 90fps fall rate?...
                this.altitude -= 90 * window.gameController.game_delta();
                this.speed *= 0.99;

                return;
            }

            // TURNING
            // this.target.heading = radians_normalize(this.target.heading);
            if (!this.isOnGround() && this.heading !== this.target.heading) {
                // Perform standard turns 3 deg/s or 25 deg bank, whichever
                // requires less bank angle.
                // Formula based on http://aviation.stackexchange.com/a/8013
                var turn_rate = (0, _core.clamp)(0, 1 / (this.speed / 8.883031), 0.0523598776);
                var turn_amount = turn_rate * window.gameController.game_delta();
                var offset = (0, _circle.angle_offset)(this.target.heading, this.heading);

                if ((0, _core.abs)(offset) < turn_amount) {
                    this.heading = this.target.heading;
                } else if (offset < 0 && this.target.turn === null || this.target.turn === 'left') {
                    this.heading -= turn_amount;
                } else if (offset > 0 && this.target.turn === null || this.target.turn === 'right') {
                    this.heading += turn_amount;
                }
            }

            // ALTITUDE
            var distance = null;
            var expedite_factor = 1.5;
            this.trend = 0;

            if (this.target.altitude < this.altitude - 0.02) {
                distance = -this.model.rate.descent / 60 * window.gameController.game_delta();

                if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                    distance *= 3;
                }

                this.trend -= 1;
            } else if (this.target.altitude > this.altitude + 0.02) {
                var climbrate = this.getClimbRate();
                distance = climbrate / 60 * window.gameController.game_delta();

                if (this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                    distance *= 1.5;
                }

                this.trend = 1;
            }

            if (distance) {
                if (this.target.expedite) {
                    distance *= expedite_factor;
                }

                var _offset = this.altitude - this.target.altitude;

                if ((0, _core.abs)(_offset) < (0, _core.abs)(distance)) {
                    this.altitude = this.target.altitude;
                } else {
                    this.altitude += distance;
                }
            }

            if (this.isOnGround()) {
                this.trend = 0;
            }

            // SPEED
            var difference = null;

            if (this.target.speed < this.speed - 0.01) {
                difference = -this.model.rate.decelerate * window.gameController.game_delta() / 2;

                if (this.isOnGround()) {
                    difference *= 3.5;
                }
            } else if (this.target.speed > this.speed + 0.01) {
                difference = this.model.rate.accelerate * window.gameController.game_delta() / 2;
                difference *= (0, _core.extrapolate_range_clamp)(0, this.speed, this.model.speed.min, 2, 1);
            }

            if (difference) {
                var _offset2 = this.speed - this.target.speed;

                if ((0, _core.abs)(_offset2) < (0, _core.abs)(difference)) {
                    this.speed = this.target.speed;
                } else {
                    this.speed += difference;
                }
            }

            if (!this.position) {
                return;
            }

            // Trailling
            if (this.position_history.length === 0) {
                this.position_history.push([this.position[0], this.position[1], window.gameController.game_time() / window.gameController.game_speedup()]);
                // TODO: this can be abstracted
            } else if ((0, _core.abs)(window.gameController.game_time() / window.gameController.game_speedup() - this.position_history[this.position_history.length - 1][2]) > 4 / window.gameController.game_speedup()) {
                this.position_history.push([this.position[0], this.position[1], window.gameController.game_time() / window.gameController.game_speedup()]);
            }

            var angle = this.heading;
            // FIXME: is this ratio correct? is it 0.000514444 or 0.514444?
            var scaleSpeed = this.speed * 0.000514444 * window.gameController.game_delta(); // knots to m/s

            if (window.gameController.game.option.get('simplifySpeeds') === 'no') {
                // TODO: this should be abstracted to a helper function
                // Calculate the true air speed as indicated airspeed * 1.6% per 1000'
                scaleSpeed *= 1 + this.altitude * 0.000016;

                // Calculate movement including wind assuming wind speed
                // increases 2% per 1000'
                var wind = window.airportController.airport_get().wind;
                var vector = void 0;

                if (this.isOnGround()) {
                    vector = (0, _vector.vscale)([(0, _core.sin)(angle), (0, _core.cos)(angle)], scaleSpeed);
                } else {
                    var crab_angle = 0;

                    // Compensate for crosswind while tracking a fix or on ILS
                    if (this.fms.currentWaypoint.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.FIX || this.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                        // TODO: this should be abstracted to a helper function
                        var _offset3 = (0, _circle.angle_offset)(this.heading, wind.angle + Math.PI);
                        crab_angle = Math.asin(wind.speed * (0, _core.sin)(_offset3) / this.speed);
                    }

                    // TODO: this should be abstracted to a helper function
                    vector = (0, _vector.vadd)((0, _vector.vscale)((0, _vector.vturn)(wind.angle + Math.PI), wind.speed * 0.000514444 * window.gameController.game_delta()), (0, _vector.vscale)((0, _vector.vturn)(angle + crab_angle), scaleSpeed));
                }

                this.ds = (0, _vector.vlen)(vector);
                // TODO: this should be abstracted to a helper function
                this.groundSpeed = this.ds / 0.000514444 / window.gameController.game_delta();
                this.groundTrack = (0, _vector.vradial)(vector);
                this.position = (0, _vector.vadd)(this.position, vector);
            } else {
                this.ds = scaleSpeed;
                this.groundSpeed = this.speed;
                this.groundTrack = this.heading;
                this.position = (0, _vector.vadd)(this.position, (0, _vector.vscale)([(0, _core.sin)(angle), (0, _core.cos)(angle)], scaleSpeed));
            }

            this.distance = (0, _vector.vlen)(this.position);
            this.radial = (0, _vector.vradial)(this.position);

            if (this.radial < 0) {
                this.radial += (0, _circle.tau)();
            }

            var isInsideAirspace = this.isInsideAirspace(window.airportController.airport_get());

            if (isInsideAirspace !== this.inside_ctr) {
                this.crossBoundary(isInsideAirspace);
            }
        }

        // TODO: this method needs a lot of love. its much too long with waaay too many nested if/else ifs.
        /**
         * @for AircraftInstanceModel
         * @method updateWarning
         */

    }, {
        key: 'updateWarning',
        value: function updateWarning() {
            var area = void 0;
            var warning = void 0;
            var status = void 0;
            var new_inside = void 0;

            // Ignore other aircraft while taxiing
            if (this.isTaxiing()) {
                return;
            }

            warning = false;

            // restricted areas
            // players are penalized for each area entry
            if (this.position) {
                for (var i = 0; i < this.restricted.list.length; i++) {
                    // TODO: this should be abstracted to a helper function
                    //   Polygon matching procedure:
                    //
                    //   1. Filter polygons by aircraft altitude
                    //   2. For other polygons, measure distance to it (distance_to_poly), then
                    //      substract travelled distance every turn
                    //      If distance is about less than 10 seconds of flight,
                    //      assign distance equal to 10 seconds of flight,
                    //      otherwise planes flying along the border of entering at shallow angle
                    //      will cause too many checks.
                    //   3. if distance has reached 0, check if the aircraft is within the poly.
                    //      If not, redo #2.
                    area = this.restricted.list[i];

                    // filter only those relevant by height
                    if (area.data.height < this.altitude) {
                        area.range = null;
                        area.inside = false;
                        continue;
                    }

                    // count distance untill the next check
                    if (area.range) {
                        area.range -= this.ds;
                    }

                    // recalculate for new areas or those that should be checked
                    if (!area.range || area.range <= 0) {
                        new_inside = (0, _vector.point_in_poly)(this.position, area.data.coordinates);

                        // ac has just entered the area: .inside is still false, but st is true
                        if (new_inside && !area.inside) {
                            window.gameController.events_recordNew(_GameController.GAME_EVENTS.AIRSPACE_BUST);
                            area.range = this.speed * 1.85 / 3.6 * 50 / 1000; // check in 50 seconds
                            // speed is kts, range is km.
                            // if a plane got into restricted area, don't check it too often
                        } else {
                            // don't calculate more often than every 10 seconds
                            area.range = Math.max(this.speed * 1.85 / 36 / 1000 * 10, (0, _vector.distance_to_poly)(this.position, area.data.coordinates));
                        }

                        area.inside = new_inside;
                    }
                }

                // raise warning if in at least one restricted area
                _jquery2.default.each(this.restricted.list, function (k, v) {
                    warning = warning || v.inside;
                });
            }

            if (this.terrain_ranges && !this.isOnGround()) {
                var terrain = prop.airport.current.terrain;
                var prev_level = this.terrain_ranges[this.terrain_level];
                var ele = Math.ceil(this.altitude, 1000);
                var curr_ranges = this.terrain_ranges[ele];

                if (ele !== this.terrain_level) {
                    for (var lev in prev_level) {
                        prev_level[lev] = Infinity;
                    }

                    this.terrain_level = ele;
                }

                for (var id in curr_ranges) {
                    curr_ranges[id] -= this.ds;
                    // console.log(curr_ranges[id]);

                    if (curr_ranges[id] < 0 || curr_ranges[id] === Infinity) {
                        area = terrain[ele][id];
                        status = (0, _vector.point_to_mpoly)(this.position, area, id);

                        if (status.inside) {
                            this.altitude = 0;

                            if (!this.hit) {
                                this.hit = true;

                                console.log('hit terrain');
                                var isWarning = true;
                                window.uiController.ui_log(this.getCallsign() + ' collided with terrain in controlled flight', isWarning);
                                (0, _speech.speech_say)([{ type: 'callsign', content: this }, { type: 'text', content: ', we\'re going down!' }]);

                                window.gameController.events_recordNew(_GameController.GAME_EVENTS.COLLISION);
                            }
                        } else {
                            curr_ranges[id] = Math.max(0.2, status.distance);
                            // console.log(this.getCallsign(), 'in', curr_ranges[id], 'km from', id, area[0].length);
                        }
                    }
                }
            }

            this.warning = warning;
        }

        /**
         * @for AircraftInstanceModel
         * @method updateStrip
         */

    }, {
        key: 'updateStrip',
        value: function updateStrip() {
            if (this.projected) {
                return;
            }

            // Update fms.following
            this.fms.followCheck();

            var wp = this.fms.currentWaypoint;
            // Populate strip fields with default values
            var defaultHeadingText = (0, _unitConverters.heading_to_string)(wp.heading);
            var defaultAltitudeText = (0, _get3.default)(wp, 'altitude', '-');
            var defaultDestinationText = (0, _get3.default)(this, 'destination', window.airportController.airport_get().icao);
            var currentSpeedText = wp.speed;

            var headingText = void 0;
            var altitudeText = this.taxi_next ? 'ready' : null;
            var destinationText = this.fms.getFollowingSIDText();
            var hasAltitude = (0, _has3.default)(wp, 'altitude');
            var isFollowingSID = (0, _isString3.default)(destinationText);
            var isFollowingSTAR = (0, _isString3.default)(this.fms.following.star);
            var fixRestrictions = this.fms.currentWaypoint.fixRestrictions;


            this.aircraftStripView.update(defaultHeadingText, defaultAltitudeText, defaultDestinationText, currentSpeedText);

            switch (this.mode) {
                case _aircraftConstants.FLIGHT_MODES.APRON:
                    this.aircraftStripView.updateViewForApron(destinationText, hasAltitude, isFollowingSID);
                    break;
                case _aircraftConstants.FLIGHT_MODES.TAXI:
                    this.aircraftStripView.updateViewForTaxi(destinationText, hasAltitude, isFollowingSID, altitudeText);
                    break;
                case _aircraftConstants.FLIGHT_MODES.WAITING:
                    this.aircraftStripView.updateViewForWaiting(destinationText, hasAltitude, isFollowingSID);
                    break;
                case _aircraftConstants.FLIGHT_MODES.TAKEOFF:
                    // When taking off...
                    this.aircraftStripView.updateViewForTakeoff(destinationText, isFollowingSID);

                    break;
                case _aircraftConstants.FLIGHT_MODES.CRUISE:
                    // When in normal flight...
                    if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.FIX) {
                        headingText = wp.fix[0] === '_' ? '[RNAV]' : wp.fix;
                        destinationText = this.fms.getFollowingSTARText();
                    } else if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HOLD) {
                        headingText = 'holding';
                    } else if (wp.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.RWY) {
                        headingText = 'intercept';
                        destinationText = this.fms.getDesinationIcaoWithRunway();
                    }

                    this.aircraftStripView.updateViewForCruise(wp.navmode, headingText, destinationText, isFollowingSID, isFollowingSTAR, fixRestrictions);
                    break;
                case _aircraftConstants.FLIGHT_MODES.LANDING:
                    destinationText = this.fms.getDesinationIcaoWithRunway();

                    this.aircraftStripView.updateViewForLanding(destinationText);
                    break;
                default:
                    throw new TypeError('Invalid FLIGHT_MODE ' + this.mode + ' passed to .updateStrip()');
            }
        }

        /**
         * @for AircraftInstanceModel
         * @method updateAuto
         */

    }, {
        key: 'updateAuto',
        value: function updateAuto() {}

        /**
         * @for AircraftInstanceModel
         * @method update
         */

    }, {
        key: 'update',
        value: function update() {
            if (prop.aircraft.auto.enabled) {
                this.updateAuto();
            }

            this.updateTarget();
            this.updatePhysics();
        }

        /**
         * @for AircraftInstanceModel
         * @method addConflict
         */

    }, {
        key: 'addConflict',
        value: function addConflict(conflict, other) {
            this.conflicts[other.getCallsign()] = conflict;
        }

        /**
         * @for AircraftInstanceModel
         * @method checkConflict
         */

    }, {
        key: 'checkConflict',
        value: function checkConflict(other) {
            if (this.conflicts[other.getCallsign()]) {
                this.conflicts[other.getCallsign()].update();
                return true;
            }

            return false;
        }

        /**
         * @for AircraftInstanceModel
         * @method hasAlerts
         */

    }, {
        key: 'hasAlerts',
        value: function hasAlerts() {
            var a = [false, false];
            var c = null;
            for (var i in this.conflicts) {
                c = this.conflicts[i].hasAlerts();
                a[0] = a[0] || c[0];
                a[1] = a[1] || c[1];
            }

            return a;
        }

        /**
         * @for AircraftInstanceModel
         * @method removeConflict
         * @param other
         */

    }, {
        key: 'removeConflict',
        value: function removeConflict(other) {
            delete this.conflicts[other.getCallsign()];
        }
    }]);

    return Aircraft;
}();

exports.default = Aircraft;

},{"../airport/Route/RouteModel":548,"../constants/aircraftConstants":570,"../constants/selectors":575,"../game/GameController":580,"../math/circle":583,"../math/core":584,"../math/distance":585,"../math/flightMath":586,"../math/vector":587,"../speech":588,"../utilities/radioUtilities":593,"../utilities/unitConverters":595,"./AircraftStripView":527,"./FlightManagementSystem/AircraftFlightManagementSystem":528,"./FlightManagementSystem/Waypoint":530,"jquery":296,"lodash/forEach":468,"lodash/get":469,"lodash/has":470,"lodash/isEqual":481,"lodash/isNaN":484,"lodash/isNil":485,"lodash/isString":489,"lodash/map":496}],526:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _AircraftInstanceModel = require('./AircraftInstanceModel');

var _AircraftInstanceModel2 = _interopRequireDefault(_AircraftInstanceModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// TODO: this class could use a better name. What differentiates this class from `AircraftInstanceModel`?
/**
 * Definitions for characteristics of a particular aircraft type
 *
 * @class AircraftModel
 */
var AircraftModel = function () {
    /**
     * @for AircraftModel
     * @constructor
     * @param options {object}
     */
    function AircraftModel() {
        var _this = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, AircraftModel);

        this.onLoadSuccess = function (response) {
            _this.parse(response);

            _this.loading = false;
            _this.loaded = true;

            _this._generatePendingAircraft();
        };

        this.onLoadError = function (_ref) {
            var textStatus = _ref.textStatus;

            _this.loading = false;
            _this._pendingAircraft = [];

            console.error('Unable to load aircraft/ ' + _this.icao + ' : ' + textStatus);
        };

        this.loading = true;
        this.loaded = false;
        this.priorityLoad = false;
        this.name = (0, _get3.default)(options, 'name', null);
        this.icao = (0, _get3.default)(options, 'icao', null);
        this.engines = null;
        this.ceiling = null;
        this.weightclass = (0, _get3.default)(options, 'weightClass', null);
        this.category = (0, _get3.default)(options, 'category', null);
        this._url = '';
        this._pendingAircraft = [];

        this.rate = {
            // radians per second
            turn: 0,
            // feet per second
            climb: 0,
            descent: 0,
            // knots per second
            accelerate: 0,
            decelerate: 0
        };

        this.runway = {
            // km needed to takeoff
            takeoff: 0,
            landing: 0
        };

        this.speed = {
            min: 0,
            max: 0,
            landing: 0,
            cruise: 0
        };

        this.parse(options);

        if (options.url) {
            this.load(options.url);
        }
    }

    /**
     * Set class properties with `data`.
     *
     * This method is run once on instantiation and again `onLoadSuccess`
     *
     * @for AircraftModel
     * @method parse
     * @param data {object}
     */


    _createClass(AircraftModel, [{
        key: 'parse',
        value: function parse(data) {
            this.engines = (0, _get3.default)(data, 'engines', this.engines);
            this.ceiling = (0, _get3.default)(data, 'ceiling', this.ceiling);
            this.runway = (0, _get3.default)(data, 'runway', this.runway);
            this.speed = (0, _get3.default)(data, 'speed', this.speed);
            this.rate = (0, _get3.default)(data, 'rate', this.rate);
        }

        /**
         * @for AircraftModel
         * @method load
         * @param url {string}
         */

    }, {
        key: 'load',
        value: function load(url) {
            var _this2 = this;

            this._url = url;

            zlsa.atc.loadAsset({
                url: url,
                immediate: false
            }).done(function (response) {
                return _this2.onLoadSuccess(response);
            }).fail(function () {
                return _this2.onLoadError.apply(_this2, arguments);
            });
        }

        /**
         * @for AircraftModel
         * @method onLoadSuccess
         * @param response {object}
         */


        /**
         * @for AircraftModel
         * @method onLoadError
         * @param textStatus {string}
         */

    }, {
        key: 'generateAircraft',


        /**
         * Generate a new aircraft of this model
         *
         * Handles the case where this model may be asynchronously loaded
         *
         * @for AircraftModel
         * @method generateAircraft
         * @param options {object}
         */
        value: function generateAircraft(options) {
            // TODO: prop names of loaded and loading are concerning. there may be state machine magic happening here
            // that could lead to issues
            if (!this.loaded) {
                if (this.loading) {
                    this._pendingAircraft.push(options);

                    if (!this.priorityLoad) {
                        zlsa.atc.loadAsset({
                            url: this._url,
                            immediate: true
                        });

                        this.priorityLoad = true;
                    }

                    return true;
                }

                console.warn('Unable to spawn aircraft/ ' + options.icao + ' as loading failed');

                return false;
            }

            return this._generateAircraft(options);
        }

        /**
         * Actual implementation of generateAircraft
         *
         * @for AircraftModel
         * @method _generateAircraft
         * @param options {object}
         * @return {boolean}
         * @private
         */

    }, {
        key: '_generateAircraft',
        value: function _generateAircraft(options) {
            options.model = this;
            var aircraft = new _AircraftInstanceModel2.default(options);

            prop.aircraft.list.push(aircraft);

            console.log('Spawning ' + options.category + ' : ' + aircraft.getCallsign());

            return true;
        }

        /**
         * Generate aircraft which were queued while the model loaded
         *
         * @for AircraftModel
         * @method _generatePendingAircraft
         */

    }, {
        key: '_generatePendingAircraft',
        value: function _generatePendingAircraft() {
            var _this3 = this;

            (0, _forEach3.default)(this._pendingAircraft, function (pendingAircraftOptions) {
                _this3._generateAircraft(pendingAircraftOptions);
            });

            this._pendingAircraft = [];
        }
    }]);

    return AircraftModel;
}();

exports.default = AircraftModel;

},{"./AircraftInstanceModel":525,"lodash/forEach":468,"lodash/get":469}],527:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _core = require('../math/core');

var _aircraftConstants = require('../constants/aircraftConstants');

var _selectors = require('../constants/selectors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * unique id for each AircraftStripView instance
 *
 * @property ID
 * @type {number}
 */
var ID = 0;

/**
 * Root html element
 *
 * @property AIRCRAFT_STRIP_TEMPLATE
 * @type {string}
 * @final
 */
var AIRCRAFT_STRIP_TEMPLATE = '<li class="strip"></li>';

/**
 * Height of the AircraftStrip DOM element in px.
 *
 * @property AIRCRAFT_STRIP_HEIGHT
 * @type {number}
 * @final
 */
var AIRCRAFT_STRIP_HEIGHT = 45;

/**
 * @class AircraftStripView
 */

var AircraftStripView = function () {
    /**
     * @for AircraftStripView
     * @constructor
     * @param callsign {string}  this property is a result of a function call and not directly tied to the
     *                           `AircraftInstanceModel`, thus it is included explicitly intead of obtainined
     *                           from the `AircraftInstanceModel`
     * @param aircraftInstanceModel {AircraftInstanceModel}
     */
    function AircraftStripView() {
        var _this = this;

        var callsign = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var aircraftInstanceModel = arguments[1];

        _classCallCheck(this, AircraftStripView);

        this.onClickHandler = function (event) {
            window.inputController.input_select(_this.callsign);
        };

        this.onDoubleClickHandler = function (event) {
            prop.canvas.panX = 0 - (0, _core.round)(window.uiController.km_to_px(event.data.position[0]));
            prop.canvas.panY = (0, _core.round)(window.uiController.km_to_px(event.data.position[1]));
            prop.canvas.dirty = true;
        };

        // TODO: change to use lodash _uniqueId
        this._id = ID++;

        this.$element = null;
        this.$callsign = null;
        this.$aircraft = null;
        this.$heading = null;
        this.$altitude = null;
        this.$destination = null;
        this.$speed = null;

        this.height = AIRCRAFT_STRIP_HEIGHT;
        this.callsign = callsign;
        this.icao = aircraftInstanceModel.model.icao;
        this.destination = aircraftInstanceModel.destination;
        this.weightclass = aircraftInstanceModel.model.weightclass;
        this.category = aircraftInstanceModel.category;
        this.flightPlan = aircraftInstanceModel.fms.fp.route.join(' ');

        return this._init().setupHandlers(aircraftInstanceModel).layout().redraw();
    }

    /**
     * @for AircraftStripView
     * @method
     */


    _createClass(AircraftStripView, [{
        key: '_init',
        value: function _init() {
            this.$element = (0, _jquery2.default)(AIRCRAFT_STRIP_TEMPLATE);
            this.$aircraft = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.AIRCRAFT, this.buildIcaoWithWeightClass()));
            this.$callsign = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.CALLSIGN, this.callsign));
            this.$heading = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.HEADING));
            this.$altitude = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.ALTITUDE));
            this.$destination = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.DESTINATION, this.destination));
            this.$speed = (0, _jquery2.default)(this.buildSpanForViewItem(_selectors.SELECTORS.CLASSNAMES.SPEED));

            return this;
        }

        /**
         * @for AircraftStripView
         * @method setupHandlers
         */

    }, {
        key: 'setupHandlers',
        value: function setupHandlers(aircraftInstanceModel) {
            this.$element.on('click', this.onClickHandler);
            this.$element.on('dblclick', aircraftInstanceModel, this.onDoubleClickHandler);

            return this;
        }

        /**
         * @for AircraftStripView
         * @method layout
         */

    }, {
        key: 'layout',
        value: function layout() {
            // TODO: some of the static HTML here could be moved to template constants
            this.$element.append(this.$callsign);
            this.$element.append(this.$heading);
            this.$element.append(this.$altitude);
            this.$element.append(this.$aircraft);
            this.$element.append(this.$destination);
            this.$element.append(this.$speed);
            this.$element.addClass(this.findClassnameForFlightCateogry());
            // TODO: this doesnt appear to be doing what the below comment says it should be doing
            // show fp route on hover
            this.$element.prop('title', this.flightPlan);

            return this;
        }

        /**
         * @for AircraftStripView
         * @method redraw
         */

    }, {
        key: 'redraw',
        value: function redraw() {
            return this;
        }

        /**
         * @for AircraftStripView
         * @method enable
         */

    }, {
        key: 'enable',
        value: function enable() {
            return this;
        }

        /**
         * @for AircraftStripView
         * @method disable
         */

    }, {
        key: 'disable',
        value: function disable() {
            this.$element.off('click', this.onClickHandler);
            this.$element.off('dblclick', this.onDoubleClickHandler);

            return this.destroy();
        }

        /**
         * @for AircraftStripView
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$element = null;
            this.$callsign = null;
            this.$aircraft = null;
            this.$heading = null;
            this.$altitude = null;
            this.$destination = null;
            this.$speed = null;

            this.callsign = '';
            this.icao = '';
            this.destination = '';
            this.weightclass = '';
            this.category = '';
            this.flightPlan = '';

            return this;
        }

        /**
         * Return a span with a classname and/or content string.
         *
         * Used when initializing templates. Removes the need for having individual template constants for each line
         * when the only difference is a classname and content. Also provides a way to cache all the AircraftStripView
         * selectors on instantiation.
         *
         * @for AircraftStripView
         * @param className {string}
         * @param content {string}
         */

    }, {
        key: 'buildSpanForViewItem',
        value: function buildSpanForViewItem(className) {
            var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            return '<span class="' + className + '">' + content + '</span>';
        }

        /**
         * @for AircraftStripView
         * @method buildIcaoWithWeightClass
         * @return aircraftIcao {string}
         */

    }, {
        key: 'buildIcaoWithWeightClass',
        value: function buildIcaoWithWeightClass() {
            var aircraftIcao = this.icao;

            // TODO: indexOf is goofy here, this can be simplified
            // Bottom Line Data
            if (['H', 'U'].indexOf(this.weightclass) > -1) {
                aircraftIcao = 'H/' + this.icao;
            }

            return aircraftIcao.toUpperCase();
        }

        /**
         * @for AircraftStripView
         * @method findClassnameForFlightCateogry
         * @return {string}
         */

    }, {
        key: 'findClassnameForFlightCateogry',
        value: function findClassnameForFlightCateogry() {
            return this.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE ? _selectors.SELECTORS.CLASSNAMES.DEPARTURE : _selectors.SELECTORS.CLASSNAMES.ARRIVAL;
        }

        /**
         * Fascade method for jquery `.hide()`
         *
         * @for AircraftStripView
         * @method hide
         * @param duration {number}
         */

    }, {
        key: 'hide',
        value: function hide() {
            var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            this.$element.hide(duration);
        }

        /**
         * @for AircraftStripView
         * @method update
         */

    }, {
        key: 'update',
        value: function update(headingText, altitudeText, destinationText, currentSpeedText) {
            this.resetStripStyles();
            this.updateAircraftTelemetryText(headingText, altitudeText, destinationText, currentSpeedText);

            return this;
        }

        /**
         * Remove all old styling
         *
         * @for AircraftStripView
         * @method resetStripStyles
         * @param headingText {string}
         * @param altitudeText {string}
         * @param destinationText {string}
         * @param currentSpeedText {string}
         */

    }, {
        key: 'resetStripStyles',
        value: function resetStripStyles() {
            var classnamesToRemove = 'runway hold waiting taxi lookingGood allSet';

            this.$heading.removeClass(classnamesToRemove);
            this.$altitude.removeClass(classnamesToRemove);
            this.$destination.removeClass(classnamesToRemove);
            this.$speed.removeClass(classnamesToRemove);
        }

        /**
         * @for AircraftStripView
         * @method updateAircraftTelemetryText
         * @param headingText {string}
         * @param altitudeText {string}
         * @param destinationText {string}
         * @param currentSpeedText {string}
         */

    }, {
        key: 'updateAircraftTelemetryText',
        value: function updateAircraftTelemetryText(headingText, altitudeText, destinationText, currentSpeedText) {
            this.$heading.text(headingText);
            this.$altitude.text(altitudeText);
            this.$destination.text(destinationText);
            this.$speed.text(currentSpeedText);
        }

        /**
         * @for AircraftStripView
         * @method updateViewForApron
         * @param destinationText {string}
         * @param hasAltitude {boolean}
         * @param isFollowingSID {boolean}
         */

    }, {
        key: 'updateViewForApron',
        value: function updateViewForApron(destinationText, hasAltitude, isFollowingSID) {
            this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.text(_aircraftConstants.FLIGHT_MODES.APRON);

            if (hasAltitude) {
                this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }

            if (isFollowingSID) {
                // TODO: this should be a class method on the FMS
                this.$destination.text(destinationText);
                this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }
        }

        /**
         * @for AircraftStripView
         * @method updateViewForTaxi
         * @param destinationText {string}
         * @param hasAltitude {boolean}
         * @param isFollowingSID {boolean}
         * @param altitudeText {string}
         */

    }, {
        key: 'updateViewForTaxi',
        value: function updateViewForTaxi(destinationText, hasAltitude, isFollowingSID, altitudeText) {
            // TODO: abstract FROM HERE
            this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.text(_aircraftConstants.FLIGHT_MODES.TAXI);

            if (hasAltitude) {
                this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }

            if (isFollowingSID) {
                // TODO: this should be a class method on the FMS
                this.$destination.text(destinationText);
                this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }
            // TODO: abstract TO HERE

            if (altitudeText) {
                this.$altitude.text(altitudeText);
            }
        }

        /**
         * @for AircraftStripView
         * @method updateViewForWaiting
         * @param destinationText {string}
         * @param hasAltitude {boolean}
         * @param isFollowingSID {boolean}
         */

    }, {
        key: 'updateViewForWaiting',
        value: function updateViewForWaiting(destinationText, hasAltitude, isFollowingSID) {
            this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            this.$heading.text(_aircraftConstants.FLIGHT_MODES.WAITING);

            if (hasAltitude) {
                this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }

            if (isFollowingSID) {
                // TODO: this should be a class method on the FMS
                this.$destination.text(destinationText);
                this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.RUNWAY);
            }
        }

        /**
         * @for AircraftStripView
         * @method updateTakeOffView
         * @param destinationText {string}
         */

    }, {
        key: 'updateViewForTakeoff',
        value: function updateViewForTakeoff(destinationText, isFollowingSID) {
            this.$heading.text(_aircraftConstants.FLIGHT_MODES.TAKEOFF);

            if (isFollowingSID) {
                this.$destination.text(destinationText);
                this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.LOOKING_GOOD);
            }
        }

        /**
         * @for AircraftStripView
         * @method updateViewForLanding
         * @param destinationText {string}
         */

    }, {
        key: 'updateViewForLanding',
        value: function updateViewForLanding(destinationText) {
            var ON_GLIDESLOPE = 'GS';
            var ON_ILS = 'on ILS';

            this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
            this.$heading.text(ON_ILS);
            this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
            this.$altitude.text(ON_GLIDESLOPE);
            this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
            this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
            this.$destination.text(destinationText);
        }

        /**
         * @for AircraftStripView
         * @method updateViewForCruise
         * @param navMode
         * @param headingText {string}
         * @param destinationText {string}
         * @param isFollowingSID {boolean}
         * @param isFollowingSTAR {boolean}
         * @param fixRestrictions {object}
         */

    }, {
        key: 'updateViewForCruise',
        value: function updateViewForCruise(navMode) {
            var headingText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            var destinationText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
            var isFollowingSID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var isFollowingSTAR = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var fixRestrictions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

            switch (navMode) {
                case _aircraftConstants.WAYPOINT_NAV_MODE.FIX:
                    this.$heading.text(headingText);

                    if (isFollowingSID) {
                        this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
                        this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
                        this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
                        this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.ALL_SET);
                    }

                    if (isFollowingSTAR) {
                        this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.FOLLOWING_STAR);
                        this.$destination.text(destinationText);
                        this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.FOLLOWING_STAR);

                        if (fixRestrictions.altitude) {
                            this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.FOLLOWING_STAR);
                        }

                        if (fixRestrictions.speed) {
                            this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.FOLLOWING_STAR);
                        }
                    }

                    break;
                case _aircraftConstants.WAYPOINT_NAV_MODE.HOLD:
                    this.$heading.text(headingText);
                    this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.HOLD);
                    break;
                case _aircraftConstants.WAYPOINT_NAV_MODE.RWY:
                    // attempting ILS intercept
                    this.$heading.addClass(_selectors.SELECTORS.CLASSNAMES.LOOKING_GOOD);
                    this.$heading.text(headingText);
                    this.$altitude.addClass(_selectors.SELECTORS.CLASSNAMES.LOOKING_GOOD);
                    this.$speed.addClass(_selectors.SELECTORS.CLASSNAMES.LOOKING_GOOD);
                    this.$destination.addClass(_selectors.SELECTORS.CLASSNAMES.LOOKING_GOOD);
                    this.$destination.text(destinationText);
                    break;
                default:
                    break;
            }
        }

        /**
         * Click handler for a single click on an AircraftStripView
         *
         * @for AircraftStripView
         * @method onClickHandler
         * @param event {jquery event}
         */


        /**
         * Click handler for a double-click on an AircraftStripView
         *
         * @for AircraftStripView
         * @method onDoubleClickHandler
         * @param  event {jquery event}
         */

    }]);

    return AircraftStripView;
}();

exports.default = AircraftStripView;

},{"../constants/aircraftConstants":570,"../constants/selectors":575,"../math/core":584,"jquery":296}],528:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-plusplus */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _FixCollection = require('../../airport/Fix/FixCollection');

var _FixCollection2 = _interopRequireDefault(_FixCollection);

var _Waypoint = require('./Waypoint');

var _Waypoint2 = _interopRequireDefault(_Waypoint);

var _Leg = require('./Leg');

var _Leg2 = _interopRequireDefault(_Leg);

var _RouteModel = require('../../airport/Route/RouteModel');

var _RouteModel2 = _interopRequireDefault(_RouteModel);

var _core = require('../../math/core');

var _aircraftConstants = require('../../constants/aircraftConstants');

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Enumeration of the Leg index in `this.current`
 *
 * @property
 * @type {number}
 * @final
 */
var LEG = 0;

/**
 * Enumeration of the Waypoint within leg index in `this.current`
 *
 * @property
 * @type {number}
 * @final
 */
var WAYPOINT_WITHIN_LEG = 1;

/**
  * Manage current and future aircraft waypoints
  *
  * waypoint navmodes
  * -----------------
  * May be one of null, "fix", "heading", "hold", "rwy"
  *
  * * null is assigned, if the plane is not actively following an
  *    objective. This is only the case, if a plane enters the airspace
  *    or an action has been aborted and no new command issued
  *
  * * "fix" is assigned, if the plane is heading for a fix. In this
  *    case, the attribute request.fix is used for navigation
  *
  * * "heading" is assigned, if the plane was given directive to follow
  *    the course set out by the given heading. In this case, the
  *    attributes request.heading and request.turn are used for
  *    navigation
  *
  * * "hold" is assigned, if the plane should hold its position. As
  *    this is archieved by continuously turning, request.turn is used
  *    in this case
  *
  * * "rwy" is assigned, if the plane is heading for a runway. This is
  *    only the case, if the plane was issued the command to land. In
  *    this case, request.runway is used
  *
  * @class AircraftFlightManagementSystem
 */

var AircraftFlightManagementSystem = function () {
    /**
     * @for AircraftFlightManagementSystem
     * @constructor
     * @param options {object}
     */
    function AircraftFlightManagementSystem(options) {
        _classCallCheck(this, AircraftFlightManagementSystem);

        /**
         * @property may_aircrafts_eid
         * @type {number}
         * @default options.aircraft.eid
         */
        this.my_aircrafts_eid = options.aircraft.eid;

        // TODO: we should remove this reference and instead supply methods that the aircraft can call via the fms
        /**
         * @property my_aircraft
         * @type {AircrafInstanceModel}
         * @default options.aircraft
         */
        this.my_aircraft = options.aircraft;

        /**
         * @property legs
         * @type {array}
         * @default []
         */
        this.legs = [];

        /**
         * Current indicies for Leg and Waypoint within that Leg.
         *
         * [current_Leg, current_Waypoint_within_that_Leg]
         *
         * @property current
         * @type {array}
         * @default [0, 0]
         */
        this.current = [0, 0];

        // TODO: possible model object here
        /**
         * @property fp
         * @type {object}
         */
        this.fp = {
            altitude: null,
            route: []
        };

        // TODO: possible model object here
        /**
         * @property following
         * @type {object}
         */
        this.following = {
            sid: null, // Standard Instrument Departure Procedure
            star: null, // Standard Terminal Arrival Route Procedure
            iap: null, // Instrument Approach Procedure (like ILS, GPS, RNAV, VOR-A, etc)
            awy: null, // Airway (V, J, T, Q, etc.)
            tfc: null, // Traffic (another airplane)
            anything: false // T/F flag for if anything is being "followed"
        };

        // TODO: this doesn't belong in the constructor
        // TODO: enumerate the magic numbers
        // set initial altitude
        this.fp.altitude = (0, _core.clamp)(1000, options.model.ceiling, 60000);

        if (options.aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL) {
            this.prependLeg({ route: 'UNASSIGNED' });
        } else if (options.aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
            this.prependLeg({ route: window.airportController.airport_get().icao });
        }

        this.update_fp_route();
    }

    /** ***************** FMS FLIGHTPLAN CONTROL FUNCTIONS *******************/

    /**
     * Insert a Leg at the front of the flightplan
     */


    _createClass(AircraftFlightManagementSystem, [{
        key: 'prependLeg',
        value: function prependLeg(data) {
            var prev = this.currentWaypoint;
            var legToAdd = new _Leg2.default(data, this);

            this.legs.unshift(legToAdd);
            this.update_fp_route();

            // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
            // Verify altitude & speed not null
            var curr = this.currentWaypoint;
            if (prev && !curr.altitude) {
                curr.altitude = prev.altitude;
            }

            if (prev && !curr.speed) {
                curr.speed = prev.speed;
            }
        }

        /**
         * Insert a waypoint at current position and immediately activate it
         */

    }, {
        key: 'insertWaypointHere',
        value: function insertWaypointHere(data) {
            var airport = window.airportController.airport_get();
            var prev = this.currentWaypoint;
            var waypointToAdd = new _Waypoint2.default(data, airport);

            // TODO: split this up into smaller chunks
            this.currentLeg.waypoints.splice(this.current[WAYPOINT_WITHIN_LEG], 0, waypointToAdd);
            this.update_fp_route();

            // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
            // Verify altitude & speed not null
            var curr = this.currentWaypoint;
            if (prev && !curr.altitude) {
                curr.altitude = prev.altitude;
            }

            if (prev && !curr.speed) {
                curr.speed = prev.speed;
            }
        }

        /**
         * Insert a Leg at a particular position in the flightplan
         * Note: if no position passed in, defaults to add to the end
         */

    }, {
        key: 'insertLeg',
        value: function insertLeg(data) {
            // TODO: reassigining data here is dangerous.
            if (data.firstIndex == null) {
                data.firstIndex = this.legs.length;
            }

            var prev = this.currentWaypoint;
            var legToAdd = new _Leg2.default(data, this);

            this.legs.splice(data.firstIndex, 0, legToAdd);

            this.update_fp_route();

            // Adjust 'current'
            if (this.current[LEG] >= data.firstIndex) {
                this.current[WAYPOINT_WITHIN_LEG] = 0;
            }

            // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
            // Verify altitude & speed not null
            var curr = this.currentWaypoint;
            if (prev && !curr.altitude) {
                curr.altitude = prev.altitude;
            }

            if (prev && !curr.speed) {
                curr.speed = prev.speed;
            }
        }

        /**
         * Insert a Leg at current position immediately activate it
         */

    }, {
        key: 'insertLegHere',
        value: function insertLegHere(data) {
            // index of current leg
            data.firstIndex = this.current[LEG];
            // put new Leg at current position
            this.insertLeg(data);
            // start at first wp in this new leg
            this.current[WAYPOINT_WITHIN_LEG] = 0;
        }

        /**
         *  Insert a Leg at the end of the flightplan
         */

    }, {
        key: 'appendLeg',
        value: function appendLeg(data) {
            var legToAdd = new _Leg2.default(data, this);

            this.legs.push(legToAdd);
            this.update_fp_route();
        }

        /**
         *  Insert a waypoint after the *current* waypoint
         */

    }, {
        key: 'appendWaypoint',
        value: function appendWaypoint(data) {
            var airport = window.airportController.airport_get();
            var waypointToAdd = new _Waypoint2.default(data, airport);

            this.currentLeg.waypoints.splice(this.current[WAYPOINT_WITHIN_LEG] + 1, 0, waypointToAdd);
            this.update_fp_route();
        }

        /**
         *  Switch to the next waypoint
         */

    }, {
        key: 'nextWaypoint',
        value: function nextWaypoint() {
            var prev = this.currentWaypoint;
            var leg = this.current[LEG];
            var wp = this.current[WAYPOINT_WITHIN_LEG] + 1;

            if (wp < this.legs[leg].waypoints.length) {
                // look to next waypoint in current leg
                this.current[WAYPOINT_WITHIN_LEG]++;
            } else if (leg + 1 < this.legs.length) {
                // look to the next leg
                this.current[LEG]++;
                this.current[WAYPOINT_WITHIN_LEG] = 0; // look to the first waypoint of that leg
            }

            // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
            // Replace null values with current values
            var curr = this.currentWaypoint;
            if (prev && !curr.altitude) {
                curr.altitude = prev.altitude;
            }

            if (prev && !curr.speed) {
                curr.speed = prev.speed;
            }

            if (!curr.heading && curr.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HEADING) {
                curr.heading = prev.heading;
            }
        }

        /**
         *  Switch to the next Leg
         */

    }, {
        key: 'nextLeg',
        value: function nextLeg() {
            var prev = this.currentWaypoint;
            this.current[LEG]++;
            this.current[WAYPOINT_WITHIN_LEG] = 0;

            // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
            // Replace null values with current values
            var curr = this.currentWaypoint;
            if (prev && !curr.altitude) {
                curr.altitude = prev.altitude;
            }

            if (prev && !curr.speed) {
                curr.speed = prev.speed;
            }

            if (!curr.heading && curr.navmode === _aircraftConstants.WAYPOINT_NAV_MODE.HEADING) {
                curr.heading = prev.heading;
            }
        }

        /**
         * Skips to the given waypoint
         * @param {string} name - the name of the fix to skip to
         */

    }, {
        key: 'skipToFix',
        value: function skipToFix(name) {
            var prev = this.currentWaypoint;

            // TODO: these nested for loops should be simplified
            for (var l = 0; l < this.legs.length; l++) {
                for (var w = 0; w < this.legs[l].waypoints.length; w++) {
                    if (this.legs[l].waypoints[w].fix === name) {
                        this.current = [l, w];

                        // TODO: these if blocks a repeated elsewhere, perhaps currentWaypoint can handle this logic?
                        // Verify altitude & speed not null
                        var curr = this.currentWaypoint;
                        if (prev && !curr.altitude) {
                            curr.altitude = prev.altitude;
                        }

                        if (prev && !curr.speed) {
                            curr.speed = prev.speed;
                        }

                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Modify all waypoints
         */

    }, {
        key: 'setAll',
        value: function setAll(data) {
            // TODO: refactor this, what is actually happening here?
            for (var i = 0; i < this.legs.length; i++) {
                for (var j = 0; j < this.legs[i].waypoints.length; j++) {
                    for (var k in data) {
                        this.legs[i].waypoints[j][k] = data[k];
                    }
                }
            }
        }

        /**
         * Modify the current waypoint
         */

    }, {
        key: 'setCurrent',
        value: function setCurrent(data) {
            // TODO: refactor this, what is actually happening here?
            // FIXME: it may be easier to replace current waypoint with a new one?
            for (var i in data) {
                this.currentWaypoint[i] = data[i];
            }
        }

        /**
         * Updates fms.fp.route to correspond with the fms Legs
         */

    }, {
        key: 'update_fp_route',
        value: function update_fp_route() {
            var flightPlanRoute = [];

            for (var i = 0; i < this.legs.length; i++) {
                var leg = this.legs[i];

                if (!leg.type) {
                    continue;
                }

                // FIXME: replace the string splitting with the `RouteModel` class methods
                switch (leg.type) {
                    case _aircraftConstants.FP_LEG_TYPE.SID:
                        // departure airport
                        flightPlanRoute.push(leg.route.entry);
                        // 'sidname.exitPoint'
                        flightPlanRoute.push(leg.route.procedure + '.' + leg.route.exit);

                        break;
                    case _aircraftConstants.FP_LEG_TYPE.STAR:
                        // 'entryPoint.starname.exitPoint'
                        flightPlanRoute.push(leg.route.entry + '.' + leg.route.procedure);
                        // arrival airport
                        flightPlanRoute.push(leg.route.exit);

                        break;
                    case _aircraftConstants.FP_LEG_TYPE.IAP:
                        // no need to include these in flightplan (because wouldn't happen in real life)
                        break;
                    case _aircraftConstants.FP_LEG_TYPE.AWY:
                        var previousFlightPlanRoute = flightPlanRoute[flightPlanRoute.length - 1];

                        if (previousFlightPlanRoute !== leg.route.split('.')[0]) {
                            flightPlanRoute.push(leg.route.split('.')[0]); // airway entry fix
                            flightPlanRoute.push(leg.route.split('.')[1]); // airway identifier
                            flightPlanRoute.push(leg.route.split('.')[2]); // airway exit fix
                        }

                        break;
                    case _aircraftConstants.FP_LEG_TYPE.FIX:
                        // this is just a fixname
                        flightPlanRoute.push(leg.route);

                        break;
                    case _aircraftConstants.FP_LEG_TYPE.MANUAL:
                        // no need to include these in flightplan (because wouldn't happen in real life)
                        break;
                    default:
                        break;
                }

                // TODO: this should be first and return early
                if (flightPlanRoute.length === 0) {
                    flightPlanRoute.push(this.legs[0].route);
                }
            }

            this.fp.route = flightPlanRoute;
        }

        /**
         * Calls various task-based functions and sets 'fms.following' flags
         */

    }, {
        key: 'followCheck',
        value: function followCheck() {
            var leg = this.currentLeg;
            this.following.anything = true;

            // tODO replace the string splitting with the `RouteModel`
            switch (leg.type) {
                case _aircraftConstants.FP_LEG_TYPE.SID:
                    this.following.sid = leg.route.procedure;
                    break;
                case _aircraftConstants.FP_LEG_TYPE.STAR:
                    this.following.star = leg.route.procedure;
                    break;
                case _aircraftConstants.FP_LEG_TYPE.IAP:
                    // *******NEEDS TO BE FINISHED***************************
                    // this.following.iap = ;
                    break;
                case 'tfc':
                    // **FUTURE FUNCTIONALITY**
                    // this.following.anything = true;
                    // this.following.tfc = // EID of the traffic we're following
                    break;
                case _aircraftConstants.FP_LEG_TYPE.AWY:
                    // **FUTURE FUNCTIONALITY**
                    this.following.awy = leg.route.split('.')[1];
                    break;
                default:
                    this.followClear();
                    return false;
            }

            return this.following;
        }

        // TODO: rename to something more accurate like `resetFollowingType`
        /**
         * Clears any current follows by updating the 'fms.following' flags
         */

    }, {
        key: 'followClear',
        value: function followClear() {
            this.following = {
                sid: null,
                star: null,
                iap: null,
                awy: null,
                tfc: null,
                anything: false
            };
        }

        /**
         * Join an instrument approach (eg. ILS/GPS/RNAV/VOR/LAAS/etc)
         *
         * @param {string} type - the type of approach (like "ils")
         * @param {Runway} rwy - the Runway object the approach ends into
         * @param {string} variant - (optional) for stuff like "RNAV-Z 17L"
         */

    }, {
        key: 'followApproach',
        value: function followApproach(type, rwy, variant) {
            // Note: 'variant' is set up to pass to this function, but is not used here yet.
            if (type === 'ils') {
                this.my_aircraft.cancelFix();
                // TODO: this looks like a model object
                this.setCurrent({
                    navmode: 'rwy',
                    runway: rwy.toUpperCase(),
                    turn: null,
                    start_speed: this.my_aircraft.speed
                });
            }
            // if-else all the other approach types here...
            // ILS, GPS, RNAV, VOR, NDB, LAAS/WAAS, MLS, etc...
        }

        /**
         * Inserts the SID as the first Leg in the fms's flightplan
         */

    }, {
        key: 'followSID',
        value: function followSID(route) {
            var airport = window.airportController.airport_get();

            for (var i = 0; i < this.legs.length; i++) {
                // sid assigned after taking off without SID
                if (this.legs[i].route === airport.icao) {
                    // remove the manual departure leg
                    this.legs.splice(i, 1);
                } else if (this.legs[i].type === _aircraftConstants.FP_LEG_TYPE.SID) {
                    // check to see if SID already assigned
                    // remove the old SID
                    this.legs.splice(i, 1);
                }
            }

            // Add the new SID Leg
            this.prependLeg({
                type: _aircraftConstants.FP_LEG_TYPE.SID,
                route: route
            });

            this.setAll({
                altitude: Math.max(airport.initial_alt, this.my_aircraft.altitude)
            });
        }

        /**
         * Inserts the STAR as the last Leg in the fms's flightplan
         */

    }, {
        key: 'followSTAR',
        value: function followSTAR(route) {
            for (var i = 0; i < this.legs.length; i++) {
                if (this.legs[i].type === _aircraftConstants.FP_LEG_TYPE.STAR) {
                    // check to see if STAR already assigned
                    this.legs.splice(i, 1); // remove the old STAR
                }
            }

            this.current = [0, 0];
            // Add the new STAR Leg
            this.appendLeg({
                route: route,
                type: _aircraftConstants.FP_LEG_TYPE.STAR
            });
        }

        // TODO: move this logic to the `RouteModel`
        /**
         * Takes a single-string route and converts it to a segmented route the fms can understand
         *
         * Note: Input Data Format : "KSFO.OFFSH9.SXC.V458.IPL.J2.JCT..LLO..ACT..KACT"
         *       Return Data Format: ["KSFO.OFFSH9.SXC", "SXC.V458.IPL", "IPL.J2.JCT", "LLO", "ACT", "KACT"]
         */

    }, {
        key: 'formatRoute',
        value: function formatRoute(data) {
            // const routeModel = new RouteModel(data);

            // Format the user's input
            var route = [];
            var airport = window.airportController.airport_get();
            var fixOK = function fixOK(fixName) {
                return _FixCollection2.default.findFixByName(fixName) !== null;
            };

            if (data.indexOf(' ') !== -1) {
                return; // input can't contain spaces
            }

            // TODO: this should be reassigned and returned instead of operating on the passed in paramater
            // split apart "direct" pieces
            data = data.split('..');

            // TODO: This block needs some work. the logic could be simplified.
            // deal with multilinks (eg 'KSFO.OFFSH9.SXC.V458.IPL')
            for (var i = 0; i < data.length; i++) {
                var a = void 0;

                if (data[i].split('.').length === 1) {
                    if (!fixOK(data[i])) {
                        return;
                    }

                    // just a fix/navaid
                    route.push(data[i]);
                    continue;
                } else {
                    // is a procedure, eg SID, STAR, IAP, airway, etc.
                    if (data[i].split('.').length % 2 !== 1) {
                        // user either didn't specify start point or end point
                        return;
                    }

                    // TODO: this should be abstracted to another class method.
                    var pieces = data[i].split('.');
                    // FIXME: what does 'a' mean? better naming
                    a = [pieces[0] + '.' + pieces[1] + '.' + pieces[2]];

                    // chop up the multilink
                    for (var j = 3; j < data[i].split('.').length; j + 2) {
                        if (!fixOK(pieces[0]) || !fixOK(pieces[2])) {
                            return; // invalid join/exit points
                        }

                        if (!airport.sidCollection.hasRoute(pieces[1]) || !Object.keys(airport.airways).indexOf(pieces[1])) {
                            // invalid procedure
                            return;
                        }

                        a.push(pieces[j - 1] + '.' + pieces[j] + pieces[j + 1]);
                    }
                }

                // push the properly reformatted multilink
                route = route.concat(a);
            }

            return route;
        }

        // TODO: refactor this to use `RouteModel` and possibly a `LegsCollection` class
        /**
         * Take an array of leg routes and build the legs that will go into the fms
         * @param {array} route - an array of properly formatted route strings
         *                        Example: ["KSFO.OFFSH9.SXC", "SXC.V458.IPL",
         *                                 "IPL.J2.JCT", "LLO", "ACT", "KACT"]
         * @param {boolean} fullRouteClearance - set to true IF you want the provided route to completely
         *                                       replace the current contents of 'this.legs'
         */

    }, {
        key: 'customRoute',
        value: function customRoute(route, fullRouteClearance) {
            // save the current waypoint
            var curr = this.currentWaypoint;

            var legs = [];

            for (var i = 0; i < route.length; i++) {
                var routeSections = route[i].split('.');

                // just a fix/navaid
                if (routeSections.length === 1) {
                    var legToAdd = new _Leg2.default({ type: _aircraftConstants.FP_LEG_TYPE.FIX, route: route[i] }, this);

                    legs.push(legToAdd);
                } else if (routeSections.length === 3) {
                    var routeModel = new _RouteModel2.default(route[i]);
                    var currentAirport = window.airportController.airport_get();

                    if (!(0, _isNil3.default)(currentAirport.sidCollection.findRouteByIcao(routeModel.procedure))) {
                        // it's a SID!
                        var _legToAdd = new _Leg2.default({ type: _aircraftConstants.FP_LEG_TYPE.SID, route: routeModel.routeCode }, this);

                        legs.push(_legToAdd);
                    } else if (!(0, _isNil3.default)(currentAirport.starCollection.findRouteByIcao(routeModel.procedure))) {
                        // it's a STAR!
                        var _legToAdd2 = new _Leg2.default({ type: _aircraftConstants.FP_LEG_TYPE.STAR, route: routeModel.routeCode }, this);

                        legs.push(_legToAdd2);
                    } else if (Object.keys(window.airportController.airport_get().airways).indexOf(routeModel.procedure) > -1) {
                        // it's an airway!
                        var _legToAdd3 = new _Leg2.default({ type: _aircraftConstants.FP_LEG_TYPE.AWY, route: routeModel.routeCode }, this);

                        legs.push(_legToAdd3);
                    }
                } else {
                    // neither formatted like "JAN" nor "JAN.V18.MLU"
                    log('Passed invalid route to fms. Unable to create leg from input: ' + route[i], _logLevel.LOG.WARNING);
                    return false;
                }
            }

            // TODO: this should be its own method
            // TODO: this could be simplified. there is a lot of branching logic here that makes this block tough to follow.
            // insert user's route to the legs
            if (!fullRouteClearance) {
                // Check if user's route hooks up to the current Legs anywhere
                var pieces = legs[legs.length - 1].route.split('.');
                var last_fix = pieces[pieces.length - 1];
                var continuity = this.indexOfWaypoint(last_fix);

                // user route connects with existing legs
                if (continuity) {
                    var inMiddleOfLeg = continuity.lw[1] !== this.legs[continuity.lw[0]].waypoints.length - 1;
                    var legsToRemove = Math.max(0, continuity.lw[0] - inMiddleOfLeg - this.current[LEG]);

                    if (inMiddleOfLeg) {
                        // change the existing leg @ merge point
                        // Remove the waypoints before the merge point
                        this.legs[continuity.lw[0]].waypoints.splice(0, continuity.lw[1]);
                        var r = this.legs[continuity.lw[0]].route.split('.');

                        // TODO: this should be a helper method
                        // Update the leg's route to reflect the change
                        this.legs[continuity.lw[0]].route = last_fix + '.' + r[1] + '.' + r[2];
                    }

                    // remove old legs before the point where the two routes join
                    this.legs.splice.apply(this.legs, [Math.max(0, continuity.lw[0] - legsToRemove), legsToRemove].concat(legs));
                    // move to the newly inserted Leg
                    this.current[LEG] = Math.max(0, continuity.lw[0] - legsToRemove);
                    this.current[WAYPOINT_WITHIN_LEG] = 0;
                } else {
                    // no route continuity... just adding legs
                    // insert the legs after the active Leg
                    this.legs.splice.apply(this.legs, [this.current[LEG] + 1, 0].concat(legs));
                    this.nextLeg();
                }
            } else {
                // TODO: move up and return early
                // replace all legs with the legs we've built here in this function
                this.legs = legs;
                this.current = [0, 0]; // look to beginning of route
            }

            this.update_fp_route();

            // Maintain old speed and altitude
            if (this.currentWaypoint.altitude == null) {
                this.setCurrent({ altitude: curr.altitude });
            }

            if (this.currentWaypoint.speed == null) {
                this.setCurrent({ speed: curr.speed });
            }

            return true;
        }

        /**
         * Climbs aircraft in compliance with the SID they're following
         * Adds altitudes and speeds to each waypoint that are as high as
         * possible without exceeding any the following:
         *    - (alt) airspace ceiling ('ctr_ceiling')
         *    - (alt) filed cruise altitude
         *    - (alt) waypoint's altitude restriciton
         *    - (spd) 250kts when under 10k ft
         *    - (spd) waypoint's speed restriction
         */

    }, {
        key: 'climbViaSID',
        value: function climbViaSID() {
            if (this.currentLeg.type !== _aircraftConstants.FP_LEG_TYPE.SID) {
                return false;
            }

            var wp = this.currentLeg.waypoints;
            var cruise_alt = this.fp.altitude;
            var cruise_spd = this.my_aircraft.model.speed.cruise;

            for (var i = 0; i < wp.length; i++) {
                var waypoint = wp[i];

                var _window$airportContro = window.airportController.airport_get(),
                    ctr_ceiling = _window$airportContro.ctr_ceiling;

                waypoint.setAltitude(ctr_ceiling, cruise_alt);
                waypoint.setSpeed(cruise_spd);
            }

            return true;
        }

        /**
         * Descends aircraft in compliance with the STAR they're following
         * Adds altitudes and speeds to each waypoint in accordance with the STAR
         */

    }, {
        key: 'descendViaSTAR',
        value: function descendViaSTAR() {
            var waypointList = this.getStarLegWaypoints();

            // TODO: would a star leg ever not have waypoints?
            if (!waypointList) {
                return;
            }

            var start_alt = this.currentWaypoint.altitude || this.my_aircraft.altitude;
            var start_spd = this.currentWaypoint.speed || this.my_aircraft.model.speed.cruise;

            for (var i = 0; i < waypointList.length; i++) {
                var waypoint = waypointList[i];
                var previousWaypoint = waypointList[i - 1];

                if (i >= 1) {
                    start_alt = previousWaypoint.altitude;
                    start_spd = previousWaypoint.speed;
                }

                waypoint.setAltitude(null, start_alt);
                waypoint.setSpeed(start_spd);
            }

            return true;
        }

        /** ************************ FMS QUERY FUNCTIONS **************************/
        /**
         * True if waypoint of the given name exists
         */

    }, {
        key: 'hasWaypoint',
        value: function hasWaypoint(name) {
            // TODO: lodash will simplify this logic block
            for (var i = 0; i < this.legs.length; i++) {
                for (var j = 0; j < this.legs[i].waypoints.length; j++) {
                    if (this.legs[i].waypoints[j].fix === name) {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Returns object's position in flightplan as object with 2 formats
         *
         * @param {string} fix - name of the fix to look for in the flightplan
         * @returns {wp: "position-of-fix-in-waypoint-list",
         *           lw: "position-of-fix-in-leg-wp-matrix"}
         */

    }, {
        key: 'indexOfWaypoint',
        value: function indexOfWaypoint(fix) {
            var wp = 0;

            for (var l = 0; l < this.legs.length; l++) {
                for (var w = 0; w < this.legs[l].waypoints.length; w++) {
                    if (this.legs[l].waypoints[w].fix === fix) {
                        // TODO: what do wp and lw stand for?
                        return {
                            wp: wp,
                            lw: [l, w]
                        };
                    }

                    wp++;
                }
            }

            return false;
        }

        /**
         * Returns currentWaypoint's position in flightplan as object with 2 formats
         * @returns {wp: "position-of-fix-in-waypoint-list",
         *           lw: "position-of-fix-in-leg-wp-matrix"}
         */

    }, {
        key: 'indexOfCurrentWaypoint',
        value: function indexOfCurrentWaypoint() {
            var wp = 0;
            for (var i = 0; i < this.current[LEG]; i++) {
                // add wp's of completed legs
                wp += this.legs[i].waypoints.length;
            }

            wp += this.current[WAYPOINT_WITHIN_LEG];

            // TODO: what do wp and lw stand for?
            return {
                wp: wp,
                lw: this.current
            };
        }

        /** ************************* FMS GET FUNCTIONS ***************************/

    }, {
        key: 'fixes',


        /**
        * Returns an array of all fixes along the flightplan route
        */
        value: function fixes() {
            return (0, _map3.default)(this.waypoints(), function (w) {
                return w.fix;
            });
        }

        /**
         * Return this fms's parent aircraft
         */

    }, {
        key: 'my_aircraft',
        value: function my_aircraft() {
            // TODO: if we already have a ref to the current aircraft, `this.my_aircraft`, why are we getting it again here?
            return window.aircraftController.aircraft_get(this.my_aircrafts_eid);
        }

        /**
         * Returns a waypoint at the provided position
         *
         * @method waypoint
         * @param {array or number} pos - position of the desired waypoint. May be
         *                          provided either as an array showing the leg and
         *                          waypoint within the leg (eg [l,w]), or as the
         *                          number representing the position of the desired
         *                          waypoint in the list of all waypoints (running
         *                          this.waypoints() will return the list)
         * @returns {Waypoint} - the Waypoint object at the specified location
         */

    }, {
        key: 'waypoint',
        value: function waypoint(pos) {
            // input is like [leg, waypointWithinLeg]
            if (Array.isArray(pos)) {
                return this.legs[pos[0]].waypoints[pos[1]];
            } else if (typeof pos === 'number') {
                // input is a position of wp in list of all waypoints
                var l = 0;

                // count up to pos to locate the waypoint
                while (pos >= 0) {
                    if (this.legs[l].waypoints.length <= pos) {
                        pos -= this.legs[l].waypoints.length;
                        l++;
                    } else {
                        return this.legs[l].waypoints[pos];
                    }
                }
            }

            return;
        }

        /**
         * Find a leg with type `star` and return that leg's waypoints.
         *
         * @method getSt
         * @return {array<Waypoint>}
         */

    }, {
        key: 'getStarLegWaypoints',
        value: function getStarLegWaypoints() {
            var starLeg = (0, _find3.default)(this.legs, { type: _aircraftConstants.FP_LEG_TYPE.STAR });

            return starLeg.waypoints || [];
        }

        /**
        * Returns all waypoints in fms, in order
        */

    }, {
        key: 'waypoints',
        value: function waypoints() {
            // TODO: move to _map() or refactor
            // TODO: there is a better way to do this with lodash
            var waypointList = _jquery2.default.map(this.legs, function (v) {
                return v.waypoints;
            });

            return waypointList;
        }
    }, {
        key: 'atLastWaypoint',
        value: function atLastWaypoint() {
            // TODO: simplify
            return this.indexOfCurrentWaypoint().wp === this.waypoints().length - 1;
        }

        /**
         * Given a SID that is currently being followed, return a string of: `SID_NAME.LAST_FIX`
         *
         * ex:
         * - current SID name = OFFSH9
         * - current SID route = KSFO.OFFSH9.SXC
         *
         * Given the above current values, this function would return:
         * `OFFSH9.SXC`
         *
         * @for AircraftFlightManagementSystem
         * @method getFollowingSideText
         * @return {string|null}
         */

    }, {
        key: 'getFollowingSIDText',
        value: function getFollowingSIDText() {
            if (!this.following.sid) {
                return null;
            }

            return this.following.sid + '.' + this.currentLeg.route.exit;
        }

        /**
         * @for AircraftFlightManagementSystem
         * @method getFollowingSTARText
         * @return {string|null}
         */

    }, {
        key: 'getFollowingSTARText',
        value: function getFollowingSTARText() {
            if (!this.following.star) {
                return null;
            }

            var _window$airportContro2 = window.airportController.airport_get(),
                icao = _window$airportContro2.icao;

            return this.following.star + '.' + icao.toUpperCase();
        }

        /**
         * Returns a string used in the `AircraftStripView` for a landing aircraft.
         *
         * `KSFO 28L`
         *
         * @for AircraftFlightManagementSystem
         * @method getDesinationIcaoWithRunway
         * @return {string}
         */

    }, {
        key: 'getDesinationIcaoWithRunway',
        value: function getDesinationIcaoWithRunway() {
            return (0, _last3.default)(this.fp.route) + ' ' + this.currentWaypoint.runway;
        }

        /**
         * @for AircraftFlightManagementSystem
         * @method altitudeForCurrentWaypoint
         * @return {number|null}
         */

    }, {
        key: 'altitudeForCurrentWaypoint',
        value: function altitudeForCurrentWaypoint() {
            return this.currentWaypoint.altitude;
        }
    }, {
        key: 'currentLeg',
        get: function get() {
            return this.legs[this.current[LEG]];
        }
    }, {
        key: 'currentWaypoint',
        get: function get() {
            if (this.legs.length < 1) {
                return null;
            }

            var currentLeg = this.currentLeg;

            return currentLeg.waypoints[this.current[WAYPOINT_WITHIN_LEG]];
        }
    }]);

    return AircraftFlightManagementSystem;
}();

exports.default = AircraftFlightManagementSystem;

},{"../../airport/Fix/FixCollection":546,"../../airport/Route/RouteModel":548,"../../constants/aircraftConstants":570,"../../constants/logLevel":574,"../../math/core":584,"./Leg":529,"./Waypoint":530,"jquery":296,"lodash/find":466,"lodash/isNil":485,"lodash/last":494,"lodash/map":496}],529:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _Waypoint = require('./Waypoint');

var _Waypoint2 = _interopRequireDefault(_Waypoint);

var _RouteModel = require('../../airport/Route/RouteModel');

var _RouteModel2 = _interopRequireDefault(_RouteModel);

var _aircraftConstants = require('../../constants/aircraftConstants');

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
  * This class acts as a collection of Waypoint model objects.
  *
  * @class Leg
  */
var Leg = function () {
    /**
     *
     * @for Leg
     * @constructor
     * @param data
     * @param {object} route:           "KSFO.OFFSH9.SXC", either a fix, or with format 'start.procedure.end', or
     *                                  "[RNAV/GPS]" for custom positions
     *                 type: "sid",     can be 'sid', 'star', 'iap', 'awy', 'fix'
     *                 firstIndex: 0    the position (index) in fms.legs to insert this leg
     */
    function Leg() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var fms = arguments[1];

        _classCallCheck(this, Leg);

        /**
         * String representation of a route.
         *
         * May be a single fix or a route expressed in dot notation. ex:
         * - `KSFO.OFFSH9.SXC`
         * - `FAITH`
         *
         * @property route
         * @type {string}
         * @default ''
         */
        this.route = '';

        /**
         * @property type
         * @type {string}
         * @default ''
         */
        this.type = '';

        // TODO: possibly implement as a waypointCollection
        /**
         * A collection of Waypoint instances
         *
         * @property waypoints
         * @type {Array}
         * @default []
         */
        this.waypoints = [];

        this.parse(data, fms);
    }

    /**
     * Parse input data and apply to this leg
     *
     * @for Leg
     * @method parse
     * @param data {object}
     * @param fms {AircraftFlightManagementSystem}
     */


    _createClass(Leg, [{
        key: 'parse',
        value: function parse(data, fms) {
            // TODO: move radar vectors to constants file
            this.route = (0, _get3.default)(data, 'route', '[radar vectors]');
            this.type = (0, _get3.default)(data, 'type', _aircraftConstants.FP_LEG_TYPE.MANUAL);
            this.waypoints = (0, _get3.default)(data, 'waypoints', []);

            if (this.waypoints.length === 0) {
                this.generateWaypoints(data, fms);
            }
        }

        /**
         * Adds Waypoint objects to this Leg based on the route type
         *
         * @for Leg
         * @method generateWaypoints
         * @param data {object}
         * @param fms {AircraftFlightManagementSystem}
         */

    }, {
        key: 'generateWaypoints',
        value: function generateWaypoints(data, fms) {
            if (!this.type) {
                return;
            }

            var airport = window.airportController.airport_get();

            switch (this.type) {
                case _aircraftConstants.FP_LEG_TYPE.SID:
                    // TODO: this is gross. we instantiate route with a string and new mutate it here to a RouteModel.
                    this.route = new _RouteModel2.default(data.route);
                    this._generateWaypointsForSid(data, fms);

                    break;
                case _aircraftConstants.FP_LEG_TYPE.STAR:
                    // TODO: this is gross. we instantiate route with a string and new mutate it here to a RouteModel.
                    this.route = new _RouteModel2.default(data.route);
                    this._generateWaypointsForStar(data, fms);

                    break;
                case _aircraftConstants.FP_LEG_TYPE.IAP:
                    // FUTURE FUNCTIONALITY
                    this._generateWaypointsForIap(data, airport);

                    break;
                case _aircraftConstants.FP_LEG_TYPE.AWY:
                    // TODO: this is gross. we instantiate route with a string and new mutate it here to a RouteModel.
                    this.route = new _RouteModel2.default(data.route);
                    this._generateWaypointsForAirway(data, airport);

                    break;
                case _aircraftConstants.FP_LEG_TYPE.FIX:
                    this._generateWaypointForFix(airport);

                    break;
                case _aircraftConstants.FP_LEG_TYPE.MANUAL:
                    this._generateManualWaypoint(airport);

                    break;
                default:
                    this._generateEmptyWaypoint(airport);

                    break;
            }
        }

        /**
         * Add a new Waypoint to the collection
         *
         * @method addWaypointToLeg
         * @param waypointToAdd {Waypoint}
         */

    }, {
        key: 'addWaypointToLeg',
        value: function addWaypointToLeg(waypointToAdd) {
            if (!(waypointToAdd instanceof _Waypoint2.default)) {
                throw new TypeError('Invalid parameter, expecte waypointToAdd to be an instanceof the Waypoint class');
            }

            this.waypoints.push(waypointToAdd);
        }

        /**
         * @for Leg
         * @method _generateWaypointsForSid
         * @param data {object}
         * @param fms {AircraftFlightManagementSystem}
         * @private
         */

    }, {
        key: '_generateWaypointsForSid',
        value: function _generateWaypointsForSid(data, fms) {
            if (!fms) {
                log('Attempted to generate waypoints for SID, but cannot because fms ref not passed!', _logLevel.LOG.WARNING);

                return;
            }

            this._resetWaypoints();

            var rwy = fms.my_aircraft.rwy_dep;

            if (!rwy) {
                var isWarning = true;

                window.uiController.ui_log(fms.my_aircraft.getCallsign() + ' unable to fly SID, we haven\'t been assigned a departure runway!', isWarning);

                return;
            }

            var airport = window.airportController.airport_get(this.route.entry);
            var waypointsForSid = airport.findWaypointModelsForSid(this.route.procedure, rwy, this.route.exit);

            // TODO: refactor/abstract this boolean logic
            // Remove the placeholder leg (if present)
            if (fms.my_aircraft.isOnGround() && fms.legs.length > 0 && fms.legs[0].route === airport.icao && pairs.length > 0) {
                // remove the placeholder leg, to be replaced below with SID Leg
                fms.legs.splice(0, 1);
            }

            for (var i = 0; i < waypointsForSid.length; i++) {
                var waypointToAdd = waypointsForSid[i].generateFmsWaypoint(airport);

                this.addWaypointToLeg(waypointToAdd);
            }

            if (!this.waypoints[0].speed) {
                this.waypoints[0].speed = fms.my_aircraft.model.speed.cruise;
            }
        }

        /**
         * @for Leg
         * @method _generateWaypointsForStar
         * @param data {object}
         * @param fms {AircraftFlightManagementSystem}
         * @private
         */

    }, {
        key: '_generateWaypointsForStar',
        value: function _generateWaypointsForStar(data, fms) {
            if (!fms) {
                log('Attempted to generate waypoints for STAR, but cannot because fms ref not passed!', _logLevel.LOG.WARNING);

                return;
            }

            this._resetWaypoints();

            var rwy = fms.my_aircraft.rwy_arr;
            var airport = window.airportController.airport_get(this.route.exit);
            var waypointsForStar = airport.findWaypointModelsForStar(this.route.procedure, this.route.entry, rwy);

            for (var i = 0; i < waypointsForStar.length; i++) {
                var waypointToAdd = waypointsForStar[i].generateFmsWaypoint(airport);

                this.addWaypointToLeg(waypointToAdd);
            }

            if (!this.waypoints[0].speed) {
                this.waypoints[0].speed = fms.my_aircraft.model.speed.cruise;
            }
        }

        // NOT IN USE

    }, {
        key: '_generateWaypointsForIap',
        value: function _generateWaypointsForIap(data, airport) {
            return;
        }

        // NOT IN USE
        /**
         * @for Leg
         * @method _generateWaypointsForAirway
         * @param data {object}
         * @param fms {AircraftFlightManagementSystem}
         * @private
         */

    }, {
        key: '_generateWaypointsForAirway',
        value: function _generateWaypointsForAirway(data, airport) {
            var _this = this;

            var start = this.route.split('.')[0];
            var airway = this.route.split('.')[1];
            var end = this.route.split('.')[2];
            // Verify airway is valid
            var apt = window.airportController.airport_get();

            if (!(0, _has3.default)(apt, 'airways') || !(0, _has3.default)(apt.airways, 'airway')) {
                log('Airway ' + airway + ' not defined at ' + apt.icao, _logLevel.LOG.WARNING);
                return;
            }

            // Verify start/end points are along airway
            var awy = apt.airways[airway];
            if (!(awy.indexOf(start) !== -1 && awy.indexOf(end) !== -1)) {
                log('Unable to follow ' + airway + ' from ' + start + ' to ' + end, _logLevel.LOG.WARNING);
                return;
            }

            // TODO: abstract this logic
            // Build list of fixes, depending on direction traveling along airway
            var fixes = [];
            var readFwd = awy.indexOf(end) > awy.indexOf(start);

            if (readFwd) {
                for (var f = awy.indexOf(start); f <= awy.indexOf(end); f++) {
                    fixes.push(awy[f]);
                }
            } else {
                for (var _f = awy.indexOf(start); _f >= awy.indexOf(end); _f--) {
                    fixes.push(awy[_f]);
                }
            }

            this._resetWaypoints();

            (0, _forEach3.default)(fixes, function (fix) {
                var waypointToAdd = new _Waypoint2.default({ fix: fix }, airport);

                _this.addWaypointToLeg(waypointToAdd);
            });
        }

        /**
         * @for Leg
         * @method _generateWaypointForFix
         * @param airport {AirportInstanceModel}
         * @private
         */

    }, {
        key: '_generateWaypointForFix',
        value: function _generateWaypointForFix(airport) {
            this._resetWaypoints();

            var waypointToAdd = new _Waypoint2.default({ fix: this.route }, airport);

            this.addWaypointToLeg(waypointToAdd);
        }

        /**
         * @for Leg
         * @method _generateManualWaypoint
         * @param airport {AirportInstanceModel}
         * @private
         */

    }, {
        key: '_generateManualWaypoint',
        value: function _generateManualWaypoint(airport) {
            var waypointToAdd = new _Waypoint2.default({ route: this.route }, airport);

            this.addWaypointToLeg(waypointToAdd);
        }

        /**
         * @for Leg
         * @method _generateEmptyWaypoint
         * @param airport {AirportInstanceModel}
         * @private
         */

    }, {
        key: '_generateEmptyWaypoint',
        value: function _generateEmptyWaypoint(airport) {
            var waypointToAdd = new _Waypoint2.default({ route: '' }, airport);

            this.addWaypointToLeg(waypointToAdd);
        }

        /**
         * Reset the waypoint property to an empty array.
         *
         * Provides a single method that encapsulates common functionality that
         * can be used throughout the class.
         *
         * @for Leg
         * @method _resetWaypoints
         * @private
         */

    }, {
        key: '_resetWaypoints',
        value: function _resetWaypoints() {
            this.waypoints = [];
        }
    }]);

    return Leg;
}();

exports.default = Leg;

},{"../../airport/Route/RouteModel":548,"../../constants/aircraftConstants":570,"../../constants/logLevel":574,"./Waypoint":530,"lodash/forEach":468,"lodash/get":469,"lodash/has":470,"lodash/map":496}],530:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _head2 = require('lodash/head');

var _head3 = _interopRequireDefault(_head2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _FixCollection = require('../../airport/Fix/FixCollection');

var _FixCollection2 = _interopRequireDefault(_FixCollection);

var _aircraftConstants = require('../../constants/aircraftConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Symbol denoting a greater than restriction
 *
 * @property ABOVE_SYMBOL
 * @type {string}
 * @final
 */
var ABOVE_SYMBOL = '+';

/**
 * Symbol denoting a less than restriction
 *
 * @property ABOVE_SYMBOL
 * @type {string}
 * @final
 */
var BELOW_SYMBOL = '-';

// TODO: there should be a helper function for this
/**
 * Number to used to cnovert a FL altitude to an altitude in thousands
 *
 * @property ABOVE_SYMBOL
 * @type {string}
 * @final
 */
var FL_TO_THOUSANDS_MULTIPLIER = 100;

/**
 * Enemuration for an invalid index number.
 *
 * @property INVALID_INDEX
 * @type {number}
 * @final
 */
var INVALID_INDEX = -1;

/**
 * Enumeration for the radix value of `parseInt`
 *
 * @proeprty DECIMAL_RADIX
 * @type {number}
 * @final
 */
var DECIMAL_RADIX = 10;

/**
  * Build a waypoint object
  *
  * Note that .prependLeg() or .appendLeg() or .insertLeg()
  * should be called in order to add waypoints to the fms, based on which
  * you want. This function serves only to build the waypoint object; it is
  * placed by one of the other three functions.
  *
  * @class Waypoint
  */

var Waypoint = function () {
    /**
     * Initialize Waypoint with empty values, then call the parser
     *
     * @for Waypoint
     * @constructor
     */
    function Waypoint() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var airport = arguments[1];

        _classCallCheck(this, Waypoint);

        this.altitude = null;
        this.fix = null;
        this.navmode = null;
        this.heading = null;
        this.turn = null;
        this.location = null;
        this.expedite = false;
        this.speed = null;

        this.hold = {
            dirTurns: null,
            fixName: null,
            fixPos: null,
            inboundHd: null,
            legLength: null,
            timer: 0
        };

        this.fixRestrictions = {
            alt: null,
            spd: null
        };

        this.route = '';

        this.parse(data, airport);
    }

    /**
     * Parse input data and apply to this waypoint
     *
     * @for Waypoint
     * @method parse
     * @param data {object}
     */


    _createClass(Waypoint, [{
        key: 'parse',
        value: function parse(data, airport) {
            // TODO: is this used?
            this.route = (0, _get3.default)(data, 'route', this.route);
            this.altitude = (0, _get3.default)(data, 'altitude', this.altitude);
            this.navmode = (0, _get3.default)(data, 'navmode', this.navmode);
            this.heading = (0, _get3.default)(data, 'heading', this.heading);
            this.turn = (0, _get3.default)(data, 'turn', this.turn);
            this.location = (0, _get3.default)(data, 'location', this.location);
            this.expedite = (0, _get3.default)(data, 'expedite', this.expedite);
            this.speed = (0, _get3.default)(data, 'speed', this.speed);
            this.hold = (0, _get3.default)(data, 'hold', this.hold);

            // Populate Waypoint with data
            if (data.fix) {
                this.navmode = _aircraftConstants.WAYPOINT_NAV_MODE.FIX;
                this.fix = data.fix;
                this.location = _FixCollection2.default.getFixPositionCoordinates(data.fix);
            }

            this.extractFixRestrictions(data);
            this.setInitialNavMode(airport);
        }

        /**
         * @for Waypoint
         * @method extractFixRestrictions
         * @param fixRestrictions {object}
         */

    }, {
        key: 'extractFixRestrictions',
        value: function extractFixRestrictions(_ref) {
            var fixRestrictions = _ref.fixRestrictions;

            if ((0, _isNil3.default)(fixRestrictions)) {
                return;
            }

            this.fixRestrictions = fixRestrictions;
        }

        /**
         * If there isn't a navmode set, set one here
         *
         * For aircraft that don't yet have proper guidance (eg: SID/STAR, or departing aircraft)
         *
         * @for Waypoint
         * @method setInitialNavMode
         */

    }, {
        key: 'setInitialNavMode',
        value: function setInitialNavMode(airport) {
            if (this.navmode) {
                return;
            }

            this.navmode = _aircraftConstants.WAYPOINT_NAV_MODE.HEADING;
            var firstRouteSegment = (0, _head3.default)(this.route.split('.'));

            if (firstRouteSegment === airport.icao && this.heading === null) {
                // aim departure along runway heading
                var _airport$getRunway = airport.getRunway(airport.runway),
                    angle = _airport$getRunway.angle;

                this.heading = angle;
            } else if (firstRouteSegment === 'UNASSIGNED' && this.heading === null) {
                // FIXME: radial is not defined or set anywhere in this class. this block DOES get hit for
                // every arriving aircraft

                // aim arrival @ middle of airspace
                this.heading = this.radial + Math.PI;
            }
        }

        // TODO: rename centerCeiling and make this method more flexible
        // TODO: use a default constant for cruiseAltitude
        /**
         * @for Waypoint
         * @method setAltitude
         * @param centerCeiling {number}  ceiling of the airspace in feet
         * @param cruiseAltitude {number} cruiseAltitude of the current aircraft
         */

    }, {
        key: 'setAltitude',
        value: function setAltitude() {
            var centerCeiling = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var cruiseAltitude = arguments[1];
            var altitudeRestriction = this.fixRestrictions.alt;


            if (!altitudeRestriction) {
                this.altitude = !(0, _isNil3.default)(centerCeiling) ? Math.min(centerCeiling, cruiseAltitude) : cruiseAltitude;

                return;
            }

            // TODO: there has to be an easier way to do this logic.
            if (altitudeRestriction.indexOf(ABOVE_SYMBOL) !== INVALID_INDEX) {
                // at-or-above altitudeRestriction restriction
                var minAlt = parseInt(altitudeRestriction.replace(ABOVE_SYMBOL, ''), DECIMAL_RADIX);
                var minimumAltitudeWithoutSymbol = minAlt * FL_TO_THOUSANDS_MULTIPLIER;

                // not a fan of this ternary, but I don't think there is a better way to do it
                this.altitude = minimumAltitudeWithoutSymbol > cruiseAltitude ? minimumAltitudeWithoutSymbol : cruiseAltitude;
            } else if (altitudeRestriction.indexOf(BELOW_SYMBOL) !== INVALID_INDEX) {
                var maxAlt = parseInt(altitudeRestriction.replace(BELOW_SYMBOL, ''), DECIMAL_RADIX);
                var maximumAltitudeWithoutSymbol = maxAlt * FL_TO_THOUSANDS_MULTIPLIER;

                // climb as high as restrictions permit
                this.altitude = Math.min(maximumAltitudeWithoutSymbol, cruiseAltitude);
            } else {
                // cross AT this altitudeRestriction
                this.altitude = parseInt(altitudeRestriction, DECIMAL_RADIX) * FL_TO_THOUSANDS_MULTIPLIER;
            }
        }

        /**
         * @for Waypoint
         * @method setSpeed
         * @param cruiseSpeed {number}  cruiseSpeed of the current aircraft
         */

    }, {
        key: 'setSpeed',
        value: function setSpeed(cruiseSpeed) {
            var speedRestriction = this.fixRestrictions.spd;


            if (!speedRestriction) {
                this.speed = cruiseSpeed;

                return;
            }

            // TODO: there has to be an easier way to do this logic.
            if (speedRestriction.indexOf(ABOVE_SYMBOL) !== INVALID_INDEX) {
                // at-or-above speed restriction
                var minSpd = parseInt(speedRestriction.replace(ABOVE_SYMBOL, ''), DECIMAL_RADIX);

                this.speed = minSpd > cruiseSpeed ? minSpd : cruiseSpeed;
            } else if (speedRestriction.indexOf(BELOW_SYMBOL) !== INVALID_INDEX) {
                var maxSpd = parseInt(speedRestriction.replace(BELOW_SYMBOL, ''), DECIMAL_RADIX);

                // go as fast as restrictions permit
                this.speed = Math.min(maxSpd, cruiseSpeed);
            } else {
                // cross AT this speed
                this.speed = parseInt(speedRestriction, DECIMAL_RADIX);
            }
        }
    }]);

    return Waypoint;
}();

exports.default = Waypoint;

},{"../../airport/Fix/FixCollection":546,"../../constants/aircraftConstants":570,"lodash/get":469,"lodash/head":472,"lodash/isNil":485}],531:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _AirlineModel = require('./AirlineModel');

var _AirlineModel2 = _interopRequireDefault(_AirlineModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var airline = {};

/**
 * @class AirlineController
 */

var AirlineController = function () {
    /**
     * @constructor
     */
    function AirlineController() {
        _classCallCheck(this, AirlineController);

        this.airline = airline;
        this.airline.airlines = {};
        prop.airline = airline;
    }

    /**
     * @for AirlineController
     * @method airline_get
     * @param icao {string}
     * return {AirlineModel|null}
     */


    _createClass(AirlineController, [{
        key: 'airline_get',
        value: function airline_get(icao) {
            icao = icao.toLowerCase();

            if (!(0, _has3.default)(this.airline.airlines, icao)) {
                this.addAirline(icao);
            }

            return this.airline.airlines[icao];
        }

        /**
         * @for airlineController
         * @method addAirline
         * @param icao {string}
         */

    }, {
        key: 'addAirline',
        value: function addAirline(icao) {
            var airlineToAdd = new _AirlineModel2.default(icao, {
                url: 'assets/airlines/' + icao + '.json'
            });

            this.airline.airlines[icao] = airlineToAdd;
        }
    }]);

    return AirlineController;
}();

exports.default = AirlineController;

},{"./AirlineModel":532,"lodash/has":470}],532:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _generalUtilities = require('../utilities/generalUtilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An aircrcraft operating agency
 *
 * @class AirlineModel
 */
var AirlineModel = function () {
    /**
     * Create new airline
     *
     * @constructor
     * @for AirlineModel
     * @param icao {string}
     * @param options {object}
     */
    function AirlineModel(icao, options) {
        _classCallCheck(this, AirlineModel);

        // ICAO airline designation
        this.icao = icao;
        // Agency name
        this.name = (0, _get3.default)(options, 'name', 'Default airline');
        // Radio callsign
        this.callsign = 'Default';
        // Parameters for flight number generation
        this.flightNumberGeneration = {
            // How many characters in the flight number
            length: 3,
            // Whether to use alphabetical characters
            alpha: false
        };

        // Named weighted sets of aircraft
        this.fleets = {
            default: []
        };

        this.loading = true;
        this.loaded = false;
        this.priorityLoad = false;
        this._pendingAircraft = [];

        this.parse(options);

        if (options.url) {
            this.load(options.url);
        }
    }

    /**
     * Initialize object from data
     *
     * This method will be called twice at minimum; once on instantiation and again once
     * `onLoadSuccess`. Most of the properties below will only be available `onLoadSuccess`
     *
     * @for AirlineModel
     * @method parse
     * @param data {object}
     */


    _createClass(AirlineModel, [{
        key: 'parse',
        value: function parse(data) {
            this.icao = (0, _get3.default)(data, 'icao', this.icao);

            if (data.callsign) {
                this.callsign = data.callsign.name;

                if (data.callsign.length) {
                    this.flightNumberGeneration.length = data.callsign.length;
                }

                this.flightNumberGeneration.alpha = (0, _has3.default)(data, 'callsign.alpha');
            }

            if (data.fleets) {
                this.fleets = data.fleets;
            } else if (data.aircraft) {
                this.fleets.default = data.aircraft;
            }

            (0, _forEach3.default)(this.fleets, function (fleet) {
                (0, _forEach3.default)(fleet, function (aircraftInFleet) {
                    var NAME_INDEX = 0;
                    aircraftInFleet[NAME_INDEX] = aircraftInFleet[NAME_INDEX].toLowerCase();
                });
            });
        }

        /**
         * Load the data for this airline
         *
         * @for AirlineModel
         * @method load
         * @param url {string}
         */

    }, {
        key: 'load',
        value: function load(url) {
            var _this = this;

            this._url = url;

            if (this.loaded) {
                return;
            }

            zlsa.atc.loadAsset({
                url: url,
                immediate: this.priorityLoad
            }).done(function (response) {
                return _this.onLoadSuccess(response);
            }).fail(function () {
                return _this.onLoadError.apply(_this, arguments);
            });
        }

        /**
         * @for AirlineModel
         * @method onLoadSuccess
         * @param response {object}
         */

    }, {
        key: 'onLoadSuccess',
        value: function onLoadSuccess(response) {
            this.parse(response);

            this.loading = false;
            this.loaded = true;

            this.validateFleets();
            this._generatePendingAircraft();
        }

        /**
         * @for AirlineModel
         * @method onLoadError
         * @param textStatus {string}
         */

    }, {
        key: 'onLoadError',
        value: function onLoadError(_ref) {
            var textStatus = _ref.textStatus;

            this.loading = false;
            this._pendingAircraft = [];

            console.error('Unable to load airline/' + this.icao + ': ' + textStatus);
        }

        /**
         * Return a random ICAO aircraft designator from the given fleet
         *
         * If no fleet is specified the default fleet is used
         *
         * @for AirlineModel
         * @method chooseAircraft
         * @param fleet
         * @return
         */

    }, {
        key: 'chooseAircraft',
        value: function chooseAircraft(fleet) {
            if (!fleet) {
                fleet = 'default';
            }

            // TODO: why is this a try/catch?
            // TODO: this try/catch block could be improved. its hard to tell what his block is actually doing.
            try {
                return (0, _generalUtilities.choose_weight)(this.fleets[fleet.toLowerCase()]);
            } catch (error) {
                console.log('Unable to find fleet ' + fleet + ' for airline ' + this.icao);

                throw error;
            }
        }

        /**
         * Create an aircraft
         *
         * @for AirlineModel
         * @method generateAircraft
         * @param options {object}
         * @return
         */

    }, {
        key: 'generateAircraft',
        value: function generateAircraft(options) {
            if (!this.loaded) {
                if (this.loading) {
                    this._pendingAircraft.push(options);

                    if (!this.priorityLoad) {
                        zlsa.atc.loadAsset({
                            url: this._url,
                            immediate: true
                        });

                        this.priorityLoad = true;
                    }

                    return true;
                }

                console.warn('Unable to spawn aircraft for airline/ ' + this.icao + ' as loading failed');

                return false;
            }

            return this._generateAircraft(options);
        }

        // TODO: the logic here can be simplified.
        /**
         * Create a flight number/identifier
         *
         * @for AirlineModel
         * @method generateFlightNumber
         * @return flightNumber {string}
         */

    }, {
        key: 'generateFlightNumber',
        value: function generateFlightNumber() {
            var flightNumber = '';
            var list = '0123456789';

            // Start with a number other than zero
            flightNumber += (0, _generalUtilities.choose)(list.substr(1));

            if (this.flightNumberGeneration.alpha) {
                // TODO: why `this.flightNumberGeneration.length - 3`?  enumerate the magic number.
                for (var i = 0; i < this.flightNumberGeneration.length - 3; i++) {
                    flightNumber += (0, _generalUtilities.choose)(list);
                }

                list = 'abcdefghijklmnopqrstuvwxyz';

                for (var _i = 0; _i < 2; _i++) {
                    flightNumber += (0, _generalUtilities.choose)(list);
                }
            } else {
                for (var _i2 = 1; _i2 < this.flightNumberGeneration.length; _i2++) {
                    flightNumber += (0, _generalUtilities.choose)(list);
                }
            }

            // if this flightNumber already exists, repeat the process of generating a new flightNumber
            if (window.aircraftController.isCallsignInList(flightNumber)) {
                return this.generateFlightNumber();
            }

            return flightNumber;
        }

        /**
         * Checks all fleets for valid aircraft identifiers and log errors
         *
         * @for AirlineModel
         * @method validateFleets
         */

    }, {
        key: 'validateFleets',
        value: function validateFleets() {
            var _this2 = this;

            (0, _forEach3.default)(this.fleets, function (fleet) {
                (0, _forEach3.default)(fleet, function (fleetAircraft) {
                    var NAME_INDEX = 0;
                    // Preload the aircraft model
                    window.aircraftController.aircraft_model_get(fleetAircraft[NAME_INDEX]);

                    if (typeof fleetAircraft[1] !== 'number') {
                        console.warn('Airline ' + _this2.icao.toUpperCase() + ' uses non numeric weight for aircraft ' + fleetAircraft[NAME_INDEX] + ', expect errors');
                    }
                });
            });
        }

        /**
         * Generate aircraft which were queued while the model loaded
         *
         * @for AirlineModel
         * @method _generatePendingAircraft
         * @private
         */

    }, {
        key: '_generatePendingAircraft',
        value: function _generatePendingAircraft() {
            var _this3 = this;

            (0, _forEach3.default)(this._pendingAircraft, function (aircraftOptions) {
                _this3._generateAircraft(aircraftOptions);
            });

            this._pendingAircraft = null;
        }

        /**
         * @for AirlineModel
         * @method _generateAircraft
         * @param options {object}
         * @return {function}
         */

    }, {
        key: '_generateAircraft',
        value: function _generateAircraft(options) {
            if (!options.callsign) {
                options.callsign = this.generateFlightNumber();

                window.aircraftController.addCallsignToList(options.callsign);
            }

            if (!options.icao) {
                options.icao = this.chooseAircraft(options.fleet);
            }

            var model = window.aircraftController.aircraft_model_get(options.icao.toLowerCase());

            return model.generateAircraft(options);
        }
    }]);

    return AirlineModel;
}();

exports.default = AirlineModel;

},{"../utilities/generalUtilities":592,"lodash/forEach":468,"lodash/get":469,"lodash/has":470}],533:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomAirlineSelectionHelper = exports.airlineNameAndFleetHelper = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _generalUtilities = require('../utilities/generalUtilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: this file needs to be renamed to something more generalized.

/**
 * Symobl that possibly seperates and airline name from its fleet classification
 *
 * @property NAME_FLEET_SEPERATOR
 * @type {string}
 * @final
 */
var NAME_FLEET_SEPERATOR = '/';

/**
 * @property INVALID_INDEX
 * @type {number}
 * @final
 */
var INVALID_INDEX = -1;

/**
 * Enemeration of an index value of `0`
 *
 * @property FIRST_INDEX
 * @type {number}
 * @final
 */
var FIRST_INDEX = 0;

/**
 * Enemeration of an index value of `1`
 *
 * @property SECOND_INDEX
 * @type {number}
 * @final
 */
var SECOND_INDEX = 1;

/**
 * Accepts a selected airline name, which may or may not contain the `NAME_FLEET_SEPERATOR`, and
 * returns the `airlineNameAndFleet` object with updated property values.
 *
 * @function _extractNameAndFleetFromCurrentAirline
 * @param selectedAirline {string}
 * @param airlineNameAndFleet {object}
 * @return airlineNameAndFleet {object}
 */
var _extractNameAndFleetFromCurrentAirline = function _extractNameAndFleetFromCurrentAirline(selectedAirline, airlineNameAndFleet) {
    airlineNameAndFleet.name = selectedAirline;

    if (selectedAirline.indexOf(NAME_FLEET_SEPERATOR) > INVALID_INDEX) {
        var nameAndFleet = selectedAirline.split(NAME_FLEET_SEPERATOR);

        airlineNameAndFleet.name = nameAndFleet[FIRST_INDEX];
        airlineNameAndFleet.fleet = nameAndFleet[SECOND_INDEX];
    }

    return airlineNameAndFleet;
};

/**
 * Accepts an airline, as defined in an airport json file from the `departures` and `arrivals` sections,
 * and returns a consistent object containing an airline name and fleet classification.
 *
 * @method airlineNameAndFleetHelper
 * @param airline {string}
 * @return airlineNameAndFleet {object}
 */
var airlineNameAndFleetHelper = exports.airlineNameAndFleetHelper = function airlineNameAndFleetHelper(airline) {
    if (!(0, _isArray3.default)(airline)) {
        throw new TypeError('Invalid parameter. Expected airline to be an array but instead received ' + (typeof airline === 'undefined' ? 'undefined' : _typeof(airline)));
    }

    // this could be a model object, but the values used here are temporary so we just use a constant
    // and update its key values as needed.
    var airlineNameAndFleet = {
        name: '',
        fleet: ''
    };

    if (airline.length === 0) {
        return airlineNameAndFleet;
    }

    return _extractNameAndFleetFromCurrentAirline(airline[FIRST_INDEX], airlineNameAndFleet);
};

/**
 * Accepts a list of airlines, as defined in an airport json file from the `departures` and `arrivals` sections,
 * and returns a consistent object containing an airline name and fleet classification.
 *
 * @function randomAirlineSelectionHelper
 * @param airlineList {array}
 * @return {object}
 */
var randomAirlineSelectionHelper = exports.randomAirlineSelectionHelper = function randomAirlineSelectionHelper(airlineList) {
    // TODO: a large portion of this function is duplicated above, refactor
    if (!(0, _isArray3.default)(airlineList)) {
        throw new TypeError('Invalid parameter. Expected airlineList to be an array but instead received ' + (typeof airlineList === 'undefined' ? 'undefined' : _typeof(airlineList)));
    }

    // this could be a model object, but the values used here are temporary so we just use a constant
    // and update its key values as needed.
    var airlineNameAndFleet = {
        name: '',
        fleet: ''
    };

    if (airlineList.length === 0) {
        return airlineNameAndFleet;
    }

    var selectedAirline = (0, _generalUtilities.choose_weight)(airlineList);

    return _extractNameAndFleetFromCurrentAirline(selectedAirline, airlineNameAndFleet);
};

},{"../utilities/generalUtilities":592,"lodash/isArray":476}],534:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _lowerCase2 = require('lodash/lowerCase');

var _lowerCase3 = _interopRequireDefault(_lowerCase2);

var _AirlineController = require('../airline/AirlineController');

var _AirlineController2 = _interopRequireDefault(_AirlineController);

var _AircraftController = require('../aircraft/AircraftController');

var _AircraftController2 = _interopRequireDefault(_AircraftController);

var _AirportModel = require('./AirportModel');

var _AirportModel2 = _interopRequireDefault(_AirportModel);

var _storageKeys = require('../constants/storageKeys');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var airport = {};

/**
 * @property DEFAULT_AIRPORT_ICAO
 * @type {string}
 * @final
 */
var DEFAULT_AIRPORT_ICAO = 'ksfo';

/**
 * @class AirportController
 */

var AirportController = function () {
    /**
     * @constructor
     * @param airportLoadList {array<object>}  List of airports to load
     * @param updateRun {function}
     */
    function AirportController(airportLoadList, updateRun) {
        _classCallCheck(this, AirportController);

        this.updateRun = updateRun;
        this.airport = airport;
        this.airport.airports = {};
        this.airport.current = null;
        this.airlineController = null;
        this.aircraftController = null;
        this._airportListToLoad = airportLoadList;
    }

    /**
     * Lifecycle method. Should run only once on App initialiazation
     *
     * @for AirportController
     * @method init_pre
     */


    _createClass(AirportController, [{
        key: 'init_pre',
        value: function init_pre() {
            prop.airport = airport;

            this.airlineController = new _AirlineController2.default();
            this.aircraftController = new _AircraftController2.default();

            window.airlineController = this.airlineController;
            window.aircraftController = this.aircraftController;
        }

        /**
         * Lifecycle method. Should run only once on App initialiazation
         *
         * Load each airport in the `airportLoadList`
         *
         * @for AirportController
         * @method init
         */

    }, {
        key: 'init',
        value: function init() {
            for (var i = 0; i < this._airportListToLoad.length; i++) {
                var _airport = this._airportListToLoad[i];

                this.airport_load(_airport);
            }
        }

        /**
         * Lifecycle method called from `App`.
         *
         * This acts as a fascade for the `aircraftController.aircraft_update` method,
         * where aircraft data is recalculated before re-rendering
         *
         * @method recalculate
         */

    }, {
        key: 'recalculate',
        value: function recalculate() {
            this.aircraftController.aircraft_update();
        }

        /**
         * Lifecycle method. Should run only once on App initialiazation
         *
         * @for AirportController
         * @method ready
         */

    }, {
        key: 'ready',
        value: function ready() {
            var airportName = DEFAULT_AIRPORT_ICAO;

            if ((0, _has3.default)(localStorage, _storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT) || (0, _has3.default)(this.airport.airports, (0, _lowerCase3.default)(localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT]))) {
                airportName = (0, _lowerCase3.default)(localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT]);
            }

            this.airport_set(airportName);
        }

        /**
         * @function airport_load
         * @param icao {string}
         * @param level {string}
         * @param name {string}
         * @return airport {AirtportInstance}
         */

    }, {
        key: 'airport_load',
        value: function airport_load(_ref) {
            var icao = _ref.icao,
                level = _ref.level,
                name = _ref.name;

            icao = icao.toLowerCase();

            if (this.hasAirport()) {
                console.log(icao + ': already loaded');

                return null;
            }

            // create a new Airport with a reference to this.updateRun()
            var airport = new _AirportModel2.default({
                icao: icao,
                level: level,
                name: name
            }, this.updateRun);

            this.airport_add(airport);

            return airport;
        }

        /**
         * @function airport_add
         * @param airport
         */

    }, {
        key: 'airport_add',
        value: function airport_add(airport) {
            this.airport.airports[airport.icao] = airport;
        }

        /**
         * @for AirportController
         * @method airport_set
         */

    }, {
        key: 'airport_set',
        value: function airport_set(icao) {
            if (this.hasStoredIcao(icao)) {
                icao = localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT];
            }

            icao = icao.toLowerCase();

            if (!this.airport.airports[icao]) {
                console.log(icao + ': no such airport');

                return;
            }

            if (this.airport.current) {
                this.airport.current.unset();
                this.aircraftController.aircraft_remove_all();
            }

            var nextAirportModel = this.airport.airports[icao];
            nextAirportModel.set();
        }
        /**
         * @function airport_get
         * @param icao {string}
         * @return
         */

    }, {
        key: 'airport_get',
        value: function airport_get(icao) {
            if (!icao) {
                return this.airport.current;
            }

            return this.airport.airports[icao.toLowerCase()];
        }

        /**
         * @method hasStoredIcao
         * @return {boolean}
         */

    }, {
        key: 'hasStoredIcao',
        value: function hasStoredIcao(icao) {
            return !icao && (0, _has3.default)(localStorage, _storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT);
        }

        /**
         * @method hasAirport
         * @return {boolean}
         */

    }, {
        key: 'hasAirport',
        value: function hasAirport(icao) {
            return (0, _has3.default)(this.airport.airports, icao);
        }

        /**
         * Remove an aircraft from the queue of any runway(s) at the AirportModel
         * @for AirportModel
         * @method removeAircraftFromAllRunwayQueues
         * @param  {aircraft} aircraft The aircraft to remove
         */

    }, {
        key: 'removeAircraftFromAllRunwayQueues',
        value: function removeAircraftFromAllRunwayQueues(aircraft) {
            var runwayPrimaryEndIndex = 0;
            var runwaySecondaryEndIndex = 1;
            var runways = this.airport_get().runways;
            for (var runwayPair = 0; runwayPair < runways.length; runwayPair++) {
                runways[runwayPair][runwayPrimaryEndIndex].removeQueue(aircraft, true);
                runways[runwayPair][runwaySecondaryEndIndex].removeQueue(aircraft, true);
            }
        }
    }]);

    return AirportController;
}();

exports.default = AirportController;

},{"../aircraft/AircraftController":524,"../airline/AirlineController":531,"../constants/storageKeys":576,"./AirportModel":535,"lodash/has":470,"lodash/lowerCase":495}],535:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-multi-spaces, func-names, camelcase, no-undef, max-len, object-shorthand */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _head2 = require('lodash/head');

var _head3 = _interopRequireDefault(_head2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _AirspaceModel = require('./AirspaceModel');

var _AirspaceModel2 = _interopRequireDefault(_AirspaceModel);

var _PositionModel = require('../base/PositionModel');

var _PositionModel2 = _interopRequireDefault(_PositionModel);

var _RunwayModel = require('./RunwayModel');

var _RunwayModel2 = _interopRequireDefault(_RunwayModel);

var _FixCollection = require('./Fix/FixCollection');

var _FixCollection2 = _interopRequireDefault(_FixCollection);

var _StandardRouteCollection = require('./StandardRoute/StandardRouteCollection');

var _StandardRouteCollection2 = _interopRequireDefault(_StandardRouteCollection);

var _arrivalFactory = require('./Arrival/arrivalFactory');

var _departureFactory = require('./Departure/departureFactory');

var _unitConverters = require('../utilities/unitConverters');

var _core = require('../math/core');

var _circle = require('../math/circle');

var _flightMath = require('../math/flightMath');

var _vector = require('../math/vector');

var _logLevel = require('../constants/logLevel');

var _selectors = require('../constants/selectors');

var _storageKeys = require('../constants/storageKeys');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// TODO: This function should really live in a different file and have tests.
// what does ra stand for? runway angle? what about n? need better names here.
/**
 * @function ra
 * @param n {numer}
 * @return {number}
 */
var ra = function ra(n) {
    var deviation = (0, _unitConverters.degreesToRadians)(10);

    return n + (0, _core.extrapolate_range_clamp)(0, Math.random(), 1, -deviation, deviation);
};

var DEFAULT_CTR_RADIUS_NM = 80;
var DEFAULT_CTR_CEILING_FT = 10000;
var DEFAULT_INITIAL_ALTITUDE_FT = 5000;
var DEAFULT_RR_RADIUS_NM = 5;

/**
 *
 *
 * @class AirportModel
 */

var AirportModel = function () {
    /**
     * @constructor
     * @param options {object}
     * @param updateRun {function}
     */
    function AirportModel() {
        var _this = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var updateRun = arguments[1];

        _classCallCheck(this, AirportModel);

        this.onLoadAirportSuccess = function (response) {
            _this.parse(response);

            if (_this.has_terrain) {
                return;
            }

            _this.loading = false;
            _this.loaded = true;
            _this.set();
        };

        this.onLoadAirportError = function (_ref) {
            var textStatus = _ref.textStatus;

            console.error('Unable to load airport/' + _this.icao + ': ' + textStatus);

            _this.loading = false;
            _this.airport.current.set();
        };

        this.updateRun = updateRun;
        // FIXME: All properties of this class should be instantiated here, even if they wont have values yet.
        // there is a lot of logic below that can be elimininated by simply instantiating values here.
        this.loaded = false;
        this.loading = false;
        this.name = null;
        this.icao = null;
        this.radio = null;
        this.level = null;
        this.position = null;
        this.runways = [];
        // TODO: rename to `runwayName`
        this.runway = null;
        // this property is kept for each airport to allow for re-hydration of the `FixCollection` on airport change
        this.fixes = {};
        this.sidCollection = null;
        this.starCollection = null;
        this.maps = {};
        this.airways = {};
        this.restricted_areas = [];
        this.metadata = {
            rwy: {}
        };
        // array of areas under this sector's control. If null, draws circle with diameter of 'ctr_radius'
        this.airspace = null;
        // area outlining the outermost lateral airspace boundary. Comes from this.airspace[0]
        this.perimeter = null;
        this.timeout = {
            runway: null,
            departure: null
        };
        this.departures = [];
        this.arrivals = [];

        this.wind = {
            speed: 10,
            angle: 0
        };

        this.ctr_radius = 80;
        this.ctr_ceiling = 10000;
        this.initial_alt = 5000;
        this.rr_radius_nm = 0;
        this.rr_center = 0;

        this.parse(options);
    }

    /**
     * @property real_fixes
     * @return {array<FixModel>}
     */


    _createClass(AirportModel, [{
        key: 'parse',


        /**
         * @for AirportModel
         * @method parse
         * @param data {object}
         */
        value: function parse(data) {
            this.name = (0, _get3.default)(data, 'name', this.name);
            this.icao = (0, _get3.default)(data, 'icao', this.icao).toLowerCase();
            this.level = (0, _get3.default)(data, 'level', this.level);

            // exit early if `position` doesnt exist in data. on app initialiazation, we loop through every airport
            // in the `airportLoadList` and instantiate a model for each but wont have the full data set until the
            // airport json file is loaded.
            if (!data.position) {
                return;
            }

            this.setCurrentPosition(data.position, data.magnetic_north);

            this.radio = (0, _get3.default)(data, 'radio', this.radio);
            this.has_terrain = (0, _get3.default)(data, 'has_terrain', false);
            this.airways = (0, _get3.default)(data, 'airways', {});
            this.ctr_radius = (0, _get3.default)(data, 'ctr_radius', DEFAULT_CTR_RADIUS_NM);
            this.ctr_ceiling = (0, _get3.default)(data, 'ctr_ceiling', DEFAULT_CTR_CEILING_FT);
            this.initial_alt = (0, _get3.default)(data, 'initial_alt', DEFAULT_INITIAL_ALTITUDE_FT);
            this.rr_radius_nm = (0, _get3.default)(data, 'rr_radius_nm');
            this.rr_center = (0, _get3.default)(data, 'rr_center');

            this.fixes = (0, _get3.default)(data, 'fixes', {});
            _FixCollection2.default.addItems(this.fixes, this.position);

            this.sidCollection = new _StandardRouteCollection2.default(data.sids);
            this.starCollection = new _StandardRouteCollection2.default(data.stars);

            this.loadTerrain();
            this.buildAirportAirspace(data.airspace);
            this.buildAirportRunways(data.runways);
            this.buildAirportMaps(data.maps);
            this.buildRestrictedAreas(data.restricted);
            this.updateCurrentWind(data.wind);
            this.buildAirportDepartures(data.departures);
            this.buildArrivals(data.arrivals);
            this.buildRunwayMetaData();
        }

        /**
         * @for AirportModel
         * @method setCurrentPosition
         * @param currentPosition {array}
         */

    }, {
        key: 'setCurrentPosition',
        value: function setCurrentPosition(currentPosition, magneticNorth) {
            if (!currentPosition) {
                return;
            }

            this.position = new _PositionModel2.default(currentPosition, null, magneticNorth);
        }

        /**
         * create 3d polygonal airspace
         *
         * @for AirportModel
         * @method buildAirportAirspace
         * @param airspace
         */

    }, {
        key: 'buildAirportAirspace',
        value: function buildAirportAirspace(airspace) {
            var _this2 = this;

            if (!airspace) {
                return;
            }

            // for each area
            this.airspace = (0, _map3.default)(airspace, function (airspaceSection) {
                return new _AirspaceModel2.default(airspaceSection, _this2.position, _this2.magnetic_north);
            });

            // airspace perimeter (assumed to be first entry in data.airspace)
            this.perimeter = (0, _head3.default)(this.airspace);

            // change ctr_radius to point along perimeter that's farthest from rr_center
            // const pos = new PositionModel(this.perimeter.poly[0].position, this.position, this.magnetic_north);

            this.ctr_radius = Math.max.apply(Math, _toConsumableArray((0, _map3.default)(this.perimeter.poly, function (v) {
                return (0, _vector.vlen)((0, _vector.vsub)(v.position, _PositionModel2.default.calculatePosition(_this2.rr_center, _this2.position, _this2.magnetic_north)));
            })));
        }

        /**
         * @for AirportModel
         * @method buildAirportRunways
         * @param runways {array}
         */

    }, {
        key: 'buildAirportRunways',
        value: function buildAirportRunways(runways) {
            var _this3 = this;

            if (!runways) {
                return;
            }

            (0, _forEach3.default)(runways, function (runway) {
                runway.reference_position = _this3.position;
                runway.magnetic_north = _this3.magnetic_north;

                // TODO: what do the 0 and 1 mean? magic numbers should be enumerated

                _this3.runways.push([new _RunwayModel2.default(runway, 0, _this3), new _RunwayModel2.default(runway, 1, _this3)]);
            });
        }

        /**
         * @for AirportModel
         * @method buildAirportMaps
         * @param maps {object}
         */

    }, {
        key: 'buildAirportMaps',
        value: function buildAirportMaps(maps) {
            var _this4 = this;

            if (!maps) {
                return;
            }

            (0, _forEach3.default)(maps, function (map, key) {
                _this4.maps[key] = [];
                var lines = map;

                (0, _forEach3.default)(lines, function (line) {
                    var start = _PositionModel2.default.calculatePosition([line[0], line[1]], _this4.position, _this4.magnetic_north);
                    var end = _PositionModel2.default.calculatePosition([line[2], line[3]], _this4.position, _this4.magnetic_north);

                    _this4.maps[key].push([start[0], start[1], end[0], end[1]]);
                });
            });
        }

        /**
         * @for AirportModel
         * @method buildRestrictedAreas
         * @param restrictedAreas
         */

    }, {
        key: 'buildRestrictedAreas',
        value: function buildRestrictedAreas(restrictedAreas) {
            var _this5 = this;

            if (!restrictedAreas) {
                return;
            }

            (0, _forEach3.default)(restrictedAreas, function (area) {
                // TODO: what is `obj` going to be? need better name.
                var obj = {};
                if (area.name) {
                    obj.name = area.name;
                }

                obj.height = (0, _unitConverters.parseElevation)(area.height);
                obj.coordinates = _jquery2.default.map(area.coordinates, function (v) {
                    return [_PositionModel2.default.calculatePosition(v, _this5.position, _this5.magnetic_north)];
                });

                // TODO: is this right? max and min are getting set to the same value?
                // const coords = obj.coordinates;
                var coords_max = obj.coordinates[0];
                var coords_min = obj.coordinates[0];

                (0, _forEach3.default)(obj.coordinates, function (v) {
                    coords_max = [Math.max(v[0], coords_max[0]), Math.max(v[1], coords_max[1])];
                    coords_min = [Math.min(v[0], coords_min[0]), Math.min(v[1], coords_min[1])];
                });

                obj.center = (0, _vector.vscale)((0, _vector.vadd)(coords_max, coords_min), 0.5);

                _this5.restricted_areas.push(obj);
            });
        }

        /**
         * @for AirportModel
         * @method updateCurrentWind
         * @param currentWind
         */

    }, {
        key: 'updateCurrentWind',
        value: function updateCurrentWind(currentWind) {
            if (!currentWind) {
                return;
            }

            this.wind.speed = currentWind.speed;
            this.wind.angle = (0, _unitConverters.degreesToRadians)(currentWind.angle);
        }
    }, {
        key: 'buildAirportDepartures',
        value: function buildAirportDepartures(departures) {
            if (!departures) {
                return;
            }

            this.departures = (0, _departureFactory.departureFactory)(this, departures);
        }

        /**
         * @for AirportModel
         * @method buildArrivals
         * @param arrivals {array}
         */

    }, {
        key: 'buildArrivals',
        value: function buildArrivals(arrivals) {
            if (!arrivals) {
                return;
            }

            for (var i = 0; i < arrivals.length; i++) {
                if (!(0, _has3.default)(arrivals[i], 'type')) {
                    log(this.icao + ' arrival stream #' + i + ' not given type!', _logLevel.LOG.WARNING);
                } else {
                    this.arrivals.push((0, _arrivalFactory.arrivalFactory)(this, arrivals[i]));
                }
            }
        }

        /**
         * @for AirportModel
         * @method buildRunwayMetaData
         */

    }, {
        key: 'buildRunwayMetaData',
        value: function buildRunwayMetaData() {
            // TODO: translate these to _forEach()
            for (var rwy1 in this.runways) {
                for (var rwy1end in this.runways[rwy1]) {
                    // setup primary runway object
                    this.metadata.rwy[this.runways[rwy1][rwy1end].name] = {};

                    for (var rwy2 in this.runways) {
                        if (rwy1 === rwy2) {
                            continue;
                        }

                        for (var rwy2end in this.runways[rwy2]) {
                            // setup secondary runway subobject
                            var r1 = this.runways[rwy1][rwy1end];
                            var r2 = this.runways[rwy2][rwy2end];
                            var offset = (0, _flightMath.getOffset)(r1, r2.position, r1.angle);
                            this.metadata.rwy[r1.name][r2.name] = {};

                            // generate this runway pair's relationship data
                            this.metadata.rwy[r1.name][r2.name].lateral_dist = (0, _core.abs)(offset[0]);
                            this.metadata.rwy[r1.name][r2.name].straight_dist = (0, _core.abs)(offset[2]);
                            this.metadata.rwy[r1.name][r2.name].converging = (0, _vector.raysIntersect)(r1.position, r1.angle, r2.position, r2.angle);
                            this.metadata.rwy[r1.name][r2.name].parallel = (0, _core.abs)((0, _circle.angle_offset)(r1.angle, r2.angle)) < (0, _unitConverters.degreesToRadians)(10);
                        }
                    }
                }
            }
        }

        /**
         * @for AirportModel
         * @method set
         */

    }, {
        key: 'set',
        value: function set() {
            if (!this.loaded) {
                this.load();

                return;
            }

            localStorage[_storageKeys.STORAGE_KEY.ATC_LAST_AIRPORT] = this.icao;
            prop.airport.current = this;

            prop.canvas.draw_labels = true;
            (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_LABELS).toggle(!(0, _isEmpty3.default)(this.maps));
            (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_RESTRICTED_AREAS).toggle((this.restricted_areas || []).length > 0);
            (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_SIDS).toggle(!(0, _isNil3.default)(this.sidCollection));

            prop.canvas.dirty = true;
            (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TERRAIN).toggle(!(0, _isEmpty3.default)(this.terrain));

            window.gameController.game_reset_score_and_events();

            this.start = window.gameController.game_time();

            // when the parse method is run, this method also runs. however, when an airport is being re-loaded,
            // only this method runs. this doesnt belong here but needs to be here so the fixes get populated correctly.
            // FIXME: make FixCollection a instance class ainstead of a static class
            _FixCollection2.default.addItems(this.fixes, this.position);

            this.updateRunway();
            this.addAircraft();
            this.updateRun(true);
        }

        /**
         * @for AirportModel
         * @method unset
         */

    }, {
        key: 'unset',
        value: function unset() {
            for (var i = 0; i < this.arrivals.length; i++) {
                this.arrivals[i].stop();
            }

            this.departures.stop();

            if (this.timeout.runway) {
                window.gameController.game_clear_timeout(this.timeout.runway);
            }
        }

        /**
         * @for AirportModel
         * @method addAircraft
         */

    }, {
        key: 'addAircraft',
        value: function addAircraft() {
            if (this.departures) {
                this.departures.start();
            }

            if (this.arrivals) {
                for (var i = 0; i < this.arrivals.length; i++) {
                    this.arrivals[i].start();
                }
            }
        }

        /**
         * @for AirportModel
         * @method getWind
         * @return wind {number}
         */

    }, {
        key: 'getWind',
        value: function getWind() {
            // TODO: there are a lot of magic numbers here. What are they for and what do they mean? These should be enumerated.
            var wind = clone(this.wind);
            var s = 1;
            var angle_factor = (0, _core.sin)((s + window.gameController.game_time()) * 0.5) + (0, _core.sin)((s + window.gameController.game_time()) * 2);
            // TODO: why is this var getting reassigned to a magic number?
            s = 100;
            var speed_factor = (0, _core.sin)((s + window.gameController.game_time()) * 0.5) + (0, _core.sin)((s + window.gameController.game_time()) * 2);
            wind.angle += (0, _core.extrapolate_range_clamp)(-1, angle_factor, 1, (0, _unitConverters.degreesToRadians)(-4), (0, _unitConverters.degreesToRadians)(4));
            wind.speed *= (0, _core.extrapolate_range_clamp)(-1, speed_factor, 1, 0.9, 1.05);

            return wind;
        }

        /**
         * @for AirportModel
         * @method updateRunway
         */

    }, {
        key: 'updateRunway',
        value: function updateRunway() {
            var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            // TODO: this method contains some ambiguous names. need better names.
            var wind = this.getWind();
            var headwind = {};

            for (var i = 0; i < this.runways.length; i++) {
                var runway = this.runways[i];
                headwind[runway[0].name] = Math.cos(runway[0].angle - ra(wind.angle)) * wind.speed;
                headwind[runway[1].name] = Math.cos(runway[1].angle - ra(wind.angle)) * wind.speed;
            }

            var best_runway = '';
            var best_runway_headwind = -Infinity;
            for (var _runway in headwind) {
                if (headwind[_runway] > best_runway_headwind && this.getRunway(_runway).length > length) {
                    best_runway = _runway;
                    best_runway_headwind = headwind[_runway];
                }
            }

            this.runway = best_runway;
            this.timeout.runway = window.gameController.game_timeout(this.updateRunway, Math.random() * 30, this);
        }

        /**
         * @for AirportModel
         * @method selectRunway
         */

    }, {
        key: 'selectRunway',
        value: function selectRunway() {
            return this.runway;
        }
    }, {
        key: 'parseTerrain',
        value: function parseTerrain(data) {
            // TODO: reassignment of this to apt is not needed here. change apt to this.
            // terrain must be in geojson format
            var apt = this;
            apt.terrain = {};

            (0, _forEach3.default)(data.features, function (f) {
                // const f = data.features[i];
                // m => ft, rounded to 1K (but not divided)
                var ele = (0, _core.round)(f.properties.elevation / 0.3048, 1000);

                if (!apt.terrain[ele]) {
                    apt.terrain[ele] = [];
                }

                var multipoly = f.geometry.coordinates;
                // TODO: add enumeration
                if (f.geometry.type === 'LineString') {
                    multipoly = [[multipoly]];
                }

                // TODO: add enumeration
                if (f.geometry.type === 'Polygon') {
                    multipoly = [multipoly];
                }

                _jquery2.default.each(multipoly, function (i, poly) {
                    // multipoly contains several polys
                    // each poly has 1st outer ring and other rings are holes
                    apt.terrain[ele].push(_jquery2.default.map(poly, function (line_string) {
                        return [_jquery2.default.map(line_string, function (pt) {
                            pt.reverse(); // `PositionModel` requires [lat,lon] order
                            var pos = new _PositionModel2.default(pt, apt.position, apt.magnetic_north);

                            return [pos.position];
                        })];
                    }));
                });
            });
        }

        /**
         * @for AirportModel
         * @method loadTerrain
         */

    }, {
        key: 'loadTerrain',
        value: function loadTerrain() {
            var _this6 = this;

            if (!this.has_terrain) {
                return;
            }

            // TODO: there is a lot of binding here, use => functions and this probably wont be an issue.
            zlsa.atc.loadAsset({
                url: 'assets/airports/terrain/' + this.icao.toLowerCase() + '.geojson',
                immediate: true
            })
            // TODO: change to onSuccess and onError handler abstractions
            .done(function (data) {
                try {
                    log('Parsing terrain');
                    _this6.parseTerrain(data);
                } catch (e) {
                    log(e.message);
                }

                _this6.loading = false;
                _this6.loaded = true;
                _this6.set();
            }).fail(function (jqXHR, textStatus, errorThrown) {
                console.error('Unable to load airport/terrain/' + _this6.icao + ': ' + textStatus);

                _this6.loading = false;
                _this6.airport.current.set();
            });
        }

        /**
         * @for AirportModel
         * @method load
         */

    }, {
        key: 'load',
        value: function load() {
            var _this7 = this;

            if (this.loaded) {
                return;
            }

            this.updateRun(false);
            this.loading = true;

            zlsa.atc.loadAsset({
                url: 'assets/airports/' + this.icao.toLowerCase() + '.json',
                immediate: true
            }).done(function (response) {
                return _this7.onLoadAirportSuccess(response);
            }).fail(function () {
                return _this7.onLoadAirportError.apply(_this7, arguments);
            });
        }

        /**
         * @method onLoadAirportSuccess
         * @param response {object}
         */


        /**
         * @for AirportModel
         * @method onLoadAirportError
         * @param textStatus {string}
         */

    }, {
        key: 'getRestrictedAreas',


        /**
         * @for AirportModel
         * @method getRestrictedAreas
         * @return {array|null}
         */
        value: function getRestrictedAreas() {
            return (0, _get3.default)(this, 'restricted_areas', null);
        }

        /**
         * Get the position of a FixModel
         *
         * @for AirportModel
         * @method getFixPosition
         * @param fixName {string}
         * @return {array}
         */

    }, {
        key: 'getFixPosition',
        value: function getFixPosition(fixName) {
            // TODO: if possible, replace with FoxCollection.getFixPositionCoordinates
            var fixModel = _FixCollection2.default.findFixByName(fixName);

            return fixModel.position;
        }

        /**
         * @for AirportModel
         * @param id {string}
         * @param exit {string}
         * @param runway {string}
         * @return {array}
         */

    }, {
        key: 'getSID',
        value: function getSID(id, exit, runway) {
            return this.sidCollection.findFixesForSidByRunwayAndExit(id, exit, runway);
        }

        /**
         *
         * @for AirportModel
         * @method findWaypointModelsForSid
         * @param id {string}
         * @param entry {string}
         * @param runway {string}
         * @param isPreSpawn {boolean} flag used to determine if distances between waypoints should be calculated
         * @return {array<StandardWaypointModel>}
         */

    }, {
        key: 'findWaypointModelsForSid',
        value: function findWaypointModelsForSid(id, entry, runway) {
            var isPreSpawn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            return this.sidCollection.findFixModelsForRouteByEntryAndExit(id, entry, runway, isPreSpawn);
        }

        /**
         * @for AirportModel
         * @method getSIDExitPoint
         * @param icao {string}  Name of SID
         * @return {string}  Name of Exit fix in SID
         */

    }, {
        key: 'getSIDExitPoint',
        value: function getSIDExitPoint(icao) {
            return this.sidCollection.findRandomExitPointForSIDIcao(icao);
        }

        /**
         * Return an array of [Waypoint, fixRestrictions] for a given STAR
         *
         * Note: Passing a value for 'rwy' will help the fms distinguish between
         *       different branches of a STAR, when it splits into different paths
         *       for landing on different runways (eg 'HAWKZ4, landing south' vs
         *       'HAWKZ4, landing north'). Not strictly required, but not passing
         *       it will cause an incomplete route in many cases (depends on the
         *       design of the actual STAR in the airport's json file).
         *
         * @param {string} id - the identifier for the STAR (eg 'LENDY6')
         * @param {string} entry - the entryPoint from which to join the STAR
         * @param {string} rwy - (optional) the planned arrival runway
         * @return {array<string>}
         */

    }, {
        key: 'getSTAR',
        value: function getSTAR(id, entry, rwy) {
            return this.starCollection.findFixesForStarByEntryAndRunway(id, entry, rwy);
        }

        /**
         *
         * @for AirportModel
         * @method findWaypointModelsForStar
         * @param id {string}
         * @param entry {string}
         * @param runway {string}
         * @param isPreSpawn {boolean} flag used to determine if distances between waypoints should be calculated
         * @return {array<StandardWaypointModel>}
         */

    }, {
        key: 'findWaypointModelsForStar',
        value: function findWaypointModelsForStar(id, entry, runway) {
            var isPreSpawn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            return this.starCollection.findFixModelsForRouteByEntryAndExit(id, entry, runway, isPreSpawn);
        }

        /**
         *
         *
         */

    }, {
        key: 'getRunway',
        value: function getRunway(name) {
            if (!name) {
                return null;
            }

            name = name.toLowerCase();

            for (var i = 0; i < this.runways.length; i++) {
                if (this.runways[i][0].name.toLowerCase() === name) {
                    return this.runways[i][0];
                }
                if (this.runways[i][1].name.toLowerCase() === name) {
                    return this.runways[i][1];
                }
            }

            return null;
        }
    }, {
        key: 'real_fixes',
        get: function get() {
            return _FixCollection2.default.findRealFixes();
        }

        /**
         * @property elevation
         * @return {number}
         */

    }, {
        key: 'elevation',
        get: function get() {
            return this.position.elevation;
        }

        /**
         * @property magnetic_north
         * @return {number}
         */

    }, {
        key: 'magnetic_north',
        get: function get() {
            return this.position.magneticNorthInRadians;
        }
    }]);

    return AirportModel;
}();

exports.default = AirportModel;

},{"../base/PositionModel":560,"../constants/logLevel":574,"../constants/selectors":575,"../constants/storageKeys":576,"../math/circle":583,"../math/core":584,"../math/flightMath":586,"../math/vector":587,"../utilities/unitConverters":595,"./AirspaceModel":536,"./Arrival/arrivalFactory":541,"./Departure/departureFactory":545,"./Fix/FixCollection":546,"./RunwayModel":549,"./StandardRoute/StandardRouteCollection":552,"jquery":296,"lodash/forEach":468,"lodash/get":469,"lodash/has":470,"lodash/head":472,"lodash/isEmpty":480,"lodash/isNil":485,"lodash/map":496}],536:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _BaseModel2 = require('../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _PositionModel = require('../base/PositionModel');

var _PositionModel2 = _interopRequireDefault(_PositionModel);

var _unitConverters = require('../utilities/unitConverters');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An enclosed region defined by a series of Position objects and an altitude range
 *
 * @class AirspaceModel
 */
var AirspaceModel = function (_BaseModel) {
  _inherits(AirspaceModel, _BaseModel);

  /**
   * @for AirspaceModel
   * @constructor
   * @param airspace {object}
   * @param airportPosition {PositionModel}
   * @param magneticNorth {number}
   */
  function AirspaceModel(airspace, airportPosition, magneticNorth) {
    var _ret;

    _classCallCheck(this, AirspaceModel);

    var _this = _possibleConstructorReturn(this, (AirspaceModel.__proto__ || Object.getPrototypeOf(AirspaceModel)).call(this));

    if (!airspace || !airportPosition || !(0, _isNumber3.default)(magneticNorth)) {
      // eslint-disable-next-line max-len
      throw new TypeError('Invalid parameter, expected airspace, airportPosition and magneticNorth to be defined');
    }

    /**
     * List of lat/long coordinates that outline the shape of the area
     *
     * DO NOT repeat the origin to 'close' the shape, this happens programatically
     *
     * @property poly
     * @type {array}
     */
    _this.poly = [];

    /**
     * Altitude at bottom of area, in hundreds of feet
     *
     * @property floor
     * @type {number}
     */
    _this.floor = -1;

    /**
     * Altitude of top of area, in hundreds of feet
     *
     * @property ceiling
     * @type {number}
     */
    _this.ceiling = -1;

    /**
     * FAA airspace classification (A,B,C,D,E,G)
     *
     * @property airspace_class
     * @type {string}
     */
    _this.airspace_class = '';

    return _ret = _this._init(airspace, airportPosition, magneticNorth), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * Initialize the model
   *
   * @for AirspaceModel
   * @method _init
   * @param airspace {array}
   * @param airportPosition {PositionModel}
   * @param magneticNorth {number}
   * @private
   */


  _createClass(AirspaceModel, [{
    key: '_init',
    value: function _init(airspace, airportPosition, magneticNorth) {
      this.floor = (0, _unitConverters.convertToThousands)(airspace.floor);
      this.ceiling = (0, _unitConverters.convertToThousands)(airspace.ceiling);
      this.airspace_class = airspace.airspace_class;
      this.poly = this._buildPolyPositionModels(airspace.poly, airportPosition, magneticNorth);

      return this;
    }

    /**
     * @for AirspaceModel
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.poly = [];
      this.floor = -1;
      this.ceiling = -1;
      this.airspace_class = '';
    }

    /**
     * Create a PositionModel for each poly listed in `airspace.poly`.
     *
     * If the last entry is the same as the first, remove it because the path will be closed automatically.
     *
     * @for AirspaceModel
     * @method _buildPolyPositionModels
     * @param polyList {array}
     * @param airportPosition {PositionModel}
     * @param magneticNorth {number}
     * @return polyPositionModels {array}
     * @private
     */

  }, {
    key: '_buildPolyPositionModels',
    value: function _buildPolyPositionModels(polyList, airportPosition, magneticNorth) {
      var polyPositionModels = (0, _map3.default)(polyList, function (poly) {
        return new _PositionModel2.default(poly, airportPosition, magneticNorth);
      });

      var firstIndex = 0;
      var lastIndex = polyPositionModels.length - 1;

      if ((0, _isEqual3.default)(polyPositionModels[firstIndex].position, polyPositionModels[lastIndex].position)) {
        // shape shouldn't fully close; will draw with 'cc.closepath()' so we remove the last item
        polyPositionModels.pop();
      }

      return polyPositionModels;
    }
  }]);

  return AirspaceModel;
}(_BaseModel3.default);

exports.default = AirspaceModel;

},{"../base/BaseModel":556,"../base/PositionModel":560,"../utilities/unitConverters":595,"lodash/isEqual":481,"lodash/isNumber":486,"lodash/map":496}],537:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _FixCollection = require('../Fix/FixCollection');

var _FixCollection2 = _interopRequireDefault(_FixCollection);

var _RouteModel = require('../Route/RouteModel');

var _RouteModel2 = _interopRequireDefault(_RouteModel);

var _PositionModel = require('../../base/PositionModel');

var _PositionModel2 = _interopRequireDefault(_PositionModel);

var _randomAirlineSelectionHelper = require('../../airline/randomAirlineSelectionHelper');

var _unitConverters = require('../../utilities/unitConverters');

var _core = require('../../math/core');

var _flightMath = require('../../math/flightMath');

var _aircraftConstants = require('../../constants/aircraftConstants');

var _airportConstants = require('../../constants/airportConstants');

var _globalConstants = require('../../constants/globalConstants');

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @property INTERVAL_DELAY_IN_MS
 * @type {number}
 * @final
 */
var INTERVAL_DELAY_IN_MS = _globalConstants.TIME.ONE_HOUR_IN_SECONDS;

// TODO: this shouldn't live here. perhaps move to `FixCollection` as an exported function?
/**
 * Encapsulation of a `FixCollection` method.
 *
 * This allows for centralization of this logic, while avoiding the need for
 * another class method.
 *
 * @method getFixPostiion
 * @param fixName {string}
 * @return fix.position {array}
 */
var getFixPosition = function getFixPosition(fixName) {
    var fix = _FixCollection2.default.findFixByName(fixName);

    return fix.position;
};

/**
 * Generate arrivals at random, averaging the specified arrival rate
 *
 * @class ArrivalBase
 */

var ArrivalBase = function () {
    /**
     * @for ArrivalBase
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function ArrivalBase(airport, options) {
        _classCallCheck(this, ArrivalBase);

        // FIXME: this creates a circular reference and should be refactored
        /**
         * Airport that arrivals belong to
         *
         * @property airport
         * @type {AirportInstanceModel}
         * @default airport
         */
        this.airport = airport;

        /**
         * List of airlines with weight for each
         *
         * @property airlines
         * @type {array[]}
         * @default []
         */
        this.airlines = [];

        // TODO: this needs a better name. this is actually fixes for a route
        /**
         * Set of fixes to traverse (eg. for STARs) as defined in the airport json file.
         *
         * Spawn occurs at first fix listed.
         * This property gets sent to an `AirportInstanceModel` and becomes that aircraft's
         * waypoint list in the fms.
         *
         * @property fixes
         * @type {array}
         * @default []
         */
        this.fixes = [];

        /**
         * Text representation of a `StandardRoute`.
         *
         * `RouteModel` object provides methods for dealing with a route string.
         * Expects string to be in the shape of:
         * - `ORIGIN_FIXNAME.ROUTE_NAME.DESTINATION_FIXNAME`
         *
         * @property activeRouteModel
         * @type {RouteModel}
         * @default null
         */
        this.activeRouteModel = null;

        /**
         * Altitude in feet or min/max range of altitudes
         *
         * Altitude may be passed in as either an array of altitudes [min, max], or as a single number.
         *
         * @property altitude
         * @type {array}
         * @default [AIRPORT_CONSTANTS.DEFAULT_SPAWN_ALTITUDE_MIN, AIRPORT_CONSTANTS.DEFAULT_SPAWN_ALTITUDE_MAX]
         */
        this.altitude = [_airportConstants.AIRPORT_CONSTANTS.DEFAULT_SPAWN_ALTITUDE_MIN, _airportConstants.AIRPORT_CONSTANTS.DEFAULT_SPAWN_ALTITUDE_MAX];

        /**
         * Initial heading of a spawned aircraft
         *
         * @property heading
         * @type {number}
         * @default null
         */
        this.heading = null;

        /**
         * Bearing from airspace center to spawn point.
         *
         * Shouldn't be used with fixes
         *
         * @property radial
         * @type {number}
         * @default 0
         */
        this.radial = 0;

        /**
         * game time
         *
         * @property cycleStart
         * @type {number}
         * @default 0
         */
        this.cycleStart = 0;

        /**
         * Start at the beginning of the surge
         *
         * @property offset
         * @type {number}
         * @default 0
         */
        this.offset = 0;

        /**
         * 30 minute cycle
         *
         * @property period
         * @type {number}
         * @default 1800
         */
        this.period = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / 2;

        /**
         * Initial speed in knots of spawned aircraft.
         *
         * @property speed
         * @type {number}
         * @default AIRPORT_CONSTANTS.DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS
         */
        this.speed = _airportConstants.AIRPORT_CONSTANTS.DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS;

        /**
         * Arrival rate along this stream.
         *
         * Number represents aircraft per hour (acph)
         *
         * @property frequency
         * @type {number}
         * @default 0
         */
        this.frequency = 0;

        /**
         * @property timeout
         * @type {function}
         * @default null
         */
        this.timeout = null;

        this.parse(options);
    }

    /**
     * Initialize arrival stream
     *
     * @for ArrivalBase
     * @method parse
     * @param options {object}
     * @private
     */


    _createClass(ArrivalBase, [{
        key: 'parse',
        value: function parse(options) {
            this.airlines = (0, _get3.default)(options, 'airlines', this.airlines);
            this.altitude = (0, _get3.default)(options, 'altitude', this.altitude);
            this.frequency = (0, _get3.default)(options, 'frequency', this.frequency);
            this.speed = (0, _get3.default)(options, 'speed', this.speed);

            // Make corrections to data
            if (options.radial) {
                this.radial = (0, _unitConverters.degreesToRadians)(options.radial);
            }

            if (options.heading) {
                this.heading = (0, _unitConverters.degreesToRadians)(options.heading);
            }

            // altitude may be passed in as either an array of altitudes [min, max], or as a single number.
            // here we check for the single number and transform it into a [min, max] format.
            if (typeof this.altitude === 'number') {
                this.altitude = [this.altitude, this.altitude];
            }

            if (options.route) {
                this.activeRouteModel = new _RouteModel2.default(options.route);
            } else if (options.fixes) {
                // TODO: this may not be needed at all. we could just use `_get()` instead.
                // `this.fixes` eventually makes its way to the `AircraftInstanceModel.fms` via
                // `AircraftInstanceModel.setArrivalWaypoints()`. that method simply builds another object and
                // pulls each item from this array. creating an object here is doesn't appear to serve any real purpose.
                this.fixes = (0, _map3.default)(options.fixes, function (fix) {
                    return {
                        fix: fix
                    };
                });
            }

            this.preloadAirlines();
        }

        /**
         * Loop through each airline provided from an airport json and ensure it had been loaded.
         *
         * @for ArrivalBase
         * @method preloadAirlines
         */

    }, {
        key: 'preloadAirlines',
        value: function preloadAirlines() {
            // TODO: this really doesn't belong here and should be moved
            // Pre-load the airlines
            for (var i = 0; i < this.airlines.lenth; i++) {
                var airline = this.airlines[i];
                // reassigns `airline.name` to `airlineName` for readability

                var _airlineNameAndFleetH = (0, _randomAirlineSelectionHelper.airlineNameAndFleetHelper)(airline),
                    airlineName = _airlineNameAndFleetH.name;

                window.airlineController.airline_get(airlineName);
            }
        }

        /**
         * Backfill STAR routes with arrivals closer than the spawn point.
         *
         * Should be run only once on airport load.
         *
         * Aircraft spawn at the first point defined in the `arrivals` entry of the airport json file.
         * When that spawn point is very far from the airspace boundary, it obviously takes quite a
         * while for them to reach the airspace. This function spawns (all at once) arrivals along
         * the route, between the spawn point and the airspace boundary, in order to
         * ensure the player is not kept waiting for their first arrival aircraft.
         *
         * @for ArrivalBase
         * @method preSpawn
         */

    }, {
        key: 'preSpawn',
        value: function preSpawn() {
            // find last fix along STAR that is outside of airspace, ie: next fix is within airspace
            // distance between closest fix outside airspace and airspace border in nm
            var extra = 0;
            var totalDistance = 0;
            var isPreSpawn = true;
            var waypointModelList = this.airport.findWaypointModelsForStar(this.activeRouteModel.procedure, this.activeRouteModel.entry, this.airport.runway, isPreSpawn);

            for (var i = 0; i < waypointModelList.length; i++) {
                var waypoint = waypointModelList[i];
                var waypointPosition = waypoint.position;
                var previousWaypoint = waypoint;
                var previousPosition = waypoint.position;

                if (i > 0) {
                    previousWaypoint = waypointModelList[i - 1];
                    previousPosition = previousWaypoint.position;
                }

                if ((0, _flightMath.isWithinAirspace)(this.airport, waypointPosition) && i > 0) {
                    extra = (0, _unitConverters.nm)((0, _flightMath.calculateDistanceToBoundary)(this.airport, previousPosition));

                    continue;
                }

                totalDistance += waypoint.distanceFromPreviousWaypoint;
            }

            // FIXME: incluing this causes aircraft to spawn within airspace. something goofy is going on here.
            // totalDistance += extra;

            // distance between each arriving aircraft, in nm
            var entrailDistance = this.speed / this.frequency;
            var spawnOffsets = this.assembleSpawnOffsets(entrailDistance, totalDistance);
            var spawnPositions = this.calculateSpawnPositions(waypointModelList, spawnOffsets);

            this.createAircraftAtSpawnPositions(spawnPositions);
        }

        /**
         * @for ArrivalBase
         * @method assembleSpawnOffsets
         * @param entrailDistance {number}
         * @param totalDistance {number}
         * @return spawnOffsets {array}
         */

    }, {
        key: 'assembleSpawnOffsets',
        value: function assembleSpawnOffsets(entrailDistance, totalDistance) {
            var spawnOffsets = [];

            // distance between successive arrivals in nm
            for (var i = entrailDistance; i < totalDistance; i += entrailDistance) {
                spawnOffsets.push(i);
            }

            return spawnOffsets;
        }

        /**
         * @for ArrivalBase
         * @method calculateSpawnPositions
         * @param waypointModelList {array<StandardWaypointModel>}
         * @param spawnOffsets {array}
         * @return spawnPositions {array}
         */

    }, {
        key: 'calculateSpawnPositions',
        value: function calculateSpawnPositions(waypointModelList, spawnOffsets) {
            var spawnPositions = [];

            // for each new aircraft
            for (var i = 0; i < spawnOffsets.length; i++) {
                var spawnOffset = spawnOffsets[i];

                // for each fix ahead
                for (var j = 1; j < waypointModelList.length; j++) {
                    var waypoint = waypointModelList[j];

                    if (spawnOffset > waypoint.distanceFromPreviousWaypoint) {
                        // if point beyond next fix subtract distance from spawnOffset and continue
                        spawnOffset -= waypoint.distanceFromPreviousWaypoint;

                        continue;
                    } else {
                        // if point before next fix
                        var nextFix = waypoint;
                        var previousFix = waypointModelList[j - 1];
                        var heading = (0, _flightMath.bearingToPoint)(previousFix.gpsXY, nextFix.gpsXY);
                        var spawnPoint = (0, _flightMath.fixRadialDist)(previousFix.gps, heading, spawnOffset);
                        var spawnPosition = new _PositionModel2.default(spawnPoint, this.airport.position, this.airport.magnetic_north);

                        // TODO: this looks like it should be a model object
                        spawnPositions.push({
                            heading: heading,
                            pos: spawnPosition,
                            nextFix: nextFix.name
                        });

                        break;
                    }
                }
            }

            return spawnPositions;
        }

        /**
         * Given an array of `spawnPositions`, create new aircraft for each `spawnPosition`
         *
         * @for ArrivalBase
         * @method createAircraftAtSpawnPositions
         * @param spawnPositions {array}
         */

    }, {
        key: 'createAircraftAtSpawnPositions',
        value: function createAircraftAtSpawnPositions(spawnPositions) {
            // Spawn aircraft along the route, ahead of the standard spawn point
            for (var i = 0; i < spawnPositions.length; i++) {
                var _spawnPositions$i = spawnPositions[i],
                    heading = _spawnPositions$i.heading,
                    pos = _spawnPositions$i.pos,
                    nextFix = _spawnPositions$i.nextFix;
                var icao = this.airport.icao;

                var airline = (0, _randomAirlineSelectionHelper.randomAirlineSelectionHelper)(this.airlines);
                var aircraftToAdd = {
                    category: _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL,
                    destination: icao,
                    airline: airline.name,
                    fleet: airline.fleet,
                    // TODO: should eventually look up altitude restrictions and try to spawn in an appropriate range
                    //       this can be done with the `waypointModelList` and `StandardWaypointModel` objects,
                    //       in conjuntion with the `RouteModel`.
                    altitude: 10000,
                    // TODO: this could be a _get() instead of an || assignment
                    heading: heading || this.heading,
                    waypoints: this.fixes,
                    route: (0, _get3.default)(this, 'activeRouteModel.routeCode', ''),
                    position: pos.position,
                    speed: this.speed,
                    nextFix: nextFix
                };

                window.aircraftController.aircraft_new(aircraftToAdd);
            }
        }

        /**
         * Stop this arrival stream
         *
         * @for ArrivalBase
         * @method stop
         */

    }, {
        key: 'stop',
        value: function stop() {
            if (this.timeout) {
                window.gameController.game_clear_timeout(this.timeout);
            }
        }

        /**
         * Start this arrival stream
         *
         * @for ArrivalBase
         * @method start
         */

    }, {
        key: 'start',
        value: function start() {
            // TODO: what do these numbers mean? enumerate the magic numbers.
            var delay = (0, _random3.default)(0, _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.frequency);
            this.timeout = window.gameController.game_timeout(this.spawnAircraft, delay, this, [true, true]);

            if (this.activeRouteModel) {
                this.preSpawn();
            }
        }

        // TODO: this method should accept explicit arguments
        /**
         * Spawn a new aircraft
         *
         * @for ArrivalBase
         * @method spawnAircraft
         */

    }, {
        key: 'spawnAircraft',
        value: function spawnAircraft(args) {
            var position = void 0;
            var heading = void 0;
            var distance = void 0;
            // args = [boolean, boolean]
            var altitude = (0, _core.round)((0, _random3.default)(this.altitude[0], this.altitude[1]) / 1000) * 1000;
            var message = !(window.gameController.game_time() - this.airport.start < 2);
            var airline = (0, _randomAirlineSelectionHelper.randomAirlineSelectionHelper)(this.airlines);
            // What is this next variable for, why is it here and can it be removed?
            // FIXME: this is not used
            var start_flag = args[0];
            var timeout_flag = args[1] || false;

            // spawn at first fix
            if (this.fixes.length > 1) {
                // calculate heading to next fix
                position = getFixPosition(this.fixes[0].fix);
                var nextPosition = getFixPosition(this.fixes[1].fix);
                heading = (0, _flightMath.bearingToPoint)(position, nextPosition);
            } else if (this.activeRouteModel) {
                var isPreSpawn = false;
                var waypointModelList = this.airport.findWaypointModelsForStar(this.activeRouteModel.procedure, this.activeRouteModel.entry, this.airport.runway, isPreSpawn);

                // grab position of first fix
                position = waypointModelList[0].position;
                // calculate heading from first waypoint to second waypoint
                heading = (0, _flightMath.bearingToPoint)(position, waypointModelList[1].position);
            } else {
                // spawn outside the airspace along 'this.radial'
                distance = 2 * this.airport.ctr_radius;
                // TODO: this should really use `PositionModel`
                position = [(0, _core.sin)(this.radial) * distance, (0, _core.cos)(this.radial) * distance];
                heading = this.heading || this.radial + Math.PI;
            }

            var aircraftToAdd = {
                altitude: altitude,
                heading: heading,
                message: message,
                position: position,
                category: _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL,
                destination: this.airport.icao,
                airline: airline.name,
                fleet: airline.fleet,
                waypoints: this.fixes,
                route: (0, _get3.default)(this, 'activeRouteModel.routeCode', ''),
                // TODO: this should use a `PositionModel` instead of just using it to get a position
                // this will take a lot of refactoring, though, as aircraft.position is used all over the app.
                speed: this.speed
            };

            window.aircraftController.aircraft_new(aircraftToAdd);

            if (timeout_flag) {
                this.timeout = window.gameController.game_timeout(this.spawnAircraft, this.nextInterval(), this, [null, true]);
            }
        }

        /**
         * Determine delay until next spawn
         *
         * @for ArrivalBase
         * @method nextInterval
         * @return {number}
         */

    }, {
        key: 'nextInterval',
        value: function nextInterval() {
            var min_interval = _airportConstants.AIRPORT_CONSTANTS.MIN_ENTRAIL_DISTANCE_NM * (INTERVAL_DELAY_IN_MS / this.speed);
            var tgt_interval = INTERVAL_DELAY_IN_MS / this.frequency;

            if (tgt_interval < min_interval) {
                tgt_interval = min_interval;

                log('Requested arrival rate of ' + this.frequency + ' acph overridden to ' + ('maintain minimum of ' + _airportConstants.AIRPORT_CONSTANTS.MIN_ENTRAIL_DISTANCE_NM + ' miles entrail on arrival stream ') + ('following route ' + this.activeRouteModel.routeCode), _logLevel.LOG.INFO);
            }

            var max_interval = tgt_interval + (tgt_interval - min_interval);

            return (0, _random3.default)(min_interval, max_interval);
        }
    }]);

    return ArrivalBase;
}();

exports.default = ArrivalBase;

},{"../../airline/randomAirlineSelectionHelper":533,"../../base/PositionModel":560,"../../constants/aircraftConstants":570,"../../constants/airportConstants":571,"../../constants/globalConstants":573,"../../constants/logLevel":574,"../../math/core":584,"../../math/flightMath":586,"../../utilities/unitConverters":595,"../Fix/FixCollection":546,"../Route/RouteModel":548,"lodash/get":469,"lodash/map":496,"lodash/random":500}],538:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _ArrivalBase2 = require('./ArrivalBase');

var _ArrivalBase3 = _interopRequireDefault(_ArrivalBase2);

var _unitConverters = require('../../utilities/unitConverters');

var _globalConstants = require('../../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand */


/**
 * Generate arrivals in cyclic pattern
 * Arrival rate varies as pictured below. Rate at which the arrival rate
 * increases or decreases remains constant throughout the cycle.

 * |---o---------------o---------------o---------------o-----------| < - - - - - - max arrival rate
 * | o   o           o   o           o   o           o   o         |   +variation
 * o-------o-------o-------o-------o-------o-------o-------o-------o < - - - - - - avg arrival rate
 * |         o   o |         o   o           o   o           o   o |   -variation
 * |-----------o---|-----------o---------------o---------------o---| < - - - - - - min arrival rate
 * |<---period---->|           |<---period---->|
 *
 * @class ArrivalCyclic
 * @extends ArrivalBase
 */
var ArrivalCyclic = function (_ArrivalBase) {
    _inherits(ArrivalCyclic, _ArrivalBase);

    /**
     * @for ArrivalCyclic
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function ArrivalCyclic(airport, options) {
        _classCallCheck(this, ArrivalCyclic);

        /**
         * amount to deviate from the prescribed frequency
         *
         * @property variation
         * @type {number}
         * @default 0
         */
        var _this = _possibleConstructorReturn(this, (ArrivalCyclic.__proto__ || Object.getPrototypeOf(ArrivalCyclic)).call(this, airport, options));

        _this.variation = 0;

        _this.parse(options);
        return _this;
    }

    /**
     * Arrival Stream Settings
     *
     * @param {integer} period - (optional) length of a cycle, in minutes
     * @param {integer} offset - (optional) minutes to shift starting position in cycle
     */


    _createClass(ArrivalCyclic, [{
        key: 'parse',
        value: function parse(options) {
            _get(ArrivalCyclic.prototype.__proto__ || Object.getPrototypeOf(ArrivalCyclic.prototype), 'parse', this).call(this, options);

            if (options.offset) {
                this.offset = (0, _unitConverters.convertMinutesToSeconds)(options.offset);
            }

            if (options.period) {
                this.period = (0, _unitConverters.convertMinutesToSeconds)(options.period);
            }

            if (options.variation) {
                this.variation = options.variation;
            }
        }
    }, {
        key: 'start',
        value: function start() {
            this.cycleStart = window.gameController.game.time - this.offset;
            var delay = (0, _random3.default)(0, _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.frequency);
            this.timeout = window.gameController.game_timeout(this.spawnAircraft, delay, this, [true, true]);
        }
    }, {
        key: 'nextInterval',
        value: function nextInterval() {
            // TODO: what do all these magic numbers mean? enumerate the magic numbers.
            var t = window.gameController.game.time - this.cycleStart;
            var done = t / (this.period / 4); // progress in current quarter-period

            if (done >= 4) {
                this.cycleStart += this.period;

                return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency + (done - 4) * this.variation);
            } else if (done <= 1) {
                return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency + done * this.variation);
            } else if (done <= 2) {
                return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency + 2 * (this.period - 2 * t) / this.period * this.variation);
            } else if (done <= 3) {
                return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency - (done - 2) * this.variation);
            } else if (done < 4) {
                return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency - 4 * (this.period - t) / this.period * this.variation);
            }
        }
    }]);

    return ArrivalCyclic;
}(_ArrivalBase3.default);

exports.default = ArrivalCyclic;

},{"../../constants/globalConstants":573,"../../utilities/unitConverters":595,"./ArrivalBase":537,"lodash/random":500}],539:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _ArrivalBase2 = require('./ArrivalBase');

var _ArrivalBase3 = _interopRequireDefault(_ArrivalBase2);

var _core = require('../../math/core');

var _unitConverters = require('../../utilities/unitConverters');

var _globalConstants = require('../../constants/globalConstants');

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand */


/**
 * Generate arrivals in a repeating surge
 *
 * Arrival rate goes from very low and steeply increases to a sustained arrival surge of densely packed aircraft.
 *
 * Example airport: `EDDT - Berlin Tegel Airport`
 *
 * o o o o o o o o o o - - - - - - - - - - - o o o o o o o o o o-----+ < - - - max arrival rate (*this.factor)
 * o                 o                       o                 o     |
 * o                 o                       o                 o     |   x(this.factor)
 * o                 o                       o                 o     |
 * o - - - - - - - - o o o o o o o o o o o o o - - - - - - - - o o o-+ < - - - min arrival rate (n)
 * |<--- up time --->|<----- down time ----->|<--- up time --->|
 *
 * @class ArrivalSurge
 * @extends ArrivalBase
 */
var ArrivalSurge = function (_ArrivalBase) {
    _inherits(ArrivalSurge, _ArrivalBase);

    /**
     * @for ArrivalBase
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function ArrivalSurge(airport, options) {
        _classCallCheck(this, ArrivalSurge);

        /**
         * miles entrail during the surge [fast,slow]
         *
         * @property entrail
         * @type {number}
         * @default
         */
        var _this = _possibleConstructorReturn(this, (ArrivalSurge.__proto__ || Object.getPrototypeOf(ArrivalSurge)).call(this, airport, options));

        _this.entrail = [5.5, 10];

        // Calculated
        /**
         * time length of surge, in minutes
         *
         * @property uptime
         * @type {number}
         * @default 0
         */
        _this.uptime = 0;

        /**
         * arrival rate when "in the surge"
         *
         * @property acph_up
         * @type {number}
         * @default 0
         */
        _this.acph_up = 0;

        /**
         * arrival rate when not "in the surge"
         *
         * @property acph_dn
         * @type {number}
         * @default 0
         */
        _this.acph_dn = 0;

        _this.parse(options);
        _this.shapeTheSurge();
        return _this;
    }

    /**
     * Arrival Stream Settings
     *
     * @for ArrivalSurge
     * @method parse
     * @param {integer} period - Optionally specify the length of a cycle in minutes
     * @param {integer} offset - Optionally specify the center of the wave in minutes
     * @param {array} entrail - 2-element array with [fast,slow] nm between each
     *                          successive arrival. Note that the entrail distance on
     *                          the larger gap ("slow") will be adjusted slightly in
     *                          order to maintain the requested frequency. This is
     *                          simply due to the fact that we can't divide perfectly
     *                          across each period, so we squish the gap a tiny bit to
     *                          help us hit the mark on the aircraft-per-hour rate.
     */


    _createClass(ArrivalSurge, [{
        key: 'parse',
        value: function parse(options) {
            _get(ArrivalSurge.prototype.__proto__ || Object.getPrototypeOf(ArrivalSurge.prototype), 'parse', this).call(this, options);

            if (options.offset) {
                this.offset = (0, _unitConverters.convertMinutesToSeconds)(options.offset);
            }

            if (options.period) {
                this.period = (0, _unitConverters.convertMinutesToSeconds)(options.period);
            }

            if (options.entrail) {
                this.entrail = options.entrail;
            }
        }

        /**
         * Determines the time spent at elevated and slow spawn rates
         *
         * @for ArrivalSurge
         * @method shapeTheSurge
         */

    }, {
        key: 'shapeTheSurge',
        value: function shapeTheSurge() {
            this.acph_up = this.speed / this.entrail[0];
            this.acph_dn = this.speed / this.entrail[1]; // to help the uptime calculation

            this.uptime = (this.period * this.frequency - this.period * this.acph_dn) / (this.acph_up - this.acph_dn);
            this.uptime -= this.uptime % (_globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.acph_up);
            // FIXME: This would better belong in a helper method and should be simplified
            // adjust to maintain correct acph rate
            this.acph_dn = Math.floor(this.frequency * this.period / _globalConstants.TIME.ONE_HOUR_IN_SECONDS - Math.round(this.acph_up * this.uptime / _globalConstants.TIME.ONE_HOUR_IN_SECONDS)) * _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.period - this.uptime);

            // TODO: abstract this if/else block
            // Verify we can comply with the requested arrival rate based on entrail spacing
            if (this.frequency > this.acph_up) {
                log(this.airport.icao + ': TOO MANY ARRIVALS IN SURGE! Requested: ' + (this.frequency + ' acph | Acceptable Range for requested entrail distance: ') + (Math.ceil(this.acph_dn) + ' acph - ' + Math.floor(this.acph_up) + ' acph'), _logLevel.LOG.WARNING);

                this.frequency = this.acph_up;
                this.acph_dn = this.acph_up;
            } else if (this.frequency < this.acph_dn) {
                log(this.airport.icao + ': TOO FEW ARRIVALS IN SURGE! Requested: ' + (this.frequency + ' acph | Acceptable Range for requested entrail distance: ') + (Math.ceil(this.acph_dn) + ' acph - ' + Math.floor(this.acph_up) + ' acph'), _logLevel.LOG.WARNING);

                this.frequency = this.acph_dn;
                this.acph_up = this.acph_dn;
            }
        }

        /**
         * @for ArrivalSurge
         * @method nextInterval
         * @return interval_up {number}
         */

    }, {
        key: 'nextInterval',
        value: function nextInterval() {
            var t = window.gameController.game.time - this.cycleStart;
            var done = t / this.period; // progress in period
            var interval_up = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.acph_up;
            var interval_dn = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.acph_dn;
            // reduced spawn rate
            var timeleft = this.period - t;

            if (done >= 1) {
                this.cycleStart += this.period;

                return interval_up;
            }

            // elevated spawn rate
            if (t <= this.uptime) {
                return interval_up;
            }

            if (timeleft > interval_dn + interval_up) {
                // plenty of time until new period
                return interval_dn;
            } else if (timeleft > interval_dn) {
                // next plane will delay the first arrival of the next period
                return interval_dn - (t + interval_dn + interval_up - this.period);
            }

            // next plane is first of elevated spawn rate
            this.cycleStart += this.period;

            return interval_up;
        }

        /**
         * @for ArrivalSurge
         * @method start
         */

    }, {
        key: 'start',
        value: function start() {
            var delay = (0, _random3.default)(0, _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.frequency);
            this.cycleStart = window.gameController.game.time - this.offset + delay;
            this.timeout = window.gameController.game_timeout(this.spawnAircraft, delay, this, [true, true]);
        }
    }]);

    return ArrivalSurge;
}(_ArrivalBase3.default);

exports.default = ArrivalSurge;

},{"../../constants/globalConstants":573,"../../constants/logLevel":574,"../../math/core":584,"../../utilities/unitConverters":595,"./ArrivalBase":537,"lodash/random":500}],540:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _ArrivalBase2 = require('./ArrivalBase');

var _ArrivalBase3 = _interopRequireDefault(_ArrivalBase2);

var _core = require('../../math/core');

var _circle = require('../../math/circle');

var _unitConverters = require('../../utilities/unitConverters');

var _globalConstants = require('../../constants/globalConstants');

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand */


/** Generate arrivals in a repeating wave
  * Arrival rate varies as pictured below. Arrival rate will increase
  * and decrease faster when changing between the lower/higher rates.
  *
  * ------------o-o-o---------------------------------------+-----------o-o < - - - - - max arrival rate
  *        o             o                                  |      o      |       ^
  *    o                     o                              |  o          |  +variation
  *  o                         o                            |o            |       v
  * o-------------------------- o---------------------------o-------------+ < - - - - - avg arrival rate
  * |                            o                         o|             |       ^
  * |                              o                     o  |             |  -variation
  * |                                  o             o      |             |       v
  * +---------------------------------------o-o-o-----------+-------------+ < - - - - - min arrival rate
  * |                                                       |
  * |<  -  -  -  -  -  -  -  - period -  -  -  -  -  -  -  >|
  *
  * @class ArrivalWave
  * @extends ArrivalBase
 */
var ArrivalWave = function (_ArrivalBase) {
    _inherits(ArrivalWave, _ArrivalBase);

    /**
     * @for ArrivalWave
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function ArrivalWave(airport, options) {
        _classCallCheck(this, ArrivalWave);

        /**
         * amount to deviate from the prescribed frequency
         *
         * @propery variation
         * @type {number}
         * @default 0
         */
        var _this = _possibleConstructorReturn(this, (ArrivalWave.__proto__ || Object.getPrototypeOf(ArrivalWave)).call(this, airport, options));

        _this.variation = 0;

        _this.parse(options);
        _this.clampSpawnRate(5.5); // minimum of 5.5nm entrail
        return _this;
    }

    /**
     * Arrival Stream Settings
     *
     * @for ArrivalWave
     * @method parse
     * @param {integer} period - (optional) length of a cycle, in minutes
     * @param {integer} offset - (optional) minutes to shift starting position in cycle
     */


    _createClass(ArrivalWave, [{
        key: 'parse',
        value: function parse(options) {
            _get(ArrivalWave.prototype.__proto__ || Object.getPrototypeOf(ArrivalWave.prototype), 'parse', this).call(this, options);

            if (options.offset) {
                this.offset = (0, _unitConverters.convertMinutesToSeconds)(options.offset);
            }

            if (options.period) {
                this.period = (0, _unitConverters.convertMinutesToSeconds)(options.period);
            }

            if (options.variation) {
                this.variation = options.variation;
            }
        }

        /**
         * Ensures the spawn rate will be at least the required entrail distance
         *
         * @for ArrivalWave
         * @method clampSpawnRate
         * @param {number} entrail_dist - minimum distance between successive arrivals, in nm
         */

    }, {
        key: 'clampSpawnRate',
        value: function clampSpawnRate(entrail_dist) {
            var entrail_interval = entrail_dist * (_globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.speed);
            var min_interval = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / (this.frequency + this.variation);

            // TODO: return early here to avoid this wrapping if
            if (min_interval < entrail_interval) {
                var diff = entrail_interval - min_interval;

                // can reduce variation to achieve acceptable spawn rate
                if (diff <= _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.variation) {
                    log('Requested arrival rate variation of +/-' + this.variation + ' acph reduced to ' + 'maintain minimum of ' + entrail_dist + ' miles entrail on arrival stream following ' + 'route ' + _jquery2.default.map(this.fixes, function (v) {
                        return v.fix;
                    }).join('-'), _logLevel.LOG.WARNING);

                    this.variation = this.variation - _globalConstants.TIME.ONE_HOUR_IN_SECONDS / diff; // reduce the variation
                } else {
                    // need to reduce frequency to achieve acceptable spawn rate
                    log('Requested arrival rate of ' + this.frequency + ' acph overridden to ' + 'maintain minimum of ' + entrail_dist + ' miles entrail on arrival stream ' + 'following route ' + _jquery2.default.map(this.fixes, function (v) {
                        return v.fix;
                    }).join('-'), _logLevel.LOG.WARNING);

                    // make spawn at constant interval
                    this.variation = 0;
                    // reduce the frequency
                    this.frequency = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / entrail_interval;
                }
            }
        }

        /**
         * @for ArrivalWave
         * @method nextInterval
         * return {number}
         */

    }, {
        key: 'nextInterval',
        value: function nextInterval() {
            var t = window.gameController.game.time - this.cycleStart;
            var done = t / this.period; // progress in period

            if (done >= 1) {
                this.cycleStart += this.period;
            }

            var rate = this.frequency + this.variation * (0, _core.sin)(done * (0, _circle.tau)());

            return _globalConstants.TIME.ONE_HOUR_IN_SECONDS / rate;
        }

        /**
         * @for ArrivalWave
         * @method start
         */

    }, {
        key: 'start',
        value: function start() {
            var delay = (0, _random3.default)(0, _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.frequency);
            // TODO: this might not be available on `window.prop` update reference
            this.cycleStart = window.gameController.game.time - this.offset + delay;
            this.timeout = window.gameController.game_timeout(this.spawnAircraft, delay, this, [true, true]);
        }
    }]);

    return ArrivalWave;
}(_ArrivalBase3.default);

exports.default = ArrivalWave;

},{"../../constants/globalConstants":573,"../../constants/logLevel":574,"../../math/circle":583,"../../math/core":584,"../../utilities/unitConverters":595,"./ArrivalBase":537,"jquery":296,"lodash/random":500}],541:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.arrivalFactory = undefined;

var _ArrivalBase = require('./ArrivalBase');

var _ArrivalBase2 = _interopRequireDefault(_ArrivalBase);

var _ArrivalCyclic = require('./ArrivalCyclic');

var _ArrivalCyclic2 = _interopRequireDefault(_ArrivalCyclic);

var _ArrivalWave = require('./ArrivalWave');

var _ArrivalWave2 = _interopRequireDefault(_ArrivalWave);

var _ArrivalSurge = require('./ArrivalSurge');

var _ArrivalSurge2 = _interopRequireDefault(_ArrivalSurge);

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls constructor of the appropriate arrival type
 *
 * @function ArrivalFactory
 * @param airport {AirportModel}
 * @param options {obejct}
 * @return {constructor}
 */
var arrivalFactory = exports.arrivalFactory = function arrivalFactory(airport, options) {
    if (options.type === '') {
        log(airport.icao + ' arrival stream not given type!', _logLevel.LOG.WARNING);
        return null;
    }

    switch (options.type) {
        case 'random':
            return new _ArrivalBase2.default(airport, options);
        case 'cyclic':
            return new _ArrivalCyclic2.default(airport, options);
        case 'wave':
            return new _ArrivalWave2.default(airport, options);
        case 'surge':
            return new _ArrivalSurge2.default(airport, options);
        default:
            log(airport.icao + ' using unsupported arrival type "' + options.type + '"', _logLevel.LOG.WARNING);
            return null;
    }
};

},{"../../constants/logLevel":574,"./ArrivalBase":537,"./ArrivalCyclic":538,"./ArrivalSurge":539,"./ArrivalWave":540}],542:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _RouteModel = require('../Route/RouteModel');

var _RouteModel2 = _interopRequireDefault(_RouteModel);

var _randomAirlineSelectionHelper = require('../../airline/randomAirlineSelectionHelper');

var _generalUtilities = require('../../utilities/generalUtilities');

var _aircraftConstants = require('../../constants/aircraftConstants');

var _globalConstants = require('../../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate departures at random, averaging the specified spawn rate
 *
 * @class DepartureBase
 */
var DepartureBase = function () {
    /**
     * @for DepartureBase
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function DepartureBase(airport, options) {
        _classCallCheck(this, DepartureBase);

        /**
         * List of airlines with weight for each
         *
         * @property airlines
         * @type {array}
         * @default []
         */
        this.airlines = [];

        /**
         * @property airport
         * @type {AirportInstanceModel}
         */
        this.airport = airport;

        // TODO: are we initializing an array with a value here?
        /**
         * List of SIDs or departure fix names
         *
         * @property destinations
         * @type {array}
         * @default [0]
         */
        this.destinations = [0];

        /**
         * Spawn rate, in aircraft per hour (acph)
         *
         * @property frequency
         * @type {number}
         * @default 0
         */
        this.frequency = 0;

        /**
         * @property timeout
         * @type {function}
         * @default null
         */
        this.timeout = null;

        /**
         * @property activeRouteModel
         * @type {RouteModel}
         * @default null
         */
        this.activeRouteModel = null;

        this.parse(options);
    }

    /**
     * Departure Stream Settings
     *
     * @for DepartureBase
     * @method parse
     */


    _createClass(DepartureBase, [{
        key: 'parse',
        value: function parse(options) {
            this.airlines = (0, _get3.default)(options, 'airlines', this.airlines);
            this.destinations = (0, _get3.default)(options, 'destinations', this.destinations);
            this.frequency = (0, _get3.default)(options, 'frequency', this.frequency);

            for (var i = 0; i < this.airlines.lenth; i++) {
                var airline = this.airlines[i];
                // reassigns `airline.name` to `airlineName` for readability

                var _airlineNameAndFleetH = (0, _randomAirlineSelectionHelper.airlineNameAndFleetHelper)(airline),
                    airlineName = _airlineNameAndFleetH.name;

                window.airlineController.airline_get(airlineName);
            }
        }

        /**
         * Stop this departure stream
         *
         * @for DepartureBase
         * @method stop
         */

    }, {
        key: 'stop',
        value: function stop() {
            if (this.timeout) {
                window.gameController.game_clear_timeout(this.timeout);
            }
        }

        /**
         * Start this departure stream
         *
         * @for DepartureBase
         * @method start
         */

    }, {
        key: 'start',
        value: function start() {
            var randomSpawnCount = Math.floor((0, _random3.default)(2, 5.99));

            for (var i = 1; i <= randomSpawnCount; i++) {
                // spawn 2-5 departures to start with
                this.spawnAircraft(false);
            }

            this.initiateSpawningLoop();
        }

        /**
         * @for DepartureBase
         * @method initiateSpawningLoop
         */

    }, {
        key: 'initiateSpawningLoop',
        value: function initiateSpawningLoop() {
            var minFrequency = this.frequency * 0.5;
            var maxFrequency = this.frequency * 1.5;
            var randomNumberForTimeout = (0, _random3.default)(minFrequency, maxFrequency);

            // start spawning loop
            this.timeout = window.gameController.game_timeout(this.spawnAircraft, randomNumberForTimeout, this, true);
        }

        /**
         * Spawn a new aircraft
         *
         * @for DepartureBase
         * @method spawnAircraft
         */

    }, {
        key: 'spawnAircraft',
        value: function spawnAircraft(timeout) {
            var message = window.gameController.game_time() - this.start >= 2;
            var airline = (0, _randomAirlineSelectionHelper.randomAirlineSelectionHelper)(this.airlines);
            var aircraftToAdd = {
                message: message,
                airline: airline.name,
                fleet: airline.fleet,
                category: _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE,
                destination: (0, _generalUtilities.choose)(this.destinations)
            };

            window.aircraftController.aircraft_new(aircraftToAdd);

            if (timeout) {
                this.timeout = window.gameController.game_timeout(this.spawnAircraft, this.nextInterval(), this, true);
            }
        }

        /**
         * Determine delay until next spawn
         *
         * @for DepartureBase
         * @method nextInterval
         * @return {number}
         */

    }, {
        key: 'nextInterval',
        value: function nextInterval() {
            // fastest possible between back-to-back departures, in seconds
            var min_interval = 5;
            var tgt_interval = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / this.frequency;
            var max_interval = tgt_interval + (tgt_interval - min_interval);

            return (0, _random3.default)(min_interval, max_interval);
        }
    }]);

    return DepartureBase;
}();

exports.default = DepartureBase;

},{"../../airline/randomAirlineSelectionHelper":533,"../../constants/aircraftConstants":570,"../../constants/globalConstants":573,"../../utilities/generalUtilities":592,"../Route/RouteModel":548,"lodash/get":469,"lodash/random":500}],543:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _DepartureBase2 = require('./DepartureBase');

var _DepartureBase3 = _interopRequireDefault(_DepartureBase2);

var _core = require('../../math/core');

var _circle = require('../../math/circle');

var _unitConverters = require('../../utilities/unitConverters');

var _globalConstants = require('../../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-underscore-dangle, no-mixed-operators, func-names, object-shorthand */


/**
 * Generate departures in cyclic pattern
 *
 * @class DepartureCyclic
 * @extends DepartureBase
 */
var DepartureCyclic = function (_DepartureBase) {
  _inherits(DepartureCyclic, _DepartureBase);

  /**
   * @for DepartureBase
   * @constructor
   * @param airport {AirportInstanceModel}
   * @param options {object}
   */
  function DepartureCyclic(airport, options) {
    _classCallCheck(this, DepartureCyclic);

    /**
     * length of a cycle
     *
     * @property period
     * @type {number}
     * @default TIME.ONE_HOUR_IN_SECONDS
     */
    var _this = _possibleConstructorReturn(this, (DepartureCyclic.__proto__ || Object.getPrototypeOf(DepartureCyclic)).call(this, airport, options));

    _this.period = _globalConstants.TIME.ONE_HOUR_IN_SECONDS;

    /**
     * Start at the peak
     *
     * Optionally specify when the cycle peaks
     *
     * @property offset
     * @type {number}
     * @default -900
     */
    _this.offset = -900;

    /**
     * @property _amplitude
     * @type {number}
     */
    _this._amplitude = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / _this.frequency / 2;

    /**
     * @property _average
     * @type {number}
     */
    _this._average = _globalConstants.TIME.ONE_HOUR_IN_SECONDS / _this.frequency;
    return _this;
  }

  /**
   * @for DepartureCyclic
   * @method parse
   */


  _createClass(DepartureCyclic, [{
    key: 'parse',
    value: function parse(options) {
      _get(DepartureCyclic.prototype.__proto__ || Object.getPrototypeOf(DepartureCyclic.prototype), 'parse', this).call(this, options);

      if (options.period) {
        this.period = (0, _unitConverters.convertMinutesToSeconds)(options.period);
      }

      if (options.offset) {
        // TODO: enumerate the magic numbers
        this.offset = -this.period / 4 + (0, _unitConverters.convertMinutesToSeconds)(options.offset);
      }
    }

    /**
     * @for DepartureCyclic
     * @method nextInterval
     * @return {number}
     */

  }, {
    key: 'nextInterval',
    value: function nextInterval() {
      var gameTimeWithOffset = window.gameController.game_time() + this.offset;
      var sinOffsetOverPeriod = (0, _core.sin)((0, _circle.tau)() * (gameTimeWithOffset / this.period));
      var amplitudeTimesSinOffsetOverPeriod = this._amplitude * sinOffsetOverPeriod;

      return (amplitudeTimesSinOffsetOverPeriod + this._average) / window.gameController.game.frequency;
    }
  }]);

  return DepartureCyclic;
}(_DepartureBase3.default);

exports.default = DepartureCyclic;

},{"../../constants/globalConstants":573,"../../math/circle":583,"../../math/core":584,"../../utilities/unitConverters":595,"./DepartureBase":542}],544:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DepartureCyclic2 = require('./DepartureCyclic');

var _DepartureCyclic3 = _interopRequireDefault(_DepartureCyclic2);

var _globalConstants = require('../../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Generate departures in a repeating wave
 *
 * @class DepartureWave
 * @extends DepartureCyclic
 */
var DepartureWave = function (_DepartureCyclic) {
    _inherits(DepartureWave, _DepartureCyclic);

    /**
     * @for DepartureCyclic
     * @constructor
     * @param airport {AirportInstanceModel}
     * @param options {object}
     */
    function DepartureWave(airport, options) {
        _classCallCheck(this, DepartureWave);

        // TODO: better commenting of the magic numbers in this file. enumerate the magic numbers.
        // Time between aircraft in the wave
        var _this = _possibleConstructorReturn(this, (DepartureWave.__proto__ || Object.getPrototypeOf(DepartureWave)).call(this, airport, options));

        _this._separation = 10;

        // Aircraft per wave
        _this._count = Math.floor(_this._average / _globalConstants.TIME.ONE_HOUR_IN_SECONDS * _this.period);

        if (_this.period / _this._separation < _this._count) {
            console.log('Reducing average departure frequency from ' + _this._average + '/hour to maintain minimum interval');

            _this._count = Math.floor(_globalConstants.TIME.ONE_HOUR_IN_SECONDS / _this._separation);
        }

        // length of a wave in seconds
        _this._waveLength = _this._separation * _this._count - 1;

        // Offset to have center of wave at 0 time
        _this._offset = (_this._waveLength - _this._separation) / 2 + _this.offset;
        return _this;
    }

    /**
     * @for DepartureCyclic
     * @method nextInterval
     * @return {number}
     */


    _createClass(DepartureWave, [{
        key: 'nextInterval',
        value: function nextInterval() {
            var position = (window.gameController.game_time() + this._offset) % this.period;

            if (position >= this._waveLength) {
                return this.period - position;
            }

            return this._separation / window.gameController.game.frequency;
        }
    }]);

    return DepartureWave;
}(_DepartureCyclic3.default);

exports.default = DepartureWave;

},{"../../constants/globalConstants":573,"./DepartureCyclic":543}],545:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.departureFactory = undefined;

var _DepartureBase = require('./DepartureBase');

var _DepartureBase2 = _interopRequireDefault(_DepartureBase);

var _DepartureCyclic = require('./DepartureCyclic');

var _DepartureCyclic2 = _interopRequireDefault(_DepartureCyclic);

var _DepartureWave = require('./DepartureWave');

var _DepartureWave2 = _interopRequireDefault(_DepartureWave);

var _logLevel = require('../../constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls constructor of the appropriate arrival type
 *
 * @function DepartureFactory
 * @param airport {AirportModel}
 * @param options {object}
 * @return {constructor}
 */
var departureFactory = exports.departureFactory = function departureFactory(airport, options) {
    if (options.type === '') {
        return log(airport.icao + ' departure stream not given type!', _logLevel.LOG.WARNING);
    }

    switch (options.type) {
        case 'random':
            return new _DepartureBase2.default(airport, options);
        case 'cyclic':
            return new _DepartureCyclic2.default(airport, options);
        case 'wave':
            return new _DepartureWave2.default(airport, options);
        default:
            log(airport.icao + ' using unsupported departure type "' + options.type + '"', _logLevel.LOG.WARNING);
            return null;
    }
};

},{"../../constants/logLevel":574,"./DepartureBase":542,"./DepartureCyclic":543,"./DepartureWave":544}],546:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _ModelSourceFactory = require('../../base/ModelSource/ModelSourceFactory');

var _ModelSourceFactory2 = _interopRequireDefault(_ModelSourceFactory);

var _BaseCollection2 = require('../../base/BaseCollection');

var _BaseCollection3 = _interopRequireDefault(_BaseCollection2);

var _FixModel = require('./FixModel');

var _FixModel2 = _interopRequireDefault(_FixModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A collection of all the `FixModel`s defined in an airport json file.
 *
 * This is built as a static class, so there is only ever once instance.
 * We use a static class here because the methods contained herein are needed by several
 * different classes. This provides a single source of truth for all the `FixModel`s
 * belonging to an Airport.
 *
 * @class FixCollection
 * @extends BaseCollection
 */
var FixCollection = function (_BaseCollection) {
    _inherits(FixCollection, _BaseCollection);

    function FixCollection() {
        _classCallCheck(this, FixCollection);

        return _possibleConstructorReturn(this, (FixCollection.__proto__ || Object.getPrototypeOf(FixCollection)).apply(this, arguments));
    }

    _createClass(FixCollection, [{
        key: 'addItems',

        /**
         * Lifecycle method. Should be run only once on instantiation.
         *
         * @for FixCollection
         * @method addItems
         * @param fixList {object}
         * @param airportPosition {PositionModel}
         */
        value: function addItems(fixList, airportPosition) {
            if (this.length !== 0) {
                // you made it here because an airport has changed.
                // in `AirportModel.parse()` this method is called with the fix data for the new airport. We don't want
                // or need to keep the fixes from a previous airport so if `_items` has a length, we need to reset that
                // property before we begin to add fixes for the new airport.
                this.removeItems();
            }

            this._buildFixModelsFromList(fixList, airportPosition);
        }

        /**
         * Destroy the current instance
         *
         * @for FixCollection
         * @method removeItems
         */

    }, {
        key: 'removeItems',
        value: function removeItems() {
            this._resetFixModels();

            this._items = [];
        }

        /**
         * Add a `FixModel` to the collection
         *
         * @for FixCollection
         * @method addFixToCollection
         * @param fixToAdd {FixModel}
         */

    }, {
        key: 'addFixToCollection',
        value: function addFixToCollection(fixToAdd) {
            if (!(fixToAdd instanceof _FixModel2.default)) {
                throw new TypeError('Expected fixToAdd to be an instance of FixModel');
            }

            this._items.push(fixToAdd);
        }

        /**
         * Find a `FixModel` by `name` if it exists within the collection.
         *
         * @for FixCollection
         * @method findFixByName
         * @param fixName {string}
         * @return {FixModel|null}
         */

    }, {
        key: 'findFixByName',
        value: function findFixByName(fixName) {
            var fixModel = (0, _find3.default)(this._items, { name: fixName.toUpperCase() });

            // if a fix is not found, _find() returns `undefined` so we specifically return null here if a fix is not found
            return fixModel || null;
        }

        /**
         * @for FixCollection
         * @method getFixPositionCoordinates
         * @param fixName {string}
         * @return {array<number>}
         */

    }, {
        key: 'getFixPositionCoordinates',
        value: function getFixPositionCoordinates(fixName) {
            var fixModel = this.findFixByName(fixName);

            if (!fixModel) {
                // error
                return null;
            }

            return fixModel.position;
        }

        /**
         * Find a list of all `FixModel`s within the collection that have a name that does not start with an underscore.
         *
         * @for FixCollection
         * @method findRealFixes
         * @return {array<FixModel>}
         */

    }, {
        key: 'findRealFixes',
        value: function findRealFixes() {
            var realFixList = (0, _map3.default)(this._items, function (item) {
                if (item.name.indexOf('_') !== 0) {
                    return item;
                }
            });

            return (0, _compact3.default)(realFixList);
        }

        /**
         * Loop through each fix provided in the fix list, create a new `FixModel` instance, then send it off
         * to be added to the collection.
         *
         * @for FixCollection
         * @method _buildFixModelsFromList
         * @param fixList {object}
         * @private
         */

    }, {
        key: '_buildFixModelsFromList',
        value: function _buildFixModelsFromList(fixList, airportPosition) {
            var _this2 = this;

            (0, _forEach3.default)(fixList, function (fixCoordinates, fixName) {
                var fixModel = _ModelSourceFactory2.default.getModelSourceForType('FixModel', fixName, fixCoordinates, airportPosition);

                _this2.addFixToCollection(fixModel);
            });
        }

        /**
         * @for FixCollection
         * @method _resetFixModels
         * @private
         */

    }, {
        key: '_resetFixModels',
        value: function _resetFixModels() {
            (0, _forEach3.default)(this._items, function (fixModel) {
                fixModel.reset();
                _ModelSourceFactory2.default.returnModelToPool(fixModel);
            });
        }
    }]);

    return FixCollection;
}(_BaseCollection3.default);

exports.default = new FixCollection();

},{"../../base/BaseCollection":555,"../../base/ModelSource/ModelSourceFactory":557,"./FixModel":547,"lodash/compact":462,"lodash/find":466,"lodash/forEach":468,"lodash/map":496}],547:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _BaseModel2 = require('../../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _PositionModel = require('../../base/PositionModel');

var _PositionModel2 = _interopRequireDefault(_PositionModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Defines a navigational `FixModel`
 *
 * A `FixModel` can be used as part of a `StandardRoute` or as a naviagtional aid.
 * Not all `FixModel`s are a part of a `StandardRoute`.
 *
 * @class FixModel
 */
var FixModel = function (_BaseModel) {
  _inherits(FixModel, _BaseModel);

  /**
   * @for FixModel
   * @constructor
   * @param fixName {string}
   * @param fixCoordinate {array}
   * @param airportPosition {PositionModel}
   */
  function FixModel(fixName, fixCoordinate, airportPosition) {
    _classCallCheck(this, FixModel);

    /**
     * Name of the Fix
     *
     * @property name
     * @type {string}
     * @default ''
     */
    var _this = _possibleConstructorReturn(this, (FixModel.__proto__ || Object.getPrototypeOf(FixModel)).call(this));

    _this.name = '';

    /**
     * Coordinates of the fix
     *
     * @property _fixPosition
     * @type {PositionModel}
     * @default null
     */
    _this._fixPosition = null;

    _this.init(fixName, fixCoordinate, airportPosition);
    return _this;
  }

  /**
   * Provides access to the position data of the instance
   *
   * @property position
   * @return {array}
   */


  _createClass(FixModel, [{
    key: 'init',


    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * @for FixModel
     * @method init
     * @param fixName {string}
     * @param fixCoordinate {array}
     * @param airportPosition {PositionModel}
     * @chainable
     */
    value: function init(fixName, fixCoordinate, airportPosition) {
      // TODO: should this be a throwing instead of returning early?
      if (!fixName || !fixCoordinate || !airportPosition) {
        return;
      }

      this.name = fixName.toUpperCase();
      this._fixPosition = new _PositionModel2.default(fixCoordinate, airportPosition, airportPosition.magneticNorthInRadians);

      return this;
    }

    /**
     * reset the current instance
     *
     * @for FixModel
     * @method reset
     * @chainable
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.name = '';
      this._fixPosition = null;

      return this;
    }

    /**
     * Returns a clone of an instance's `_fixPosition` property.
     *
     * It is important to note that this is a _clone_ and not a copy. Once any changes made to this instance will
     * not be reflected in the clone. This creates an entirely new instance of the `_fixPosition` property,
     * and after creation is completely independant of this instance.
     *
     * This is used with `StandardRouteWaypointModel` objects to obtain the position of a fix. This method
     * provides easy access to the `PositionModel` that already exists here.
     *
     * @for FixModel
     * @return {PositionModel}  a clone of the current `_fixPosition` property
     */

  }, {
    key: 'clonePosition',
    value: function clonePosition() {
      return (0, _cloneDeep3.default)(this._fixPosition);
    }
  }, {
    key: 'position',
    get: function get() {
      return this._fixPosition.position;
    }
  }]);

  return FixModel;
}(_BaseModel3.default);

exports.default = FixModel;

},{"../../base/BaseModel":556,"../../base/PositionModel":560,"lodash/cloneDeep":461}],548:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseModel2 = require('../../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Symbol that divides each route segment
 *
 * @property SEGMENT_SEPARATION_SYMBOL
 * @type {string}
 * @final
 */
var SEGMENT_SEPARATION_SYMBOL = '.';

/**
 * A route is assumed to have, at most, three parts.
 *
 * @property MAXIMUM_ROUTE_SEGMENT_LENGTH
 * @type {number}
 * @final
 */
var MAXIMUM_ROUTE_SEGMENT_LENGTH = 3;

// TODO: this class needs a better name
/**
 * @class RouteModel
 */

var RouteModel = function (_BaseModel) {
  _inherits(RouteModel, _BaseModel);

  /**
   * example `routeCode`
   *
   * ```
   * 'BETHL.GRNPA1.KLAS'
   * ```
   *
   * // TODO: should be able to support input of:
   * - KSFO.OFFSH9.SXC.V458.IPL.J2.JCT..LLO..ACT..KACT
   * which can be returned as:
   * - ['KSFO.OFFSH9.SXC', 'SXC.V458.IPL', 'IPL.J2.JCT', 'LLO', 'ACT', 'KACT']
   *
   * @for RouteModel
   * @constructor
   * @param routeCode {string}
   */
  function RouteModel(routeCode) {
    var _ret;

    _classCallCheck(this, RouteModel);

    var _this = _possibleConstructorReturn(this, (RouteModel.__proto__ || Object.getPrototypeOf(RouteModel)).call(this));

    if (typeof routeCode === 'undefined' || typeof routeCode !== 'string') {
      console.error('Invalid data type passed to RouteModel. Expected a string but received ' + routeCode);

      return _possibleConstructorReturn(_this);
    }

    if (!_this._isValidRouteCode(routeCode)) {
      // eslint-disable-next-line max-len
      throw new TypeError('Invalid routeCode passed to RouteModel. Expected a routeCode of the shape ORIGIN.BASE.DESTINATION but instead received ' + routeCode);
    }

    /**
     * @property entry
     * @type {string}
     * @default ''
     */
    _this.entry = '';

    /**
     * @property procedure
     * @type {string}
     * @default ''
     */
    _this.procedure = '';

    /**
     * @property exit
     * @type {string}
     * @default ''
     */
    _this.exit = '';

    return _ret = _this._init(routeCode), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * A single string that represents the entire route
   *
   * @property routeCode
   * @return {string}
   */


  _createClass(RouteModel, [{
    key: '_init',


    /**
     * Lifecycle method. Should be run only once on instantiation
     *
     * @for RouteModel
     * @method _init
     * @param routeCode {string}
     * @private
     */
    value: function _init(routeCode) {
      var _extractSegmentNamesF = this._extractSegmentNamesFromRouteCode(routeCode),
          entry = _extractSegmentNamesF.entry,
          base = _extractSegmentNamesF.base,
          exit = _extractSegmentNamesF.exit;

      this.entry = entry.toUpperCase();
      this.procedure = base.toUpperCase();
      this.exit = exit.toUpperCase();

      return this;
    }

    /**
     * reset this instance
     *
     * @for RouteModel
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.entry = '';
      this.procedure = '';
      this.exit = '';
    }

    /**
     * @for RouteModel
     * @method _extractSegmentNamesFromRouteCode
     * @param routeCode {string}
     * @return {object}
     * @private
     */

  }, {
    key: '_extractSegmentNamesFromRouteCode',
    value: function _extractSegmentNamesFromRouteCode(routeCode) {
      var routeSegments = routeCode.split(SEGMENT_SEPARATION_SYMBOL);

      return {
        entry: routeSegments[0],
        base: routeSegments[1],
        exit: routeSegments[2]
      };
    }

    /**
     * Verify that a routeCode has exactly 3 segments
     *
     * @for RouteModel
     * @method _isValidRouteCode
     * @param routeCode {string}
     * @return {boolean}
     * @private
     */

  }, {
    key: '_isValidRouteCode',
    value: function _isValidRouteCode(routeCode) {
      return routeCode.split(SEGMENT_SEPARATION_SYMBOL).length === MAXIMUM_ROUTE_SEGMENT_LENGTH;
    }
  }, {
    key: 'routeCode',
    get: function get() {
      return this.entry + '.' + this.procedure + '.' + this.exit;
    }
  }]);

  return RouteModel;
}(_BaseModel3.default);

exports.default = RouteModel;

},{"../../base/BaseModel":556}],549:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseModel2 = require('../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _PositionModel = require('../base/PositionModel');

var _PositionModel2 = _interopRequireDefault(_PositionModel);

var _core = require('../math/core');

var _circle = require('../math/circle');

var _unitConverters = require('../utilities/unitConverters');

var _vector = require('../math/vector');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class RunwayModel
 */
var RunwayModel = function (_BaseModel) {
    _inherits(RunwayModel, _BaseModel);

    /**
     * @for RunwayModel
     * @constructor
     * @param options {object}
     * @param end
     * @param airport {AirportModel}
     */
    function RunwayModel() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var end = arguments[1];
        var airport = arguments[2];

        _classCallCheck(this, RunwayModel);

        var _this = _possibleConstructorReturn(this, (RunwayModel.__proto__ || Object.getPrototypeOf(RunwayModel)).call(this));

        options.airport = airport;
        _this.airport = null;
        _this.angle = null;
        _this.elevation = 0;
        _this.delay = 2;
        _this.gps = [];
        _this.ils = {
            // TODO: what do these numbers mean? enumerate the magic numbers
            enabled: true,
            loc_maxDist: (0, _unitConverters.km)(25),
            gs_maxHeight: 9999,
            gs_gradient: (0, _unitConverters.degreesToRadians)(3)
        };
        _this.labelPos = [];
        _this.length = null;
        _this.midfield = [];
        _this.name = '';
        _this.position = [];
        _this.queue = [];
        _this.sepFromAdjacent = (0, _unitConverters.km)(3);

        _this.parse(options, end);
        return _this;
    }

    /**
     * @for RunwayModel
     * @method parse
     * @param data
     * @param end
     */


    _createClass(RunwayModel, [{
        key: 'parse',
        value: function parse(data, end) {
            this.airport = data.airport;

            if (data.delay) {
                this.delay = data.delay[end];
            }

            if (data.end) {
                var thisSide = new _PositionModel2.default(data.end[end], data.reference_position, data.magnetic_north);
                // FIXME: ressignment of an argument with an inline ternary? this line needs some work.
                var farSide = new _PositionModel2.default(data.end[end === 0 ? 1 : 0], data.reference_position, data.magnetic_north);

                // TODO: `gps` and `elevation` are available from the `PositionModel` and should be pulled from there
                // instead of setting direct properties. If direct properties are needed, use getters isntead.
                // GPS latitude and longitude position
                this.gps = [thisSide.latitude, thisSide.longitude];

                if (thisSide.elevation != null) {
                    this.elevation = thisSide.elevation;
                }

                if (this.elevation === 0 && this.airport.elevation !== 0) {
                    this.elevation = this.airport.elevation;
                }

                // relative position, based on center of map
                this.position = thisSide.position;
                this.length = (0, _vector.vlen)((0, _vector.vsub)(farSide.position, thisSide.position));
                // TODO: what is the 0.5 for? enumerate the magic number
                this.midfield = (0, _vector.vscale)((0, _vector.vadd)(thisSide.position, farSide.position), 0.5);
                this.angle = (0, _circle.radians_normalize)((0, _vector.vradial)((0, _vector.vsub)(farSide.position, thisSide.position)));
            }

            if (data.ils) {
                this.ils.enabled = data.ils[end];
            }

            if (data.ils_distance) {
                this.ils.loc_maxDist = (0, _unitConverters.km)(data.ils_distance[end]);
            }

            if (data.ils_gs_maxHeight) {
                this.ils.gs_maxHeight = data.ils_gs_maxHeight[end];
            }

            if (data.glideslope) {
                this.ils.gs_gradient = (0, _unitConverters.degreesToRadians)(data.glideslope[end]);
            }

            if (data.name_offset) {
                this.labelPos = data.name_offset[end];
            }

            if (data.name) {
                this.name = data.name[end];
            }

            if (data.sepFromAdjacent) {
                this.sepFromAdjacent = (0, _unitConverters.km)(data.sepFromAdjacent[end]);
            }
        }

        /**
         *
         *
         * @for RunwayModel
         * @method
         */

    }, {
        key: 'addQueue',
        value: function addQueue(aircraft) {
            this.queue.push(aircraft);
        }

        /**
         *
         *
         * @for RunwayModel
         * @method
         */

    }, {
        key: 'removeQueue',
        value: function removeQueue(aircraft, force) {
            if (this.queue[0] === aircraft || force) {
                this.queue.shift(aircraft);

                if (this.queue.length >= 1) {
                    this.queue[0].moveForward();
                }

                return true;
            }

            return false;
        }

        /**
         *
         *
         * @for RunwayModel
         * @method
         */

    }, {
        key: 'inQueue',
        value: function inQueue(aircraft) {
            return this.queue.indexOf(aircraft);
        }

        /**
         *
         *
         * @for RunwayModel
         * @method
         */

    }, {
        key: 'taxiDelay',
        value: function taxiDelay() {
            // TODO: what does 3 mean? enumerate the magic numbers.
            return (this.delay + Math.random()) * 3;
        }

        /**
         *
         *
         * @for RunwayModel
         * @method
         */

    }, {
        key: 'getGlideslopeAltitude',
        value: function getGlideslopeAltitude(distance, /* optional */gs_gradient) {
            if (!gs_gradient) {
                gs_gradient = this.ils.gs_gradient;
            }

            distance = Math.max(0, distance);
            var rise = (0, _core.tan)((0, _core.abs)(gs_gradient));

            // TODO: this logic could be abstracted to a helper.
            // TODO: what does 3280 mean? enumerate the magic number
            return this.elevation + rise * distance * 3280;
        }
    }]);

    return RunwayModel;
}(_BaseModel3.default);

exports.default = RunwayModel;

},{"../base/BaseModel":556,"../base/PositionModel":560,"../math/circle":583,"../math/core":584,"../math/vector":587,"../utilities/unitConverters":595}],550:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _BaseCollection2 = require('../../base/BaseCollection');

var _BaseCollection3 = _interopRequireDefault(_BaseCollection2);

var _RouteSegmentModel = require('./RouteSegmentModel');

var _RouteSegmentModel2 = _interopRequireDefault(_RouteSegmentModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A collection of `RouteSegment`s.
 *
 * Provide a way to deal with the various parts of a `StandardProcedureRoute` as defined in each
 * airport json file.
 *
 * Each SID is broken up into three route segments:
 * - `rwy` (optional)
 * - `body`
 * - `exitPoints` (optional)
 *
 * Each STAR is broken up into three route segments:
 * - `entryPoints` (optional)
 * - `body`
 * - `rwy` (optional)
 *
 * This collection is meant to contain the waypoints for a single route segment and can be
 * used to resaon about the route as a single unit.
 *
 * @class RouteSegmentCollection
 */
var RouteSegmentCollection = function (_BaseCollection) {
    _inherits(RouteSegmentCollection, _BaseCollection);

    /**
     * @constructor
     * @param routeSegments {object}
     */
    /* istanbul ignore next */
    function RouteSegmentCollection(routeSegments) {
        var _ret;

        _classCallCheck(this, RouteSegmentCollection);

        var _this = _possibleConstructorReturn(this, (RouteSegmentCollection.__proto__ || Object.getPrototypeOf(RouteSegmentCollection)).call(this));

        if (typeof routeSegments === 'undefined' || !(0, _isObject3.default)(routeSegments) || (0, _isArray3.default)(routeSegments)) {
            throw new TypeError('Expected routeSegments to be an object. Instead received ' + (typeof routeSegments === 'undefined' ? 'undefined' : _typeof(routeSegments)));
        }

        /**
         * Name of the RouteSegment
         *
         * @property name
         * @type {string}
         * @default ''
         */
        _this.name = '';

        return _ret = _this._init(routeSegments), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Provide access to the contents of `_items`
     *
     * @property items
     * @return {array}
     */


    _createClass(RouteSegmentCollection, [{
        key: '_init',


        /**
         * Lifecycle method. Should be run only once on instantiation.
         *
         * @for RouteSegmentCollection
         * @method _init
         * @param routeSegments {object}
         * @chainable
         * @private
         */
        value: function _init(routeSegments) {
            var _this2 = this;

            (0, _forEach3.default)(routeSegments, function (routeWaypoints, key) {
                var routeSegmentModel = new _RouteSegmentModel2.default(key, routeWaypoints);

                _this2._addSegmentToCollection(routeSegmentModel);
            });

            return this;
        }

        /**
         * Destroy the current instance
         *
         * @for RouteSegmentCollection
         * @method destroy
         * @chainable
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this._id = '';
            this.name = '';
            this._items = [];

            return this;
        }

        /**
         * Find a `RouteSegmentModel` within the collection by its name
         *
         * @for RouteSegmentCollection
         * @method findSegmentByName
         * @param segmentName {string}
         * @return {SegmentModel}
         */

    }, {
        key: 'findSegmentByName',
        value: function findSegmentByName(segmentName) {
            return (0, _find3.default)(this._items, { name: segmentName.toUpperCase() });
        }

        /**
         * Find a list of waypoints for a given `segmentName`
         *
         * @for RouteSegmentCollection
         * @method findWaypointsForSegmentName
         * @param segmentName {string}
         * @return {array}
         */

    }, {
        key: 'findWaypointsForSegmentName',
        value: function findWaypointsForSegmentName(segmentName) {
            var segment = this.findSegmentByName(segmentName);

            return segment.findWaypointsForSegment();
        }

        /**
         * Return a list of fixNames for all of the `RouteSegmentModel`s in the collection
         *
         * @for RouteSegmentCollection
         * @method gatherFixNamesForCollection
         * @return {array}
         */

    }, {
        key: 'gatherFixNamesForCollection',
        value: function gatherFixNamesForCollection() {
            return (0, _map3.default)(this._items, function (item) {
                return item.name;
            });
        }

        /**
         * Add a new segment to the collection
         *
         * @for RouteSegmentCollection
         * @method _addSegmentToCollection
         * @param segment {SegmentModel}
         * @chainable
         * @private
         */

    }, {
        key: '_addSegmentToCollection',
        value: function _addSegmentToCollection(segment) {
            if (!(segment instanceof _RouteSegmentModel2.default)) {
                // eslint-disable-next-line max-len
                throw new TypeError('Expected segment to be an instance of RouteSegmentModel, instead received ' + segment + '.');
            }

            this._items.push(segment);

            return this;
        }
    }, {
        key: 'items',
        get: function get() {
            return this._items;
        }
    }]);

    return RouteSegmentCollection;
}(_BaseCollection3.default);

exports.default = RouteSegmentCollection;

},{"../../base/BaseCollection":555,"./RouteSegmentModel":551,"lodash/find":466,"lodash/forEach":468,"lodash/isArray":476,"lodash/isObject":487,"lodash/map":496}],551:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _BaseModel2 = require('../../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _StandardRouteWaypointModel = require('./StandardRouteWaypointModel');

var _StandardRouteWaypointModel2 = _interopRequireDefault(_StandardRouteWaypointModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides an interface for dealing with a list of `StandardRouteWaypointModel`s that make up a given route segment.
 *
 * @class RouteSegmentModel
 */
var RouteSegmentModel = function (_BaseModel) {
    _inherits(RouteSegmentModel, _BaseModel);

    /**
     * segmentWaypoints should come in a similar shape to:
     * - ["_NAPSE068", "NAPSE", ["RIOOS", "A130+"], "COMPS"]
     *
     * @constructor
     * @param name {string}  Icao of particular waypoint
     * @param segmentWaypoints {array}  a mixed array of strings or arrays of strings
     */
    /* istanbul ignore next */
    function RouteSegmentModel(name) {
        var _ret;

        var segmentWaypoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        _classCallCheck(this, RouteSegmentModel);

        /**
         * Name of the RouteSegment
         *
         * @property name
         * @type {string}
         * @default ''
         * @private
         */
        var _this = _possibleConstructorReturn(this, (RouteSegmentModel.__proto__ || Object.getPrototypeOf(RouteSegmentModel)).call(this));

        _this.name = '';

        /**
         * `StandardRouteWaypointModel`s that make up the RouteSegment
         *
         * @property _items
         * @type {array}
         * @default []
         * @private
         */
        _this._items = [];

        return _ret = _this._init(name, segmentWaypoints), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Return the items in the collection
     *
     * @property items
     * @return {array}
     */


    _createClass(RouteSegmentModel, [{
        key: '_init',


        /**
         * Lifecycle method. Should be run only once on instantiation.
         *
         * @for RouteSegmentModel
         * @method _init
         * @param name {string}
         * @param segmentWaypoints {array}
         * @private
         */
        value: function _init(name, segmentWaypoints) {
            this.name = name;

            if ((0, _isArray3.default)(segmentWaypoints)) {
                this._createWaypointModelsFromList(segmentWaypoints);
            }

            return this;
        }

        /**
         * rest the current instance
         *
         * @for RouteSegmentModel
         * @method reset
         */

    }, {
        key: 'reset',
        value: function reset() {
            this.name = '';
            this._items = [];

            return this;
        }

        /**
         * Return a list of fixes for the RouteSegment.
         *
         * This will return a normalized list of fixes, ex:
         * - [FIXNAME, null]
         * - [FIXNAME, RESTRICTIONS]
         *
         * @for RouteSegmentModel
         * @method findWaypointsForSegment
         * @return fixList {array}
         */

    }, {
        key: 'findWaypointsForSegment',
        value: function findWaypointsForSegment() {
            var fixList = (0, _map3.default)(this._items, function (waypoint) {
                return waypoint.fix;
            });

            return fixList;
        }

        /**
         * @for RouteSegmentModel
         * @method _createWaypointModelsFromList
         * @param segmentWaypoints {array}
         * @return waypointModelList {array}
         */

    }, {
        key: '_createWaypointModelsFromList',
        value: function _createWaypointModelsFromList(segmentWaypoints) {
            var _this2 = this;

            (0, _forEach3.default)(segmentWaypoints, function (fixAndRestrictions) {
                var waypointModel = new _StandardRouteWaypointModel2.default(fixAndRestrictions);

                // TODO: calculate distance here

                _this2._addWaypointToCollection(waypointModel);
            });
        }

        /**
         * Add a new model to the collection and update length.
         *
         * @for RouteSegmentModel
         * @method _addWaypointToCollection
         * @param waypoint {StandardRouteWaypointModel}
         * @private
         */

    }, {
        key: '_addWaypointToCollection',
        value: function _addWaypointToCollection(waypoint) {
            if (!(waypoint instanceof _StandardRouteWaypointModel2.default)) {
                throw new TypeError('Expected waypoint to be an instance of StandardRouteWaypointModel, instead received ' + waypoint + '.');
            }

            this._items.push(waypoint);
        }
    }, {
        key: 'items',
        get: function get() {
            return this._items;
        }

        /**
         * Convenience property to get at the current length of `_items`.
         *
         * @property length
         * @type {number}
         */

    }, {
        key: 'length',
        get: function get() {
            return this._items.length;
        }
    }]);

    return RouteSegmentModel;
}(_BaseModel3.default);

exports.default = RouteSegmentModel;

},{"../../base/BaseModel":556,"./StandardRouteWaypointModel":554,"lodash/forEach":468,"lodash/isArray":476,"lodash/map":496}],552:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _BaseCollection2 = require('../../base/BaseCollection');

var _BaseCollection3 = _interopRequireDefault(_BaseCollection2);

var _StandardRouteModel = require('./StandardRouteModel');

var _StandardRouteModel2 = _interopRequireDefault(_StandardRouteModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Accept `sids` or `stars` data from an airport json file and create a collection of model objects.
 *
 * Provides and interface to reason about a `StandardRoute`, defined as either a SID or STAR.
 * Creates a `StandardRouteModel` for each route defined in the StandardRoute.
 *
 * @class StandardRouteCollection
 */
var StandardRouteCollection = function (_BaseCollection) {
    _inherits(StandardRouteCollection, _BaseCollection);

    /**
     * @constructor
     * @param standardRouteEnum {object}
     */
    /* istanbul ignore next */
    function StandardRouteCollection(standardRouteEnum) {
        var _ret;

        _classCallCheck(this, StandardRouteCollection);

        var _this = _possibleConstructorReturn(this, (StandardRouteCollection.__proto__ || Object.getPrototypeOf(StandardRouteCollection)).call(this));

        if (typeof standardRouteEnum === 'undefined') {
            return _possibleConstructorReturn(_this);
        }

        return _ret = _this._init(standardRouteEnum), _possibleConstructorReturn(_this, _ret);
    }

    // TODO: refactor into a reusable class that can be fed an `item` and will be consumed by the `CanvasController`
    /**
     * Return an identifier and a list of fixes in the order in which they should be drawn.
     *
     * Pulled directly from an airport json `draw` definition per route.
     *
     * @property draw
     * @return {array}
     */


    _createClass(StandardRouteCollection, [{
        key: '_init',


        /**
         * Lifecycle method. Should be run only once on instantiation.
         *
         * @for StandardRouteCollection
         * @method _init
         * @param standardRouteEnum {object}
         * @private
         */
        value: function _init(standardRouteEnum) {
            this._addRouteListToCollection(standardRouteEnum);

            return this;
        }

        /**
         * Destroy the current instance
         *
         * @for StandardRouteCollection
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this._items = [];

            return this;
        }

        // TODO: update implementations to accept the FixModel instead of an array
        /**
         * Find a list of fixes for a route, given an `icao`, `exitFixName` and `runwayName` parameter.
         *
         * @for StandardRouteCollection
         * @method getSID
         * @param icao {string}
         * @param exitFixName {string}
         * @param runwayName {string}
         * @return {array}
         */

    }, {
        key: 'findFixesForSidByRunwayAndExit',
        value: function findFixesForSidByRunwayAndExit(icao, exitFixName, runwayName) {
            if (!icao) {
                return;
            }

            var sid = this.findRouteByIcao(icao);

            return sid.findFixesAndRestrictionsForRunwayAndExit(runwayName, exitFixName);
        }

        // TODO: update implementations to accept the FixModel instead of an array
        /**
         * Find a list of fixes for a route, given an `icao`, `entryFixName` and `runwayName` parameter.
         *
         * Used to gather all the fixes for a give STAR route.
         *
         * @for StandardRouteCollection
         * @method getSID
         * @param icao {string}
         * @param entryFixName {string}
         * @param runwayName {string} (optional)
         * @return {array}
         */

    }, {
        key: 'findFixesForStarByEntryAndRunway',
        value: function findFixesForStarByEntryAndRunway(icao, entryFixName, runwayName) {
            if (!icao) {
                return;
            }

            var star = this.findRouteByIcao(icao);

            return star.findFixesAndRestrictionsForEntryAndRunway(entryFixName, runwayName);
        }

        /**
         * Find a list of `StandardWaypointModel`s for a specific route
         *
         * @for StandardRouteCollection
         * @method findFixModelsForRouteByEntryAndExit
         * @param icao {string}
         * @param entry {string}
         * @param exit {string}
         * @param isPreSpawn {boolean} flag used to determine if distances between waypoints should be calculated
         * @return {StandardRouteModel}
         */

    }, {
        key: 'findFixModelsForRouteByEntryAndExit',
        value: function findFixModelsForRouteByEntryAndExit(icao, entry, exit, isPreSpawn) {
            if (!icao) {
                return;
            }

            var route = this.findRouteByIcao(icao);

            return route.findStandardWaypointModelsForEntryAndExit(entry, exit, isPreSpawn);
        }

        /**
         * Find a random name of an `exitPoint` segment that exists within the collection.
         *
         * @for StandardRouteCollection
         * @method findRandomExitPointForSIDIcao
         * @param icao {string}
         * @return {string}
         */

    }, {
        key: 'findRandomExitPointForSIDIcao',
        value: function findRandomExitPointForSIDIcao(icao) {
            var sid = this.findRouteByIcao(icao);

            // if sid doesnt have any exit points it ends at fix for which the SID is named
            if (!sid.hasExitPoints()) {
                return sid.icao;
            }

            // if has exitPoints, return a randomly selected one from a list of exitFixNames
            var exitPointIcaos = sid.gatherExitPointNames();
            var maxIndex = exitPointIcaos.length - 1;
            var randomIndex = (0, _random3.default)(0, maxIndex);

            return exitPointIcaos[randomIndex];
        }

        /**
         * Find a `StandardRouteModel` within the collection given an `icao`
         *
         * @for StandardRouteCollection
         * @method findRouteByIcao
         * @param icao {string}
         * @return {StandardRouteModel|undefined}
         */

    }, {
        key: 'findRouteByIcao',
        value: function findRouteByIcao(icao) {
            return (0, _find3.default)(this._items, { icao: icao.toUpperCase() });
        }

        /**
         * @for StandardRouteCollection
         * @method hasRoute
         * @param routeName {string}
         * @return {boolean}
         */

    }, {
        key: 'hasRoute',
        value: function hasRoute(routeName) {
            return !(0, _isNil3.default)(this.findRouteByIcao(routeName));
        }

        /**
         * Add a list of sids to the collection
         *
         * @for StandardRouteCollection
         * @method _addRouteListToCollection
         * @param routeList {object}
         * @private
         */

    }, {
        key: '_addRouteListToCollection',
        value: function _addRouteListToCollection(routeList) {
            var _this2 = this;

            (0, _forEach3.default)(routeList, function (route) {
                var routeModel = new _StandardRouteModel2.default(route);

                _this2._addSidToCollection(routeModel);
            });

            return this;
        }

        /**
         * Add a `StandardRouteModel` to the collection and update length.
         *
         * @for StandardRouteCollection
         * @method _addSidToCollection
         * @param routeModel {StandardRouteModel}
         * @private
         */

    }, {
        key: '_addSidToCollection',
        value: function _addSidToCollection(routeModel) {
            if (!(routeModel instanceof _StandardRouteModel2.default)) {
                // eslint-disable-next-line max-len
                throw new TypeError('Expected routeModel to be an instance of StandardRouteModel, instead received ' + routeModel);
            }

            this._items.push(routeModel);

            return this;
        }
    }, {
        key: 'draw',
        get: function get() {
            return (0, _map3.default)(this._items, function (item) {
                var sidForCanvas = {};
                sidForCanvas.identifier = item.icao;

                if (!(0, _isEmpty3.default)(item.draw)) {
                    sidForCanvas.draw = item.draw;
                }

                return sidForCanvas;
            });
        }
    }]);

    return StandardRouteCollection;
}(_BaseCollection3.default);

exports.default = StandardRouteCollection;

},{"../../base/BaseCollection":555,"./StandardRouteModel":553,"lodash/find":466,"lodash/forEach":468,"lodash/isEmpty":480,"lodash/isNil":485,"lodash/map":496,"lodash/random":500}],553:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _BaseModel2 = require('../../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _RouteSegmentCollection = require('./RouteSegmentCollection');

var _RouteSegmentCollection2 = _interopRequireDefault(_RouteSegmentCollection);

var _RouteSegmentModel = require('./RouteSegmentModel');

var _RouteSegmentModel2 = _interopRequireDefault(_RouteSegmentModel);

var _distance = require('../../math/distance');

var _unitConverters = require('../../utilities/unitConverters');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Accepts a single route belonging to a SID or STAR and provides methods to reason about its contents.
 *
 * @class StandardRouteModel
 */
var StandardRouteModel = function (_BaseModel) {
    _inherits(StandardRouteModel, _BaseModel);

    /**
     * Expects an object in the form of (taken from `klas.sids.SHEAD9`):
     *
     *  {
     *    'icao': 'SHEAD9',
     *    'name': 'Shead Nine',
     *    'rwy': {
     *      '01L': [['BESSY', 'S230'], ['MDDOG', 'A90'], ['TARRK', 'A110']],
     *      '01R': [['BESSY', 'S230'], ['MDDOG', 'A90'], ['TARRK', 'A110']],
     *      '07L': ['WASTE', ['BAKRR', 'A70'], ['MINEY', 'A80+'], 'HITME'],
     *      '07R': ['JESJI', ['BAKRR', 'A70'], ['MINEY', 'A80+'], 'HITME'],
     *      '19L': ['FIXIX', ['ROPPR', 'A70'], ['MDDOG', 'A90'], ['TARRK', 'A110']],
     *      '19R': ['JAKER', ['ROPPR', 'A70'], ['MDDOG', 'A90'], ['TARRK', 'A110']],
     *      '25L': ['PIRMD', ['ROPPR', 'A70'], ['MDDOG', 'A90'], ['TARRK', 'A110']],
     *      '25R': ['RBELL', ['ROPPR', 'A70'], ['MDDOG', 'A90'], ['TARRK', 'A110']]
     *    },
     *    'body': [['SHEAD', 'A140+']],
     *    'exitPoints': {
     *      'KENNO': [['DBIGE', 'A210+'], ['BIKKR', 'A210+'], 'KENNO'],
     *      'OAL': [['DBIGE', 'A210+'], ['BIKKR', 'A210+'], 'KENNO', 'OAL']
     *    },
     *    'draw': [
     *      ['BESSY', 'MDDOG'],
     *      ['ROPPR', 'MDDOG', 'TARRK', 'SHEAD'],
     *      ['HITME', 'SHEAD', 'DBIGE', 'BIKKR', 'KENNO*'],
     *      ['KENNO', 'OAL*']
     *    ]
     *  }
     *
     * - `rwy` becomes the `_runwayCollection`. may not be included in a route definition
     * - `body` becomes the `_bodySegmentModel`. may not be included in a route definition
     * - `exitPoints` becomes the  `_exitCollection`. will only be present on SID routes
     * - `entryPoints` (not shown above) becomes the `_entryCollection`. will only be present on STAR routes
     *
     * @constructor
     * @param standardRoute {object}
     */
    /* istanbul ignore next */
    function StandardRouteModel(standardRoute) {
        var _ret;

        _classCallCheck(this, StandardRouteModel);

        var _this = _possibleConstructorReturn(this, (StandardRouteModel.__proto__ || Object.getPrototypeOf(StandardRouteModel)).call(this));

        _this._generateFixList = function (entrySegment, bodySegment, exitSegment) {
            // in the event that one of these functions doesnt find a result set it will return an empty array.
            // we leverage then `lodash.compact()` below to remove any empty values from the array before
            // returning the `fixList`.
            // These functions are called synchronously and order of operation is very important here.
            var fixList = [].concat(_toConsumableArray(entrySegment), _toConsumableArray(bodySegment), _toConsumableArray(exitSegment));

            return (0, _compact3.default)(fixList);
        };

        _this._findFixListForSidByRunwayAndExit = function (runwayName, exitFixName) {
            return _this._generateFixList(_this._findFixListInByCollectionAndSegmentName('rwy', '_entryCollection', runwayName), _this._findBodyFixList(), _this._findFixListInByCollectionAndSegmentName('exitPoints', '_exitCollection', exitFixName));
        };

        _this._findFixListForStarByEntryAndRunway = function (entryFixName, runwayName) {
            return _this._generateFixList(_this._findFixListInByCollectionAndSegmentName('entryPoints', '_entryCollection', entryFixName), _this._findBodyFixList(), _this._findFixListInByCollectionAndSegmentName('rwy', '_exitCollection', runwayName));
        };

        if (!(0, _isObject3.default)(standardRoute) || (0, _isArray3.default)(standardRoute)) {
            throw new TypeError('Expected standardRoute to be an object, instead received ' + (typeof standardRoute === 'undefined' ? 'undefined' : _typeof(standardRoute)));
        }

        /**
         * Name of the fix
         *
         * @property name
         * @type {string}
         * @default ''
         */
        _this.name = '';

        /**
         * SID icoa identifier
         *
         * @property icao
         * @type {string}
         * @default ''
         */
        _this.icao = '';

        /**
         * List of fixes in the order that they should be drawn
         *
         * Pulled straight from the json file.
         * Currently unused and is only a place to put the data.
         *
         * @property draw
         * @type {array}
         * @default
         */
        _this.draw = [];

        /**
         * List of `rwy` segments and fixes
         *
         * Pulled straight from the json file.
         * Currently unused and is only a place to put the data.
         *
         * @property rwy
         * @type {object}
         * @default {}
         */
        _this.rwy = {};

        /**
         * @property body
         * @type {array}
         * @default []
         */
        _this.body = [];

        /**
         * List of `exitPoints` segments and fixes
         *
         * Pulled straight from the json file.
         * Currently unused and is only a place to put the data.
         *
         * @property exitPoints
         * @type {object}
         * @default {}
         */
        _this.exitPoints = {};

        /**
         * `RouteSegmentModel` for the fixes belonging to the `body` segment
         *
         * @property _bodySegmentModel
         * @type {RouteSegmentModel}
         * @default null
         * @private
         */
        _this._bodySegmentModel = null;

        /**
         * Collection of `exitPoints` route segments
         *
         * This property should only be defined for SIDs and null for STAR routes
         *
         * @property _exitCollection
         * @type {RouteSegmentCollection}
         * @default null
         * @private
         */
        _this._exitCollection = null;

        /**
         * Collection of the `entryPoints` route segments.
         *
         * This property should only be defined for STARs and null for SID routes
         * @type {RouteSegmentCollection}
         * @default null
         * @private
         */
        _this._entryCollection = null;

        return _ret = _this._init(standardRoute), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * @for StandardRouteModel
     * @method _init
     * @param standardRoute {object}
     * @private
     */


    _createClass(StandardRouteModel, [{
        key: '_init',
        value: function _init(standardRoute) {
            this.icao = standardRoute.icao;
            this.name = standardRoute.name;
            this.draw = standardRoute.draw;
            this.rwy = standardRoute.rwy;
            this.body = standardRoute.body;
            this.exitPoints = (0, _get3.default)(standardRoute, 'exitPoints', {});
            this.entryPoints = (0, _get3.default)(standardRoute, 'entryPoints', {});
            this._bodySegmentModel = this._buildSegmentModel(standardRoute.body);

            this._buildEntryAndExitCollections(standardRoute);
        }

        /**
         * reset the current instance
         *
         * @for StandardRouteModel
         * @method reset
         */

    }, {
        key: 'reset',
        value: function reset() {
            this.icao = '';
            this.name = '';
            this.rwy = [];
            this.body = [];
            this.exitPoints = [];
            this.draw = [];
            this._bodySegmentModel = null;
            this._exitCollection = null;
            this._entryCollection = null;

            return this;
        }

        /**
         * Gather the fixes from all the route segments.
         *
         * Returns an 2d array in the shape of
         * - [[FIXNAME, FIX_RESTRICTIONS], [FIXNAME, FIX_RESTRICTIONS]]
         *
         * @for StandardRouteModel
         * @method findFixesAndRestrictionsForRunwayAndExit
         * @param runwayName {string}
         * @param exitFixName {string}
         * @return {array}
         */

    }, {
        key: 'findFixesAndRestrictionsForRunwayAndExit',
        value: function findFixesAndRestrictionsForRunwayAndExit(runwayName, exitFixName) {
            return this._findFixListForSidByRunwayAndExit(runwayName, exitFixName);
        }

        /**
         * Gather the fixes from all the route segments.
         *
         * @for StandardRouteModel
         * @method findFixesAndRestrictionsForEntryAndRunway
         * @param entryFixName {string}
         * @param runwayName {string}
         * @return {array}
         */

    }, {
        key: 'findFixesAndRestrictionsForEntryAndRunway',
        value: function findFixesAndRestrictionsForEntryAndRunway(entryFixName, runwayName) {
            return this._findFixListForStarByEntryAndRunway(entryFixName, runwayName);
        }

        /**
         * Collect all the `StandardWaypointModel` objects for a given route.
         *
         * @for StandardRouteModel
         * @method findStandardWaypointModelsForEntryAndExit
         * @param entry {string}
         * @param exit {string}
         * @param isPreSpawn {boolean} flag used to determine if distances between waypoints should be calculated
         * @return waypointList {array<StandardWaypointModel>}
         */

    }, {
        key: 'findStandardWaypointModelsForEntryAndExit',
        value: function findStandardWaypointModelsForEntryAndExit(entry, exit, isPreSpawn) {
            var waypointList = this._findStandardWaypointModelsForRoute(entry, exit);

            if (isPreSpawn) {
                this._updateWaypointsWithPreviousWaypointData(waypointList);
            }

            return waypointList;
        }

        /**
         * Given two `StandardWaypointModel` objects, calculate the distance in `nm` between them
         *
         * @for StandardRouteModel
         * @method calculateDistanceBetweenWaypoints
         * @param waypoint {StandardWaypointModel}
         * @param previousWaypoint {StandardWaypointModel}
         * @return distance {number}
         */

    }, {
        key: 'calculateDistanceBetweenWaypoints',
        value: function calculateDistanceBetweenWaypoints(waypoint, previousWaypoint) {
            var distance = (0, _distance.distance2d)(previousWaypoint, waypoint);

            return (0, _unitConverters.nm)(distance);
        }

        /**
         * Return the fixnames for the `_exitCollection`
         *
         * @for StandardRouteModel
         * @method gatherExitPointNames
         * @return {array}
         */

    }, {
        key: 'gatherExitPointNames',
        value: function gatherExitPointNames() {
            if (!this.hasExitPoints()) {
                return [];
            }

            return this._exitCollection.gatherFixNamesForCollection();
        }

        /**
         * Does the `_exitCollection` have any exitPoints?
         *
         * @for StandardRouteModel
         * @method hasExitPoints
         * @return {boolean}
         */

    }, {
        key: 'hasExitPoints',
        value: function hasExitPoints() {
            return this._exitCollection !== null && this._exitCollection.length > 0;
        }

        /**
         * Checks if a given `fixName` is present in the `_entryCollection` or `_exitCollection`.
         *
         * This method does not check for items within the `_bodySegmentModel`. In the future
         * this method may need to be extended to work with `_bodySegmentModel` items as well.
         *
         * @for StandardRouteModel
         * @method hasFixName
         * @param {string}
         * @return {boolean}
         */

    }, {
        key: 'hasFixName',
        value: function hasFixName(fixName) {
            return this._entryCollection && !(0, _isNil3.default)(this._entryCollection.findSegmentByName(fixName)) || this._exitCollection && !(0, _isNil3.default)(this._exitCollection.findSegmentByName(fixName));
        }

        /**
         * Build a new RouteSegmentModel for a segmentFixList
         *
         * `body` segment is expected to be an array, so instead of creating a collection like with `rwy` and
         * `exitPoints`, here we just create a model.  This provides the same methods the collections use, only
         * without the collection layer.
         *
         * @for StandardRouteModel
         * @method _buildSegmentModel
         * @param segmentFixList {array}
         * @return segmentModel {SegmentModel}
         * @private
         */

    }, {
        key: '_buildSegmentModel',
        value: function _buildSegmentModel(segmentFixList) {
            var segmentModel = new _RouteSegmentModel2.default('body', segmentFixList);

            return segmentModel;
        }

        /**
         * Build a collection of `RouteSegmentModel`s from a segment.
         *
         * @for StandardRouteModel
         * @method _buildSegmentCollection
         * @param segment {object}
         * @return segmentCollection {SegmentCollection}
         * @private
         */

    }, {
        key: '_buildSegmentCollection',
        value: function _buildSegmentCollection(segment) {
            if (typeof segment === 'undefined' || (0, _isEmpty3.default)(segment)) {
                return null;
            }

            var segmentCollection = new _RouteSegmentCollection2.default(segment);

            return segmentCollection;
        }

        /**
         * Determine if the `standardRoute` is a sid or a star and build the entry/exit collections
         * with the correct data.
         *
         * STARS will have `entryPoints` defined so `rwy` becomes the `_exitCollection`
         * SIDS will have `exitPoints` defined so `rwy` becomes the `_entryCollection`
         *
         * @for StandardRouteModel
         * @method _buildEntryAndExitCollections
         * @param standardRoute
         * @private
         */

    }, {
        key: '_buildEntryAndExitCollections',
        value: function _buildEntryAndExitCollections(standardRoute) {
            if ((0, _has3.default)(standardRoute, 'entryPoints')) {
                this._entryCollection = this._buildSegmentCollection(standardRoute.entryPoints);
                this._exitCollection = this._buildSegmentCollection(standardRoute.rwy);
            } else if ((0, _has3.default)(standardRoute, 'exitPoints')) {
                this._entryCollection = this._buildSegmentCollection(standardRoute.rwy);
                this._exitCollection = this._buildSegmentCollection(standardRoute.exitPoints);
            } else if ((0, _has3.default)(standardRoute, 'rwy')) {
                console.error('The \'' + this.icao + '\' procedure does not contain exitPoints or entryPoints. ' + 'If this is a SID, at least one exitPoint must be defined. If this is a STAR, at least ' + 'one entryPoint must be defined.');

                this._entryCollection = this._buildSegmentCollection(standardRoute.rwy);
            }
        }

        /**
         * Given three functions, spread their result in an array then return the compacted result.
         *
         * This method expects to receive arrays as results from the three methods passed in.
         * This wrapper method is provided to maintain a consistent interface while allowing for a varying set
         * of methods to be called in the place of each parameter.
         *
         * @for StandardRouteModel
         * @method _generateFixList
         * @param entrySegment {function}
         * @param bodySegment {function}
         * @param exitSegment {function}
         * @return {array}
         * @private
         */


        /**
         * Given a `runwayName` and `exitFixName`, find a list of fixes for the `rwy`, `body` and `exitPoints` segments.
         *
         * @for StandardRouteModel
         * @method _findFixListForSidByRunwayAndExit
         * @param runwayName {string}
         * @param exitFixName {string}
         * @return fixList {array}
         * @private
         */


        /**
         * Given an `entryFixName` and/or a `runwayName`, find a list of fixes for the `entryPoints`,
         * `body` and `rwy` segments.
         *
         * @for StandardRouteModel
         * @method _findFixListForStarByEntryAndRunway
         * @param entryFixName {string}
         * @param runwayName {string} (optional)
         * @return {array}
         */

    }, {
        key: '_findFixListInByCollectionAndSegmentName',


        /**
         * Given an `originalCollectionName`, `collectionName` and a `segmentName`, return a normalized list of
         * fixes with restrictions.
         *
         * @for StandardRouteModel
         * @method _findFixListInByCollectionAndSegmentName
         * @param originalCollectionName {string}  the name of the original collection from airport json,
         *                                         one of: [entryPoints, rwy, exitPoints]
         * @param collectionName {string}  collectionName as defined here, one of: [_entryCollection, _exitCollection]
         * @segmentName {string}  name of the segment to search for
         * @return array {array<array>}
         */
        value: function _findFixListInByCollectionAndSegmentName(originalCollectionName, collectionName, segmentName) {
            var originalCollection = (0, _get3.default)(this, originalCollectionName, null);
            var collection = (0, _get3.default)(this, collectionName, null);

            // specifically checking for an empty string here because this param gets a default of '' when
            // it is received in to the public method
            if (!originalCollection || !collection || segmentName === '') {
                return [];
            }

            return collection.findWaypointsForSegmentName(segmentName);
        }

        /**
         * Gather a list of `StandardWaypointModel` objects for a particular route.
         *
         * @for StandardRouteModel
         * @method _findStandardWaypointModelsForRoute
         * @param entry {string}
         * @param exti {string}
         * @return {array<StandardWaypointModel>}
         */

    }, {
        key: '_findStandardWaypointModelsForRoute',
        value: function _findStandardWaypointModelsForRoute(entry, exit) {
            var entrySegmentItems = [];
            var exitSegmentItems = [];

            if (this._entryCollection) {
                var entrySegment = this._entryCollection.findSegmentByName(entry);

                if (typeof entrySegment === 'undefined') {
                    throw new TypeError('Expected \'entry\' to exist in the RouteSegmentCollection, but \'' + this.icao + '\' ' + ('does not have an entry of \'' + entry + '\''));
                }

                entrySegmentItems = entrySegment.items;
            }

            if (this._exitCollection) {
                var exitSegment = this._exitCollection.findSegmentByName(exit);

                if (typeof exitSegment === 'undefined') {
                    throw new TypeError('Expected \'exit\' to exist in the RouteSegmentCollection, but \'' + this.icao + '\' ' + ('does not have an exit of \'' + exit + '\''));
                }

                exitSegmentItems = exitSegment.items;
            }

            return this._generateFixList(entrySegmentItems, this._bodySegmentModel.items, exitSegmentItems);
        }

        /**
         * Find list of waypoints for the `body` segment
         *
         * @for StandardRouteModel
         * @method _findBodyFixList
         * @return {array}
         * @private
         */

    }, {
        key: '_findBodyFixList',
        value: function _findBodyFixList() {
            if (typeof this.body === 'undefined' || this.body.length === 0) {
                return [];
            }

            return this._bodySegmentModel.findWaypointsForSegment();
        }

        /**
         * Update each `StandardRouteWaypointModel` in the list the with disance from the previous waypoint, and
         * that waypoint's name.
         *
         * @for StandardRouteModel
         * @method _updateWaypointsWithPreviousWaypointData
         * @parma waypointModelList {array<StandardRouteWaypointModel>}
         * @private
         */

    }, {
        key: '_updateWaypointsWithPreviousWaypointData',
        value: function _updateWaypointsWithPreviousWaypointData(waypointModelList) {
            var _this2 = this;

            (0, _forEach3.default)(waypointModelList, function (waypoint, i) {
                var previousWaypoint = waypointModelList[i - 1];
                if (i === 0) {
                    previousWaypoint = waypoint;
                }

                var distance = _this2.calculateDistanceBetweenWaypoints(waypoint.position, previousWaypoint.position);
                waypoint.distanceFromPreviousWaypoint = distance;
                waypoint.previousStandardWaypointName = previousWaypoint.name;
            });
        }
    }]);

    return StandardRouteModel;
}(_BaseModel3.default);

exports.default = StandardRouteModel;

},{"../../base/BaseModel":556,"../../math/distance":585,"../../utilities/unitConverters":595,"./RouteSegmentCollection":550,"./RouteSegmentModel":551,"lodash/compact":462,"lodash/forEach":468,"lodash/get":469,"lodash/has":470,"lodash/isArray":476,"lodash/isEmpty":480,"lodash/isNil":485,"lodash/isObject":487}],554:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _BaseModel2 = require('../../base/BaseModel');

var _BaseModel3 = _interopRequireDefault(_BaseModel2);

var _FixCollection = require('../Fix/FixCollection');

var _FixCollection2 = _interopRequireDefault(_FixCollection);

var _Waypoint = require('../../aircraft/FlightManagementSystem/Waypoint');

var _Waypoint2 = _interopRequireDefault(_Waypoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @property NAME_INDEX
 * @type {number}
 * @final
 */
var NAME_INDEX = 0;

/**
 * @property RESTRICTION_INDEX
 * @type {number}
 * @final
 */
var RESTRICTION_INDEX = 1;

/**
 * @property RESTRICTION_SEPARATOR
 * @type {string}
 * @final
 */
var RESTRICTION_SEPARATOR = '|';

/**
 * @property ALTITUDE_RESTRICTION_PREFIX
 * @type {string}
 * @final
 */
var ALTITUDE_RESTRICTION_PREFIX = 'A';

/**
 * @property SPEED_RESTRICTION_PREFIX
 * @type {string}
 * @final
 */
var SPEED_RESTRICTION_PREFIX = 'S';

/**
 * A route waypoint describes a `fixName` and any altitude or speed restrictions for that fix.
 *
 * @class StandardRouteWaypointModel
 * @extends BaseModel
 */

var StandardRouteWaypointModel = function (_BaseModel) {
  _inherits(StandardRouteWaypointModel, _BaseModel);

  /**
   * Expects `routeWaypoint` to be in one of these forms:
   * - ["FRAWG", "A80+|S210+"]
   * - ["FRAWG", "A80-|S210"]
   * - ["FRAWG", "A80"]
   * - ["FRAWG", "S210"]
   * - "FRAWG"
   *
   * @constructor
   * @param routeWaypoint {array|string}
   */
  function StandardRouteWaypointModel(routeWaypoint) {
    var _ret2;

    _classCallCheck(this, StandardRouteWaypointModel);

    var _this = _possibleConstructorReturn(this, (StandardRouteWaypointModel.__proto__ || Object.getPrototypeOf(StandardRouteWaypointModel)).call(this, routeWaypoint));

    if (typeof routeWaypoint === 'undefined') {
      var _ret;

      return _ret = _this, _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Name of the fix
     *
     * @property name
     * @type {string}
     * @default ''
     * @private
     */
    _this.name = '';

    /**
     * Any restrictions for a given fix
     *
     * ex:
     * - "A80+|S210"
     * - "A80-"
     * - "S230"
     *
     * using null here to match current api, if restrictions dont exist for a given waypoint
     * the consumers are expecting this to be null.
     *
     * @property _restrictions
     * @type {string|null}
     * @default null
     * @private
     */
    _this._restrictions = null;

    /**
     * NOT IN USE
     *
     * Required altitude for a fix
     *
     * @property _altitude (optional)
     * @type {number}
     * @default null
     * @private
     */
    _this._altitude = null;

    // TODO: This will need to be implemented in the future as an emuneration. Something to the effect of: {BELOW|AT|ABOVE}
    /**
     * NOT IN USE
     *
     * Altitude constraints, if any, for a fix.
     *
     * @property _altitudeConstraint (options)
     * @type {string}
     * @default ''
     * @private
     */
    _this._altitudeConstraint = '';

    /**
     * NOT IN USE
     *
     * Speed constraint, if any, for a fix.
     *
     * @property _speed (optional)
     * @type {string}
     * @default null
     * @private
     */
    _this._speed = null;

    /**
     * Positon information for the current waypoint
     *
     * Specific bits of this property are exposed via public getters.
     * This property should never be modified by an exteral method.
     *
     * @property _waypointPosition
     * @type {PositionModel}
     * @default null
     * @private
     */
    _this._waypointPosition = null;

    /**
     * Distance in nm from the previous waypoint.
     *
     * This property is set exterally by the `StandardRouteModel` and used only when called via
     * `ArrivalBase.preSpawn()`.
     *
     * This value is mutable and is not intended to be re-used after its initial use.
     *
     * @property distanceFromPreviousWaypoint
     * @type {number}
     * @default -1
     */
    _this.distanceFromPreviousWaypoint = -1;

    /**
     * Name of the previous `StandardWaypointModel` object in a route
     *
     * This property is set exterally by the `StandardRouteModel` and used only when called via
     * `ArrivalBase.preSpawn()`.
     *
     * This value is mutable and is not intended to be re-used after its initial use.
     *
     * @property previousStandardWaypointName
     * @type {string}
     * @default ''
     */
    _this.previousStandardWaypointName = '';

    return _ret2 = _this._init(routeWaypoint).clonePoisitonFromFix(), _possibleConstructorReturn(_this, _ret2);
  }

  /**
   * Return this waypoint's `position` propery
   *
   * @property position
   * @return {array}
   */


  _createClass(StandardRouteWaypointModel, [{
    key: '_init',


    /**
     * Lifecycle method. Should be run only once on instantiation.
     *
     * @for StandardRouteWaypointModel
     * @method _init
     * @param routeWaypoint {array|string}
     * @chainable
     * @private
     */
    value: function _init(routeWaypoint) {
      // if we receive a string, this fix doesnt have any restrictions so we only need to set `name`
      if (typeof routeWaypoint === 'string') {
        this.name = routeWaypoint;

        return this;
      }

      this.name = routeWaypoint[NAME_INDEX];
      // temporary property. should end up as a getter that wraps private methods
      this._restrictions = routeWaypoint[RESTRICTION_INDEX];

      this._parseWaypointRestrictions(routeWaypoint[RESTRICTION_INDEX]);

      return this;
    }

    /**
     * reset the current model instance
     *
     * @for StandardRouteWaypointModel
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.name = '';
      this._restrictions = null;
      this._altitude = null;
      this._altitudeConstraint = '';
      this._speed = null;

      return this;
    }

    /**
     * Find the matching fix from the `FixCollection` and clone its `PositionModel` this `_waypointPosition`
     *
     * @for StandardRouteWaypointModel
     * @method _clonePoisitonFromFix
     * @param fixCollection {FixCollection}
     * @private
     */

  }, {
    key: 'clonePoisitonFromFix',
    value: function clonePoisitonFromFix() {
      var fixModel = _FixCollection2.default.findFixByName(this.name);

      if (!fixModel) {
        console.warn('The following fix was not found in the list of fixes for this Airport: ' + this.name);

        return this;
      }

      this._waypointPosition = fixModel.clonePosition();

      return this;
    }

    /**
     * @for StandardRouteWaypointModel
     * @method generateFmsWaypoint
     * @param airport {AirportInstanceModel}
     * @return {Waypoint}
     */

  }, {
    key: 'generateFmsWaypoint',
    value: function generateFmsWaypoint(airport) {
      var fmsWaypoint = {
        fix: this.name,
        fixRestrictions: {
          alt: this._altitude,
          spd: this._speed
        }
      };

      return new _Waypoint2.default(fmsWaypoint, airport);
    }

    /**
     * Parse any waypoint restrictions
     *
     * Parse a single string into:
     * - `this._altitude`            = expressed in feet
     * - `this._altitudeConstraint`  = {BELOW|AT|ABOVE}
     * - `this._speed`      = expressed in kts
     *
     * Exapmles:
     * - "A80+|S210"
     * - "A80-|S210"
     * - "A80"
     * - "S210"
     *
     * @for StandardRouteWaypointModel
     * @method _parseWaypointRestrictions
     * @param waypointRestrictions {string}
     * @private
     */

  }, {
    key: '_parseWaypointRestrictions',
    value: function _parseWaypointRestrictions(waypointRestrictions) {
      if ((0, _isNil3.default)(waypointRestrictions)) {
        return;
      }

      var restrictionPieces = this._extractRestrictionPieces(waypointRestrictions);

      for (var i = 0; i < restrictionPieces.length; i++) {
        var restriction = restrictionPieces[i];

        // looking at the first letter of a restrictionPiece here.
        if (restriction[0] === ALTITUDE_RESTRICTION_PREFIX) {
          this._setAltitudeRestriction(restriction);
        } else if (restriction[0] === SPEED_RESTRICTION_PREFIX) {
          this._setSpeedRestriction(restriction);
        }
      }
    }

    /**
     * @for StandardRouteWaypointModel
     * @method _setAltitudeRestriction
     * @param altitudeRestriction {string}
     * @private
     */

  }, {
    key: '_setAltitudeRestriction',
    value: function _setAltitudeRestriction(altitudeRestriction) {
      this._altitude = altitudeRestriction.substr(1);
    }

    /**
     * @for StandardRouteWaypointModel
     * @method _setSpeedRestriction
     * @param speedRestriction {string}
     * @private
     */

  }, {
    key: '_setSpeedRestriction',
    value: function _setSpeedRestriction(speedRestriction) {
      this._speed = speedRestriction.substr(1);
    }

    /**
     * @for StandardRouteWaypointModel
     * @method _extractRestrictionPieces
     * @param waypointRestrictions {array<string>}
     * @@return {string}
     * @private
     */

  }, {
    key: '_extractRestrictionPieces',
    value: function _extractRestrictionPieces(waypointRestrictions) {
      return waypointRestrictions.split(RESTRICTION_SEPARATOR);
    }
  }, {
    key: 'position',
    get: function get() {
      return this._waypointPosition.position;
    }

    /**
     * Return this waypoint's `gps` position property
     *
     * @property gps
     * @return {array}
     */

  }, {
    key: 'gps',
    get: function get() {
      return this._waypointPosition.gps;
    }

    /**
     * Return this waypoint's `gpsXY` position property
     *
     * @property gps
     * @return {array}
     */

  }, {
    key: 'gpsXY',
    get: function get() {
      return this._waypointPosition.gpsXY;
    }

    /**
     * This will return a normalized fix in the shape of `[FIXNAME, FIX_RESTRICTIONS]`.
     *
     * Fixes without restrictions are brought in to the application as a single string, however, all
     * fixes are consumed as an array. `_restrictions` are initialized as null, thus if there are
     * no restrictions for a fix this getter will return `[FIXNAME, null]`
     *
     * @for StandardRouteWaypointModel
     * @property fix
     * @return {array}
     */

  }, {
    key: 'fix',
    get: function get() {
      return [this.name, this._restrictions];
    }
  }]);

  return StandardRouteWaypointModel;
}(_BaseModel3.default);

exports.default = StandardRouteWaypointModel;

},{"../../aircraft/FlightManagementSystem/Waypoint":530,"../../base/BaseModel":556,"../Fix/FixCollection":546,"lodash/isNil":485}],555:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base class from which a collection type class can inherit from.
 *
 * This class is meant to be extended and should never be used directly.
 *
 * @class BaseCollection
 */
var BaseCollection = function () {
  /**
   * @constructor
   * @for BaseCollection
   */
  function BaseCollection() {
    _classCallCheck(this, BaseCollection);

    /**
     * Unigue string id that can be used to differentiate this model instance from another.
     *
     * @property _id
     * @type {string}
     * @private
     */
    this._id = (0, _uniqueId3.default)();

    /**
     * @property _items
     * @type {array}
     * @default []
     * @private
     */
    this._items = [];
  }

  /**
   * Current length of the collection
   *
   * @property length
   * @return {number}
   */


  _createClass(BaseCollection, [{
    key: '_init',


    /**
     * Initialize the model properties. Should be run on instantiation and, though not desired,
     * could be run multiple times after instantiation.
     *
     * This method may be called by the constructor or from a public fascade.
     *
     * @for BaseCollection
     * @method _init
     * @private
     */
    value: function _init() {
      throw new TypeError('BaseCollection#_init has not been implemented by the extending class');
    }

    /**
     * Destory the current instance.
     *
     * When implemented by the inheriting class, this method should un-set all class properties
     * and remove any handlers.
     *
     * @for BaseCollection
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      throw new TypeError('BaseCollection#destroy has not been implemented by the extending class');
    }
  }, {
    key: 'length',
    get: function get() {
      return this._items.length;
    }
  }]);

  return BaseCollection;
}();

exports.default = BaseCollection;

},{"lodash/uniqueId":510}],556:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base class for all Model objects to inherit from.
 *
 * This class is meant to be extended and should never be used directly.
 *
 * @class BaseModel
 */
var BaseModel = function () {
  function BaseModel() {
    _classCallCheck(this, BaseModel);

    /**
     * Unigue string id that can be used to differentiate this model instance from another.
     *
     * @property _id
     * @type {string}
     * @private
     */
    this._id = (0, _uniqueId3.default)();
  }

  /**
   * Initialize the model properties. Should be run on instantiation and, though not desired,
   * could be run multiple times after instantiation.
   *
   * This method may be called by the constructor or from a public fascade.
   *
   * @for BaseModel
   * @method _init
   * @private
   */


  _createClass(BaseModel, [{
    key: '_init',
    value: function _init() {
      throw new TypeError('BaseModel#_init method must be implemented by the class extending BaseModel');
    }

    /**
     * Destory the current instance.
     *
     * When implemented by the inheriting class, this method should un-set all class properties
     * and remove any handlers.
     *
     * @for BaseModel
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      throw new TypeError('BaseModel#reset method must be implemented by the class extending BaseModel');
    }
  }]);

  return BaseModel;
}();

exports.default = BaseModel;

},{"lodash/uniqueId":510}],557:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _ModelSourcePool = require('./ModelSourcePool');

var _ModelSourcePool2 = _interopRequireDefault(_ModelSourcePool);

var _modelSourceClassMap = require('./modelSourceClassMap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides a pulic gateway to the `modelSourcePool`.
 *
 * This class has only one concern, brokering changes to the `modelSourcePool`.
 *
 * @class ModelSourceFactory
 */
var ModelSourceFactory = function () {
    function ModelSourceFactory() {
        _classCallCheck(this, ModelSourceFactory);
    }

    _createClass(ModelSourceFactory, [{
        key: 'getModelSourceForType',

        /**
         * Given a model type, retrieve a model from the `modelSourcePool`.
         *
         * @for ModelSourceFactory
         * @method getModelSourceForType
         * @param type {string}                 constructor name. must be incldued in `CLASS_MAP` dictonary
         * @param args {*[]}                    parameters used for initializing a `modelSource` instance
         * @return modelSource {constructor}    one of CLASS_MAP
         */
        value: function getModelSourceForType(type) {
            if (!(0, _has3.default)(_modelSourceClassMap.CLASS_MAP, type)) {
                throw new TypeError('Unsupported type passed to ModelSourceFactory: ' + type);
            }

            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            var modelSource = _ModelSourcePool2.default.releaseReusable.apply(_ModelSourcePool2.default, [type].concat(args));

            return modelSource;
        }

        /**
         * Return a model back to the `modelSourcePool`.
         *
         * @for ModelSourceFactory
         * @method returnModelToPool
         * @param model {constructor}  one of CLASS_MAP
         */

    }, {
        key: 'returnModelToPool',
        value: function returnModelToPool(model) {
            if (!(0, _has3.default)(_modelSourceClassMap.CLASS_MAP, model.constructor.name)) {
                throw new TypeError('Unsupported type passed to ModelSourceFactory: ' + model.constructor.name);
            }

            _ModelSourcePool2.default.returnReusable(model);
        }
    }]);

    return ModelSourceFactory;
}();

exports.default = new ModelSourceFactory();

},{"./ModelSourcePool":558,"./modelSourceClassMap":559,"lodash/has":470}],558:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _without2 = require('lodash/without');

var _without3 = _interopRequireDefault(_without2);

var _BaseCollection2 = require('../BaseCollection');

var _BaseCollection3 = _interopRequireDefault(_BaseCollection2);

var _modelSourceClassMap = require('./modelSourceClassMap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @property MAX_POOL_SIZE_PER_MODEL
 * @type {number}
 * @final
 */
var MAX_POOL_SIZE_PER_MODEL = 300;

/**
 * @property MAX_POOL_SIZE
 * @type {number}
 * @final
 */
var MAX_POOL_SIZE = MAX_POOL_SIZE_PER_MODEL * _modelSourceClassMap.CLASS_MAP_LENGTH;

/**
 * A collection of model objects that are not in use.
 *
 * This provides:
 * - a way to instantiate a `MAX_POOL_SIZE_PER_MODEL` number of model objects
 * - a way to release a model for use within the app and remove it from the pool
 * - a way to return a model after use and add it back into the pool
 *
 * This allows for decreased garbage collection because the model instances being used are already created. The
 * app isn't always creating and destroying classes, instead it is creating, using and re-using the same models.
 *
 * see: (Object Pool)[https://sourcemaking.com/design_patterns/object_pool] on
 * (sourcemaking.com)[https://sourcemaking.com] for more information.
 *
 * @class ModelSourcePool
 * @extends BaseCollection
 */

var ModelSourcePool = function (_BaseCollection) {
    _inherits(ModelSourcePool, _BaseCollection);

    /**
     * @constructor
     * @for ModelSourcePool
     */
    function ModelSourcePool() {
        var _ret;

        _classCallCheck(this, ModelSourcePool);

        // NOT IN USE
        /**
         * Maximum number of instances per model/reusable allowing in the pool
         *
         * This property is also used for pre-warming the pool on instantiation
         *
         * @property _maxPoolSizePerModel
         * @type {number}
         * @default MAX_POOL_SIZE
         * @private
         */
        var _this = _possibleConstructorReturn(this, (ModelSourcePool.__proto__ || Object.getPrototypeOf(ModelSourcePool)).call(this));

        _this._maxPoolSizePerModel = MAX_POOL_SIZE;

        return _ret = _this._hydratePool(), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Add a reusable to the pool
     *
     * @for ModelSourcePool
     * @method returnReusable
     * @param modelToAdd {constructor} one of CLASS_MAP
     */


    _createClass(ModelSourcePool, [{
        key: 'returnReusable',
        value: function returnReusable(modelToAdd) {
            if (!(0, _has3.default)(_modelSourceClassMap.CLASS_MAP, modelToAdd.constructor.name)) {
                throw new TypeError('Unsupported constructor passed to ModelSourcePool: ' + modelToAdd.constructor.name);
            }

            this._items.push(modelToAdd);
        }

        /**
         * Remove a reusable from the collection and return it for use by the caller
         *
         * @for ModelSourcePool
         * @method releaseReusable
         * @param constructorName {string}  constructor name
         * @param args {*[]}                parameters used for initializing a `modelSource` instance
         * @return model {constructor}      one of CLASS_MAP
         */

    }, {
        key: 'releaseReusable',
        value: function releaseReusable(constructorName) {
            var _model;

            var model = this._findModelByConstructorName(constructorName);

            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            if (!model) {
                model = new (Function.prototype.bind.apply(_modelSourceClassMap.CLASS_MAP[constructorName], [null].concat(args)))();
            }

            (_model = model).init.apply(_model, args);

            return model;
        }

        /**
         * On instantiation pre-warm the pool with reusables so they don't need to be created at run time.
         *
         * @for ModelSourcePool
         * @method _hydratePool
         * @private
         */

    }, {
        key: '_hydratePool',
        value: function _hydratePool() {
            var _this2 = this;

            (0, _forEach3.default)(_modelSourceClassMap.CLASS_MAP, function (ModelSource) {
                for (var i = 0; i < MAX_POOL_SIZE_PER_MODEL; i++) {
                    var model = new ModelSource();

                    _this2._items.push(model);
                }
            });
        }

        /**
         * @for ModelSourcePool
         * @method _findModelByConstructorName
         * @param constructorName {string}  the name of a constructor
         * @return model {constructor}      one of CLASS_MAP
         * @private
         */

    }, {
        key: '_findModelByConstructorName',
        value: function _findModelByConstructorName(constructorName) {
            var model = (0, _find3.default)(this._items, function (model) {
                return model.constructor.name === constructorName;
            });

            if ((0, _isNil3.default)(model)) {
                return null;
            }

            this._removeItem(model);

            return model;
        }

        /**
         * Remove a specific instance from the pool
         *
         * When a reusable has been requested, it mush be removed from the pool
         *
         * @for ModelSourcePool
         * @method _removeItem
         * @param model {constructor} one of CLASS_MAP
         * @private
         */

    }, {
        key: '_removeItem',
        value: function _removeItem(model) {
            this._items = (0, _without3.default)(this._items, model);
        }
    }]);

    return ModelSourcePool;
}(_BaseCollection3.default);

exports.default = new ModelSourcePool();

},{"../BaseCollection":555,"./modelSourceClassMap":559,"lodash/find":466,"lodash/forEach":468,"lodash/has":470,"lodash/isNil":485,"lodash/without":513}],559:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLASS_MAP_LENGTH = exports.CLASS_MAP = undefined;

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _FixModel = require('../../airport/Fix/FixModel');

var _FixModel2 = _interopRequireDefault(_FixModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import Waypoint from '../../aircraft/Waypoint';
// import PositionModel from '../PositionModel';

/**
 * A map of Constructor names to constructor functions
 *
 * @property CLASS_MAP
 * @type {object}
 * @final
 */
var CLASS_MAP = exports.CLASS_MAP = {
  /**
   * @memberof CLASS_MAP
   * @property FixModel
   * @type {FixModel}
   * @final
   */
  FixModel: _FixModel2.default

  // TODO: Future additions to the pool each of these models need some work in orer to integrate
  // into the pool structure
  //
  // /**
  //  * @memberof CLASS_MAP
  //  * @property Waypoint
  //  * @type {Waypoint}
  //  * @final
  //  */
  // Waypoint: Waypoint
  // /**
  //  * @memberof CLASS_MAP
  //  * @property PositionModel
  //  * @type {PositionModel}
  //  * @final
  //  */
  // PositionModel: PositionModel
};

/**
 * Provide a length number that can be accessed externally
 *
 * Since CLASS_MAP is an object, determining the length (number of keys) is a two-step process.
 * We do that here so any class that needs to know the length can simply import this property.
 *
 * @property CLASS_MAP_LENGTH
 * @type {number}
 */
var CLASS_MAP_LENGTH = exports.CLASS_MAP_LENGTH = (0, _keys3.default)(CLASS_MAP).length;

},{"../../airport/Fix/FixModel":547,"lodash/keys":492}],560:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

var _positionModelHelpers = require('./positionModelHelpers');

var _circle = require('../math/circle');

var _unitConverters = require('../utilities/unitConverters');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @property LATITUDE_INDEX
 * @type {number}
 * @final
 */
var LATITUDE_INDEX = 0;

/**
 * @property LONGITUDE_INDEX
 * @type {number}
 * @final
 */
var LONGITUDE_INDEX = 1;

/**
 * @property ELEVATION_INDEX
 * @type {number}
 * @final
 */
var ELEVATION_INDEX = 2;

/**
 * A physical location on the Earth's surface
 *
 * properties:
 *   latitude - Latitude in decimal degrees
 *   longitude - Longitude in decimal degrees
 *   elevation - Elevation in feet
 *   reference_position - Position to use when calculating offsets
 *   x - Offset from reference position in km
 *   y - Offset from reference position in km
 *   position - Array containing the x,y pair
 *
 * @class Position
 */

var PositionModel = function () {
    /**
     * coordinates may contain an optional elevation as a third element.
     * It must be suffixed by either 'ft' or 'm' to indicate the units.
     *
     * Latitude and Longitude numbers may be one of the following forms:
     *   Decimal degrees - 'N47.112388112'
     *   Decimal minutes - 'N38d38.109808'
     *   Decimal seconds - 'N58d27m12.138'
     *
     * @for PositionModel
     * @constructor
     * @param coordinates {array}               Array containing offset pair or latitude/longitude pair
     * @param reference {PositionModel|null}    Position to use for calculating offsets when lat/long given
     * @param magnetic_north {number}           magnetic north direction
     * @param mode {string}                     Set to 'GPS' to indicate you are inputting lat/long that should
     *                                          be converted to positions
     */
    function PositionModel() {
        var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var reference = arguments[1];
        var magnetic_north = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        _classCallCheck(this, PositionModel);

        /**
         * @property _id
         * @type {string}
         */
        this._id = (0, _uniqueId3.default)('position-model-');

        /**
         * @property latitude
         * @type {number}
         * @default 0
         */
        this.latitude = 0;

        /**
         * @property longitude
         * @type {number}
         * @default 0
         */
        this.longitude = 0;

        /**
         * @property elevation
         * @type {number}
         * @default 0
         */
        this.elevation = 0;

        /**
         * @property reference_position
         * @type {PositionModel|null}
         */
        this.reference_position = reference;

        /**
         * @property magnetic_north
         * @type {number}
         */
        this.magnetic_north = magnetic_north;

        /**
         * @property x
         * @type {number}
         * @default 0
         */
        this.x = 0;

        /**
         * @property y
         * @type {number}
         * @default 0
         */
        this.y = 0;

        return this.init(coordinates);
    }

    /**
     * Current x, y position
     *
     * @property position
     * @return {array}
     */


    _createClass(PositionModel, [{
        key: 'init',


        /**
         * @for PositionModel
         * @method init
         */
        value: function init(coordinates) {
            this.latitude = (0, _unitConverters.parseCoordinate)(coordinates[LATITUDE_INDEX]);
            this.longitude = (0, _unitConverters.parseCoordinate)(coordinates[LONGITUDE_INDEX]);

            // TODO: this is using coersion and shoudld be updated to be more explicit
            if (coordinates[ELEVATION_INDEX] != null) {
                this.elevation = (0, _unitConverters.parseElevation)(coordinates[ELEVATION_INDEX]);
            }

            this._calculateScreenPosition();
        }

        /**
         * @for PositionModel
         * @method distanceTo
         * @param point
         * @return {number}
         */

    }, {
        key: 'distanceTo',
        value: function distanceTo(point) {
            return (0, _circle.distanceToPoint)(this.latitude, this.longitude, point.latitude, point.longitude);
        }

        /**
         * Checks whether or not this `PositionModel` has a reference `PositionModel`
         * Without the reference position, the rotation due to magnetic variation will not be applied
         * @for PositionModel
         * @method _hasReferencePosition
         * @return {Boolean} whether this position is based on a reference position
         */

    }, {
        key: '_hasReferencePosition',
        value: function _hasReferencePosition() {
            return this.reference_position !== null;
        }

        /**
         * Determine the `x` and `y` values of the `PositionModel`, used for drawing on the canvas
         * @for PositionModel
         * @method _calculateScreenPosition
         * @private
         */

    }, {
        key: '_calculateScreenPosition',
        value: function _calculateScreenPosition() {
            if (!this._hasReferencePosition()) {
                return;
            }

            var _PositionModel$calcul = PositionModel.calculatePosition(this.gps, this.reference_position, this.magnetic_north),
                _PositionModel$calcul2 = _slicedToArray(_PositionModel$calcul, 2),
                x = _PositionModel$calcul2[0],
                y = _PositionModel$calcul2[1];

            this.x = x;
            this.y = y;
        }
    }, {
        key: 'position',
        get: function get() {
            return [this.x, this.y];
        }

        /**
         * GPS coordinates in [latitude, longitude] order
         * For reverse order, see `PositionModel.gpsXY`
         * @property gps
         * @return {array}
         */

    }, {
        key: 'gps',
        get: function get() {
            return [this.latitude, this.longitude];
        }

        /**
         * GPS coordinates in [x,y] order
         * For reverse order, see `PositionModel.gps`
         * @property gpsXY
         * @return {array}
         */

    }, {
        key: 'gpsXY',
        get: function get() {
            return [this.longitude, this.latitude];
        }

        /**
         * Magnetic north of the current instance expressed in radians
         *
         * @property magneticNorthInRadians
         * @return {number}
         */

    }, {
        key: 'magneticNorthInRadians',
        get: function get() {
            return (0, _unitConverters.degreesToRadians)(this.magnetic_north);
        }
    }]);

    return PositionModel;
}();

/**
 * Calculate x/y position from latitude and longitude and a referencePostion
 *
 * Provides a static method to calculate position without instantiating a `PositionModel` class.
 *
 * @function getPosition
 * @param coordinates {array<string>}
 * @param referencePostion {PositionModel|null}
 * @param magneticNorth {number}
 * @return {array}
 * @static
 */


exports.default = PositionModel;
PositionModel.calculatePosition = function (coordinates, referencePostion, magneticNorth) {
    if (!coordinates || !referencePostion || !(0, _isNumber3.default)(magneticNorth)) {
        throw new TypeError('Invalid parameter. PositionModel.getPosition() requires coordinates, referencePostion ' + 'and magneticNorth as parameters');
    }

    var latitude = (0, _unitConverters.parseCoordinate)(coordinates[LATITUDE_INDEX]);
    var longitude = (0, _unitConverters.parseCoordinate)(coordinates[LONGITUDE_INDEX]);

    var canvasPositionX = (0, _positionModelHelpers.calculateDistanceToPointForX)(referencePostion, referencePostion.latitude, longitude);

    var canvasPositionY = (0, _positionModelHelpers.calculateDistanceToPointForY)(referencePostion, latitude, referencePostion.longitude);

    var _adjustForMagneticNor = (0, _positionModelHelpers.adjustForMagneticNorth)(canvasPositionX, canvasPositionY, magneticNorth),
        x = _adjustForMagneticNor.x,
        y = _adjustForMagneticNor.y;

    return [x, y];
};

},{"../math/circle":583,"../utilities/unitConverters":595,"./positionModelHelpers":561,"lodash/isNumber":486,"lodash/uniqueId":510}],561:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.adjustForMagneticNorth = exports.calculateDistanceToPointForY = exports.calculateDistanceToPointForX = exports.hasCardinalDirectionInCoordinate = undefined;

var _circle = require('../math/circle');

var _globalConstants = require('../constants/globalConstants');

/**
 * @function hasCardinalDirectionInCoordinate
 * @param coordinate {string}
 * @return {boolean}
 */
var hasCardinalDirectionInCoordinate = exports.hasCardinalDirectionInCoordinate = function hasCardinalDirectionInCoordinate(coordinate) {
    return _globalConstants.REGEX.COMPASS_DIRECTION.test(coordinate);
};

/**
 * @function calculateDistanceToPointForX
 * @param referencePostion {PositionModel}
 * @param latitude {number}
 * @param longitude {number}
 * @return x {number}
 */
var calculateDistanceToPointForX = exports.calculateDistanceToPointForX = function calculateDistanceToPointForX(referencePostion, latitude, longitude) {
    var x = (0, _circle.distanceToPoint)(referencePostion.latitude, referencePostion.longitude, latitude, longitude);

    if (referencePostion.longitude > longitude) {
        x *= -1;
    }

    return x;
};

/**
 *
 *
 * @function calculateDistanceToPointForY
 * @param referencePostion {PositionModel}
 * @param latitude {number}
 * @param longitude {number}
 * @return y {number}
 */
var calculateDistanceToPointForY = exports.calculateDistanceToPointForY = function calculateDistanceToPointForY(referencePostion, latitude, longitude) {
    var y = (0, _circle.distanceToPoint)(referencePostion.latitude, referencePostion.longitude, latitude, longitude);

    if (referencePostion.latitude > latitude) {
        y *= -1;
    }

    return y;
};

/**
 * Adjust to use magnetic north instead of true north
 *
 * @function adjustForMagneticNorth
 * @param originalX {string}
 * @param originalY {string}
 * @param magneticNorth {number}
 * @return {object}
 */
var adjustForMagneticNorth = exports.adjustForMagneticNorth = function adjustForMagneticNorth(originalX, originalY, magneticNorth) {
    var t = Math.atan2(originalY, originalX) + magneticNorth;
    var r = Math.sqrt(originalX * originalX + originalY * originalY);

    var x = r * Math.cos(t);
    var y = r * Math.sin(t);

    return {
        x: x,
        y: y
    };
};

},{"../constants/globalConstants":573,"../math/circle":583}],562:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _unitConverters = require('../utilities/unitConverters');

var _timeHelpers = require('../utilities/timeHelpers');

var _core = require('../math/core');

var _circle = require('../math/circle');

var _distance = require('../math/distance');

var _vector = require('../math/vector');

var _selectors = require('../constants/selectors');

var _logLevel = require('../constants/logLevel');

var _aircraftConstants = require('../constants/aircraftConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var canvas = {};

/**
 * @property BASE_CANVAS_FONT
 * @type {string}
 * @final
 */
var BASE_CANVAS_FONT = '10px monoOne, monospace';

/**
 * @property DEFAULT_CANVAS_SIZE
 * @type {Object}
 * @final
 */
var DEFAULT_CANVAS_SIZE = {
    HEIGHT: 480,
    WIDTH: 640
};

/**
 * @property COLORS
 * @type {Object}
 * @final
 */
var COLORS = {
    WHITE_00: 'rgba(255, 255, 255, 0)',
    WHITE_02: 'rgba(255, 255, 255, 0.2)',
    WHITE_03: 'rgba(255, 255, 255, 0.2)',
    WHITE_04: 'rgba(255, 255, 255, 0.4)',
    WHITE_05: 'rgba(255, 255, 255, 0.5)',
    WHITE_07: 'rgba(255, 255, 255, 0.7)',
    WHITE_08: 'rgba(255, 255, 255, 0.8)',
    WHITE: 'rgba(255, 255, 255, 1.0)',
    LIGHT_SILVER_03: 'rgba(224, 224, 224, 0.3)',
    LIGHT_SILVER: 'rgba(224, 224, 224, 1.0)',
    RED_06: 'rgba(224, 128, 128, 0.6)',
    RED_08: 'rgba(224, 128, 128, 0.8)',
    RED: 'rgba(224, 128, 128, 1.0)',
    CORAL_RED: 'rgba(255, 64, 64, 1.0)',
    BRIGHT_RED: 'rgba(255, 0, 0, 0.7)',
    GRAIN_BROWN: 'rgba(224, 210, 180, 1.0)',
    DEPARTURE_COLOR: 'rgba(128, 255, 255, 0.6)',
    VIDEO_MAP_STROKE: 'rgba(193, 218, 205, 1)',
    DEPARTURE_STROKE: 'rgba(128, 255, 255, 0.9)',
    AIRSPACE_RADIUS_FILL: 'rgba(200, 255, 200, 0.02)',
    AIRSPACE_RADIUS_STROKE: 'rgba(200, 255, 200, 0.25)',
    AIRSPACE_RANGE_RING_COLOR: 'rgba(200, 255, 200, 0.1)',
    CROSSHAIR_STROKE: 'rgba(136, 153, 153, 1)',
    RESTRICTED_AIRSPACE_STROKE: 'rgba(150, 200, 255, 0.3)',
    RESTRICTED_AIRSPACE_FILL: 'rgba(150, 200, 255, 0.4)'
};

/**
 * @class CanvasController
 */

var ConvasController = function () {
    /**
     * @constructor
     */
    function ConvasController($element) {
        _classCallCheck(this, ConvasController);

        this.$window = (0, _jquery2.default)(window);
        this.$element = $element;
        this.canvas = canvas;
        this.canvas.contexts = {};
        this.canvas.panY = 0;
        this.canvas.panX = 0;
        // resize canvas to fit window?
        this.canvas.resize = true;
        // all canvases are the same size
        this.canvas.size = {
            height: DEFAULT_CANVAS_SIZE.HEIGHT,
            width: DEFAULT_CANVAS_SIZE.WIDTH
        };
        this.canvas.last = (0, _timeHelpers.time)();
        this.canvas.dirty = true;
        this.canvas.draw_labels = true;
        this.canvas.draw_restricted = true;
        this.canvas.draw_sids = true;
        this.canvas.draw_terrain = true;

        return this._init().enable();
    }

    /**
     * @for CanvasController
     * @method _init
     */


    _createClass(ConvasController, [{
        key: '_init',
        value: function _init() {
            return this;
        }

        /**
         * @for CanvasController
         * @method enable
         */

    }, {
        key: 'enable',
        value: function enable() {
            return this;
        }

        /**
         * @for CanvasController
         * @method disable
         */

    }, {
        key: 'disable',
        value: function disable() {
            return this.destroy();
        }

        /**
         * @for CanvasController
         * @method destroy
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$window = null;
            this.$element = null;
            this.canvas = {};
            this.canvas.contexts = {};
            this.canvas.panY = 0;
            this.canvas.panX = 0;
            // resize canvas to fit window?
            this.canvas.resize = true;
            // all canvases are the same size
            this.canvas.size = {
                height: DEFAULT_CANVAS_SIZE.HEIGHT,
                width: DEFAULT_CANVAS_SIZE.WIDTH
            };
            this.canvas.last = (0, _timeHelpers.time)();
            this.canvas.dirty = true;
            this.canvas.draw_labels = true;
            this.canvas.draw_restricted = true;
            this.canvas.draw_sids = true;
            this.canvas.draw_terrain = true;

            return this;
        }

        /**
         * @for CanvasController
         * @method canvas_init_pre
         */

    }, {
        key: 'canvas_init_pre',
        value: function canvas_init_pre() {
            prop.canvas = canvas;
        }

        /**
         * @for CanvasController
         * @method canvas_init
         */

    }, {
        key: 'canvas_init',
        value: function canvas_init() {
            this.canvas_add('navaids');
        }

        /**
         * @for CanvasController
         * @method canvas_adjust_hidpi
         */

    }, {
        key: 'canvas_adjust_hidpi',
        value: function canvas_adjust_hidpi() {
            var dpr = window.devicePixelRatio || 1;

            log('devicePixelRatio: ' + dpr);

            // TODO: change to early return
            if (dpr <= 1) {
                return;
            }

            // TODO: cache this selector, $hidefCanvas
            // TODO: replace selector with constant
            var hidefCanvas = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.NAVAIDS_CANVAS).get(0);
            var w = this.canvas.size.width;
            var h = this.canvas.size.height;

            (0, _jquery2.default)(hidefCanvas).attr('width', w * dpr);
            (0, _jquery2.default)(hidefCanvas).attr('height', h * dpr);
            (0, _jquery2.default)(hidefCanvas).css('width', w);
            (0, _jquery2.default)(hidefCanvas).css('height', h);

            var ctx = hidefCanvas.getContext('2d');

            ctx.scale(dpr, dpr);
            this.canvas.contexts.navaids = ctx;
        }

        /**
         * @for CanvasController
         * @method
         */

    }, {
        key: 'canvas_complete',
        value: function canvas_complete() {
            var _this = this;

            setTimeout(function () {
                _this.canvas.dirty = true;
            }, 500);

            this.canvas.last = (0, _timeHelpers.time)();
        }

        /**
         * @for CanvasController
         * @method
         */

    }, {
        key: 'canvas_resize',
        value: function canvas_resize() {
            var _this2 = this;

            if (this.canvas.resize) {
                this.canvas.size.width = this.$window.width();
                this.canvas.size.height = this.$window.height();
            }

            this.canvas.size.width -= 250;
            this.canvas.size.height -= 36;

            (0, _forEach3.default)(this.canvas.contexts, function (context) {
                context.canvas.height = _this2.canvas.size.height;
                context.canvas.width = _this2.canvas.size.width;
            });

            this.canvas.dirty = true;
            this.canvas_adjust_hidpi();
        }

        /**
         * @for CanvasController
         * @method canvas_update_post
         */

    }, {
        key: 'canvas_update_post',
        value: function canvas_update_post() {
            var elapsed = window.gameController.game_time() - window.airportController.airport_get().start;
            var alpha = (0, _core.extrapolate_range_clamp)(0.1, elapsed, 0.4, 0, 1);
            var framestep = Math.round((0, _core.extrapolate_range_clamp)(1, window.gameController.game.speedup, 10, 30, 1));

            if (this.canvas.dirty || !window.gameController.game_paused() && prop.time.frames % framestep === 0 || elapsed < 1) {
                var cc = this.canvas_get('navaids');
                var fading = elapsed < 1;

                cc.font = '11px monoOne, monospace';

                // TODO: what is the rationale here? with two ors and a true, this block will always be exectuted.
                if (this.canvas.dirty || fading || true) {
                    cc.save();

                    this.canvas_clear(cc);

                    cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));

                    cc.save();
                    cc.globalAlpha = alpha;

                    this.canvas_draw_videoMap(cc);
                    this.canvas_draw_terrain(cc);
                    this.canvas_draw_restricted(cc);
                    this.canvas_draw_runways(cc);
                    cc.restore();

                    cc.save();
                    cc.globalAlpha = alpha;
                    this.canvas_draw_fixes(cc);
                    this.canvas_draw_sids(cc);
                    cc.restore();

                    cc.restore();
                }

                // Controlled traffic region - (CTR)
                cc.save();
                // translate to airport center
                cc.translate((0, _core.round)(this.canvas.size.width / 2 + this.canvas.panX), (0, _core.round)(this.canvas.size.height / 2 + this.canvas.panY));
                // TODO: this is incorrect usage of a ternary. ternaries should be used for a ssignment not function calls.
                // draw airspace border
                window.airportController.airport_get().airspace ? this.canvas_draw_airspace_border(cc) : this.canvas_draw_ctr(cc);

                this.canvas_draw_range_rings(cc);
                cc.restore();

                // Special markings for ENGM point merge
                if (window.airportController.airport_get().icao === 'ENGM') {
                    cc.save();
                    cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));
                    this.canvas_draw_engm_range_rings(cc);
                    cc.restore();
                }

                // Compass
                cc.font = 'bold 10px monoOne, monospace';

                if (this.canvas.dirty || fading || true) {
                    cc.save();
                    cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));

                    this.canvas_draw_compass(cc);
                    cc.restore();
                }

                cc.font = BASE_CANVAS_FONT;

                if (this.canvas.dirty || this.canvas_should_draw() || true) {
                    cc.save();
                    cc.globalAlpha = alpha;
                    cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));
                    this.canvas_draw_all_aircraft(cc);
                    cc.restore();
                }

                cc.save();
                cc.globalAlpha = alpha;
                cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));
                this.canvas_draw_all_info(cc);
                cc.restore();

                cc.save();
                cc.globalAlpha = alpha;
                cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));

                this.canvas_draw_runway_labels(cc);
                cc.restore();

                cc.save();
                cc.globalAlpha = alpha;
                this.canvas_draw_scale(cc);
                cc.restore();

                cc.save();
                cc.globalAlpha = alpha;
                this.canvas_draw_directions(cc);
                cc.restore();

                this.canvas.dirty = false;
            }
        }

        /**
         * @for CanvasController
         * @method canvas_add
         * @param name {string}
         */

    }, {
        key: 'canvas_add',
        value: function canvas_add(name) {
            (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.CANVASES).append('<canvas id=\'' + name + '-canvas\'></canvas>');
            this.canvas.contexts[name] = (0, _jquery2.default)('#' + name + '-canvas').get(0).getContext('2d');
        }

        /**
         * @for CanvasController
         * @method canvas_get
         * @param name {string}
         */

    }, {
        key: 'canvas_get',
        value: function canvas_get(name) {
            return this.canvas.contexts[name];
        }

        /**
         * @for CanvasController
         * @method canvas_clear
         * @param cc {object}
         */

    }, {
        key: 'canvas_clear',
        value: function canvas_clear(cc) {
            cc.clearRect(0, 0, this.canvas.size.width, this.canvas.size.height);
        }

        /**
         * @for CanvasController
         * @method canvas_should_draw
         */

    }, {
        key: 'canvas_should_draw',
        value: function canvas_should_draw() {
            var elapsed = (0, _timeHelpers.time)() - this.canvas.last;

            if (elapsed > 1 / window.gameController.game.speedup) {
                this.canvas.last = (0, _timeHelpers.time)();
                return true;
            }

            return false;
        }

        /**
         * @for CanvasController
         * @method canvas_draw_runway
         * @param cc
         * @param runway
         * @param mode
         */

    }, {
        key: 'canvas_draw_runway',
        value: function canvas_draw_runway(cc, runway, mode) {
            var length2 = (0, _core.round)(window.uiController.km_to_px(runway.length / 2));
            var angle = runway.angle;

            cc.translate((0, _core.round)(window.uiController.km_to_px(runway.position[0])) + this.canvas.panX, -(0, _core.round)(window.uiController.km_to_px(runway.position[1])) + this.canvas.panY);
            cc.rotate(angle);

            // runway body
            if (!mode) {
                cc.strokeStyle = '#899';
                cc.lineWidth = 2.8;

                cc.beginPath();
                cc.moveTo(0, 0);
                cc.lineTo(0, -2 * length2);
                cc.stroke();
            } else {
                // extended centerlines
                if (!runway.ils.enabled) {
                    return;
                }

                cc.strokeStyle = '#465';
                cc.lineWidth = 1;

                cc.beginPath();
                cc.moveTo(0, 0);
                cc.lineTo(0, window.uiController.km_to_px(runway.ils.loc_maxDist));
                cc.stroke();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_runway_label
         * @param cc
         * @param runway
         */

    }, {
        key: 'canvas_draw_runway_label',
        value: function canvas_draw_runway_label(cc, runway) {
            var length2 = (0, _core.round)(window.uiController.km_to_px(runway.length / 2)) + 0.5;
            var angle = runway.angle;
            var text_height = 14;

            cc.translate((0, _core.round)(window.uiController.km_to_px(runway.position[0])) + this.canvas.panX, -(0, _core.round)(window.uiController.km_to_px(runway.position[1])) + this.canvas.panY);
            cc.rotate(angle);

            cc.textAlign = 'center';
            cc.textBaseline = 'middle';

            cc.save();
            cc.translate(0, length2 + text_height);
            cc.rotate(-angle);
            cc.translate((0, _core.round)(window.uiController.km_to_px(runway.labelPos[0])), -(0, _core.round)(window.uiController.km_to_px(runway.labelPos[1])));
            cc.fillText(runway.name, 0, 0);
            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_runways
         * @param cc
         */

    }, {
        key: 'canvas_draw_runways',
        value: function canvas_draw_runways(cc) {
            if (!this.canvas.draw_labels) {
                return;
            }

            cc.strokeStyle = COLORS.WHITE_04;
            cc.fillStyle = COLORS.WHITE_04;
            cc.lineWidth = 4;

            var airport = window.airportController.airport_get();

            // Extended Centerlines
            for (var i = 0; i < airport.runways.length; i++) {
                cc.save();
                this.canvas_draw_runway(cc, airport.runways[i][0], true);
                cc.restore();

                cc.save();
                this.canvas_draw_runway(cc, airport.runways[i][1], true);
                cc.restore();
            }

            // Runways
            for (var _i = 0; _i < airport.runways.length; _i++) {
                cc.save();
                this.canvas_draw_runway(cc, airport.runways[_i][0], false);
                cc.restore();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_runway_labels
         * @param cc
         */

    }, {
        key: 'canvas_draw_runway_labels',
        value: function canvas_draw_runway_labels(cc) {
            if (!this.canvas.draw_labels) {
                return;
            }

            cc.fillStyle = COLORS.WHITE_08;

            var airport = window.airportController.airport_get();
            for (var i = 0; i < airport.runways.length; i++) {
                cc.save();
                this.canvas_draw_runway_label(cc, airport.runways[i][0]);
                cc.restore();
                cc.save();
                this.canvas_draw_runway_label(cc, airport.runways[i][1]);
                cc.restore();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_scale
         * @param cc
         */

    }, {
        key: 'canvas_draw_scale',
        value: function canvas_draw_scale(cc) {
            cc.fillStyle = COLORS.WHITE_08;
            cc.strokeStyle = COLORS.WHITE_08;

            var offset = 10;
            var height = 5;
            var length = (0, _core.round)(1 / prop.ui.scale * 50);
            var px_length = (0, _core.round)(window.uiController.km_to_px(length));

            cc.translate(0.5, 0.5);

            cc.lineWidth = 1;
            cc.moveTo(this.canvas.size.width - offset, offset);
            cc.lineTo(this.canvas.size.width - offset, offset + height);
            cc.lineTo(this.canvas.size.width - offset - px_length, offset + height);
            cc.lineTo(this.canvas.size.width - offset - px_length, offset);
            cc.stroke();

            cc.translate(-0.5, -0.5);

            cc.textAlign = 'center';
            cc.fillText(length + ' km', this.canvas.size.width - offset - px_length * 0.5, offset + height + 17);
        }

        /**
         * @for CanvasController
         * @method canvas_draw_fix
         * @param cc
         * @param name
         * @param fix
         */

    }, {
        key: 'canvas_draw_fix',
        value: function canvas_draw_fix(cc, name, fix) {
            cc.beginPath();
            cc.moveTo(0, -5);
            cc.lineTo(4, 3);
            cc.lineTo(-4, 3);
            cc.closePath();
            cc.fill();
            cc.stroke();

            cc.textAlign = 'center';
            cc.textBaseline = 'top';
            cc.strokeText(name, 0, 6);
            cc.fillText(name, 0, 6);
        }

        /**
         * @for CanvasController
         * @method canvas_draw_fixes
         * @param cc
         */

    }, {
        key: 'canvas_draw_fixes',
        value: function canvas_draw_fixes(cc) {
            var _this3 = this;

            if (!this.canvas.draw_labels) {
                return;
            }

            cc.lineJoin = 'round';
            cc.font = BASE_CANVAS_FONT;

            var airport = window.airportController.airport_get();
            // TODO: perhaps this could be a model method?
            (0, _forEach3.default)(airport.real_fixes, function (fix, i) {
                cc.save();
                cc.translate((0, _core.round)(window.uiController.km_to_px(fix.position[0])) + _this3.canvas.panX, -(0, _core.round)(window.uiController.km_to_px(fix.position[1])) + _this3.canvas.panY);

                // draw outline (draw with eraser)
                cc.strokeStyle = 'rgba(0, 0, 0, 0.67)';
                cc.fillStyle = 'rgba(0, 0, 0, 0.67)';
                cc.globalCompositeOperation = 'destination-out';
                cc.lineWidth = 4;

                _this3.canvas_draw_fix(cc, fix.name, fix.position);

                cc.strokeStyle = COLORS.WHITE_00;
                cc.fillStyle = COLORS.WHITE_05;
                cc.globalCompositeOperation = 'source-over';
                cc.lineWidth = 1;

                _this3.canvas_draw_fix(cc, fix.name, fix.position);

                cc.restore();
            });
        }

        // TODO: break this method up into smaller chunks
        /**
         * @for CanvasController
         * @method canvas_draw_sids
         * @param cc
         */

    }, {
        key: 'canvas_draw_sids',
        value: function canvas_draw_sids(cc) {
            var _this4 = this;

            if (!this.canvas.draw_sids) {
                return;
            }

            // Store the count of sid text drawn for a specific transition
            var text_at_point = [];
            var airport = window.airportController.airport_get();

            cc.strokeStyle = COLORS.DEPARTURE_COLOR;
            cc.fillStyle = COLORS.DEPARTURE_COLOR;
            cc.setLineDash([1, 10]);
            cc.font = 'italic 14px monoOne, monospace';

            (0, _forEach3.default)(airport.sidCollection.draw, function (sid) {
                var write_sid_name = true;
                var fixX = null;
                var fixY = null;

                if (!(0, _has3.default)(sid, 'draw')) {
                    return;
                }

                (0, _forEach3.default)(sid.draw, function (fixList, i) {
                    var exit_name = null;

                    for (var j = 0; j < fixList.length; j++) {
                        // write exitPoint name
                        if (fixList[j].indexOf('*') !== -1) {
                            exit_name = fixList[j].replace('*', '');
                            write_sid_name = false;
                        }

                        var fix = airport.getFixPosition(fixList[j].replace('*', ''));

                        if (!fix) {
                            log('Unable to draw line to \'' + fixList[j] + '\' because its position is not defined!', _logLevel.LOG.WARNING);
                        }

                        fixX = window.uiController.km_to_px(fix[0]) + _this4.canvas.panX;
                        fixY = -window.uiController.km_to_px(fix[1]) + _this4.canvas.panY;

                        if (j === 0) {
                            cc.beginPath();
                            cc.moveTo(fixX, fixY);
                        } else {
                            cc.lineTo(fixX, fixY);
                        }
                    }

                    cc.stroke();

                    if (exit_name) {
                        // Initialize count for this transition
                        if (isNaN(text_at_point[exit_name])) {
                            text_at_point[exit_name] = 0;
                        }

                        // Move the y point for drawing depending on how many sids we have drawn text for
                        // at this point already
                        var y_point = fixY + 15 * text_at_point[exit_name];
                        cc.fillText(sid.identifier + '.' + exit_name, fixX + 10, y_point);

                        text_at_point[exit_name] += 1; // Increment the count for this transition
                    }
                });

                if (write_sid_name) {
                    cc.fillText(sid.identifier, fixX + 10, fixY);
                }
            });
        }

        /**
         * @for CanvasController
         * @method canvas_draw_separation_indicator
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_separation_indicator',
        value: function canvas_draw_separation_indicator(cc, aircraft) {
            // Draw a trailing indicator 2.5 NM (4.6km) behind landing aircraft to help with traffic spacing
            var rwy = window.airportController.airport_get().getRunway(aircraft.fms.currentWaypoint.runway);

            if (!rwy) {
                return;
            }

            var angle = rwy.angle + Math.PI;

            cc.strokeStyle = COLORS.RED_08;
            cc.lineWidth = 3;
            cc.translate(window.uiController.km_to_px(aircraft.position[0]) + this.canvas.panX, -window.uiController.km_to_px(aircraft.position[1]) + this.canvas.panY);
            cc.rotate(angle);
            cc.beginPath();
            cc.moveTo(-5, -window.uiController.km_to_px(5.556)); // 5.556km = 3.0nm
            cc.lineTo(+5, -window.uiController.km_to_px(5.556)); // 5.556km = 3.0nm
            cc.stroke();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_aircraft_rings
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_aircraft_rings',
        value: function canvas_draw_aircraft_rings(cc, aircraft) {
            cc.save();

            if (aircraft.hasAlerts()[0]) {
                if (aircraft.hasAlerts()[1]) {
                    // red violation circle
                    cc.strokeStyle = COLORS.RED;
                } else {
                    // white warning circle
                    cc.strokeStyle = COLORS.WHITE_02;
                }
            } else {
                cc.strokeStyle = cc.fillStyle;
            }

            cc.beginPath();
            cc.arc(0, 0, window.uiController.km_to_px((0, _unitConverters.km)(3)), 0, (0, _circle.tau)()); // 3nm RADIUS
            cc.stroke();
            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_aircraft_departure_window
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_aircraft_departure_window',
        value: function canvas_draw_aircraft_departure_window(cc, aircraft) {
            var angle = aircraft.destination - Math.PI / 2;

            cc.save();
            cc.strokeStyle = COLORS.DEPARTURE_STROKE;
            cc.beginPath();
            cc.arc(this.canvas.panX, this.canvas.panY, window.uiController.km_to_px(window.airportController.airport_get().ctr_radius), angle - 0.08726, angle + 0.08726);
            cc.stroke();
            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_aircraft
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_aircraft',
        value: function canvas_draw_aircraft(cc, aircraft) {
            var almost_match = false;
            var match = false;

            if (prop.input.callsign.length > 1 && aircraft.matchCallsign(prop.input.callsign.substr(0, prop.input.callsign.length - 1))) {
                almost_match = true;
            }

            if (prop.input.callsign.length > 0 && aircraft.matchCallsign(prop.input.callsign)) {
                match = true;
            }

            if (match && aircraft.destination != null) {
                this.canvas_draw_aircraft_departure_window(cc, aircraft);
            }

            if (!aircraft.isVisible()) {
                return;
            }

            var size = 3;
            // Trailling
            var trailling_length = 12;
            var dpr = window.devicePixelRatio || 1;

            if (dpr > 1) {
                trailling_length *= (0, _core.round)(dpr);
            }

            cc.save();

            if (!aircraft.inside_ctr) {
                cc.fillStyle = COLORS.LIGHT_SILVER;
            } else {
                cc.fillStyle = COLORS.WHITE;
            }

            var length = aircraft.position_history.length;
            for (var i = 0; i < length; i++) {
                if (!aircraft.inside_ctr) {
                    cc.globalAlpha = 0.3 / (length - i);
                } else {
                    cc.globalAlpha = 1 / (length - i);
                    cc.fillRect(window.uiController.km_to_px(aircraft.position_history[i][0]) + this.canvas.panX - 1, -window.uiController.km_to_px(aircraft.position_history[i][1]) + this.canvas.panY - 1, 2, 2);
                }
            }

            cc.restore();

            if (aircraft.position_history.length > trailling_length) {
                aircraft.position_history = aircraft.position_history.slice(aircraft.position_history.length - trailling_length, aircraft.position_history.length);
            }

            if (aircraft.isPrecisionGuided()) {
                cc.save();
                this.canvas_draw_separation_indicator(cc, aircraft);
                cc.restore();
            }

            // TODO: if all these parens are actally needed, abstract this out to a function that can return a bool.
            // Aircraft
            // Draw the future path
            if (window.gameController.game.option.get('drawProjectedPaths') === 'always' || window.gameController.game.option.get('drawProjectedPaths') === 'selected' && (aircraft.warning || match) && !aircraft.isTaxiing()) {
                this.canvas_draw_future_track(cc, aircraft);
            }

            var alerts = aircraft.hasAlerts();

            if (!aircraft.inside_ctr) {
                cc.fillStyle = COLORS.LIGHT_SILVER_03;
            } else if (almost_match) {
                cc.fillStyle = COLORS.GRAIN_BROWN;
            } else if (match) {
                cc.fillStyle = COLORS.WHITE;
            } else if (aircraft.warning || alerts[1]) {
                cc.fillStyle = COLORS.RED;
            } else if (aircraft.hit) {
                cc.fillStyle = COLORS.CORAL_RED;
            } else {
                cc.fillStyle = COLORS.WHITE;
            }

            cc.strokeStyle = cc.fillStyle;

            if (match) {
                cc.save();

                if (!aircraft.inside_ctr) {
                    cc.fillStyle = COLORS.WHITE_03;
                } else {
                    cc.fillStyle = COLORS.WHITE;
                }

                var w = this.canvas.size.width / 2;
                var h = this.canvas.size.height / 2;

                cc.translate((0, _core.clamp)(-w, window.uiController.km_to_px(aircraft.position[0]) + this.canvas.panX, w), (0, _core.clamp)(-h, -window.uiController.km_to_px(aircraft.position[1]) + this.canvas.panY, h));

                cc.beginPath();
                cc.arc(0, 0, (0, _core.round)(size * 1.5), 0, (0, _circle.tau)());
                cc.fill();

                cc.restore();
            }

            cc.translate(window.uiController.km_to_px(aircraft.position[0]) + this.canvas.panX, -window.uiController.km_to_px(aircraft.position[1]) + this.canvas.panY);

            if (!aircraft.hit) {
                cc.save();

                var tail_length = aircraft.groundSpeed / 15;
                if (match) {
                    tail_length = 15;
                }

                var angle = aircraft.groundTrack;
                var end = (0, _vector.vscale)((0, _vector.vturn)(angle), tail_length);

                cc.beginPath();
                cc.moveTo(0, 0);
                cc.lineTo(end[0], -end[1]);
                cc.stroke();
                cc.restore();
            }

            if (aircraft.notice || alerts[0]) {
                this.canvas_draw_aircraft_rings(cc, aircraft);
            }

            cc.beginPath();
            cc.arc(0, 0, size, 0, (0, _circle.tau)());
            cc.fill();
        }

        /**
         * Draw dashed line from last coordinate of future track through
         * any later requested fixes.
         *
         * @for CanvasController
         * @method canvas_draw_future_track_fixes
         * @param cc
         * @param aircraft
         * @param future_track
         */

    }, {
        key: 'canvas_draw_future_track_fixes',
        value: function canvas_draw_future_track_fixes(cc, aircraft, future_track) {
            if (aircraft.fms.waypoints.length < 1) {
                return;
            }

            var start = future_track.length - 1;
            var x = window.uiController.km_to_px(future_track[start][0]) + this.canvas.panX;
            var y = -window.uiController.km_to_px(future_track[start][1]) + this.canvas.panY;

            cc.beginPath();
            cc.moveTo(x, y);
            cc.setLineDash([3, 10]);

            for (var i = 0; i < aircraft.fms.waypoints.length; i++) {
                if (!aircraft.fms.waypoints[i].location) {
                    break;
                }

                var fix = aircraft.fms.waypoints[i].location;
                var fx = window.uiController.km_to_px(fix[0]) + this.canvas.panX;
                var fy = -window.uiController.km_to_px(fix[1]) + this.canvas.panY;

                cc.lineTo(fx, fy);
            }

            cc.stroke();
        }

        /**
         * Run physics updates into the future, draw future track
         *
         * @for CanvasController
         * @method canvas_draw_future_track
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_future_track',
        value: function canvas_draw_future_track(cc, aircraft) {
            var ils_locked = void 0;
            var lockedStroke = void 0;
            var was_locked = false;
            var future_track = [];
            var save_delta = window.gameController.game.delta;
            var fms_twin = (0, _cloneDeep3.default)(aircraft.fms);
            var twin = (0, _cloneDeep3.default)(aircraft);

            twin.fms = fms_twin;
            twin.fms.aircraft = twin;
            twin.projected = true;
            window.gameController.game.delta = 5;

            for (var i = 0; i < 60; i++) {
                twin.update();

                ils_locked = twin.isPrecisionGuided() && twin.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL && twin.mode === _aircraftConstants.FLIGHT_MODES.LANDING;

                future_track.push([twin.position[0], twin.position[1], ils_locked]);

                if (ils_locked && twin.altitude < 500) {
                    break;
                }
            }

            window.gameController.game.delta = save_delta;
            cc.save();

            if (aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE) {
                cc.strokeStyle = COLORS.DEPARTURE_COLOR;
            } else {
                cc.strokeStyle = COLORS.RED_06;
                lockedStroke = COLORS.RED;
            }

            cc.globalCompositeOperation = 'screen';
            cc.lineWidth = 2;
            cc.beginPath();

            for (var _i2 = 0; _i2 < future_track.length; _i2++) {
                var track = future_track[_i2];
                ils_locked = track[2];

                var x = window.uiController.km_to_px(track[0]) + this.canvas.panX;
                var y = -window.uiController.km_to_px(track[1]) + this.canvas.panY;

                if (ils_locked && !was_locked) {
                    cc.lineTo(x, y);
                    // end the current path, start a new path with lockedStroke
                    cc.stroke();
                    cc.strokeStyle = lockedStroke;
                    cc.lineWidth = 3;
                    cc.beginPath();
                    cc.moveTo(x, y);

                    was_locked = true;

                    continue;
                }

                if (_i2 === 0) {
                    cc.moveTo(x, y);
                } else {
                    cc.lineTo(x, y);
                }
            }

            cc.stroke();
            this.canvas_draw_future_track_fixes(cc, twin, future_track);
            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_all_aircraft
         * @param cc
         */

    }, {
        key: 'canvas_draw_all_aircraft',
        value: function canvas_draw_all_aircraft(cc) {
            cc.fillStyle = COLORS.LIGHT_SILVER;
            cc.strokeStyle = COLORS.LIGHT_SILVER;
            cc.lineWidth = 2;

            // console.time('canvas_draw_all_aircraft')
            for (var i = 0; i < prop.aircraft.list.length; i++) {
                cc.save();
                this.canvas_draw_aircraft(cc, prop.aircraft.list[i]);
                cc.restore();
            }
            // console.timeEnd('canvas_draw_all_aircraft')
        }

        /**
         * Draw an aircraft's data block
         * (box that contains callsign, altitude, speed)
         *
         * @for CanvasController
         * @method anvas_draw_info
         * @param cc
         * @param aircraft
         */

    }, {
        key: 'canvas_draw_info',
        value: function canvas_draw_info(cc, aircraft) {
            if (!aircraft.isVisible()) {
                return;
            }

            // TODO: flip the logic here and return early to make code more readable.
            if (!aircraft.hit) {
                // Initial Setup
                cc.save();

                var cs = aircraft.getCallsign();
                var paddingLR = 5;
                // width of datablock (scales to fit callsign)
                var width = (0, _core.clamp)(1, 5.8 * cs.length) + paddingLR * 2;
                var width2 = width / 2;
                // height of datablock
                var height = 31;
                var height2 = height / 2;
                // width of colored bar
                var bar_width = width / 18;
                var bar_width2 = bar_width / 2;
                var ILS_enabled = aircraft.fms.currentWaypoint.runway && aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.ARRIVAL;
                var lock_size = height / 3;
                var lock_offset = lock_size / 8;
                var pi = Math.PI;
                var point1 = lock_size - bar_width2;
                var alt_trend_char = '';
                var a = point1 - lock_offset;
                var b = bar_width2;
                var clipping_mask_angle = Math.atan(b / a);
                // describes how far around to arc the arms of the ils lock case
                var pi_slice = pi / 24;
                var match = false;
                var almost_match = false;

                // Callsign Matching
                if (prop.input.callsign.length > 1 && aircraft.matchCallsign(prop.input.callsign.substr(0, prop.input.callsign.length - 1))) {
                    almost_match = true;
                }

                if (prop.input.callsign.length > 0 && aircraft.matchCallsign(prop.input.callsign)) {
                    match = true;
                }

                // set color, intensity, and style elements
                var alpha = 0.2;
                if (match) {
                    alpha = 0.9;
                } else if (aircraft.inside_ctr) {
                    // else if (almost_match) var alpha = 0.75;
                    alpha = 0.5;
                }

                var red = 'rgba(224, 128, 128, ' + alpha + ')';
                var green = 'rgba( 76, 118, 97, ' + alpha + ')';
                var blue = 'rgba(128, 255, 255, ' + alpha + ')';
                var white = 'rgba(255, 255, 255, ' + alpha + ')';
                cc.textBaseline = 'middle';

                // Move to center of where the data block is to be drawn
                var ac_pos = [(0, _core.round)(window.uiController.km_to_px(aircraft.position[0])) + this.canvas.panX, -(0, _core.round)(window.uiController.km_to_px(aircraft.position[1])) + this.canvas.panY];

                // game will move FDB to the appropriate position
                if (aircraft.datablockDir === -1) {
                    if (-window.uiController.km_to_px(aircraft.position[1]) + this.canvas.size.height / 2 < height * 1.5) {
                        cc.translate(ac_pos[0], ac_pos[1] + height2 + 12);
                    } else {
                        cc.translate(ac_pos[0], ac_pos[1] - height2 - 12);
                    }
                } else {
                    // user wants to specify FDB position
                    var displacements = {
                        ctr: [0, 0],
                        360: [0, -height2 - 12],
                        45: [width2 + 8.5, -height2 - 8.5],
                        90: [width2 + bar_width2 + 12, 0],
                        135: [width2 + 8.5, height2 + 8.5],
                        180: [0, height2 + 12],
                        225: [-width2 - 8.5, height2 + 8.5],
                        270: [-width2 - bar_width2 - 12, 0],
                        315: [-width2 - 8.5, -height2 - 8.5]
                    };

                    cc.translate(ac_pos[0] + displacements[aircraft.datablockDir][0], ac_pos[1] + displacements[aircraft.datablockDir][1]);
                }

                // Draw datablock shapes
                if (!ILS_enabled) {
                    // Standard Box
                    cc.fillStyle = green;
                    // Draw box
                    cc.fillRect(-width2, -height2, width, height);
                    cc.fillStyle = aircraft.category === _aircraftConstants.FLIGHT_CATEGORY.DEPARTURE ? blue : red;
                    // Draw colored bar
                    cc.fillRect(-width2 - bar_width, -height2, bar_width, height);
                } else {
                    // Box with ILS Lock Indicator
                    cc.save();

                    // Draw green part of box (excludes space where ILS Clearance Indicator juts in)
                    cc.fillStyle = green;
                    cc.beginPath();
                    cc.moveTo(-width2, height2); // bottom-left corner
                    cc.lineTo(width2, height2); // bottom-right corner
                    cc.lineTo(width2, -height2); // top-right corner
                    cc.lineTo(-width2, -height2); // top-left corner
                    cc.lineTo(-width2, -point1); // begin side cutout
                    cc.arc(-width2 - bar_width2, -lock_offset, lock_size / 2 + bar_width2, clipping_mask_angle - pi / 2, 0);
                    cc.lineTo(-width2 + lock_size / 2, lock_offset);
                    cc.arc(-width2 - bar_width2, lock_offset, lock_size / 2 + bar_width2, 0, pi / 2 - clipping_mask_angle);
                    cc.closePath();
                    cc.fill();

                    // Draw ILS Clearance Indicator
                    cc.translate(-width2 - bar_width2, 0);
                    cc.lineWidth = bar_width;
                    cc.strokeStyle = red;
                    cc.beginPath(); // top arc start
                    cc.arc(0, -lock_offset, lock_size / 2, -pi_slice, pi + pi_slice, true);
                    cc.moveTo(0, -lock_size / 2);
                    cc.lineTo(0, -height2);
                    cc.stroke(); // top arc end
                    cc.beginPath(); // bottom arc start
                    cc.arc(0, lock_offset, lock_size / 2, pi_slice, pi - pi_slice);
                    cc.moveTo(0, lock_size - bar_width);
                    cc.lineTo(0, height2);
                    cc.stroke(); // bottom arc end

                    if (aircraft.mode === _aircraftConstants.FLIGHT_MODES.LANDING) {
                        // Localizer Capture Indicator
                        cc.fillStyle = white;
                        cc.beginPath();
                        cc.arc(0, 0, lock_size / 5, 0, pi * 2);
                        cc.fill(); // Draw Localizer Capture Dot
                    }

                    cc.translate(width2 + bar_width2, 0);
                    // unclear how this works...
                    cc.beginPath(); // if removed, white lines appear on top of bottom half of lock case
                    cc.stroke(); // if removed, white lines appear on top of bottom half of lock case

                    cc.restore();
                }

                // Text
                var gap = 3; // height of TOTAL vertical space between the rows (0 for touching)
                var lineheight = 4.5; // height of text row (used for spacing basis)
                var row1text = cs;
                var row2text = lpad((0, _core.round)(aircraft.altitude * 0.01), 3) + ' ' + lpad((0, _core.round)(aircraft.groundSpeed * 0.1), 2);

                // TODO: remove the if/else in favor of an initial assignment, and update with if condition
                if (aircraft.inside_ctr) {
                    cc.fillStyle = COLORS.WHITE_08;
                } else {
                    cc.fillStyle = COLORS.WHITE_02;
                }

                if (aircraft.trend === 0) {
                    // small dash (symbola font)
                    alt_trend_char = String.fromCodePoint(0x2011);
                } else if (aircraft.trend > 0) {
                    alt_trend_char = String.fromCodePoint(0x1F851); // up arrow (symbola font)
                } else if (aircraft.trend < 0) {
                    alt_trend_char = String.fromCodePoint(0x1F853); // down arrow (symbola font)
                }

                // Draw full datablock text
                cc.textAlign = 'left';
                cc.fillText(row1text, -width2 + paddingLR, -gap / 2 - lineheight);
                cc.fillText(row2text, -width2 + paddingLR, gap / 2 + lineheight);
                // Draw climb/level/descend symbol
                cc.font = '10px symbola'; // change font to the one with extended unicode characters
                cc.textAlign = 'center';
                cc.fillText(alt_trend_char, -width2 + paddingLR + 20.2, gap / 2 + lineheight - 0.25);
                cc.font = BASE_CANVAS_FONT; // change back to normal font

                cc.restore();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_all_info
         * @param cc
         */

    }, {
        key: 'canvas_draw_all_info',
        value: function canvas_draw_all_info(cc) {
            for (var i = 0; i < prop.aircraft.list.length; i++) {
                cc.save();
                this.canvas_draw_info(cc, prop.aircraft.list[i]);
                cc.restore();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_compass
         * @param cc
         */

    }, {
        key: 'canvas_draw_compass',
        value: function canvas_draw_compass(cc) {
            cc.translate((0, _core.calculateMiddle)(this.canvas.size.width), (0, _core.calculateMiddle)(this.canvas.size.height));

            var airport = window.airportController.airport_get();
            var size = 80;
            var size2 = size / 2;
            var padding = 16;
            var dot = 16;
            var windspeed_line = void 0;
            var highwind = void 0;

            // Shift compass location
            cc.translate(-size2 - padding, -size2 - padding);
            cc.lineWidth = 4;

            // Outer circle
            cc.fillStyle = 'rgba(0, 0, 0, 0.7)';
            cc.beginPath();
            cc.arc(0, 0, size2, 0, (0, _circle.tau)());
            cc.fill();

            // Inner circle
            cc.lineWidth = 1;
            cc.beginPath();
            cc.arc(0, 0, dot / 2, 0, (0, _circle.tau)());
            cc.strokeStyle = COLORS.WHITE_07;
            cc.stroke();

            // Wind Value
            cc.fillStyle = COLORS.WHITE_07;
            cc.textAlign = 'center';
            cc.textBaseline = 'center';
            cc.font = '9px monoOne, monospace';
            cc.fillText(airport.wind.speed, 0, 3.8);
            cc.font = 'bold 10px monoOne, monospace';

            // Wind line
            if (airport.wind.speed > 8) {
                windspeed_line = airport.wind.speed / 2;
                highwind = true;
            } else {
                windspeed_line = airport.wind.speed;
                highwind = false;
            }

            cc.save();
            cc.translate(-dot / 2 * (0, _core.sin)(airport.wind.angle), dot / 2 * (0, _core.cos)(airport.wind.angle));
            cc.beginPath();
            cc.moveTo(0, 0);
            cc.rotate(airport.wind.angle);
            cc.lineTo(0, (0, _core.extrapolate_range_clamp)(0, windspeed_line, 15, 0, size2 - dot));

            // TODO: simplify. replace with initial assignment and re-assignment in if condition
            // Color wind line red for high-wind
            if (highwind) {
                cc.strokeStyle = COLORS.BRIGHT_RED;
            } else {
                cc.strokeStyle = COLORS.WHITE_07;
            }

            cc.lineWidth = 2;
            cc.stroke();
            cc.restore();
            cc.fillStyle = COLORS.WHITE_07;
            cc.textAlign = 'center';
            cc.textBaseline = 'top';

            for (var i = 90; i <= 360; i += 90) {
                cc.rotate((0, _unitConverters.degreesToRadians)(90));

                var angle = void 0;
                if (i === 90) {
                    angle = '0' + i;
                } else {
                    angle = i;
                }

                cc.save();
                cc.fillText(angle, 0, -size2 + 4);
                cc.restore();
            }
        }

        /**
         * Draw circular airspace border
         *
         * @for CanvasController
         * @method anvas_draw_ctr
         * @param cc
         */

    }, {
        key: 'canvas_draw_ctr',
        value: function canvas_draw_ctr(cc) {
            // Draw a gentle fill color with border within the bounds of the airport's ctr_radius
            cc.strokeStyle = COLORS.AIRSPACE_RADIUS_STROKE;
            cc.fillStyle = COLORS.AIRSPACE_RADIUS_FILL;
            cc.beginPath();
            cc.arc(0, 0, window.airportController.airport_get().ctr_radius * prop.ui.scale, 0, (0, _circle.tau)());
            cc.fill();
            cc.stroke();
        }

        /**
         * Draw polygonal airspace border
         *
         * @for CanvasController
         * @method anvas_draw_airspace_border
         * @param cc
         */

    }, {
        key: 'canvas_draw_airspace_border',
        value: function canvas_draw_airspace_border(cc) {
            var airport = window.airportController.airport_get();
            if (!airport.airspace) {
                this.canvas_draw_ctr(cc);
            }

            // style
            cc.strokeStyle = COLORS.AIRSPACE_RADIUS_STROKE;
            cc.fillStyle = COLORS.AIRSPACE_RADIUS_FILL;

            // draw airspace
            for (var i = 0; i < airport.airspace.length; i++) {
                var poly = _jquery2.default.map(airport.perimeter.poly, function (v) {
                    // TODO: this seems strange. are we returning a single-index array everytime? what does v.position look like?
                    return [v.position];
                });

                this.canvas_draw_poly(cc, poly);
                cc.clip();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_fancy_rings
         * @param cc
         * @param fix_origin
         * @param fix1
         * @param fix2
         */

    }, {
        key: 'canvas_draw_fancy_rings',
        value: function canvas_draw_fancy_rings(cc, fix_origin, fix1, fix2) {
            var airport = window.airportController.airport_get();
            var origin = airport.getFixPosition(fix_origin);
            var f1 = airport.getFixPosition(fix1);
            var f2 = airport.getFixPosition(fix2);
            var minDist = Math.min((0, _distance.distance2d)(origin, f1), (0, _distance.distance2d)(origin, f2));
            var halfPI = Math.PI / 2;
            var extend_ring = (0, _unitConverters.degreesToRadians)(10);
            var start_angle = Math.atan2(f1[0] - origin[0], f1[1] - origin[1]) - halfPI - extend_ring;
            var end_angle = Math.atan2(f2[0] - origin[0], f2[1] - origin[1]) - halfPI + extend_ring;
            var x = (0, _core.round)(window.uiController.km_to_px(origin[0])) + this.canvas.panX;
            var y = -(0, _core.round)(window.uiController.km_to_px(origin[1])) + this.canvas.panY;
            // 5NM = 9.27km
            var radius = 9.27;

            for (var i = 0; i < 4; i++) {
                cc.beginPath();
                cc.arc(x, y, window.uiController.km_to_px(minDist - i * radius), start_angle, end_angle);

                cc.stroke();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_engm_range_rings
         * @param cc
         */
        // Draw range rings for ENGM airport to assist in point merge

    }, {
        key: 'canvas_draw_engm_range_rings',
        value: function canvas_draw_engm_range_rings(cc) {
            cc.strokeStyle = 'rgba(200, 255, 200, 0.3)';
            cc.setLineDash([3, 6]);

            this.canvas_draw_fancy_rings(cc, 'BAVAD', 'GM428', 'GM432');
            this.canvas_draw_fancy_rings(cc, 'TITLA', 'GM418', 'GM422');
            this.canvas_draw_fancy_rings(cc, 'INSUV', 'GM403', 'GM416');
            this.canvas_draw_fancy_rings(cc, 'VALPU', 'GM410', 'GM402');
        }

        /**
         * @for CanvasController
         * @method canvas_draw_range_rings
         * @param cc
         */

    }, {
        key: 'canvas_draw_range_rings',
        value: function canvas_draw_range_rings(cc) {
            var airport = window.airportController.airport_get();
            // convert input param from nm to km
            var rangeRingRadius = (0, _unitConverters.km)(airport.rr_radius_nm);

            // Fill up airport's ctr_radius with rings of the specified radius
            for (var i = 1; i * rangeRingRadius < airport.ctr_radius; i++) {
                cc.beginPath();
                cc.linewidth = 1;
                cc.arc(0, 0, rangeRingRadius * prop.ui.scale * i, 0, (0, _circle.tau)());
                cc.strokeStyle = COLORS.AIRSPACE_RANGE_RING_COLOR;
                cc.stroke();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_poly
         * @param cc
         * @param poly
         */

    }, {
        key: 'canvas_draw_poly',
        value: function canvas_draw_poly(cc, poly) {
            cc.beginPath();

            (0, _forEach3.default)(poly, function (singlePoly, v) {
                cc.lineTo(window.uiController.km_to_px(singlePoly[0]), -window.uiController.km_to_px(singlePoly[1]));
            });

            cc.closePath();
            cc.stroke();
            cc.fill();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_terrain
         * @param cc
         */

    }, {
        key: 'canvas_draw_terrain',
        value: function canvas_draw_terrain(cc) {
            if (!this.canvas.draw_terrain) {
                return;
            }

            cc.strokeStyle = COLORS.WHITE_04;
            cc.fillStyle = COLORS.WHITE_02;
            cc.lineWidth = (0, _core.clamp)(0.5, prop.ui.scale / 10, 2);
            cc.lineJoin = 'round';

            var airport = window.airportController.airport_get();
            var max_elevation = 0;

            cc.save();
            cc.translate(this.canvas.panX, this.canvas.panY);

            _jquery2.default.each(airport.terrain || [], function (elevation, terrainLevel) {
                max_elevation = Math.max(max_elevation, elevation);
                var color = 'rgba(' + prop.ui.terrain.colors[elevation] + ', ';

                cc.strokeStyle = color + ' ' + prop.ui.terrain.border_opacity + ')';
                cc.fillStyle = color + ' ' + prop.ui.terrain.fill_opacity + ')';

                (0, _forEach3.default)(terrainLevel, function (terrainGroup) {
                    cc.beginPath();

                    (0, _forEach3.default)(terrainGroup, function (terrainItem) {
                        // TODO: should this be a for/in? is it an array?
                        (0, _forEach3.default)(terrainItem, function (value, index) {
                            // Loose equals is important here.
                            if (index === 0) {
                                cc.moveTo(window.uiController.km_to_px(terrainItem[index][0]), -window.uiController.km_to_px(terrainItem[index][1]));
                            }

                            cc.lineTo(window.uiController.km_to_px(terrainItem[index][0]), -window.uiController.km_to_px(terrainItem[index][1]));
                        });

                        cc.closePath();
                    });

                    cc.fill();
                    cc.stroke();
                });
            });

            cc.restore();

            if (max_elevation === 0) {
                return;
            }

            var offset = 10;
            var width = this.canvas.size.width;
            var height = this.canvas.size.height;
            var box_width = 30;
            var box_height = 5;

            cc.font = BASE_CANVAS_FONT;
            cc.lineWidth = 1;

            for (var i = 1000; i <= max_elevation; i += 1000) {
                cc.save();
                // translate coordinates for every block to not use these X & Y twice in rect and text
                // .5 in X and Y coordinates are used to make 1px rectangle fit exactly into 1 px
                // and not be blurred
                cc.translate(width / 2 - 140.5 - (max_elevation - i) / 1000 * (box_width + 1), -height / 2 + offset + 0.5);
                cc.beginPath();
                cc.rect(0, 0, box_width - 1, box_height);
                cc.closePath();

                // in the map, terrain of higher levels has fill of all the lower levels
                // so we need to fill it below exactly as in the map
                for (var j = 0; j <= i; j += 1000) {
                    cc.fillStyle = 'rgba(' + prop.ui.terrain.colors[j] + ', ' + prop.ui.terrain.fill_opacity + ')';
                    cc.fill();
                }

                cc.strokeStyle = 'rgba(' + prop.ui.terrain.colors[i] + ', ' + prop.ui.terrain.border_opacity + ')';
                cc.stroke();

                // write elevation signs only for the outer elevations
                if (i === max_elevation || i === 1000) {
                    cc.fillStyle = COLORS.WHITE;
                    cc.textAlign = 'center';
                    cc.textBaseline = 'top';
                    cc.fillText(i + '\'', box_width / 2 + 0.5, offset + 2);
                }

                cc.restore();
            }
        }

        /**
         * @for CanvasController
         * @method canvas_draw_restricted
         * @param cc
         */

    }, {
        key: 'canvas_draw_restricted',
        value: function canvas_draw_restricted(cc) {
            var _this5 = this;

            if (!this.canvas.draw_restricted) {
                return;
            }

            cc.strokeStyle = COLORS.RESTRICTED_AIRSPACE_STROKE;
            cc.lineWidth = Math.max(prop.ui.scale / 3, 2);
            cc.lineJoin = 'round';
            cc.font = BASE_CANVAS_FONT;

            var airport = window.airportController.airport_get();

            cc.save();
            cc.translate(this.canvas.panX, this.canvas.panY);

            (0, _forEach3.default)(airport.restricted_areas, function (area) {
                cc.fillStyle = 'transparent';
                _this5.canvas_draw_poly(cc, area.coordinates);

                cc.fillStyle = COLORS.RESTRICTED_AIRSPACE_FILL;
                cc.textAlign = 'center';
                cc.textBaseline = 'top';

                var height = area.height === Infinity ? 'UNL' : 'FL' + Math.ceil(area.height / 1000) * 10;
                var height_shift = 0;

                if (area.name) {
                    height_shift = -12;

                    cc.fillText(area.name, (0, _core.round)(window.uiController.km_to_px(area.center[0])), -(0, _core.round)(window.uiController.km_to_px(area.center[1])));
                }

                cc.fillText(height, (0, _core.round)(window.uiController.km_to_px(area.center[0])), height_shift - (0, _core.round)(window.uiController.km_to_px(area.center[1])));
            });

            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_videoMap
         * @param cc
         */

    }, {
        key: 'canvas_draw_videoMap',
        value: function canvas_draw_videoMap(cc) {
            if (!(0, _has3.default)(window.airportController.airport_get(), 'maps')) {
                return;
            }

            cc.strokeStyle = COLORS.VIDEO_MAP_STROKE;
            cc.lineWidth = prop.ui.scale / 15;
            cc.lineJoin = 'round';
            cc.font = BASE_CANVAS_FONT;

            var airport = window.airportController.airport_get();
            var map = airport.maps.base;

            cc.save();
            cc.translate(this.canvas.panX, this.canvas.panY);

            (0, _forEach3.default)(map, function (mapItem, i) {
                cc.moveTo(window.uiController.km_to_px(mapItem[0]), -window.uiController.km_to_px(mapItem[1]));
                // cc.beginPath();
                cc.lineTo(window.uiController.km_to_px(mapItem[2]), -window.uiController.km_to_px(mapItem[3]));
            });

            cc.stroke();
            cc.restore();
        }

        /** Draws crosshairs that point to the currently translated location
         /**
         * @for CanvasController
         * @method canvas_draw_crosshairs
         * @param cc
         */

    }, {
        key: 'canvas_draw_crosshairs',
        value: function canvas_draw_crosshairs(cc) {
            cc.save();
            cc.strokeStyle = COLORS.CROSSHAIR_STROKE;
            cc.lineWidth = 3;
            cc.beginPath();
            cc.moveTo(-10, 0);
            cc.lineTo(10, 0);
            cc.stroke();
            cc.beginPath();
            cc.moveTo(0, -10);
            cc.lineTo(0, 10);
            cc.stroke();
            cc.restore();
        }

        /**
         * @for CanvasController
         * @method canvas_draw_directions
         * @param cc
         */

    }, {
        key: 'canvas_draw_directions',
        value: function canvas_draw_directions(cc) {
            if (window.gameController.game_paused()) {
                return;
            }

            var callsign = prop.input.callsign.toUpperCase();
            if (callsign.length === 0) {
                return;
            }

            // Get the selected aircraft.
            var aircraft = prop.aircraft.list.filter(function (p) {
                return p.isVisible() && p.getCallsign().toUpperCase() === callsign;
            })[0];

            if (!aircraft) {
                return;
            }

            var pos = this.to_canvas_pos(aircraft.position);
            var rectPos = [0, 0];
            var rectSize = [this.canvas.size.width, this.canvas.size.height];

            cc.save();
            cc.strokeStyle = COLORS.LIGHT_SILVER;
            cc.fillStyle = COLORS.WHITE;
            cc.textAlign = 'center';
            cc.textBaseline = 'middle';

            for (var alpha = 0; alpha < 360; alpha++) {
                var dir = [(0, _core.sin)((0, _unitConverters.degreesToRadians)(alpha)), -(0, _core.cos)((0, _unitConverters.degreesToRadians)(alpha))];

                var p = (0, _vector.positive_intersection_with_rect)(pos, dir, rectPos, rectSize);

                if (p) {
                    var markLen = alpha % 5 === 0 ? alpha % 10 === 0 ? 16 : 12 : 8;
                    var markWeight = alpha % 30 === 0 ? 2 : 1;

                    var dx = -markLen * dir[0];
                    var dy = -markLen * dir[1];

                    cc.lineWidth = markWeight;
                    cc.beginPath();
                    cc.moveTo(p[0], p[1]);

                    var markX = p[0] + dx;
                    var markY = p[1] + dy;

                    cc.lineTo(markX, markY);
                    cc.stroke();

                    if (alpha % 10 === 0) {
                        cc.font = alpha % 30 === 0 ? 'bold 10px monoOne, monospace' : BASE_CANVAS_FONT;

                        var text = '' + alpha;
                        var textWidth = cc.measureText(text).width;

                        cc.fillText(text, markX - dir[0] * (textWidth / 2 + 4), markY - dir[1] * 7);
                    }
                }
            }

            cc.restore();
        }

        /**
         * @for CanvasController
         * @method to_canvas_
         * @param pos {}
         */

    }, {
        key: 'to_canvas_pos',
        value: function to_canvas_pos(pos) {
            return [this.canvas.size.width / 2 + this.canvas.panX + (0, _unitConverters.km)(pos[0]), this.canvas.size.height / 2 + this.canvas.panY - (0, _unitConverters.km)(pos[1])];
        }
    }]);

    return ConvasController;
}();

exports.default = ConvasController;

},{"../constants/aircraftConstants":570,"../constants/logLevel":574,"../constants/selectors":575,"../math/circle":583,"../math/core":584,"../math/distance":585,"../math/vector":587,"../utilities/timeHelpers":594,"../utilities/unitConverters":595,"jquery":296,"lodash/cloneDeep":461,"lodash/forEach":468,"lodash/has":470}],563:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _commandDefinitions = require('./commandDefinitions');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A definition of a specific command and it's arguments.
 *
 * Conatins a command name, which maps 1:1 with a name defined in `commandMap.js` and `commandDefinitions.js`.
 * Commands may have an alias or many, we care only about the root command. The command map will map any
 * alias to a root command and this `CommandModel` is only concerned about those root commands. It has
 * no way of knowing what the original alias was, if one was used.
 *
 * Each `CommandModel` will be expected to have, at a minimum, a `name` and a matching `COMMAND_DEFINITION`.
 *
 * @class CommandModel
 */
var CommandModel = function () {
  /**
   * @constructor
   * @for CommandModel
   */
  function CommandModel() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, CommandModel);

    /**
     * command name, should match a command in the COMMANDS constant
     *
     * @property name
     * @type {string}
     */
    this.name = name;

    /**
     * A reference to the COMMAND_DEFINITION for this particular command.
     * this gives us access to both the `validate` and `parse` methods
     * that belong to this command.
     *
     * Storing this as a class property allows us to do the lookup once
     * and then make it available to the rest of the class so it can
     * be referenced when needed.
     *
     * @property _commandDefinition
     * @type {object}
     * @private
     */
    this._commandDefinition = _commandDefinitions.COMMAND_DEFINITION[name];

    /**
     * list of command arguments
     *
     * - assumed to be the text command names
     * - may be empty, depending on the command
     * - should only ever be strings on initial set immediately after instantiation
     * - will later be parsed via the `_commandDefinition.parse()` method to the
     *   correct data types and shape
     *
     * @property args
     * @type {array}
     * @default []
     */
    this.args = [];

    // TODO: may need to throw here if `_commandDefinition` is undefined
  }

  /**
   * Return an array of [name, ...args]
   *
   * We use this shape solely to match the existing api.
   *
   * @property nameAndArgs
   * @return {array}
   */


  _createClass(CommandModel, [{
    key: 'validateArgs',


    /**
     * Send the initial args off to the validator
     *
     * @for CommandModel
     * @method validateArgs
     * @return {string|undefined}
     */
    value: function validateArgs() {
      return this._commandDefinition.validate(this.args);
    }

    /**
     * Send the initial args, set from the `CommandParser` right after instantiation, off to
     * the parser for formatting.
     *
     * @for CommandModel
     * @method parseArgs
     */

  }, {
    key: 'parseArgs',
    value: function parseArgs() {
      // this completely overwrites current args. this is intended because all args are received as
      // strings but consumed as strings, numbers or booleans. and when the args are initially set
      // they may not all be available yet
      this.args = this._commandDefinition.parse(this.args);
    }
  }, {
    key: 'nameAndArgs',
    get: function get() {
      return [this.name].concat(_toConsumableArray(this.args));
    }
  }]);

  return CommandModel;
}();

exports.default = CommandModel;

},{"./commandDefinitions":567}],564:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _tail2 = require('lodash/tail');

var _tail3 = _interopRequireDefault(_tail2);

var _CommandModel = require('./CommandModel');

var _CommandModel2 = _interopRequireDefault(_CommandModel);

var _generalUtilities = require('../utilities/generalUtilities');

var _commandMap = require('./commandMap');

var _globalConstants = require('../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Symbol used to split the command string as it enters the class.
 *
 * @property COMMAND_ARGS_SEPARATOR
 * @type {string}
 * @final
 */
var COMMAND_ARGS_SEPARATOR = ' ';

/**
 * This class is responsible for taking the content of the `$commandInput` and parsing it
 * out into commands and arguments.
 *
 * Everything this class needs comes in as a single string provided by `InputController.input_run()`.
 * ex:
 * - `timewarp 50`
 * - `AA777 fh 0270 d 050 sp 200`
 * - `AA777 hold dumba left 2min`
 *
 * **Differentiation of commands and arguments is determinied by splitting the string on an empty space. This
 * is very important, so legacy commands did not have spaces between the command and argument. With this
 * implementation _every_ command shall have a space between itself and it's arguments.**
 *
 * Commands are broken out into two categories: `System` and `Transmit`.
 * - System commands are zero or single argument commands that are used for interacting with the app
 *   itslef. Things like `timewarp` or `tutorial` are examples of system commands.
 *
 * - Transmit commands are instructions meant for a specific aircraft within the controlled airspace.
 *   These commands can have zero to many arguments, depending on the command. Some examples of transmit
 *   commands are `to`, `taxi`, `hold`.
 *
 * Commands go through a lifecycle as they move from raw to parsed:
 * - user types command and presses enter
 * - command string is captured via input value, then passed as an argument to this class
 * - determine if command string is a `System Command` or `Transmit`
 * - creation of `CommandModel` objects for each command/argment group found
 * - validate command arguments (number of arguments and data type)
 * - parse command arguments
 *
 * All available commands are defined in the `commandMap`. Two terms of note are alias and root command.
 * We would call the `takeoff` command a root command and `to` and `cto` alises. The root command is the
 * one that shares the same key as the command definition which gives us the correct validator and parser.
 * The root command is also what the `AircraftInstanceModel` is expecting when it receives commands
 * from the `InputController`.
 *
 * @class CommandParser
 */

var CommandParser = function () {
    /**
     * @constructor
     * @for CommandParser
     * @param rawCommandWithArgs {string}  string present in the `$commandInput` when the user pressed `enter`
     */
    function CommandParser() {
        var rawCommandWithArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, CommandParser);

        if (!(0, _isString3.default)(rawCommandWithArgs)) {
            // istanbul ignore next
            // eslint-disable-next-line max-len
            throw new TypeError('Invalid parameter. CommandParser expects a string but received ' + (typeof rawCommandWithArgs === 'undefined' ? 'undefined' : _typeof(rawCommandWithArgs)));
        }

        /**
         * Command name
         *
         * Could be either Transmit or a System command
         *
         * This is consumed by the `InputController` after parsing here and is used to
         * determine what to do with the parsed command(s)
         *
         * @type {string}
         * @default ''
         */
        this.command = '';

        /**
         * Aircraft callsign
         *
         * this is optional and not included with system commands
         *
         * @type {string}
         * @default ''
         */
        this.callsign = '';

        /**
         * List of `CommandModel` objects.
         *
         * Each command is contained within a `CommandModel`, even System commands. This provides
         * a consistent interface for obtaining commands and arguments (via getter) and also
         * aloows for easy implementation of the legacy API structure.
         *
         * @type {array<CommandModel>}
         */
        this.commandList = [];

        this._extractCommandsAndArgs(rawCommandWithArgs.toLowerCase());
    }

    /**
     * Return an array of [commandName, ...args]
     *
     * We use this shape solely to match the existing api.
     *
     * When command is a System command:
     * - commandList is assumed to have a length on 1
     * - commandList[0].args[0] is assumed to have a single string value
     *
     * @property args
     * @return {string|array<string>}
     */


    _createClass(CommandParser, [{
        key: '_extractCommandsAndArgs',


        /**
         * Accept the entire string provided to the constructor and attempt to break it up into:
         * - System command and its arguments
         * - Transmit commands and thier arguments
         *
         * @for CommandParser
         * @method _extractCommandsAndArgs
         * @param rawCommandWithArgs {string}
         * @private
         */
        value: function _extractCommandsAndArgs(rawCommandWithArgs) {
            var commandOrCallsignIndex = 0;
            var commandArgSegmentsWithCallsign = rawCommandWithArgs.split(COMMAND_ARGS_SEPARATOR);
            var callsignOrSystemCommandName = commandArgSegmentsWithCallsign[commandOrCallsignIndex];
            // effectively a slice of the array that returns everything but the first item
            var commandArgSegments = (0, _tail3.default)(commandArgSegmentsWithCallsign);

            if (this._isSystemCommand(callsignOrSystemCommandName)) {
                this._buildSystemCommandModel(commandArgSegmentsWithCallsign);

                return;
            }

            this._buildTransmitCommandModels(callsignOrSystemCommandName, commandArgSegments);
        }

        /**
         * Build a `CommandModel` for a System command then add that model to the `commandList`
         *
         * @for CommandParser
         * @method _buildSystemCommandModel
         * @private
         */

    }, {
        key: '_buildSystemCommandModel',
        value: function _buildSystemCommandModel(commandArgSegments) {
            var commandIndex = 0;
            var argIndex = 1;
            var commandName = commandArgSegments[commandIndex];
            var commandModel = new _CommandModel2.default(commandName);
            commandModel.args.push(commandArgSegments[argIndex]);

            this.command = commandName;
            this.commandList.push(commandModel);

            this._validateAndParseCommandArguments();
        }

        /**
         * Build `CommandModel` objects for each transmit commands then add them to the `commandList`
         *
         * @private
         */

    }, {
        key: '_buildTransmitCommandModels',
        value: function _buildTransmitCommandModels(callsignOrSystemCommandName, commandArgSegments) {
            this.command = _commandMap.SYSTEM_COMMANDS.transmit;
            this.callsign = callsignOrSystemCommandName;
            this.commandList = this._buildCommandList(commandArgSegments);

            this._validateAndParseCommandArguments();
        }

        /**
         * Loop through the commandArgSegments array and either create a new `CommandModel` or add
         * arguments to a `CommandModel`.
         *
         * commandArgSegments will contain both commands and arguments (very contrived example):
         * - `[cmd, arg, arg, cmd, cmd, arg, arg, arg]`
         *
         * this method is expecting that
         * the first item it receives, that is not a space, is a command. we then push each successive
         * array item to the args array until we find another command. then we repeat the process.
         *
         * this allows us to create several `CommandModel` with arguments and only loop over them once.
         *
         * @for CommandParser
         * @method _buildCommandList
         * @param commandArgSegments {array<string>}
         * @return {array<CommandModel>}
         * @private
         */

    }, {
        key: '_buildCommandList',
        value: function _buildCommandList(commandArgSegments) {
            var _this = this;

            var commandModel = void 0;

            // TODO: this still feels icky and could be simplified some more
            var commandList = (0, _map3.default)(commandArgSegments, function (commandOrArg) {
                if (commandOrArg === '') {
                    return;
                } else if (_globalConstants.REGEX.UNICODE.test(commandOrArg)) {
                    var commandString = (0, _generalUtilities.unicodeToString)(commandOrArg);
                    commandModel = new _CommandModel2.default(_commandMap.COMMAND_MAP[commandString]);

                    return commandModel;
                } else if ((0, _has3.default)(_commandMap.COMMAND_MAP, commandOrArg) && !_this._isAliasCommandAnArg(commandModel, commandOrArg)) {
                    commandModel = new _CommandModel2.default(_commandMap.COMMAND_MAP[commandOrArg]);

                    return commandModel;
                } else if (typeof commandModel === 'undefined') {
                    // if we've made it here and commandModel is still undefined, a command was not found
                    return;
                }

                commandModel.args.push(commandOrArg);
            });

            return (0, _compact3.default)(commandList);
        }

        /**
         * This method is used for addressing a very specific situation
         *
         * When the current command is `heading` and one of the arguments is `l`, the parser interprets
         * the `l` as another command. `l` is an alias for the `land` command.
         *
         * This method expects that a commandString will look like:
         * `AA321 t l 042`
         *
         * We look for the `heading` command and no existing arguments, as the `l` would become the
         * first argument in this situation.
         *
         * @for CommandParser
         * @method _isAliasCommandAnArg
         * @param commandModel {CommandModel}
         * @param commandOrArg {string}
         * @return {boolean}
         */

    }, {
        key: '_isAliasCommandAnArg',
        value: function _isAliasCommandAnArg(commandModel, commandOrArg) {
            if (!commandModel) {
                return false;
            }

            return commandModel.name === 'heading' && commandModel.args.length === 0 && commandOrArg === 'l';
        }

        /**
         * Fire off the `_validateCommandArguments` method and throws any errors returned
         *
         * @for CommandParser
         * @method _validateAndParseCommandArguments
         * @private
         */

    }, {
        key: '_validateAndParseCommandArguments',
        value: function _validateAndParseCommandArguments() {
            var validationErrors = this._validateCommandArguments();

            if (validationErrors.length > 0) {
                (0, _forEach3.default)(validationErrors, function (error) {
                    throw error;
                });
            }
        }

        /**
         * For each `CommandModel` in the `commandList`, first validate it's arguments
         * then parse those arguments into a consumable array.
         *
         * @for CommandParser
         * @method _validateCommandArguments
         * @private
         */

    }, {
        key: '_validateCommandArguments',
        value: function _validateCommandArguments() {
            return (0, _compact3.default)((0, _map3.default)(this.commandList, function (command) {
                var hasError = command.validateArgs();

                if (hasError) {
                    // we only return here so all the errors can be thrown at once
                    // from within the calling method
                    return hasError;
                }

                command.parseArgs();
            }));
        }

        /**
         * Encapsulation of boolean logic used to determine if the `callsignOrSystemCommandName`
         * is in fact a system command.
         *
         *
         * @for CommandParser
         * @method _isSystemCommand
         * @param callsignOrSystemCommandName {string}
         * @return {boolean}
         */

    }, {
        key: '_isSystemCommand',
        value: function _isSystemCommand(callsignOrSystemCommandName) {
            return (0, _has3.default)(_commandMap.SYSTEM_COMMANDS, callsignOrSystemCommandName) && callsignOrSystemCommandName !== _commandMap.SYSTEM_COMMANDS.transmit;
        }
    }, {
        key: 'args',
        get: function get() {
            if (this.command !== _commandMap.SYSTEM_COMMANDS.transmit) {
                return this.commandList[0].args;
            }

            return (0, _map3.default)(this.commandList, function (command) {
                return command.nameAndArgs;
            });
        }
    }]);

    return CommandParser;
}();

exports.default = CommandParser;

},{"../constants/globalConstants":573,"../utilities/generalUtilities":592,"./CommandModel":563,"./commandMap":568,"lodash/compact":462,"lodash/forEach":468,"lodash/has":470,"lodash/isString":489,"lodash/map":496,"lodash/tail":505}],565:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.holdParser = exports.findHoldCommandByType = exports.headingParser = exports.altitudeParser = undefined;

var _argumentValidators = require('./argumentValidators');

var _unitConverters = require('../utilities/unitConverters');

/**
 * Enumeration of possible the hold command argument names.
 *
 * Enumerated here base these nanes are shared accross several functions and this
 * provides a single source of truth.
 *
 * @property HOLD_COMMAND_ARG_NAMES
 * @type {Object}
 * @final
 */
var HOLD_COMMAND_ARG_NAMES = {
    TURN_DIRECTION: 'turnDirection',
    LEG_LENGTH: 'legLength',
    FIX_NAME: 'fixName'
};

/**
 * Converts a flight level altitude to a number in thousands and converts second arg to a boolean
 *
 * @function altitudeParser
 * @param args {array}
 * @return {array<number, boolean>}
 */
var altitudeParser = exports.altitudeParser = function altitudeParser(args) {
    var altitude = (0, _unitConverters.convertToThousands)(args[0]);
    // the validator will have already caught an invalid value here. if one exists, it is assumed to be valid and
    // thus we return true. otherwise its false
    var shouldExpedite = typeof args[1] !== 'undefined';

    return [altitude, shouldExpedite];
};

/**
 * Accepts a direction string:
 * - `left / l / right / r`
 *
 * and returns `left / right`
 *
 * @function directionNormalizer
 * @param direction {string}
 * @return normalizedDirection {string}
 */
var directionNormalizer = function directionNormalizer(direction) {
    var normalizedDirection = direction;

    if (direction === 'l') {
        normalizedDirection = 'left';
    } else if (direction === 'r') {
        normalizedDirection = 'right';
    }

    return normalizedDirection;
};

/**
 * Returns a consistent array with the same shape no matter the number of arguments received
 *
 * Converts a flight level altitude to a number in thousands and converts second arg to a boolean
 *
 * @function headingParser
 * @param args {array}
 * @return {array<string, number, boolean>}
 */
var headingParser = exports.headingParser = function headingParser(args) {
    var direction = void 0;
    var heading = void 0;
    var isIncremental = false;

    switch (args.length) {
        case 1:
            // existing api is expeting undefined values to be exactly null
            direction = null;
            heading = (0, _unitConverters.convertStringToNumber)(args[0]);

            return [direction, heading, isIncremental];
        case 2:
            isIncremental = args[1].length === 2;
            direction = directionNormalizer(args[0]);
            heading = (0, _unitConverters.convertStringToNumber)(args[1]);

            return [direction, heading, isIncremental];
        default:
            throw new Error('An error ocurred parsing the Heading arguments');
    }
};

/**
 * Abstracted boolean logic used to detmine if a string contains `min` or `nm`.
 *
 * This is useful specifically with the `findHoldCommandByType`.
 *
 * @function isLegLengthArg
 * @param arg {string}
 * @return {boolean}
 */
var isLegLengthArg = function isLegLengthArg(arg) {
    return arg.indexOf('min') !== -1 || arg.indexOf('nm') !== -1;
};

/**
 * Given a type and an argument list, find the first occurance of `type` from within the argument list.
 *
 * We are looking for one of three things here:
 * - `turnDirection` - a variation of left or right
 * - `legLength` - length of hold leg in either minutes (min) or nautical miles (nm)
 * - `fixName` - assumed to be a string that isn't a `turnDirection` or `legLength`. The parser has no way of
 *               knowing if a certain string is an actual `fixName`. We can only determine that it isn't a
 *               `turnDirection` or `legLength`. This will error from within the `runHold` method if the
 *               `fixName` is not valid.
 *
 * @function findHoldCommandByType
 * @param type {HOLD_COMMAND_ARG_NAMES}
 * @param args {array}
 * @return {string|null}
 */
var findHoldCommandByType = exports.findHoldCommandByType = function findHoldCommandByType(type, args) {
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];

        switch (type) {
            case HOLD_COMMAND_ARG_NAMES.TURN_DIRECTION:
                if (!(0, _argumentValidators.isValidDirectionString)(arg)) {
                    continue;
                }

                return directionNormalizer(arg);
            case HOLD_COMMAND_ARG_NAMES.LEG_LENGTH:
                if (!isLegLengthArg(arg)) {
                    continue;
                }

                return arg;
            case HOLD_COMMAND_ARG_NAMES.FIX_NAME:
                if ((0, _argumentValidators.isValidDirectionString)(arg) || isLegLengthArg(arg)) {
                    continue;
                }

                return arg;
            default:
                return null;
        }
    }

    return null;
};

/**
 * The `hold` command accepts arguments in any order thus, we use the `findHoldCommandByType` helper
 * method to do that for us. This provides an easy way tp find the correct argument, no matter the order,
 * and consistently return an array of the same shape.
 *
 * @function holdParser
 * @param args {array}
 * @return {array<string>}
 */
var holdParser = exports.holdParser = function holdParser(args) {
    // existing api is expeting undefined values to be exactly null
    var fixName = findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.FIX_NAME, args);
    var turnDirection = findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.TURN_DIRECTION, args);
    var legLength = findHoldCommandByType(HOLD_COMMAND_ARG_NAMES.LEG_LENGTH, args);

    return [turnDirection, legLength, fixName];
};

},{"../utilities/unitConverters":595,"./argumentValidators":566}],566:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.holdValidator = exports.headingValidator = exports.isValidDirectionString = exports.fixValidator = exports.altitudeValidator = exports.oneOrThreeArgumentsValidator = exports.oneToThreeArgumentsValidator = exports.oneOrTwoArgumentValidator = exports.zeroOrOneArgumentValidator = exports.singleArgumentValidator = exports.zeroArgumentsValidator = undefined;

var _isNaN2 = require('lodash/isNaN');

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _unitConverters = require('../utilities/unitConverters');

var _commandMap = require('./commandMap');

var _commandParserMessages = require('./commandParserMessages');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Check that `args` has exactly zero values
 *
 * @function zeroArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */
var zeroArgumentsValidator = exports.zeroArgumentsValidator = function zeroArgumentsValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length !== 0) {
        return _commandParserMessages.ERROR_MESSAGE.ZERO_ARG_LENGTH;
    }
};

/**
 * Checks that `args` has exactly one value
 *
 * @function singleArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */
var singleArgumentValidator = exports.singleArgumentValidator = function singleArgumentValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length !== 1) {
        return _commandParserMessages.ERROR_MESSAGE.SINGLE_ARG_LENGTH;
    }
};

/**
 * Checks that `args` has exactly zero or one value
 *
 * @function zeroOrOneArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */
var zeroOrOneArgumentValidator = exports.zeroOrOneArgumentValidator = function zeroOrOneArgumentValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length > 1) {
        return _commandParserMessages.ERROR_MESSAGE.ZERO_OR_ONE_ARG_LENGTH;
    }
};

/**
 * Checks that `args` has exactly one or two values
 *
 * @function oneOrTwoArgumentValidator
 * @param args {array}
 * @return {string|undefined}
 */
var oneOrTwoArgumentValidator = exports.oneOrTwoArgumentValidator = function oneOrTwoArgumentValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length < 1 || args.length > 2) {
        return _commandParserMessages.ERROR_MESSAGE.ONE_OR_TWO_ARG_LENGTH;
    }
};

/**
 * Checks that `args` has exactly one, two or three values
 *
 * @function oneToThreeArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */
var oneToThreeArgumentsValidator = exports.oneToThreeArgumentsValidator = function oneToThreeArgumentsValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length === 0 || args.length > 3) {
        return _commandParserMessages.ERROR_MESSAGE.ONE_TO_THREE_ARG_LENGTH;
    }
};

/**
 * Checks that `args` has exactly one or three values
 *
 * @function oneOrThreeArgumentsValidator
 * @param args {array}
 * @return {string|undefined}
 */
var oneOrThreeArgumentsValidator = exports.oneOrThreeArgumentsValidator = function oneOrThreeArgumentsValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length !== 1 && args.length !== 3) {
        return _commandParserMessages.ERROR_MESSAGE.ONE_OR_THREE_ARG_LENGTH;
    }
};

/**
 * Checks that args is the required length and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['030']
 * - ['030', 'expedite']
 * - ['030', 'x']
 * ```
 *
 * @function altitudeValidator
 * @param args {array}
 * @return {string|undefined}
 */
var altitudeValidator = exports.altitudeValidator = function altitudeValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var hasLengthError = oneOrTwoArgumentValidator(args);

    if (hasLengthError) {
        return hasLengthError;
    }

    if (args.length === 2 && _commandMap.EXPEDITE.indexOf(args[1]) === -1) {
        return _commandParserMessages.ERROR_MESSAGE.ALTITUDE_EXPEDITE_ARG;
    }
};

/**
 * Verifies a list of fix names are all strings and that there is at least one
 *
 * @function fixValidator
 * @param args {array}
 * @return {array<string>}
 */
var fixValidator = exports.fixValidator = function fixValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var hasTypeError = void 0;

    if (args.length < 1) {
        return _commandParserMessages.ERROR_MESSAGE.ONE_OR_MORE_ARG_LENGTH;
    }

    (0, _forEach3.default)(args, function (arg) {
        if (!(0, _isString3.default)(arg) && !hasTypeError) {
            hasTypeError = _commandParserMessages.ERROR_MESSAGE.MUST_BE_STRING;
        }
    });

    if (hasTypeError) {
        return hasTypeError;
    }
};

/**
 * Returns true if value is one of `left / l / right / r`
 *
 * @function isValidDirectionString
 * @param value {string}
 * @return {boolean}
 */
var isValidDirectionString = exports.isValidDirectionString = function isValidDirectionString(value) {
    return value === 'left' || value === 'l' || value === 'right' || value === 'r';
};

/**
 * Checks that args is the required length and the data is of the correct type for the number of arguments
 *
 * ```
 * Allowed arguments shapes:
 * - ['180']
 * - ['left', '180']
 * - ['l', '180']
 * - ['left', '80']
 * - ['l', '80']
 * ```
 *
 * @function headingValidator
 * @param args {array}
 * @return {string|undefined}
 */
var headingValidator = exports.headingValidator = function headingValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var length = args.length;
    var hasLengthError = oneOrTwoArgumentValidator(args);
    var numberFromString = void 0;

    if (hasLengthError) {
        return hasLengthError;
    }

    switch (length) {
        case 1:
            numberFromString = (0, _unitConverters.convertStringToNumber)(args[0]);

            if ((0, _isNaN3.default)(numberFromString)) {
                return _commandParserMessages.ERROR_MESSAGE.HEADING_MUST_BE_NUMBER;
            }

            break;
        case 2:
            numberFromString = (0, _unitConverters.convertStringToNumber)(args[1]);

            if (!isValidDirectionString(args[0])) {
                return _commandParserMessages.ERROR_MESSAGE.INVALID_DIRECTION_STRING;
            }

            if (isNaN(numberFromString)) {
                return _commandParserMessages.ERROR_MESSAGE.HEADING_MUST_BE_NUMBER;
            }

            break;
        // default case is included only for semtantics, this should not ever be reachable
        // istanbul ignore next
        default:
            throw new Error('An error ocurred parsing the Heading arguments');
    }
};

/**
 * Checks that args is the required length and the data is of the correct type
 *
 * ```
 * Allowed argument shapes:
 * - ['dumba']
 * - ['dumba', 'left', '2min']
 * - ['dumba', 'left', '2nm']
 * - ['dumba', 'right', '2min']
 * - ['dumba', 'right', '2nm']
 * ```
 *
 * @function holdValidator
 * @param args {array}
 * @return {array<string>}
 */
var holdValidator = exports.holdValidator = function holdValidator() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (args.length > 3) {
        return _commandParserMessages.ERROR_MESSAGE.ZERO_TO_THREE_ARG_LENGTH;
    }

    for (var i = 0; i < args.length; i++) {
        if (!(0, _isString3.default)(args[i])) {
            return _commandParserMessages.ERROR_MESSAGE.MUST_BE_STRING;
        }
    }
};

},{"../utilities/unitConverters":595,"./commandMap":568,"./commandParserMessages":569,"lodash/forEach":468,"lodash/isNaN":484,"lodash/isString":489}],567:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.COMMAND_DEFINITION = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Root commands defined in the `commandMap` have a matching definition defined here. This definition
                                                                                                                                                                                                                                                                   * give us access to vaildate and parse functions. Some commands don't require either function and simply
                                                                                                                                                                                                                                                                   * pass the arguments through via `noop`. Other commands commands have very unique demands for how
                                                                                                                                                                                                                                                                   * arguments are formatted, these functions let us validate and parse on a case by case basis.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Keys are lowercased here so they can be accessed programatically using input string segments
                                                                                                                                                                                                                                                                   * that are converted to lowercase for ease of comparison.
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * @fileoverview
                                                                                                                                                                                                                                                                   */


var _unitConverters = require('../utilities/unitConverters');

var _argumentValidators = require('./argumentValidators');

var _argumentParsers = require('./argumentParsers');

/**
 * A no-op function used for command definitions that do not need a parser
 *
 * This function will immediately return any arguments passed to it and is
 * used in place of an actual parser. this way `command.parse` can still
 * be called even with commands that don't need to be parsed.
 *
 * @function noop
 * @param args {*}
 * @return {*}
 */
var noop = function noop(args) {
    return args;
};

/**
 * System and Aircraft command definitions that accept zero arguments
 *
 * @property ZERO_ARG_COMMANDS
 * @type {Object}
 * @final
 */
var ZERO_ARG_COMMANDS = {
    // system commands
    auto: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    clear: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    pause: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    tutorial: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    version: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },

    // Aircraft commands
    abort: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    clearedAsFiled: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    climbViaSID: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    debug: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    delete: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    descendViaSTAR: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    flyPresentHeading: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    sayRoute: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    },
    takeoff: {
        validate: _argumentValidators.zeroArgumentsValidator,
        parse: noop
    }
};

/**
 * System and Aircraft commands that accept a single argument
 *
 * these commands accept a single argument and may require further parsing, eg: (string -> number)
 *
 * @property SINGLE_ARG_COMMANDS
 * @type {Object}
 * @final
 */
var SINGLE_ARG_COMMANDS = {
    '`': {
        validate: _argumentValidators.singleArgumentValidator,
        // calling method is expecting an array with values that will get spread later, thus we purposly
        // return an array here
        parse: function parse(args) {
            return [(0, _unitConverters.convertStringToNumber)(args)];
        }
    },
    airport: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    rate: {
        validate: _argumentValidators.singleArgumentValidator,
        // calling method is expecting an array with values that will get spread later, thus we purposly
        // return an array here
        parse: function parse(args) {
            return [(0, _unitConverters.convertStringToNumber)(args)];
        }
    },
    timewarp: {
        validate: _argumentValidators.singleArgumentValidator,
        // calling method is expecting an array with values that will get spread later, thus we purposly
        // return an array here
        parse: function parse(args) {
            return [(0, _unitConverters.convertStringToNumber)(args)];
        }
    },

    direct: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    land: {
        validate: _argumentValidators.singleArgumentValidator,
        // TODO: split this out to custom parser once the null value is defined
        parse: function parse(args) {
            return [null, args[0]];
        }
    },
    moveDataBlock: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    route: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    reroute: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    sid: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    },
    speed: {
        validate: _argumentValidators.singleArgumentValidator,
        // calling method is expecting an array with values that will get spread later, thus we purposly
        // return an array here
        parse: function parse(arg) {
            return [(0, _unitConverters.convertStringToNumber)(arg)];
        }
    },
    star: {
        validate: _argumentValidators.singleArgumentValidator,
        parse: noop
    }
};

/**
 * System and Aircraft commands that accept arguments specific to the command
 *
 * These definitions will likely reference functions for validate and parse that are specific only
 * to one command
 *
 * @property CUSTOM_ARG_COMMANDS
 * @type {Object}
 * @final
 */
var CUSTOM_ARG_COMMANDS = {
    taxi: {
        validate: _argumentValidators.zeroOrOneArgumentValidator,
        parse: noop
    },

    // these commands have specific argument requirements and may need to be parsed
    // into the correct type (sting -> number)
    altitude: {
        validate: _argumentValidators.altitudeValidator,
        parse: _argumentParsers.altitudeParser
    },
    fix: {
        validate: _argumentValidators.fixValidator,
        parse: noop
    },
    heading: {
        validate: _argumentValidators.headingValidator,
        parse: _argumentParsers.headingParser
    },
    hold: {
        validate: _argumentValidators.holdValidator,
        parse: _argumentParsers.holdParser
    }
};

/**
 * Single exported constant that combines all the definitions above
 *
 * @property COMMAND_DEFINITION
 * @type {Object}
 * @final
 */
var COMMAND_DEFINITION = exports.COMMAND_DEFINITION = _extends({}, ZERO_ARG_COMMANDS, SINGLE_ARG_COMMANDS, CUSTOM_ARG_COMMANDS);

},{"../utilities/unitConverters":595,"./argumentParsers":565,"./argumentValidators":566}],568:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * List of System Commands
 *
 * When a command is parsed, the value here will be used for the `name` property
 * of the `CommandParser`
 *
 * @property SYSTEM_COMMANDS
 * @type {Object}
 * @final
 */
var SYSTEM_COMMANDS = exports.SYSTEM_COMMANDS = {
  auto: 'auto',
  clear: 'clear',
  pause: 'pause',
  tutorial: 'tutorial',
  version: 'version',

  // single arg commands
  '`': 'moveDataBlock',
  airport: 'airport',
  rate: 'rate',
  timewarp: 'timewarp',
  transmit: 'transmit'
};

/**
 * Some commands are converted to unicode (to provide arrow characters) for specific shortkeys
 *
 * This maps those unicode values, converted to a string, to the correct root command
 *
 * @property UNICODE_COMMANDS
 * @type {Object}
 * @final
 */
var UNICODE_COMMANDS = {
  '\\u2B61': 'altitude',
  '\\u2B63': 'altitude',
  '\\u2BA2': 'heading',
  '\\u2BA3': 'heading',
  '\\u2B50': 'land'
};

/**
 * Complete map of commands
 *
 * This list includes both System and Unicode commands, as well as all the various aircraft
 * commands.
 *
 * Aliased commands map to a single root command that is shared among all aliases. The values
 * here then map to a `COMMAND_DEFINITION` which contains `validate` and `parse` functions for
 * each root command. Some commands have very unique demands for how arguments are formatted,
 * those functions let us do that on a case by case basis.
 *
 * Keys are lowercased here so they can be accessed programatically using input string segments
 * that are converted to lowercase for ease of comparison.
 *
 * @propery COMMAND_MAP
 * @type {Object}
 * @final
 */
var COMMAND_MAP = exports.COMMAND_MAP = _extends({}, SYSTEM_COMMANDS, UNICODE_COMMANDS, {

  taxi: 'taxi',
  wait: 'taxi',
  w: 'taxi',
  sid: 'sid',
  star: 'star',
  clearedAsFiled: 'clearedAsFiled',
  caf: 'clearedAsFiled',
  climbViaSID: 'climbViaSID',
  cvs: 'climbViaSID',
  descendViaSTAR: 'descendViaSTAR',
  dvs: 'descendViaSTAR',
  climb: 'altitude',
  c: 'altitude',
  descend: 'altitude',
  d: 'altitude',
  altitude: 'altitude',
  a: 'altitude',
  takeoff: 'takeoff',
  to: 'takeoff',
  cto: 'takeoff',
  fph: 'flyPresentHeading',
  heading: 'heading',
  fh: 'heading',
  h: 'heading',
  turn: 'heading',
  t: 'heading',
  speed: 'speed',
  slow: 'speed',
  sp: 'speed',
  '+': 'speed',
  '-': 'speed',
  ils: 'land',
  i: 'land',
  land: 'land',
  l: 'land',
  '*': 'land',
  reroute: 'reroute',
  rr: 'reroute',
  route: 'route',
  sr: 'sayRoute',
  f: 'fix',
  fix: 'fix',
  track: 'fix',
  direct: 'direct',
  pd: 'direct',
  dct: 'direct',
  abort: 'abort',
  hold: 'hold',
  delete: 'delete',
  del: 'delete',
  kill: 'delete'
});

/**
 * @property EXPEDITE
 * @type {array}
 * @final
 */
var EXPEDITE = exports.EXPEDITE = ['expedite', 'x'];

},{}],569:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable max-len */
/**
 * @property INVALID_ARG
 * @type {string}
 * @final
 */
var INVALID_ARG = 'Invalid argument';

/**
 * @property INVALID_ARG_LENGTH
 * @type {string}
 * @final
 */
var INVALID_ARG_LENGTH = INVALID_ARG + ' length';

/**
 * Encapsulation of error messaging used with `argumentValidators` functions
 *
 * @property ERROR_MESSAGE
 * @type {Object}
 * @final
 */
var ERROR_MESSAGE = exports.ERROR_MESSAGE = {
  ZERO_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected exactly zero arguments',
  SINGLE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected exactly one argument',
  ZERO_OR_ONE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected zero or one argument',
  ZERO_TO_THREE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected zero to three arguments',
  ONE_OR_MORE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected one or more arguments',
  ONE_OR_TWO_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected one or two arguments',
  ONE_TO_THREE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected one, two, or three arguments',
  ONE_OR_THREE_ARG_LENGTH: INVALID_ARG_LENGTH + '. Expected one or three arguments',
  ALTITUDE_EXPEDITE_ARG: INVALID_ARG + '. Altitude accepts only "expedite" or "x" as a second argument',
  HEADING_MUST_BE_NUMBER: INVALID_ARG + '. Heading must be a number',
  MUST_BE_STRING: INVALID_ARG + '. Must be a string',
  INVALID_DIRECTION_STRING: INVALID_ARG + '. Expected one of \'left / l / right / r\' as the first argument when passed three arguments',
  HEADING_ACCEPTS_BOOLEAN_AS_THIRD_ARG: INVALID_ARG + '. Heading accepts a boolean for the third argument when passed three arguments'
};

},{}],570:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * @property FLIGHT_MODES
 * @type {Object}
 * @final
 */
var FLIGHT_MODES = exports.FLIGHT_MODES = {
    // - 'apron' is the initial status of a new departing plane. After
    //   the plane is issued the 'taxi' command, the plane transitions to
    //   'taxi' mode
    // - 'taxi' describes the process of getting ready for takeoff. After
    //   a delay, the plane becomes ready and transitions into 'waiting' mode
    // - 'waiting': the plane is ready for takeoff and awaits clearence to
    //   take off
    // - 'takeoff' is assigned to planes in the process of taking off. These
    //   planes are still on the ground or have not yet reached the minimum
    //   altitude
    // - 'cruse' describes, that a plane is currently in flight and
    //   not following an ILS path. Planes of category 'arrival' entering the
    //   playing field also have this state. If an ILS path is picked up, the
    //   plane transitions to 'landing'
    // - 'landing' the plane is following an ILS path or is on the runway in
    //   the process of stopping. If an ILS approach or a landing is aborted,
    //   the plane reenters 'cruise' mode
    APRON: 'apron',
    TAXI: 'taxi',
    WAITING: 'waiting',
    TAKEOFF: 'takeoff',
    CRUISE: 'cruise',
    LANDING: 'landing'
};

/**
 * @property FLIGHT_CATEGORY
 * @type {Object}
 * @final
 */
var FLIGHT_CATEGORY = exports.FLIGHT_CATEGORY = {
    ARRIVAL: 'arrival',
    DEPARTURE: 'departure'
};

/**
 * @property WAYPOINT_NAV_MODE
 * @type {Object}
 * @final
 */
var WAYPOINT_NAV_MODE = exports.WAYPOINT_NAV_MODE = {
    FIX: 'fix',
    HEADING: 'heading',
    HOLD: 'hold',
    RWY: 'rwy'
};

/**
 * Enumeration of possible FLight Plan Leg types.
 *
 * @property FP_LEG_TYPE
 * @type {Object}
 * @final
 */
var FP_LEG_TYPE = exports.FP_LEG_TYPE = {
    SID: 'sid',
    STAR: 'star',
    IAP: 'iap',
    AWY: 'awy',
    FIX: 'fix',
    MANUAL: '[manual]'
};

},{}],571:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @property AIRPORT_CONSTANTS
 * @type {Object}
 * @final
 */
var AIRPORT_CONSTANTS = exports.AIRPORT_CONSTANTS = {
  /**
   * @property DEFAULT_SPAWN_ALTITUDE_MIN
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_ALTITUDE_MIN: 10000,

  /**
   * @property DEFAULT_SPAWN_ALTITUDE_MAX
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_ALTITUDE_MAX: 10000,

  /**
   * @property DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS
   * @type {number}
   * @final
   */
  DEFAULT_SPAWN_AIRCRAFT_SPEED_KTS: 250,

  /**
   * @property MIN_ENTRAIL_DISTANCE_NM
   * @type {number}
   * @final
   */
  MIN_ENTRAIL_DISTANCE_NM: 5.5
};

},{}],572:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* eslint-disable max-len, import/prefer-default-export */
/**
 * Name enumeration of available game options
 *
 * @property GAME_OPTION_NAMES
 * @type {Object}
 * @final
 */
var GAME_OPTION_NAMES = exports.GAME_OPTION_NAMES = {
    CONTROL_METHOD: 'controlMethod',
    DRAW_PROJECTED_PATHS: 'drawProjectedPaths',
    SIMPLIFY_SPEEDS: 'simplifySpeeds',
    SOFT_CEILING: 'softCeiling'
};

/**
 * User options
 *
 * These options are presented in a modal and are stored in localStorage
 *
 * @property GAME_OPTION_VALUES
 * @type {array<object>}
 * @final
 */
var GAME_OPTION_VALUES = exports.GAME_OPTION_VALUES = [{
    name: GAME_OPTION_NAMES.CONTROL_METHOD,
    defaultValue: 'classic',
    description: 'Control Method',
    type: 'select',
    data: [['Classic', 'classic'], ['Arrow Keys', 'arrows']]
}, {
    name: GAME_OPTION_NAMES.DRAW_PROJECTED_PATHS,
    defaultValue: 'selected',
    description: 'Draw aircraft projected path',
    type: 'select',
    data: [['Always', 'always'], ['Selected', 'selected'], ['Never', 'never']]
}, {
    name: GAME_OPTION_NAMES.SIMPLIFY_SPEEDS,
    defaultValue: 'yes',
    description: 'Use simplified airspeeds',
    help: 'Controls use of a simplified calculation which results in aircraft always moving across the ground at the speed assigned.  In reality aircraft will move faster as they increase altitude.',
    type: 'select',
    data: [['Yes', 'yes'], ['No', 'no']]
}, {
    name: GAME_OPTION_NAMES.SOFT_CEILING,
    defaultValue: 'no',
    description: 'Allow departures via climb',
    help: 'Normally aircraft departs the airspace by flying beyond the horizontal bounds.  If set to yes, aircraft may also depart the airspace by climbing above it.',
    type: 'select',
    data: [['Yes', 'yes'], ['No', 'no']]
}];

},{}],573:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Commonly used time conversion rates
 *
 * @property TIME
 * @type {Object}
 * @final
 */
var TIME = exports.TIME = {
    ONE_HOUR_IN_SECONDS: 3600,
    ONE_HOUR_IN_MINUTES: 60,
    ONE_HOUR_IN_MILLISECONDS: 3600000,
    ONE_MINUTE_IN_HOURS: 1 / 60,
    ONE_MINUTE_IN_SECONDS: 60,
    ONE_MINUTE_IN_MILLISECONDS: 60000,
    ONE_SECOND_IN_HOURS: 1 / 3600,
    ONE_SECOND_IN_MINUTES: 1 / 60,
    ONE_SECOND_IN_MILLISECONDS: 1000,
    ONE_MILLISECOND_IN_HOURS: 1 / 3600000,
    ONE_MILLISECOND_IN_MINUTES: 1 / 60000,
    ONE_MILLISECOND_IN_SECONDS: 1 / 1000
};

/**
 * Regular expressions
 *
 * @property REGEX
 * @type {Object}
 * @final
 */
var REGEX = exports.REGEX = {
    COMPASS_DIRECTION: /^[NESW]/,
    SW: /[SW]/,
    LAT_LONG: /^([NESW])(\d+(\.\d+)?)([d °](\d+(\.\d+)?))?([m '](\d+(\.\d+)?))?$/,
    UNICODE: /[^\u0000-\u00ff]/
};

},{}],574:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * @property LOG
 * @type {Object}
 * @final
 */
var LOG = exports.LOG = {
    DEBUG: 0,
    INFO: 1,
    WARNING: 2,
    ERROR: 3,
    FATAL: 4
};

},{}],575:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SELECTORS = exports.IDS = exports.CLASSNAMES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * CSS classnames used throught the app.
 *
 * @property CLASSNAMES
 * @type {Object}
 * @final
 */
var CLASSNAMES = exports.CLASSNAMES = {
    ACTIVE: 'active',
    AIRCRAFT: 'aircraft',
    ALL_SET: 'allSet',
    ALTITUDE: 'altitude',
    ARRIVAL: 'arrival',
    CALLSIGN: 'callsign',
    CONTROL: 'control',
    DEPARTURE: 'departure',
    DESTINATION: 'destination',
    FAST_FORWARDS: 'fast-forwards',
    FOLLOWING_STAR: 'followingSTAR',
    HEADING: 'heading',
    HIDDEN: 'hidden',
    HOLD: 'hold',
    LEFT: 'left',
    LOOKING_GOOD: 'lookingGood',
    MESSAGE: 'message',
    NEGATIVE: 'negative',
    NEXT: 'next',
    NOT_SELECTABLE: 'notSelectable',
    OPEN: 'open',
    PAUSED: 'paused',
    PAUSE_TOGGLE: 'pause-toggle',
    PREV: 'prev',
    RIGHT: 'right',
    RUNWAY: 'runway',
    SPEECH_TOGGLE: 'speech-toggle',
    SPEED: 'speed',
    SPEED_2: 'speed-2',
    SPEED_5: 'speed-5',
    STRIP: 'strip',
    SWITCH_AIRPORT: 'switch-airport',
    TOGGLE_LABELS: 'toggle-labels',
    TOGGLE_RESTRICTED_AREAS: 'toggle-restricted-areas',
    TOGGLE_TERRAIN: 'toggle-terrain',
    TOGGLE_TUTORIAL: 'toggle-tutorial',
    TOGGLE_SIDS: 'toggle-sids',
    WARN: 'warn',
    WARNING_BUTTON: 'warning-button'
};

/**
 * CSS IDs used throughout the app.
 *
 * @property SELECTOR_IDS
 * @type {Object}
 * @final
 */
var IDS = exports.IDS = {
    AIRPORT_LIST: 'airport-list',
    AIRPORT_LIST_NOTES: 'airport-list-notes',
    AIRPORT_SWITCH: 'airport-switch',
    CANVASES: 'canvases',
    CLOCK: 'clock',
    COMMAND: 'command',
    LOADING: 'loading',
    LOADING_INDICATOR: 'loadingIndicator',
    LOG: 'log',
    NAVAIDS_CANVAS: 'navaids-canvas',
    OPTIONS_DIALOG: 'options-dialog',
    PAUSED: 'paused',
    TOGGLE_OPTIONS: 'toggle-options',
    TUTORIAL: 'tutorial',
    SCORE: 'score',
    SIDEBAR: 'sidebar',
    STRIPS: 'strips'
};

/**
 * Take a classname string and return a classname selector that can be used by jQuery to find an HTML Element.
 *
 * @function buildSelectorsFromClassnames
 * @return {object}
 */
var buildSelectorsFromClassnames = function buildSelectorsFromClassnames() {
    var classnameSelectors = (0, _mapValues3.default)(CLASSNAMES, function (value) {
        return '.' + value;
    });

    return classnameSelectors;
};

/**
 *
 * @function buildSelectorsFromIds
 * @return {object}
 */
var buildSelectorsFromIds = function buildSelectorsFromIds() {
    var idSelectors = (0, _mapValues3.default)(IDS, function (value) {
        return '#' + value;
    });

    return idSelectors;
};

/**
 * @property DOM_SELECTORS
 * @type {Object}
 * @final
 */
var DOM_SELECTORS = _extends({}, buildSelectorsFromClassnames(), buildSelectorsFromIds());

/**
 * Combinator constant.
 *
 * Allows for a single import that has access to both CLASSNAMES, IDS and DOM_SELECTORS
 *
 * @property SELECTORS
 * @type {Object}
 * @final
 */
var SELECTORS = exports.SELECTORS = {
    CLASSNAMES: CLASSNAMES,
    IDS: IDS,
    DOM_SELECTORS: DOM_SELECTORS
};

},{"lodash/mapValues":497}],576:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @property STORAGE_KEY
 * @type {Object}
 * @final
 */
var STORAGE_KEY = exports.STORAGE_KEY = {
  ATC_SCALE: 'atc-scale',
  ATC_LAST_AIRPORT: 'atc-last-airport',
  ATC_SPEECH_ENABLED: 'atc-speech-enabled',
  FIRST_RUN_TIME: 'first-run-time'
};

},{}],577:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _LoadableContentModel = require('./LoadableContentModel');

var _LoadableContentModel2 = _interopRequireDefault(_LoadableContentModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Asynchronous JSON asset loading framework.
 *
 * Allows queueing assets to be loaded, assets may queued at a higher
 * priority by specifying the `immediate` option.  All assets with the
 * `immediate` option will be loaded before other assets.
 *
 * Events:
 *   startLoading - When an asset start being loaded, asset url as data
 *   stopLoading - When the last asset in the queue is downloaded
 *
 * Example:
 *  var promise = zlsa.atc.loadAsset({url: 'assets/aircraft/b747.json'});
 *
 * @module zlsa.atc.loadAsset
 */
/**
* Implementation of the queueing
*/
var ContentQueueClass = function () {
    function ContentQueueClass(loadingView) {
        _classCallCheck(this, ContentQueueClass);

        this.loadingView = loadingView;
        this.isLoading = false;
        this.lowPriorityQueue = [];
        this.highPriorityQueue = [];
        this.queuedContent = {};
    }

    /**
     * Adds or updates a piece of content
     *
     * Supports a url becoming an `immediate` load
     *
     * @for ContentQueue
     * @method add
     * @param options {object}
     * @return {Promise}
     */


    _createClass(ContentQueueClass, [{
        key: 'add',
        value: function add(options) {
            var c = new _LoadableContentModel2.default(options);

            if (c.url in this.queuedContent) {
                c = this.queuedContent[c.url];

                if (c.immediate && !this.queuedContent[c.url].immediate) {
                    var idx = _jquery2.default.inArray(c.url, this.lowPriorityQueue);

                    if (idx > -1) {
                        this.highPriorityQueue.push(this.lowPriorityQueue.splice(idx, 1));
                    }
                }
            } else {
                this.queuedContent[c.url] = c;

                if (c.immediate) {
                    this.highPriorityQueue.push(c.url);
                } else {
                    this.lowPriorityQueue.push(c.url);
                }
            }

            if (!this.isLoading) {
                this.startLoad();
            }

            return c.deferred.promise();
        }

        /**
         * @for ContentQueue
         * @method startLoad
         * @return {boolean}
         */

    }, {
        key: 'startLoad',
        value: function startLoad() {
            if (this.highPriorityQueue.length) {
                this.load(this.highPriorityQueue.shift());

                return true;
            } else if (this.lowPriorityQueue.length) {
                this.load(this.lowPriorityQueue.shift());

                return true;
            }

            return false;
        }

        /**
         * @for contentQueue
         * @method load
         * @param url {string}
         * @return {Promise}
         */

    }, {
        key: 'load',
        value: function load(url) {
            var _this = this;

            var c = this.queuedContent[url];
            this.loadingView.startLoad(c.url);

            _jquery2.default.getJSON(c.url).done(function (data, textStatus, jqXHR) {
                c.deferred.resolve(data, textStatus, jqXHR);
            }).fail(function (jqXHR, textStatus, errorThrown) {
                c.deferred.reject(jqXHR, textStatus, errorThrown);
            }).always(function () {
                delete _this.queuedContent[c.url];

                if (!_this.startLoad()) {
                    _this.loadingView.stopLoad();
                }
            });
        }
    }]);

    return ContentQueueClass;
}();

exports.default = ContentQueueClass;

},{"./LoadableContentModel":578,"jquery":296}],578:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Simple container for a given piece of content
 *
 * @class LoadableContentModel
 */
var LoadableContentModel = function LoadableContentModel(options) {
    _classCallCheck(this, LoadableContentModel);

    this.url = options.url;
    this.immediate = (0, _get3.default)(options, 'immediate', false);
    this.type = 'json';
    this.deferred = _jquery2.default.Deferred();
};

exports.default = LoadableContentModel;

},{"jquery":296,"lodash/get":469}],579:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _radioUtilities = require('../utilities/radioUtilities');

var _selectors = require('../constants/selectors');

var _globalConstants = require('../constants/globalConstants');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Manages a clock that stays in sync with the current game time
 * @class GameClockView
 */
var GameClockView = function () {
    /**
     * @for GameClockView
     * @constructor
     */
    function GameClockView($element) {
        _classCallCheck(this, GameClockView);

        this.$element = $element;
        this.startTime = 0;
        this.time = 0;

        return this._init($element);
    }

    /**
    * Get current time in the user's time zone
    * @for GameClockView
    * @property realWorldCurrentLocalTime
    * @return {number} ms since 01/01/1970, 00:00:00 (user's time zone)
    */


    _createClass(GameClockView, [{
        key: 'destroy',


        /**
        * @for GameClockView
        * @method destroy
        * @chainable
        */
        value: function destroy() {
            this.$element = null;
            this.startTime = 0;
            this.time = 0;

            return this;
        }

        /**
        * Generates a string of the current game time in a human-readable format
        * @for GameClockView
        * @property timeString
        * @return clockTime {string} current game time formatted like '03:44:17'
        */

    }, {
        key: 'generateCurrentTimeString',
        value: function generateCurrentTimeString() {
            var gameTime = window.gameController.game.time;
            var clockDate = new Date(this.startTime + gameTime * _globalConstants.TIME.ONE_SECOND_IN_MILLISECONDS);
            var hours = (0, _radioUtilities.digits_integer)(clockDate.getHours(), 2);
            var minutes = (0, _radioUtilities.digits_integer)(clockDate.getMinutes(), 2);
            var seconds = (0, _radioUtilities.digits_integer)(clockDate.getSeconds(), 2);
            var clockTime = hours + ':' + minutes + ':' + seconds;

            return clockTime;
        }

        /**
        * Updates the stored time and displayed time in webpage
        * @for GameClockView
        * @method update
        */

    }, {
        key: 'update',
        value: function update() {
            this._tick();
            this._render();
        }

        /**
        * @for GameClockView
        * @method _init
        * @private
        */

    }, {
        key: '_init',
        value: function _init($element) {
            this.$element = $element.find(_selectors.SELECTORS.DOM_SELECTORS.CLOCK);
            this.$element.addClass(_selectors.SELECTORS.CLASSNAMES.NOT_SELECTABLE);
            this.startTime = this.realWorldCurrentZuluTime;

            return this;
        }

        /**
        * Updates the DOM with the new game time
        * @for GameClockView
        * @method _render
        * @private
        */

    }, {
        key: '_render',
        value: function _render() {
            this.$element.text(this.generateCurrentTimeString());
        }

        /**
        * Updates the time stored in the clock
        * @for GameClockView
        * @method _tick
        * @private
        */

    }, {
        key: '_tick',
        value: function _tick() {
            var elapsedTime = window.gameController.game.time * _globalConstants.TIME.ONE_SECOND_IN_MILLISECONDS;
            this.time = this.startTime + elapsedTime;
        }
    }, {
        key: 'realWorldCurrentLocalTime',
        get: function get() {
            return new Date().getTime();
        }

        /**
        * Get current zulu time in milliseconds
        * @for GameClockView
        * @property realWorldCurrentZuluTime
        * @return utc {number} ms since 01/01/1970, 00:00:00 UTC
        */

    }, {
        key: 'realWorldCurrentZuluTime',
        get: function get() {
            var date = new Date();
            var utc = date.getTime() + date.getTimezoneOffset() * _globalConstants.TIME.ONE_MINUTE_IN_MILLISECONDS;

            return utc;
        }
    }]);

    return GameClockView;
}();

exports.default = GameClockView;

},{"../constants/globalConstants":573,"../constants/selectors":575,"../utilities/radioUtilities":593}],580:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GAME_EVENTS = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     no-undef, class-methods-use-this */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _GameOptions = require('./GameOptions');

var _GameOptions2 = _interopRequireDefault(_GameOptions);

var _core = require('../math/core');

var _selectors = require('../constants/selectors');

var _globalConstants = require('../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Temporary const declaration here to attach to the window AND use as internal property
var game = {};

// TODO: Remember to move me to wherever the constants end up being moved to
/**
 * Definitions of point values for given game events
 * @type {Object}
 */
var GAME_EVENTS_POINT_VALUES = {
    AIRSPACE_BUST: -200,
    ARRIVAL: 10,
    COLLISION: -1000,
    DEPARTURE: 10,
    EXTREME_CROSSWIND_OPERATION: -15,
    EXTREME_TAILWIND_OPERATION: -75,
    GO_AROUND: -50,
    HIGH_CROSSWIND_OPERATION: -5,
    HIGH_TAILWIND_OPERATION: -25,
    ILLEGAL_APPROACH_CLEARANCE: -10,
    NOT_CLEARED_ON_ROUTE: -25,
    SEPARATION_LOSS: -200
};

/**
 * List of game events
 * @type {Object}
 */
var GAME_EVENTS = exports.GAME_EVENTS = {
    AIRSPACE_BUST: 'AIRSPACE_BUST',
    ARRIVAL: 'ARRIVAL',
    COLLISION: 'COLLISION',
    DEPARTURE: 'DEPARTURE',
    EXTREME_CROSSWIND_OPERATION: 'EXTREME_CROSSWIND_OPERATION',
    EXTREME_TAILWIND_OPERATION: 'EXTREME_TAILWIND_OPERATION',
    GO_AROUND: 'GO_AROUND',
    HIGH_CROSSWIND_OPERATION: 'HIGH_CROSSWIND_OPERATION',
    HIGH_TAILWIND_OPERATION: 'HIGH_TAILWIND_OPERATION',
    ILLEGAL_APPROACH_CLEARANCE: 'ILLEGAL_APPROACH_CLEARANCE',
    NOT_CLEARED_ON_ROUTE: 'NOT_CLEARED_ON_ROUTE',
    SEPARATION_LOSS: 'SEPARATION_LOSS'
};

/**
 * @class GameController
 */

var GameController = function () {
    /**
     * @constructor
     */
    function GameController(getDeltaTime) {
        _classCallCheck(this, GameController);

        this.getDeltaTime = getDeltaTime;
        this.game = game;
        this.game.paused = true;
        this.game.focused = true;
        this.game.speedup = 1;
        this.game.frequency = 1;
        this.game.time = 0;
        this.game.startTime = 0;
        this.game.delta = 0;
        this.game.events = {};
        this.game.timeouts = [];
        this.game.last_score = 0;
        this.game.score = 0;
        this.game.option = new _GameOptions2.default();
    }

    /**
     * @for GameController
     * @method init_pre
     */


    _createClass(GameController, [{
        key: 'init_pre',
        value: function init_pre() {
            this.game_initializeBlurFunctions();
            this.events_initializeEventCount();
        }

        /**
        * Initialize `GameController.events` to contain appropriate properties with values of 0
        * @for GameController
        * @method events_initializeEventCount
        * @return
        */

    }, {
        key: 'events_initializeEventCount',
        value: function events_initializeEventCount() {
            var _this = this;

            (0, _forEach3.default)(GAME_EVENTS, function (gameEvent, key) {
                _this.game.events[key] = 0;
            });
        }

        /**
        * Record a game event to this.game.events, and update this.game.score
        * @for GameController
        * @method events_recordNew
        * @param gameEvent {String} one of the events listed in GAME_EVENTS
        */

    }, {
        key: 'events_recordNew',
        value: function events_recordNew(gameEvent) {
            if (!(0, _has3.default)(GAME_EVENTS, gameEvent)) {
                throw new TypeError('Expected a game event listed in GAME_EVENTS, but instead received ' + gameEvent);
            }

            this.game.events[gameEvent] += 1;
            this.game.score += GAME_EVENTS_POINT_VALUES[gameEvent];
        }

        /**
        * Initialize blur functions used during game pausing
        * @for GameController
        * @method game_initializeBlurFunctions
        * @return
        */

    }, {
        key: 'game_initializeBlurFunctions',
        value: function game_initializeBlurFunctions() {
            var _this2 = this;

            // Set blurring function
            (0, _jquery2.default)(window).blur(function () {
                _this2.game.focused = false;
            });

            // Set un-blurring function
            (0, _jquery2.default)(window).focus(function () {
                _this2.game.focused = true;
            });
        }

        /**
         * @for GameController
         * @method game_get_weighted_score
         */

    }, {
        key: 'game_get_weighted_score',
        value: function game_get_weighted_score() {
            var hoursPlayed = this.game_time() / _globalConstants.TIME.ONE_HOUR_IN_SECONDS;
            var scorePerHour = this.game.score / hoursPlayed;

            return scorePerHour;
        }

        /**
         * @for GameController
         * @method game_reset_score_and_events
         */

    }, {
        key: 'game_reset_score_and_events',
        value: function game_reset_score_and_events() {
            var _this3 = this;

            // Reset events
            (0, _forEach3.default)(this.game.events, function (gameEvent, key) {
                _this3.game.events[key] = 0;
            });

            // Reset score
            this.game.score = 0;
        }

        /**
         * @for GameController
         * @method game_timewarp_toggle
         */

    }, {
        key: 'game_timewarp_toggle',
        value: function game_timewarp_toggle() {
            var $fastForwards = (0, _jquery2.default)('.' + _selectors.SELECTORS.CLASSNAMES.FAST_FORWARDS);

            if (this.game.speedup === 5) {
                this.game.speedup = 1;

                $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_5);
                $fastForwards.prop('title', 'Set time warp to 2');
            } else if (this.game.speedup === 1) {
                this.game.speedup = 2;

                $fastForwards.addClass(_selectors.SELECTORS.CLASSNAMES.SPEED_2);
                $fastForwards.prop('title', 'Set time warp to 5');
            } else {
                this.game.speedup = 5;

                $fastForwards.removeClass(_selectors.SELECTORS.CLASSNAMES.SPEED_2);
                $fastForwards.addClass(_selectors.SELECTORS.CLASSNAMES.SPEED_5);
                $fastForwards.prop('title', 'Reset time warp');
            }
        }

        /**
         * @for GameController
         * @method game_pause
         */

    }, {
        key: 'game_pause',
        value: function game_pause() {
            var $pauseToggle = (0, _jquery2.default)('.' + _selectors.SELECTORS.CLASSNAMES.PAUSE_TOGGLE);
            this.game.paused = true;

            $pauseToggle.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            $pauseToggle.attr('title', 'Resume simulation');
            (0, _jquery2.default)('html').addClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
        }

        /**
         * @for GameController
         * @method game_unpause
         */

    }, {
        key: 'game_unpause',
        value: function game_unpause() {
            var $pauseToggle = (0, _jquery2.default)('.' + _selectors.SELECTORS.CLASSNAMES.PAUSE_TOGGLE);
            this.game.paused = false;

            $pauseToggle.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            $pauseToggle.attr('title', 'Pause simulation');
            (0, _jquery2.default)('html').removeClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
        }

        /**
         * @for GameController
         * @method game_pause_toggle
         */

    }, {
        key: 'game_pause_toggle',
        value: function game_pause_toggle() {
            // TODO: simplify if/else logic. should only need an if with an early exit
            if (this.game.paused) {
                this.game_unpause();
            } else {
                this.game_pause();
            }
        }

        /**
         * @for GameController
         * @method game_paused
         * @return
         */

    }, {
        key: 'game_paused',
        value: function game_paused() {
            return !this.game.focused || this.game.paused;
        }

        /**
         * @for GameController
         * @method game_time
         * @return {number}
         */

    }, {
        key: 'game_time',
        value: function game_time() {
            return this.game.time;
        }

        /**
         * @for GameController
         * @method game_delta
         * @return {number}
         */

    }, {
        key: 'game_delta',
        value: function game_delta() {
            return this.game.delta;
        }

        /**
         * @for GameController
         * @method game_speedup
         * @return
         */

    }, {
        key: 'game_speedup',
        value: function game_speedup() {
            return !this.game_paused() ? this.game.speedup : 0;
        }

        /**
         * @for GameController
         * @method game_timeout
         * @param func {function}
         * @pram delay {number}
         * @param that
         * @param data
         * @return gameTimeout
         */

    }, {
        key: 'game_timeout',
        value: function game_timeout(func, delay, that, data) {
            var gameTimeout = [func, this.game_time() + delay, data, delay, false, that];

            this.game.timeouts.push(gameTimeout);

            return gameTimeout;
        }

        /**
         * @for GameController
         * @method game_interval
         * @param func {function}
         * @pram delay {number}
         * @param that
         * @param data
         * @return to
         */

    }, {
        key: 'game_interval',
        value: function game_interval(func, delay, that, data) {
            var to = [func, this.game_time() + delay, data, delay, true, that];

            this.game.timeouts.push(to);

            return to;
        }

        /**
         * @for GameController
         * @method game_clear_timeout
         * @param gameTimeout
         */

    }, {
        key: 'game_clear_timeout',
        value: function game_clear_timeout(gameTimeout) {
            this.game.timeouts.splice(this.game.timeouts.indexOf(gameTimeout), 1);
        }

        /**
         * @for GameController
         * @method game_updateScore
         * @param score {number}
         */

    }, {
        key: 'game_updateScore',
        value: function game_updateScore(score) {
            var $score = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.SCORE);
            $score.text((0, _core.round)(score));

            if (score < -0.51) {
                $score.addClass(_selectors.SELECTORS.CLASSNAMES.NEGATIVE);
            } else {
                $score.removeClass(_selectors.SELECTORS.CLASSNAMES.NEGATIVE);
            }

            this.game.last_score = score;
        }

        /**
         * @for GameController
         * @method update_pre
         */

    }, {
        key: 'update_pre',
        value: function update_pre() {
            if (this.game.score !== this.game.last_score) {
                this.game_updateScore(this.game.score);
            }

            this.game.delta = Math.min(this.getDeltaTime() * this.game.speedup, 100);

            if (this.game_paused()) {
                this.game.delta = 0;
            } else {
                (0, _jquery2.default)('html').removeClass(_selectors.SELECTORS.CLASSNAMES.PAUSED);
            }

            this.game.time += this.game.delta;

            for (var i = this.game.timeouts.length - 1; i >= 0; i--) {
                var remove = false;
                var timeout = this.game.timeouts[i];

                if (this.game_time() > timeout[1]) {
                    timeout[0].call(timeout[5], timeout[2]);

                    if (timeout[4]) {
                        timeout[1] += timeout[3];
                    } else {
                        remove = true;
                    }
                }

                if (remove) {
                    this.game.timeouts.splice(i, 1);
                    i -= 1;
                }
            }
        }

        /**
         * @for GameController
         * @method complete
         */

    }, {
        key: 'complete',
        value: function complete() {
            this.game.paused = false;
        }
    }]);

    return GameController;
}();

exports.default = GameController;

},{"../constants/globalConstants":573,"../constants/selectors":575,"../math/core":584,"./GameOptions":581,"jquery":296,"lodash/forEach":468,"lodash/has":470}],581:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase, no-underscore-dangle, no-mixed-operators, func-names, object-shorthand */


var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _gameOptionConstants = require('../constants/gameOptionConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Set, store and retrieve game options.
 *
 * @class GameOptions
 */
var GameOptions = function () {
    /**
     * @for GameOptions
     * @constructor
     */
    function GameOptions() {
        _classCallCheck(this, GameOptions);

        this._options = {};

        this.addGameOptions();
    }

    /**
     * @for GameOptions
     * @method addGameOptions
     */


    _createClass(GameOptions, [{
        key: 'addGameOptions',
        value: function addGameOptions() {
            for (var i = 0; i < _gameOptionConstants.GAME_OPTION_VALUES.length; i++) {
                var option = _gameOptionConstants.GAME_OPTION_VALUES[i];

                this.addOption(option);
            }
        }

        /**
         * @for GameOptions
         * @method addOption
         */

    }, {
        key: 'addOption',
        value: function addOption(data) {
            var optionStorageName = 'zlsa.atc.option.' + data.name;
            this._options[data.name] = data;

            var dataName = data.defaultValue;
            if ((0, _has3.default)(localStorage, optionStorageName)) {
                dataName = localStorage[optionStorageName];
            }

            this[data.name] = dataName;
        }

        /**
         * @for GameOptions
         * @method getDescriptions
         */

    }, {
        key: 'getDescriptions',
        value: function getDescriptions() {
            return this._options;
        }

        /**
         * @for GameOptions
         * @method get
         * @param name {string}
         */

    }, {
        key: 'get',
        value: function get(name) {
            return this[name];
        }

        /**
         * @for GameOptions
         * @method set
         * @param name {string}
         * @param value
         */

    }, {
        key: 'set',
        value: function set(name, value) {
            localStorage['zlsa.atc.option.' + name] = value;
            this[name] = value;

            return value;
        }
    }]);

    return GameOptions;
}();

exports.default = GameOptions;

},{"../constants/gameOptionConstants":572,"lodash/has":470}],582:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('babel-polyfill');

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _App = require('./App');

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable */
require('raf').polyfill();

/**
 * Entry point for the application.
 *
 * Provides a way to grab the `body` element of the document and pass it to the app.
 */
exports.default = function () {
  var airportLoadList = window.AIRPORT_LOAD_LIST;
  var $body = (0, _jquery2.default)('body');
  var app = new _App2.default($body, airportLoadList);
}();

},{"./App":519,"babel-polyfill":1,"jquery":296,"raf":517}],583:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.distanceToPoint = exports.radians_normalize = exports.degrees_normalize = exports.angle_offset = exports.tau = undefined;

var _core = require('./core');

var _unitConverters = require('../utilities/unitConverters');

/**
 * 2x Pi
 *
 * @function tau
 * @return {number}
 */
var tau = exports.tau = function tau() {
    return Math.PI * 2;
};

/**
 * Returns the angle difference between two headings
 *
 * @function angle_offset
 * @param {number} a     heading, in radians
 * @param {number} b     heading, in radians
 * @return {number}
 */
var angle_offset = exports.angle_offset = function angle_offset(a, b) {
    a = (0, _unitConverters.radiansToDegrees)(a);
    b = (0, _unitConverters.radiansToDegrees)(b);
    var invert = false;

    if (b > a) {
        invert = true;
        var temp = a;

        a = b;
        b = temp;
    }

    var offset = (0, _core.mod)(a - b, 360);
    if (offset > 180) {
        offset -= 360;
    }

    if (invert) {
        offset *= -1;
    }

    offset = (0, _unitConverters.degreesToRadians)(offset);

    return offset;
};

/**
 * normalize angles to within 0° - 360°
 * @param  {number} degrees an angle
 * @return {number}         an angle within [0,360]
 */
var degrees_normalize = exports.degrees_normalize = function degrees_normalize(degrees) {
    if (degrees >= 0) {
        return degrees % 360;
    }

    return 360 + degrees % 360;
};

/**
 * normalize angles to within 0 - 2π
 * @param  {number} radians an angle
 * @return {number}         an angle within [0,2π]
 */
var radians_normalize = exports.radians_normalize = function radians_normalize(radians) {
    if (radians >= 0) {
        return radians % tau();
    }

    return tau() + radians % tau();
};

/**
 * Calculate the distance between two lat/long coordinates in km
 *
 * This is a javascript implementation of the Haversine Formula
 *
 * for more information on the math see:
 * - http://www.movable-type.co.uk/scripts/latlong.html
 * - http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula
 *
 * @function distanceToPoint
 * @param startLatitude {number}
 * @param startLongitude {number}
 * @param endLatitude {number}
 * @param endLongitude {number}
 * return {number}
 */
var distanceToPoint = exports.distanceToPoint = function distanceToPoint(startLatitude, startLongitude, endLatitude, endLongitude) {
    // TODO: add to global constants
    var EARTH_RADIUS_KM = 6371;
    var startLatitudeRadians = (0, _unitConverters.degreesToRadians)(startLatitude);
    var endLatitudeRadians = (0, _unitConverters.degreesToRadians)(endLatitude);
    var distanceLatitude = (0, _unitConverters.degreesToRadians)(startLatitude - endLatitude);
    var distanceLongitude = (0, _unitConverters.degreesToRadians)(startLongitude - endLongitude);

    // the square of half the chord length between points
    var a = Math.pow(Math.sin(distanceLatitude / 2), 2) + Math.cos(startLatitudeRadians) * Math.cos(endLatitudeRadians) * Math.pow(Math.sin(distanceLongitude / 2), 2);

    var angularDistanceInRadians = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return angularDistanceInRadians * EARTH_RADIUS_KM;
};

// /**
//  *
//  * @function distEuclid
//  * @param
//  * @param
//  * @return
//  */
// export const distEuclid = (lat1, lon1, lat2, lon2) => {
//     // TODO: add to global constants
//     const EARTH_RADIUS_KM = 6371;
//     const lat1 = degreesToRadians(lat1);
//     const lat2 = degreesToRadians(lat2);
//     const dlat = degreesToRadians(lat2 - lat1);
//     const dlon = degreesToRadians(lon2 - lon1);
//
//     const a = Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) * Math.sin(dlon / 2);
//     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
//     const d = EARTH_RADIUS_KM * c;
//
//     return d; // distance, in kilometers
// };

},{"../utilities/unitConverters":595,"./core":584}],584:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extrapolate_range_clamp = exports.clamp = exports.mod = exports.calculateMiddle = exports.within = exports.s = exports.randint = exports.fl = exports.tan = exports.cos = exports.sin = exports.abs = exports.round = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @function round
 * @return {number}
 */
var round = exports.round = function round(n) {
    var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    return Math.round(n / factor) * factor;
};

/**
 * @function abs
 * @return {number}
 */
var abs = exports.abs = function abs(n) {
    return Math.abs(n);
};

/**
 * @function sin
 * @return {number}
 */
var sin = exports.sin = function sin(a) {
    return Math.sin(a);
};

/**
 * @function cos
 * @return {number}
 */
var cos = exports.cos = function cos(a) {
    return Math.cos(a);
};

/**
 * @function tan
 * @return {number}
 */
var tan = exports.tan = function tan(a) {
    return Math.tan(a);
};

// TODO: rename to floor,
/**
 * @function fl
 * @return {number}
 */
var fl = exports.fl = function fl(n) {
    var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    return Math.floor(n / number) * number;
};

// TODO: rename to randomInteger
/**
 * @function randint
 * @return {number}
 */
var randint = exports.randint = function randint(low, high) {
    return Math.floor(Math.random() * (high - low + 1)) + low;
};

// TODO: rename to pluralize
/**
 * @function s
 * @return {number}
 */
var s = exports.s = function s(i) {
    return i === 1 ? '' : 's';
};

// TODO: rename to isWithin
/**
 * @function within
 * @param n
 * @param c
 * @param r
 * @return {number}
 */
var within = exports.within = function within(n, c, r) {
    return n > c + r || n < c - r;
};

// TODO: add a divisor paramater that dfaults to `2`
/**
 * Given a number, find the middle value.
 *
 * @method calculateMiddle
 * @param  {number} value
 * @return {number}
 */
var calculateMiddle = exports.calculateMiddle = function calculateMiddle() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!(0, _isNumber3.default)(value)) {
        throw new TypeError('Invalid parameter, expected a number but found ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
    }

    return round(value / 2);
};

/**
 *
 * @function mod
 * @param firstValue {number}
 * @param secondValue {number}
 * @return {number}
 */
var mod = exports.mod = function mod(firstValue, secondValue) {
    return (firstValue % secondValue + secondValue) % secondValue;
};

/**
 * Clamp a value to be within a certain range
 *
 * @function clamp
 * @param min {number}
 * @param valueToClamp {number}
 * @param max {number} (optional)
 * @return {number}
 */
var clamp = exports.clamp = function clamp(min, valueToClamp) {
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;

    var temp = void 0;

    if (!(0, _isNumber3.default)(valueToClamp)) {
        throw new TypeError('Invalid parameter. Expected `valueToClamp` to be a number');
    }

    if (max === Infinity) {
        if (min > valueToClamp) {
            return min;
        }

        return valueToClamp;
    }

    if (min > max) {
        temp = max;
        max = min;
        min = temp;
    }

    if (min > valueToClamp) {
        return min;
    }

    if (max < valueToClamp) {
        return max;
    }

    return valueToClamp;
};

/**
 * Takes a value's position relative to a given range, and extrapolates to another range.
 * Note: Return will be outside range2 if target_val is outside range1.
 *       If you wish to clamp it within range2, use extrapolate_range_clamp.
 * @function extrapolate_range
 * @param  {number} range1_min minimum value of range 1
 * @param  {number} target_val target value within range 1
 * @param  {number} range1_max maximum value of range 1
 * @param  {number} range2_min minimum value of range 2
 * @param  {number} range2_max maximum value of range 2
 * @return {number}            target value wihtin range 2
 */
var extrapolate_range = function extrapolate_range(range1_min, target_val, range1_max, range2_min, range2_max) {
    return range2_min + (range2_max - range2_min) * (target_val - range1_min) / (range1_max - range1_min);
};

/**
 * Takes a value's position relative to a given range, and extrapolates to (and clamps within) another range.
 * Note: Return will be clamped within range2, even if target_val is outside range1.
 *       If you wish to allow extrapolation beyond the bounds of range2, us extrapolate_range.
 * @function extrapolate_range_clamp
 * @param  {number} range1_min minimum value of range1
 * @param  {number} target_val target value relative to range1
 * @param  {number} range1_max maximum value of range1
 * @param  {number} range2_min minimum value of range2
 * @param  {number} range2_max maximum value of range2
 * @return {number}            target value within range2
 */
var extrapolate_range_clamp = exports.extrapolate_range_clamp = function extrapolate_range_clamp(range1_min, target_val, range1_max, range2_min, range2_max) {
    var extrapolation_result = extrapolate_range(range1_min, target_val, range1_max, range2_min, range2_max);

    return clamp(extrapolation_result, range2_min, range2_max);
};

},{"lodash/isNumber":486}],585:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Calculate distance in a 2d plane between two points
 *
 * @function distance2d
 * @param a {array}
 * @param b {array}
 * return {number}
 */
var distance2d = exports.distance2d = function distance2d(a, b) {
  var x = a[0] - b[0];
  var y = a[1] - b[1];

  return Math.sqrt(x * x + y * y);
};

},{}],586:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateDistanceToBoundary = exports.isWithinAirspace = exports.fixRadialDist = exports.getOffset = exports.bearingToPoint = exports.calcTurnInitiationDistance = exports.calcTurnRadius = undefined;

var _core = require('./core');

var _distance = require('./distance');

var _vector = require('./vector');

var _unitConverters = require('../utilities/unitConverters');

/**
 * @property CONSTANTS
 * @type {Object}
 * @final
 */
var CONSTANTS = {
    /**
     * @property
     * @type {number}
     * @final
     */
    GRAVITATIONAL_MAGNITUDE: 9.81,

    /**
     * @property EARTH_RADIUS_NM
     * @type {number}
     * @final
     */
    EARTH_RADIUS_NM: 3440
};

/**
 * @function calcTurnRadius
 * @param speed {number} currentSpeed of an aircraft
 * @param bankAngle {number} bank angle of an aircraft
 * @return {number}
 */
var calcTurnRadius = exports.calcTurnRadius = function calcTurnRadius(speed, bankAngle) {
    return speed * speed / (CONSTANTS.GRAVITATIONAL_MAGNITUDE * (0, _core.tan)(bankAngle));
};

/**
 * @function calcTurnInitiationDistance
 * @param speed {number}            currentSpeed of an aircraft
 * @param bankAngle {number}        bank angle of an aircraft
 * @param courseChange {number}
 * @return {number}
 */
var calcTurnInitiationDistance = exports.calcTurnInitiationDistance = function calcTurnInitiationDistance(speed, bankAngle, courseChange) {
    var turnRadius = calcTurnRadius(speed, bankAngle);

    return turnRadius * (0, _core.tan)(courseChange / 2) + speed;
};

/**
 * Returns the bearing from `startPosition` to `endPosition`
 * @function bearingToPoint
 * @param startPosition {array}     positional array, start point
 * @param endPosition {array}       positional array, end point
 * @return {number}
 */
var bearingToPoint = exports.bearingToPoint = function bearingToPoint(startPosition, endPosition) {
    return (0, _vector.vradial)((0, _vector.vsub)(endPosition, startPosition));
};

// TODO: this may be better suited to live in an Aircraft model somewhere.
/**
 * Returns an offset array showing how far [fwd/bwd, left/right] 'aircraft' is of 'target'
 *
 * @param aircraft {Aircraft}           the aircraft in question
 * @param target {array}                positional array of the targeted position [x,y]
 * @param headingThruTarget {number}    (optional) The heading the aircraft should
 *                                      be established on when passing the target.
 *                                      Default value is the aircraft's heading.
 * @returns {array} with two elements:  retval[0] is the lateral offset, in km
 *                                      retval[1] is the longitudinal offset, in km
 *                                      retval[2] is the hypotenuse (straight-line distance), in km
 */
var getOffset = exports.getOffset = function getOffset(aircraft, target) {
    var headingThruTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!headingThruTarget) {
        headingThruTarget = aircraft.heading;
    }

    var offset = [0, 0, 0];
    var vector = (0, _vector.vsub)(target, aircraft.position); // vector from aircraft pointing to target
    var bearingToTarget = (0, _vector.vradial)(vector);

    offset[2] = (0, _vector.vlen)(vector);
    offset[0] = offset[2] * (0, _core.sin)(headingThruTarget - bearingToTarget);
    offset[1] = offset[2] * (0, _core.cos)(headingThruTarget - bearingToTarget);

    return offset;
};

/**
 * Get new position by fix-radial-distance method
 *
 * @param {array} fix       positional array of start point, in decimal-degrees [lat,lon]
 * @param {number} radial   heading to project along, in radians
 * @param {number} dist     distance to project, in nm
 * @returns {array}         location of the projected fix, in decimal-degrees [lat,lon]
 */
var fixRadialDist = exports.fixRadialDist = function fixRadialDist(fix, radial, dist) {
    // FIXME: if fix is a FixModel, there may already be a method for this. if there isnt there should be. `fix.positionInRadians`
    // convert GPS coordinates to radians
    fix = [(0, _unitConverters.degreesToRadians)(fix[0]), (0, _unitConverters.degreesToRadians)(fix[1])];

    var R = CONSTANTS.EARTH_RADIUS_NM;
    // TODO: abstract these two calculations to functions
    var lat2 = Math.asin((0, _core.sin)(fix[0]) * (0, _core.cos)(dist / R) + (0, _core.cos)(fix[0]) * (0, _core.sin)(dist / R) * (0, _core.cos)(radial));
    var lon2 = fix[1] + Math.atan2((0, _core.sin)(radial) * (0, _core.sin)(dist / R) * (0, _core.cos)(fix[0]), (0, _core.cos)(dist / R) - (0, _core.sin)(fix[0]) * (0, _core.sin)(lat2));

    return [(0, _unitConverters.radiansToDegrees)(lat2), (0, _unitConverters.radiansToDegrees)(lon2)];
};

/**
 *
 * @function isWithinAirspace
 * @param airport {AirportModel}
 * @param  pos {array}
 * @return {boolean}
 */
var isWithinAirspace = exports.isWithinAirspace = function isWithinAirspace(airport, pos) {
    var perim = airport.perimeter;

    if (perim) {
        return (0, _vector.point_in_area)(pos, perim);
    }

    return (0, _distance.distance2d)(pos, airport.position.position) <= airport.ctr_radius;
};

/**
 *
 * @function calculateDistanceToBoundary
 * @param airport {AirportModel}
 * @param pos {array}
 * @return {boolean}
 */
var calculateDistanceToBoundary = exports.calculateDistanceToBoundary = function calculateDistanceToBoundary(airport, pos) {
    var perim = airport.perimeter;

    if (perim) {
        // km
        return (0, _vector.distance_to_poly)(pos, (0, _vector.area_to_poly)(perim));
    }

    // TODO: hmm, `position.position`? that seems fishy
    return (0, _core.abs)((0, _distance.distance2d)(pos, airport.position.position) - airport.ctr_radius);
};

},{"../utilities/unitConverters":595,"./core":584,"./distance":585,"./vector":587}],587:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.positive_intersection_with_rect = exports.point_in_area = exports.area_to_poly = exports.point_to_mpoly = exports.point_in_poly = exports.distance_to_poly = exports.raysIntersect = exports.vturn = exports.vscale = exports.vadd = exports.vnorm = exports.vsub = exports.vradial = exports.vlen = undefined;

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _core = require('./core');

var _unitConverters = require('../utilities/unitConverters');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Computes length of 2D vector
 *
 * @function vlen
 */
var vlen = exports.vlen = function vlen(v) {
    try {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    } catch (err) {
        console.error('call to vlen() failed. v:' + v + ' | Err:' + err);
    }
};

/**
 * Compute angle of 2D vector, in radians
 *
 * @function vradial
 * @param v {}
 * @return {number}
 */
var vradial = exports.vradial = function vradial(v) {
    return Math.atan2(v[0], v[1]);
};

/**
 * Subtracts Vectors (all dimensions)
 *
 * @fuction vsub
 * @param v1 {number}
 * @param v2 {number}
 * @return {number}
 */
var vsub = exports.vsub = function vsub(v1, v2) {
    try {
        var v = [];
        var limit = Math.min(v1.length, v2.length);

        // TODO: this is easie rwith _map()
        for (var i = 0; i < limit; i++) {
            v.push(v1[i] - v2[i]);
        }

        return v;
    } catch (err) {
        console.error('call to vsub() failed. v1: ' + v1 + ' | v2:' + v2 + ' | Err: ' + err);
    }
};

// ************************ VECTOR FUNCTIONS ************************
// For more info, see http://threejs.org/docs/#Reference/Math/Vector3
// Remember: [x,y] convention is used, and doesn't match [lat,lon]

/**
 * Normalize a 2D vector
 * eg scaling elements such that net length is 1
 * Turns vector 'v' into a 'unit vector'
 */
var vnorm = exports.vnorm = function vnorm(v, length) {
    var x = v[0];
    var y = v[1];
    var angle = Math.atan2(x, y);

    if (!length) {
        length = 1;
    }

    return [(0, _core.sin)(angle) * length, (0, _core.cos)(angle) * length];
};

/**
 * Create a 2D vector
 * Pass a heading (rad) and this will return the corresponding unit vector
 */
var vectorize_2d = function vectorize_2d(direction) {
    return [(0, _core.sin)(direction), (0, _core.cos)(direction)];
};

/**
 * Adds Vectors (all dimensions)
 */
var vadd = exports.vadd = function vadd(v1, v2) {
    // TODO: why try/catch?
    try {
        var v = [];
        var limit = Math.min(v1.length, v2.length);

        // TODO: this can be done with a _map()
        for (var i = 0; i < limit; i++) {
            v.push(v1[i] + v2[i]);
        }

        return v;
    } catch (err) {
        console.error('call to vadd() failed. v1:' + v1 + ' | v2:' + v2 + ' | Err:' + err);
    }
};

/**
 * Multiplies Vectors (all dimensions)
 */
// const vmul = (v1, v2) => {
//     // TODO: why try/catch?
//     try {
//         const v = [];
//         const limit = Math.min(v1.length, v2.length);
//
//         // TODO: this can be done with a _map()
//         for (let i = 0; i < limit; i++) {
//             v.push(v1[i] * v2[i]);
//         }
//
//         return v;
//     } catch (err) {
//         console.error(`call to vmul() failed. v1:${v1} | v2:${v2} | Err:${err}`);
//     }
// };

/**
 * Divides Vectors (all dimensions)
 */
// const vdiv = (v1, v2) => {
//     // TODO: why try/catch?
//     try {
//         const v = [];
//         const lim = Math.min(v1.length, v2.length);
//
//         // TODO: this can be done with a _map()
//         for (let i = 0; i < lim; i++) {
//             v.push(v1[i] / v2[i]);
//         }
//
//         return v;
//     } catch (err) {
//         console.error(`call to vdiv() failed. v1:${v1} | v2:${v2} | Err:${err}`);
//     }
// };

/**
 * Scales vectors in magnitude (all dimensions)
 */
var vscale = exports.vscale = function vscale(vectors, factor) {
    return (0, _map3.default)(vectors, function (v) {
        return v * factor;
    });
};

/**
 * Vector dot product (all dimensions)
 */
// const vdp = (v1, v2) => {
//     let n = 0;
//     const lim = Math.min(v1.length, v2.length);
//
//     // TODO: mabye use _map() here?
//     for (let i = 0; i < lim; i++) {
//         n += v1[i] * v2[i];
//     }
//
//     return n;
// };

/**
 * Compute determinant of 2D/3D vectors
 * Remember: May return negative values (undesirable in some situations)
 */
var vdet = function vdet(v1, v2, /* optional */v3) {
    if (Math.min(v1.length, v2.length) === 2) {
        // 2x2 determinant
        return v1[0] * v2[1] - v1[1] * v2[0];
    } else if (Math.min(v1.length, v2.length, v3.length) === 3 && v3) {
        // 3x3 determinant
        return v1[0] * vdet([v2[1], v2[2]], [v3[1], v3[2]]) - v1[1] * vdet([v2[0], v2[2]], [v3[0], v3[2]]) + v1[2] * vdet([v2[0], v2[1]], [v3[0], v3[1]]);
    }
};

/**
 * Vector cross product (3D/2D*)
 * Passing 3D vector returns 3D vector
 * Passing 2D vector (classically improper) returns z-axis SCALAR
 * *Note on 2D implementation: http://stackoverflow.com/a/243984/5774767
 */
var vcp = function vcp(v1, v2) {
    if (Math.min(v1.length, v2.length) === 2) {
        // for 2D vector (returns z-axis scalar)
        return vcp([v1[0], v1[1], 0], [v2[0], v2[1], 0])[2];
    }

    if (Math.min(v1.length, v2.length) === 3) {
        // for 3D vector (returns 3D vector)
        return [vdet([v1[1], v1[2]], [v2[1], v2[2]]), -vdet([v1[0], v1[2]], [v2[0], v2[2]]), vdet([v1[0], v1[1]], [v2[0], v2[1]])];
    }
};

/**
 * Returns vector rotated by "radians" radians
 */
var vturn = exports.vturn = function vturn(radians, v) {
    if (!v) {
        v = [0, 1];
    }

    var x = v[0];
    var y = v[1];
    var cs = (0, _core.cos)(-radians);
    var sn = (0, _core.sin)(-radians);

    return [x * cs - y * sn, x * sn + y * cs];
};

/**
 * Determines if and where two rays will intersect. All angles in radians.
 * Variation based on http://stackoverflow.com/a/565282/5774767
 */
var raysIntersect = exports.raysIntersect = function raysIntersect(pos1, dir1, pos2, dir2, deg_allowance) {
    if (!deg_allowance) {
        // degrees divergence still considered 'parallel'
        deg_allowance = 0;
    }

    var p = pos1;
    var q = pos2;
    var r = vectorize_2d(dir1);
    var s = vectorize_2d(dir2);
    var t = (0, _core.abs)(vcp(vsub(q, p), s) / vcp(r, s));
    var t_norm = (0, _core.abs)(vcp(vsub(vnorm(q), vnorm(p)), s) / vcp(r, s));
    var u_norm = (0, _core.abs)(vcp(vsub(vnorm(q), vnorm(p)), r) / vcp(r, s));

    if ((0, _core.abs)(vcp(r, s)) < (0, _core.abs)(vcp([0, 1], vectorize_2d((0, _unitConverters.degreesToRadians)(deg_allowance))))) {
        // parallel (within allowance)
        var crossProduct = vcp(vsub(vnorm(q), vnorm(p)), r);

        if (crossProduct === 0) {
            // collinear
            return true;
        }

        // parallel, non-intersecting
        return false;
    } else if (t_norm >= 0 && t_norm <= 1 && u_norm >= 0 && u_norm <= 1) {
        // rays intersect here
        return vadd(p, vscale(r, t));
    }

    // diverging, non-intersecting
    return false;
};

/**
 * Determines if and where two runways will intersect.
 * Note: Please pass ONLY the runway identifier (eg '28r')
 */
// const runwaysIntersect = (rwy1_name, rwy2_name) => {
//     const airport = window.airportController.airport_get();
//
//     return raysIntersect(
//         airport.getRunway(rwy1_name).position,
//         airport.getRunway(rwy1_name).angle,
//         airport.getRunway(rwy2_name).position,
//         airport.getRunway(rwy2_name).angle,
//         9.9 // consider "parallel" if rwy hdgs differ by maximum of 9.9 degrees
//     );
// };

/**
 * 'Flips' vector's Y component in direction
 * Helper function for culebron's poly edge vector functions
 */
var vflipY = function vflipY(v) {
    return [-v[1], v[0]];
};

/**
 *
 *
 * solution by @culebron
 * turn poly edge into a vector.
 * the edge vector scaled by j and its normal vector scaled by i meet
 * if the edge vector points between the vertices,
 * then normal is the shortest distance.
 * --------
 * x1 + x2 * i == x3 + x4 * j
 * y1 + y2 * i == y3 + y4 * j
 * 0 < j < 1
 * --------
 *
 * i == (y3 + j y4 - y1) / y2
 * x1 + x2 y3 / y2 + j x2 y4 / y2 - x2 y1 / y2 == x3 + j x4
 * j x2 y4 / y2 - j x4 == x3 - x1 - x2 y3 / y2 + x2 y1 / y2
 * j = (x3 - x1 - x2 y3 / y2 + x2 y1 / y2) / (x2 y4 / y2 - x4)
 * i = (y3 + j y4 - y1) / y2
 *
 * i == (x3 + j x4 - x1) / x2
 * y1 + y2 x3 / x2 + j y2 x4 / x2 - y2 x1 / x2 == y3 + j y4
 * j y2 x4 / x2 - j y4 == y3 - y1 - y2 x3 / x2 + y2 x1 / x2
 * j = (y3 - y1 - y2 x3 / x2 + y2 x1 / x2) / (y2 x4 / x2 - y4)
 * i = (x3 + j x4 - x1) / x2
 *
 * @fnuction distance_to_poly
 * @param point {array}
 * @param poly {array}
 * @return number
 */
var distance_to_poly = exports.distance_to_poly = function distance_to_poly(point, poly) {
    var dists = (0, _map3.default)(poly, function (vertex1, i) {
        var prev = (i === 0 ? poly.length : i) - 1;
        var vertex2 = poly[prev];
        var edge = vsub(vertex2, vertex1);

        if (vlen(edge) === 0) {
            return vlen(vsub(point, vertex1));
        }

        // point + normal * i == vertex1 + edge * j
        var norm = vflipY(edge);
        var x1 = point[0];
        var x2 = norm[0];
        var x3 = vertex1[0];
        var x4 = edge[0];
        var y1 = point[1];
        var y2 = norm[1];
        var y3 = vertex1[1];
        var y4 = edge[1];
        var k = void 0;
        var j = void 0;

        if (y2 !== 0) {
            j = (x3 - x1 - x2 * y3 / y2 + x2 * y1 / y2) / (x2 * y4 / y2 - x4);
            k = (y3 + j * y4 - y1) / y2;
        } else if (x2 !== 0) {
            // normal can't be zero unless the edge has 0 length
            j = (y3 - y1 - y2 * x3 / x2 + y2 * x1 / x2) / (y2 * x4 / x2 - y4);
            k = (x3 + j * x4 - x1) / x2;
        }

        if (j < 0 || j > 1 || !j) {
            return Math.min(vlen(vsub(point, vertex1)), vlen(vsub(point, vertex2)));
        }

        return vlen(vscale(norm, k));
    });

    return Math.min.apply(Math, _toConsumableArray(dists));
};

// source: https://github.com/substack/point-in-polygon/
var point_in_poly = exports.point_in_poly = function point_in_poly(point, vs) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    var x = point[0];
    var y = point[1];
    var j = vs.length - 1;
    var inside = false;

    // poly might not be the correct term here
    (0, _forEach3.default)(vs, function (poly, i) {
        var xi = poly[0];
        var yi = poly[1];
        var xj = vs[j][0];
        var yj = vs[j][1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;

        if (intersect) {
            inside = !inside;
        }

        j = i;
    });

    return inside;
};

/**
 *
 * @function point_to_mpoly
 * @param point {array}
 * @param mpoly {array}
 * @return {object}
 */
var point_to_mpoly = exports.point_to_mpoly = function point_to_mpoly(point, mpoly) {
    // returns: boolean inside/outside & distance to the polygon
    var inside = false;

    (0, _forEach3.default)(mpoly, function (ring, k) {
        // ring = mpoly[k];

        if (point_in_poly(point, ring)) {
            if (k === 0) {
                // if inside outer ring, remember that and wait till the end
                inside = true;
            }

            // if by change in one of inner rings, it's out of poly, return distance to the inner ring
            return {
                inside: false,
                distance: distance_to_poly(point, ring)
            };
        }
    });

    // if not matched to inner circles, return the match to outer and distance to it
    return {
        inside: inside,
        distance: distance_to_poly(point, mpoly[0])
    };
};

/**
 * Converts an 'area' to a 'poly'
 */
var area_to_poly = exports.area_to_poly = function area_to_poly(area) {
    // TODO: this should be _map()
    // What is the significance of returning `[v.position]`? isnt position already an array?
    return _jquery2.default.map(area.poly, function (v) {
        return [v.position];
    });
};

/**
 * Checks to see if a point is in an area
 */
var point_in_area = exports.point_in_area = function point_in_area(point, area) {
    return point_in_poly(point, area_to_poly(area));
};

// TODO: this might be best accomplished with a Rectangle class, with this function working as the middleman
// creating the class and asking if there is an intersection.
/**
 * Compute a point of intersection of a ray with a rectangle.
 *
 * Args:
 *   pos: array of 2 numbers, representing ray source.
 *   dir: array of 2 numbers, representing ray direction.
 *   rectPos: array of 2 numbers, representing rectangle corner position.
 *   rectSize: array of 2 positive numbers, representing size of the rectangle.
 *
 * Returns:
 * - undefined, if pos is outside of the rectangle.
 * - undefined, in case of a numerical error.
 * - array of 2 numbers on a rectangle boundary, in case of an intersection.
 */
var positive_intersection_with_rect = exports.positive_intersection_with_rect = function positive_intersection_with_rect(pos, dir, rectPos, rectSize) {
    var left = rectPos[0];
    var right = rectPos[0] + rectSize[0];
    var top = rectPos[1];
    var bottom = rectPos[1] + rectSize[1];
    var t = void 0;
    var x = void 0;
    var y = void 0;

    dir = vnorm(dir);

    // Check if pos is outside of rectangle.
    if ((0, _core.clamp)(left, pos[0], right) !== pos[0] || (0, _core.clamp)(top, pos[1], bottom) !== pos[1]) {
        return undefined;
    }

    // Check intersection with top segment.
    if (dir[1] < 0) {
        t = (top - pos[1]) / dir[1];
        x = pos[0] + dir[0] * t;

        if ((0, _core.clamp)(left, x, right) === x) {
            return [x, top];
        }
    }

    // Check intersection with bottom segment.
    if (dir[1] > 0) {
        t = (bottom - pos[1]) / dir[1];
        x = pos[0] + dir[0] * t;

        if ((0, _core.clamp)(left, x, right) === x) {
            return [x, bottom];
        }
    }

    // Check intersection with left segment.
    if (dir[0] < 0) {
        t = (left - pos[0]) / dir[0];
        y = pos[1] + dir[1] * t;

        if ((0, _core.clamp)(top, y, bottom) === y) {
            return [left, y];
        }
    }

    // Check intersection with right segment.
    if (dir[0] > 0) {
        t = (right - pos[0]) / dir[0];
        y = pos[1] + dir[1] * t;

        if ((0, _core.clamp)(top, y, bottom) === y) {
            return [right, y];
        }
    }

    // Failed to compute intersection due to numerical precision.
    return undefined;
};

},{"../utilities/unitConverters":595,"./core":584,"jquery":296,"lodash/forEach":468,"lodash/map":496}],588:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.speech_toggle = exports.speech_say = exports.speech_init = undefined;

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _radioUtilities = require('./utilities/radioUtilities');

var _storageKeys = require('./constants/storageKeys');

var _selectors = require('./constants/selectors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @function speech_init
 */
/* eslint-disable no-underscore-dangle, no-unused-vars, no-undef, global-require */
var speech_init = exports.speech_init = function speech_init() {
    prop.speech = {};
    prop.speech.synthesis = window.speechSynthesis;
    prop.speech.enabled = false;

    if ((0, _get3.default)(localStorage, _storageKeys.STORAGE_KEY.ATC_SPEECH_ENABLED, false) === true) {
        prop.speech.enabled = true;
        (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.SPEECH_TOGGLE).addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    }
};

/**
 *
 * @function speech_say
 * @param sentence
 */
var speech_say = exports.speech_say = function speech_say(sentence) {
    if (prop.speech.synthesis != null && prop.speech.enabled) {
        var textToSay = '';

        for (var i = 0; i < sentence.length; i++) {
            var singleSentence = sentence[i];

            switch (singleSentence.type) {
                case 'callsign':
                    textToSay += ' ' + singleSentence.content.getRadioCallsign() + ' ';
                    break;
                case 'altitude':
                    textToSay += ' ' + (0, _radioUtilities.radio_altitude)(singleSentence.content) + ' ';
                    break;
                case 'speed':case 'heading':
                    textToSay += ' ' + (0, _radioUtilities.radio_heading)(singleSentence.content) + ' ';
                    break;
                case 'text':
                    textToSay += ' ' + singleSentence.content + ' ';
                    break;
                default:
                    break;
            }
        }

        var utterance = new SpeechSynthesisUtterance(textToSay); // make the object
        utterance.lang = 'en-US'; // set the language
        utterance.voice = prop.speech.synthesis.getVoices().filter(function (voice) {
            // set the voice
            return voice.name === 'Google US English';
        })[0];
        utterance.rate = 1.125; // speed up just a touch

        // say the words
        prop.speech.synthesis.speak(utterance);
    }
};

/**
 *
 * @function speech_toggle
 */
var speech_toggle = exports.speech_toggle = function speech_toggle() {
    var $speechToggle = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.SPEECH_TOGGLE);
    prop.speech.enabled = !prop.speech.enabled;

    if (prop.speech.enabled) {
        $speechToggle.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
    } else {
        $speechToggle.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
        prop.speech.synthesis.cancel();
    }

    localStorage[_storageKeys.STORAGE_KEY.ATC_SPEECH_ENABLED] = prop.speech.enabled;
};

},{"./constants/selectors":575,"./constants/storageKeys":576,"./utilities/radioUtilities":593,"jquery":296,"lodash/get":469,"lodash/has":470}],589:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INIT_POSITION_PADDING = [0, 0];

/**
 * Model representing a single tutorial step.
 *
 * Consumed by tutorial.js
 *
 * @class TutorialStep
 */

var TutorialStep = function () {
    /**
     * @for TutorialStep
     * @constructor
     */
    function TutorialStep() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, TutorialStep);

        this.title = (0, _get3.default)(options, 'title', '?');
        this.text = (0, _get3.default)(options, 'text', '?');
        this.parse = (0, _get3.default)(options, 'parse', null);
        this.side = (0, _get3.default)(options, 'side', 'none');
        this.position = (0, _get3.default)(options, 'position', INIT_POSITION_PADDING);
        this.padding = (0, _get3.default)(options, 'padding', INIT_POSITION_PADDING);
    }

    /**
     * @for TutorialStep
     * @method getText
     * @return {string}
     */


    _createClass(TutorialStep, [{
        key: 'getText',
        value: function getText() {
            if (this.parse) {
                return this.parse(this.text);
            }

            return this.text;
        }
    }]);

    return TutorialStep;
}();

exports.default = TutorialStep;

},{"lodash/get":469}],590:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable max-len */


var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _TutorialStep = require('./TutorialStep');

var _TutorialStep2 = _interopRequireDefault(_TutorialStep);

var _core = require('../math/core');

var _timeHelpers = require('../utilities/timeHelpers');

var _unitConverters = require('../utilities/unitConverters');

var _storageKeys = require('../constants/storageKeys');

var _selectors = require('../constants/selectors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var tutorial = {};

var TUTORIAL_TEMPLATE = '' + '<div id="tutorial">' + '   <h1></h1>' + '   <main></main>' + '   <div class="prev"><img src="assets/images/prev.png" title="Previous step" /></div>' + '   <div class="next"><img src="assets/images/next.png" title="Next step" /></div>' + '</div>';

/**
 * @class TutorialView
 */

var TutorialView = function () {
    /**
     * @constructor
     */
    function TutorialView() {
        var $element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, TutorialView);

        /**
         * Root DOM element
         *
         * @property $element
         * @type {jquery|HTML Element}
         * @default $element
         */
        this.$element = $element;

        /**
         * Root tutorial DOM element
         *
         * @property $tutorialView
         * @type {jquery|HTML Element}
         * @default `#tutorial`
         */
        this.$tutorialView = null;

        /**
         * @property $tutorialToggle
         * @type {jquery|HTML Element}
         * @default `.toggle-tutorial`
         */
        this.$tutorialToggle = null;

        /**
         * Previous tutorial step button
         *
         * @property $tutorialPrevious
         * @type {jquery|HTML Element}
         * @default `.prev`
         */
        this.$tutorialPrevious = null;

        /**
         * Next tutorial step button
         *
         * @property $tutorialNext
         * @type {jquery|HTML Element}
         * @default `.next`
         */
        this.$tutorialNext = null;

        prop.tutorial = tutorial;
        this.tutorial = tutorial;
        this.tutorial.steps = [];
        this.tutorial.step = 0;
        this.tutorial.open = false;

        this._init().layout().enable();
    }

    /**
     * Lifecycle method should be run once on application init.
     *
     * Caches selectors in variabls so they only need to be looked up one time.
     *
     * @for tutorialView
     * @method _init
     * @chainable
     */


    _createClass(TutorialView, [{
        key: '_init',
        value: function _init() {
            this.$tutorialView = (0, _jquery2.default)(TUTORIAL_TEMPLATE);
            this.$tutorialToggle = (0, _jquery2.default)(_selectors.SELECTORS.DOM_SELECTORS.TOGGLE_TUTORIAL);
            this.$tutorialPrevious = this.$tutorialView.find(_selectors.SELECTORS.DOM_SELECTORS.PREV);
            this.$tutorialNext = this.$tutorialView.find(_selectors.SELECTORS.DOM_SELECTORS.NEXT);

            return this;
        }

        /**
         * Lifecycle method should be run once on application init.
         *
         * Adds the TUTORIAL_TEMPLATE to the view
         *
         * @for tutorialView
         * @method layout
         * @chainable
         */

    }, {
        key: 'layout',
        value: function layout() {
            if (!this.$element) {
                throw new Error('Expected $element to be defined. `body` tag does not exist in the DOM');
            }

            prop.tutorial.html = this.$tutorialView;
            this.$element.append(this.$tutorialView);

            return this;
        }

        /**
         * Lifecycle method should be run once on application init.
         *
         * @for tutorialView
         * @method enable
         * @chainable
         */

    }, {
        key: 'enable',
        value: function enable() {
            var _this = this;

            this.$tutorialPrevious.on('click', function (event) {
                return _this.tutorial_prev(event);
            });
            this.$tutorialNext.on('click', function (event) {
                return _this.tutorial_next(event);
            });

            return this;
        }

        /**
         * Disable any click handlers.
         *
         * @for tutorialView
         * @method disable
         * @chainable
         */

    }, {
        key: 'disable',
        value: function disable() {
            var _this2 = this;

            this.$tutorialPrevious.off('click', function (event) {
                return _this2.tutorial_prev(event);
            });
            this.$tutorialNext.off('click', function (event) {
                return _this2.tutorial_next(event);
            });

            return this.destroy();
        }

        /**
         * Tear down the view and unset any properties.
         *
         * @for tutorialView
         * @method destroy
         * @chainable
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.$tutorialView = null;
            this.$tutorialToggle = null;
            this.$tutorialPrevious = null;
            this.$tutorialNext = null;

            this.tutorial = {};
            this.tutorial.steps = [];
            this.tutorial.step = 0;
            this.tutorial.open = false;

            return this;
        }

        /**
         * @for TutorialView
         * @method tutorial_init_pre
         */

    }, {
        key: 'tutorial_init_pre',
        value: function tutorial_init_pre() {
            prop.tutorial = {};
            prop.tutorial.steps = [];
            prop.tutorial.step = 0;
            prop.tutorial.open = false;

            var tutorial_position = [0.1, 0.85];

            this.tutorial_step({
                title: 'Welcome!',
                text: ['Welcome to Air Traffic Control simulator. It&rsquo;s not easy', 'to control dozens of aircraft while maintaining safe distances', 'between them; to get started with the ATC simulator tutorial, click the arrow on', 'the right. You can also click the graduation cap icon in the lower right corner', 'of the window at any time to close this tutorial.'].join(' '),
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Departing aircraft',
                text: ['Let&rsquo;s route some planes out of here. On the right side of the screen, there', 'should be a strip with a blue bar on the left, meaning the strip represents a departing aircraft.', 'Click the first one ({CALLSIGN}). The aircraft&rsquo;s callsign will appear in the command entry box', 'and the strip will move to the left and change color. This means that the aircraft is selected.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{CALLSIGN}', prop.aircraft.list[0].getCallsign());
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Taxiing',
                text: ['Now type in &lsquo;taxi&rsquo; or &lsquo;wait&rsquo; into the command box after the callsign and hit Return;', 'the messages area above it will show that the aircraft is taxiing to runway ({RUNWAY}) in', 'preparation for takeoff. (You could also specify to which runway to taxi the aircraft by', 'entering the runway name after &lsquo;taxi&rsquo; or &lsquo;wait&rsquo;.)'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length < 0) {
                        return t;
                    }

                    return t.replace('{RUNWAY}', prop.aircraft.list[0].fms.currentWaypoint.runway);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Takeoff, part 1',
                text: ['When it appears at the start of runway ({RUNWAY}) (which may take a couple of seconds), click it (or press the up arrow once)', 'and type in &lsquo;caf&rsquo; (for &lsquo;cleared as filed&rsquo;). This tells the aircraft it is cleared to follow its flightplan.', 'Just as in real life, this step must be done before clearing the aircraft for takeoff, so they know where they\'re supposed to go.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{RUNWAY}', prop.aircraft.list[0].fms.currentWaypoint.runway);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Takeoff, part 2',
                text: ['Now the aircraft is ready for take off. Click the aircraft again (or press up arrow once)', 'and type &lsquo;takeoff&rsquo; (or &lsquo;to&rsquo;) to clear the aircraft for take off.', 'Once it\'s going fast enough, it should lift off the ground and you should', 'see its altitude increasing. Meanwhile, read the next step.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{RUNWAY}', prop.aircraft.list[0].fms.currentWaypoint.runway);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Aircraft strips, part 1',
                text: ['On the right, there&rsquo;s a row of strips, one for each aircraft.', 'Each strip has a bar on its left side, colored blue for departures and', 'red for arrivals.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{RUNWAY}', prop.aircraft.list[0].fms.currentWaypoint.runway);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Aircraft strips, part 2',
                text: ['The top row shows the aircraft&rsquo;s callsign, what it\'s doing (parked at apron,', 'using a runway, flying to a fix, on a heading, etc), and its assigned altitude. The bottom row shows the model', '({MODEL} here, which is a {MODELNAME}) to the left, its destination in the middle, and its assigned speed to the right.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{MODEL}', prop.aircraft.list[0].model.icao).replace('{MODELNAME}', prop.aircraft.list[0].model.name);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Moving aircraft',
                text: ['Once {CALLSIGN} has taken off, you\'ll notice it will climb to {INIT_ALT} by itself. This is one of the instructions ', 'we gave them when we cleared them &lsquo;as filed&rsquo;. Aircraft perform better when they are able to climb directly', 'from the ground to their cruise altitude without leveling off, so let\'s keep them climbing! Click it and type &lsquo;cvs&rsquo; (for', '&lsquo;climb via SID&rsquo;). Then they will follow the altitudes and speeds defined in the {SID_NAME} departure', 'procedure. Feel free to click the speedup button on the right side of the input box (it&rsquo;s two small arrows)', 'to watch the departure climb along the SID. Then just click it again to return to 1x speed.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{CALLSIGN}', prop.aircraft.list[0].getCallsign()).replace('{INIT_ALT}', window.airportController.airport_get().initial_alt).replace('{SID_NAME}', prop.aircraft.list[0].destination);
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Departure destinations',
                text: ['If you zoom out (using the mouse wheel) and click', 'on {CALLSIGN}, you will see a blue dashed line that shows where they are heading. At the end of the', 'line is its &lsquo;departure fix&rsquo;. Your goal is to get every departure cleared to their filed departure fix. As', 'you have probably noticed, this is very easy with SIDs, as the aircraft do all the hard work themselves.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{CALLSIGN}', prop.aircraft.list[0].getCallsign());
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Basic Control Instructions: Altitude',
                text: ['You can assign altitudes with the &lsquo;climb&rsquo; command, or any of its aliases (other words that', 'act identically). Running the command &lsquo;climb&rsquo; is the same as the commands &lsquo;descend&rsquo;, &lsquo;d&rsquo;,', '&lsquo;clear&rsquo;, &lsquo;c&rsquo;, &lsquo;altitude&rsquo;, or &lsquo;a&rsquo;. Just use whichever feels correct in your situation.', 'Remember, just as in real ATC, altitudes are ALWAYS written in hundreds of feet, eg. &lsquo;descend 30&rsquo; for 3,000ft or &lsquo;climb', ' 100&rsquo; for 10,000ft.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{CALLSIGN}', prop.aircraft.list[0].getCallsign());
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Basic Control Instructions: Radar Vectors',
                text: ['Radar vectors are an air traffic controller\'s way of telling aircraft to fly a specific magnetic heading. We can give aircraft radar', 'vectors in three ways. Usually, you will use &lsquo;t l ###&rsquo; or &lsquo;t r ###&rsquo;. Be careful, as it is both easy', 'and dangerous to give a turn in the wrong direction. If the heading is only slightly left or right, to avoid choosing the wrong direction,', 'you can tell them to &lsquo;fly heading&rsquo; by typing &lsquo;fh###&rsquo;, and the aircraft will simply turn the shortest direction', 'to face that heading.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Basic Control Instructions: Speed',
                text: ['Speed control is the TRACON controller\'s best friend. Making good use of speed control can help keep the pace manageable and allow', 'you to carefully squeeze aircraft closer and closer to minimums while still maintaining safety. To enter speed instructions, use the', '&lsquo;+&rsquo; and &lsquo;-&rsquo; keys on the numpad, followed by the speed, in knots. Note that this assigned speed is indicated', 'airspeed, and our radar scope can only display groundspeed; so, the values may be different.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace(/{ANGLE}/g, (0, _unitConverters.heading_to_string)(prop.aircraft.list[0].destination));
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Fixes',
                text: ['Instead of guiding each aircraft based on heading, you can also clear each aircraft to proceed to a fix or navaid (shown on the map', 'as a small triangle). Just use the command &lsquo;fix&rsquo; and the name of a fix, and the aircraft will fly to it. Upon passing the', 'fix, it will continue flying along its present heading.'].join(' '),
                parse: function parse(t) {
                    if (prop.aircraft.list.length <= 0) {
                        return t;
                    }

                    return t.replace('{CALLSIGN}', prop.aircraft.list[0].getCallsign());
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Shortcuts',
                text: ['You can give an aircraft a shortcut in a chain of fixes through use of the &lsquo;direct&rsquo;', 'command (&lsquo;dct&rsquo;). Also, you can add more fixes to the end of that list with the', '&lsquo;proceed&rsquo; (&lsquo;pr&rsquo;) command. This is useful with overflights, and while you can have', 'departing aircraft use these commands, it is probably easier to assign them a SID if one is available at your airport.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Bon voyage, aircraft!',
                text: ['When the aircraft crosses the airspace boundary, it will ', 'automatically remove itself from the flight strip bay on the right.', 'Congratulations, you&rsquo;ve successfully taken off one aircraft.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Arrivals',
                text: ['Now, onto arrivals. Click on any arriving aircraft in the radar screen; after', 'you&rsquo;ve selected it, use the altitude/heading/speed controls you\'ve learned in', 'order to guide it to be in front of a runway. Make sure to get the aircraft down to', 'around 4,000ft, and 10-15 nautical miles (2-3 range rings) away from the airport.', 'While you work the airplane, read the next step.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Approach Clearances, part 1',
                text: ['You can clear aircraft for an ILS approach with the &quot;ILS&quot; command, followed by a runway name. Before you can do so, however,', 'it must be on a heading that will cross the runway\'s extended centerline, that is no more than 30 degrees offset from the', 'runway\'s heading. Once we eventually give them an approach clearance, you can expect aircraft to capture the ILS\'s localizer', 'once they\'re within a few degrees of the extended centerline.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Approach Clearances, part 2',
                text: ['When you have the aircraft facing the right direction, just select it and type &lsquo;i &lt;runway&gt;&rsquo;', 'with the runway that&rsquo;s in front of it. Once it\'s close enough to capture the localizer, the assigned altitude on its strip', 'will change to &lsquo;ILS locked&rsquo; (meaning the aircraft is capable of guiding itself down to the runway via', 'the Instrument Landing System), and the assigned heading should now show the runway to which it has an approach clearance.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Approach Clearances, part 3',
                text: ['You may choose to enter one command at a time, but air traffic controllers usually do multiple. Particularly in approach clearances,', 'they follow an acronym &ldquo;PTAC&rdquo; for the four elements of an approach clearance, the &lsquo;T&rsquo; and &lsquo;C&rsquo; of which', 'stand for &lsquo;Turn&rsquo; and &lsquo;Clearance&rsquo;, both of which we entered separately in this tutorial. Though longer, it is both ', 'easier and more real-world accurate to enter them together, like this: &lsquo;fh250 i 28r&rsquo;.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Aborting landings',
                text: ['If the aircraft is established on the ILS, it should be able to land on the runway. However, say there&rsquo;s another', 'aircraft that&rsquo;s planning to take off from the same runway. To abort the landing, use the command &lsquo;abort&rsquo;.', '(If the aircraft is navigating to a fix, the &lsquo;abort&rsquo; command will clear the fix instead.)'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Wind sock',
                text: ['In the lower right corner of the map is a small circle with a line. It\'s like a flag: the line trails in the direction', 'the wind is blowing toward. If it&rsquo;s pointing straight down, the wind is blowing from the North', 'to the South. Aircraft must be assigned to different runways such that they always take off and land into the wind, unless the', 'wind is less than 5 knots.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Score',
                text: ['The lower-right corner of the page has a small number in it; this is your score.', 'Whenever you successfully route an aircraft to the ground or out of the screen, you earn points. As you make mistakes,', 'like directing aircraft to a runway with a strong crosswind/tailwind, losing separation between aircraft, or ignoring an', 'aircraft, you will also lose points. If you&rsquo;d like, you can just ignore the score; it doesn&rsquo;t have any effect', 'with the simulation.'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });

            this.tutorial_step({
                title: 'Good job!',
                text: ['If you&rsquo;ve gone through this entire tutorial, you should do pretty well with the pressure.', 'In the TRACON, minimum separation is 3 miles laterally or 1000 feet vertically. Keep them separated,', 'keep them moving, and you\'ll be a controller in no time!'].join(' '),
                parse: function parse(v) {
                    return v;
                },
                side: 'left',
                position: tutorial_position
            });
        }

        /**
         * @for TutorialView
         * @method tutorial_toggle
         */

    }, {
        key: 'tutorial_toggle',
        value: function tutorial_toggle() {
            if (prop.tutorial.open) {
                this.tutorial_close();
            } else {
                this.tutorial_open();
            }
        }

        /**
         * @method tutorial_get
         */

    }, {
        key: 'tutorial_get',
        value: function tutorial_get() {
            var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (!step) {
                step = prop.tutorial.step;
            }

            return prop.tutorial.steps[step];
        }

        /**
         * @method tutorial_move
         */

    }, {
        key: 'tutorial_move',
        value: function tutorial_move() {
            var step = this.tutorial_get();
            var padding = [30, 10];
            var left = step.position[0] * ((0, _jquery2.default)(window).width() - this.$tutorialView.outerWidth() - padding[0]);
            var top = step.position[1] * (0, _jquery2.default)(window).height();
            top -= this.$tutorialView.outerHeight() - padding[1];

            //  left += step.padding[0];
            //  top  += step.padding[1];

            this.$tutorialView.offset({
                top: (0, _core.round)(top),
                left: (0, _core.round)(left)
            });
        }

        /**
         * @method tutorial_step
         */

    }, {
        key: 'tutorial_step',
        value: function tutorial_step(options) {
            prop.tutorial.steps.push(new _TutorialStep2.default(options));
        }

        /**
         * @method tutorial_update_content
         */

    }, {
        key: 'tutorial_update_content',
        value: function tutorial_update_content() {
            var step = this.tutorial_get();

            this.$tutorialView.find('h1').html(step.title);
            this.$tutorialView.find('main').html(step.getText());
            this.$tutorialView.removeClass('left right');

            if (step.side === _selectors.SELECTORS.CLASSNAMES.LEFT) {
                this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.LEFT);
            } else if (step.side === _selectors.SELECTORS.CLASSNAMES.RIGHT) {
                this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.RIGHT);
            }

            this.tutorial_move();
        }

        /**
         * @method tutorial_open
         */

    }, {
        key: 'tutorial_open',
        value: function tutorial_open() {
            prop.tutorial.open = true;

            this.$tutorialView.addClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
            this.$tutorialToggle.addClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            this.$tutorialToggle.prop('title', 'Close tutorial');

            this.tutorial_update_content();
        }

        /**
         * @method tutorial_close
         */

    }, {
        key: 'tutorial_close',
        value: function tutorial_close() {
            prop.tutorial.open = false;

            this.$tutorialView.removeClass(_selectors.SELECTORS.CLASSNAMES.OPEN);
            this.$tutorialToggle.removeClass(_selectors.SELECTORS.CLASSNAMES.ACTIVE);
            this.$tutorialToggle.prop('title', 'Open tutorial');

            this.tutorial_move();
        }

        // TODO: this function never gets called in this file
        /**
         * @method tutorial_complete
         */

    }, {
        key: 'tutorial_complete',
        value: function tutorial_complete() {
            if (!(0, _has3.default)(localStorage, _storageKeys.STORAGE_KEY.FIRST_RUN_TIME)) {
                this.tutorial_open();
            }

            localStorage[_storageKeys.STORAGE_KEY.FIRST_RUN_TIME] = (0, _timeHelpers.time)();
        }

        /**
         * @method tutorial_next
         */

    }, {
        key: 'tutorial_next',
        value: function tutorial_next() {
            if (prop.tutorial.step === prop.tutorial.steps.length - 1) {
                this.tutorial_close();

                return;
            }

            prop.tutorial.step = (0, _core.clamp)(0, prop.tutorial.step + 1, prop.tutorial.steps.length - 1);

            this.tutorial_update_content();
        }

        /**
         * @method tutorial_prev
         */

    }, {
        key: 'tutorial_prev',
        value: function tutorial_prev() {
            prop.tutorial.step = (0, _core.clamp)(0, prop.tutorial.step - 1, prop.tutorial.steps.length - 1);

            this.tutorial_update_content();
        }

        // TODO: this function never gets called in this file
        /**
         * @method tutorial_resize
         */

    }, {
        key: 'tutorial_resize',
        value: function tutorial_resize() {
            this.tutorial_move();
        }
    }]);

    return TutorialView;
}();

exports.default = TutorialView;

},{"../constants/selectors":575,"../constants/storageKeys":576,"../math/core":584,"../utilities/timeHelpers":594,"../utilities/unitConverters":595,"./TutorialStep":589,"jquery":296,"lodash/has":470}],591:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _radioUtilities = require('./utilities/radioUtilities');

var _logLevel = require('./constants/logLevel');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * The functions contained in this file should be migrated over to the `math/`
 * files as soon as possible.
 *
 * These functions are all attached to the `window` and are global to the
 * entire app. This is a problem because it polutes the global namespace,
 * and files that don't need it have access to it. These functions should be imported
 * only as needed.
 *
 * These functions should also have corresponding tests.
 *
 */

window.AudioContext = window.AudioContext || window.webkitAudioContext;

/*eslint-disable*/
// TODO: this should be replaced with lodash _clone()
function clone(obj) {
    if (null == obj || 'object' != (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
        return obj;
    }

    var copy = obj.constructor();
    for (var attr in obj) {
        if ((0, _has3.default)(obj, attr)) {
            copy[attr] = obj[attr];
        }
    }

    return copy;
};

// String repetition copied from http://stackoverflow.com/a/5450113
if (!String.prototype.hasOwnProperty('repeat')) {
    String.prototype.repeat = function (count) {
        if (count < 1) {
            return '';
        }

        var result = '';
        var pattern = this.valueOf();

        while (count > 1) {
            if (count & 1) result += pattern;
            count >>= 1, pattern += pattern;
        }

        return result + pattern;
    };
}

/**
 * Necessary for Internet Explorer 11 (IE11) to not die while using String.fromCodePoint()
 * This function is not natively available in IE11, as noted on this MSDN page:
 * https://msdn.microsoft.com/en-us/library/dn890630(v=vs.94).aspx
 *
 * Apparently, it is fine with pre-Win8.1 MS Edge 11, but never okay in IE.
 * Here, the function is added to the String prototype to make later code usable.
 *
 * Solution from: http://xahlee.info/js/js_unicode_code_point.html
*/
if (!String.fromCodePoint) {
    // ES6 Unicode Shims 0.1 , © 2012 Steven Levithan , MIT License
    String.fromCodePoint = function fromCodePoint() {
        var chars = [];
        var point = void 0;
        var offset = void 0;
        var units = void 0;

        for (var i = 0; i < arguments.length; i++) {
            point = arguments[i];
            offset = point - 0x10000;
            units = point > 0xFFFF ? [0xD800 + (offset >> 10), 0xDC00 + (offset & 0x3FF)] : [point];
            chars.push(String.fromCharCode.apply(null, units));
        }

        return chars.join('');
    };
}

var log = function log(message) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _logLevel.LOG.INFO;

    var logStrings = {
        0: 'DEBUG',
        1: 'INFO',
        2: 'WARN',
        3: 'ERROR',
        4: 'FATAL'
    };

    if (prop.log <= level) {
        var text = '[ ' + logStrings[level] + ' ]';

        if (level >= _logLevel.LOG.WARNING) {
            console.warn(text, message);
        } else {
            console.log(text, message);
        }
    }
};
window.log = log;

/*eslint-enable*/

// TODO: is this being used? and why are we cloning radio_names here?
var radio_runway_names = clone(_radioUtilities.radio_names);
radio_runway_names.l = 'left';
radio_runway_names.c = 'center';
radio_runway_names.r = 'right';

// TODO: rename leftPad
/**
 * Prepends zeros to front of str/num to make it the desired width
 */
function lpad(n, width) {
    if (n.toString().length >= width) {
        return n.toString();
    }

    var x = '0000000000000' + n;

    return x.substr(x.length - width, width);
}

// FIXME: unused
// function endsWith(str, suffix) {
//     return str.indexOf(suffix, str.length - suffix.length) !== -1;
// }
// window.endsWith = endsWith;


// TODO: lodash _compact() might be useful here
/**
 * Splices all empty elements out of an array
 */
function array_clean(array, deleteValue) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === deleteValue) {
            array.splice(i, 1);
            i--;
        }
    }

    return array;
}

// TODO: this can be done with .reduce()
/**
 * Returns the sum of all numerical values in the array
 */
function array_sum(array) {
    var total = 0;

    for (var i = 0; i < array.length; i++) {
        total += parseFloat(array[i]);
    }

    return total;
}

window.clone = clone;
// window.distEuclid = distEuclid;
window.lpad = lpad;
window.array_clean = array_clean;
window.array_sum = array_sum;

},{"./constants/logLevel":574,"./utilities/radioUtilities":593,"lodash/has":470}],592:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.choose_weight = exports.choose = exports.unicodeToString = undefined;

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper method to translate a unicode character into a readable string value
 *
 * @method unicodeToString
 * @param char {characterCode}
 * @return {string}
 */
var unicodeToString = exports.unicodeToString = function unicodeToString(char) {
    return '\\u' + char.charCodeAt(0).toString(16).toUpperCase();
};

/**
 *
 * @function choose
 */
var choose = exports.choose = function choose(l) {
    var randomIndexFromLength = Math.floor(Math.random() * l.length);

    return l[randomIndexFromLength];
};

/**
 *
 * @function choose_weight
 */
var choose_weight = exports.choose_weight = function choose_weight(l) {
    if (l.length === 0) {
        return;
    }

    if (!(0, _isArray3.default)(l[0])) {
        return choose(l);
    }

    // l = [[item, weight], [item, weight] ... ];
    var weight = 0;
    for (var i = 0; i < l.length; i++) {
        weight += l[i][1];
    }

    var randomWeight = Math.random() * weight;
    weight = 0;

    for (var _i = 0; _i < l.length; _i++) {
        weight += l[_i][1];

        if (weight > randomWeight) {
            return l[_i][0];
        }
    }

    console.log('OHSHIT');

    return null;
};

},{"lodash/isArray":476}],593:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getCardinalDirection = exports.radio_trend = exports.radio_altitude = exports.radio_spellOut = exports.radio_heading = exports.radio_runway = exports.groupNumbers = exports.getGrouping = exports.digits_decimal = exports.digits_integer = exports.radio_runway_names = exports.radio_cardinalDir_names = exports.radio_names = undefined;

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _core = require('../math/core');

var _circle = require('../math/circle');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @property CARDINAL_DIRECTION
 * @type {Array}
 * @final
 */
var CARDINAL_DIRECTION = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];

/**
 * @property radio_names
 * @type {Object}
 * @final
 */
var radio_names = exports.radio_names = {
    0: 'zero',
    1: 'one',
    2: 'two',
    3: 'three',
    4: 'four',
    5: 'five',
    6: 'six',
    7: 'seven',
    8: 'eight',
    9: 'niner',
    10: 'ten',
    11: 'eleven',
    12: 'twelve',
    13: 'thirteen',
    14: 'fourteen',
    15: 'fifteen',
    16: 'sixteen',
    17: 'seventeen',
    18: 'eighteen',
    19: 'nineteen',
    20: 'twenty',
    30: 'thirty',
    40: 'fourty',
    50: 'fifty',
    60: 'sixty',
    70: 'seventy',
    80: 'eighty',
    90: 'ninety',
    a: 'alpha',
    b: 'bravo',
    c: 'charlie',
    d: 'delta',
    e: 'echo',
    f: 'foxtrot',
    g: 'golf',
    h: 'hotel',
    i: 'india',
    j: 'juliet',
    k: 'kilo',
    l: 'lima',
    m: 'mike',
    n: 'november',
    o: 'oscar',
    p: 'papa',
    q: 'quebec',
    r: 'romeo',
    s: 'sierra',
    t: 'tango',
    u: 'uniform',
    v: 'victor',
    w: 'whiskey',
    x: 'x-ray',
    y: 'yankee',
    z: 'zulu',
    '-': 'dash',
    '.': 'point'
};

// TODO: this and CARDINAL_DIRECTION seem to be duplicating logic. look into smoothing that out by using
// just this enum and `toUpperCase()` where necessary.
/**
 * @property radio_cardinalDir_names
 * @type {Object}
 * @final
 */
var radio_cardinalDir_names = exports.radio_cardinalDir_names = {
    n: 'north',
    nw: 'northwest',
    w: 'west',
    sw: 'southwest',
    s: 'south',
    se: 'southeast',
    e: 'east',
    ne: 'northeast'
};

// TODO: probably do this with Object.assign
var radio_runway_names = exports.radio_runway_names = (0, _clone3.default)(radio_names);
radio_runway_names.l = 'left';
radio_runway_names.c = 'center';
radio_runway_names.r = 'right';

// TODO: how is this different from lpad?
// NOT IN USE
/**
 * Force a number to a string with a specific # of digits
 *
 * If the rounded integer has more digits than requested, it will be returned
 * anyway, as chopping them off the end would change the value by orders of
 * magnitude, which is almost definitely going to be undesirable.
 *
 * @param number
 * @param digits
 * @truncate {boolean}
 * @return {string} with leading zeros to reach 'digits' places
 */
var digits_integer = exports.digits_integer = function digits_integer(number, digits) {
    var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (truncate) {
        number = Math.floor(number).toString();
    } else {
        number = Math.round(number).toString();
    }

    if (number.length > digits) {
        return number;
    }

    // add leading zeros
    while (number.length < digits) {
        number = '0' + number;
    }

    return number;
};

/**
 * Round a number to a specific # of digits after the decimal
 *
 * Also supports negative digits. Ex: '-2' would do 541.246 --> 500
 *
 * @param {boolean} force - (optional) Forces presence of trailing zeros.
 *                          Must be set to true if you want '3' to be able to go to '3.0', or
 *                          for '32.168420' to not be squished to '32.16842'. If true, fxn will
 *                          return a string, because otherwise, js removes all trailing zeros.
 * @param {boolean} truncate - (optional) Selects shortening method.
 *                          to truncate: 'true', to round: 'false' (default)
 * @return {number}         if !force
 * @return {string}         if force
 */
var digits_decimal = exports.digits_decimal = function digits_decimal(number, digits, force, truncate) {
    var shorten = truncate ? Math.floor : Math.round;

    if (!force) {
        return shorten(number * Math.pow(10, digits)) / Math.pow(10, digits);
    }

    // check if needs extra trailing zeros
    if (digits <= 0) {
        return (shorten(number * Math.pow(10, digits)) / Math.pow(10, digits)).toString();
    }

    number = number.toString();

    for (var i = 0; i < number.length; i++) {
        if (number[i] === '.') {
            var trailingDigits = number.length - (i + 1);

            if (trailingDigits === digits) {
                return number.toString();
            } else if (trailingDigits < digits) {
                // add trailing zeros
                return number + Array(digits - trailingDigits + 1).join('0');
            } else if (trailingDigits > digits) {
                if (truncate) {
                    return number.substr(0, number.length - (trailingDigits - digits));
                }

                var len = number.length - (trailingDigits - digits + 1);
                var part1 = number.substr(0, len);
                var part2 = digits === 0 ? '' : shorten(parseInt(number.substr(len, 2), 10) / 10).toString();

                return part1 + part2;
            }
        }
    }
};

/**
 *
 * @function getGrouping
 * @param groupable {array}
 * @return {string}
 */
var getGrouping = exports.getGrouping = function getGrouping(groupable) {
    var digit1 = groupable[0];
    var digit2 = groupable[1];

    if (digit1 === 0) {
        if (digit2 === 0) {
            return 'hundred';
        }
        // just digits (eg 'zero seven')
        return radio_names[digit1] + ' ' + radio_names[digit2];
    } else if (digit1 === 1) {
        // exact number (eg 'seventeen')
        return radio_names[groupable];
    } else if (digit1 >= 2) {
        var firstDigit = digit1 + '0';

        if (digit2 === 0) {
            // to avoid 'five twenty zero'
            return radio_names[firstDigit];
        }
        // combo number (eg 'fifty one')
        return radio_names[firstDigit] + ' ' + radio_names[digit2];
    }

    return radio_names[digit1] + ' ' + radio_names[digit2];
};

// TODO: this needs to be simplified
/**
 *
 * @function groupNumbers
 * @param callsign {string}
 * @param airline {string} (optional)
 * @return
 */
var groupNumbers = exports.groupNumbers = function groupNumbers(callsign, airline) {
    if (!/^\d+$/.test(callsign)) {
        // GA, eg '117KS' = 'one-one-seven-kilo-sierra')
        if (airline === 'November') {
            // callsign "November"
            var _s = [];

            for (var k in callsign) {
                // one after another (eg 'one one seven kilo sierra')
                _s.push(radio_names[callsign[k]]);
            }

            return _s.join(' ');
        }

        // airline grouped, eg '3110A' = 'thirty-one-ten-alpha'
        // divide callsign into alpha/numeric sections
        var sections = [];
        var cs = callsign;
        var thisIsDigit = void 0;
        var index = cs.length - 1;
        var lastWasDigit = !isNaN(parseInt(cs[index], 10));
        index--;

        while (index >= 0) {
            thisIsDigit = !isNaN(parseInt(cs[index], 10));

            while (thisIsDigit === lastWasDigit) {
                index--;
                thisIsDigit = !isNaN(parseInt(cs[index], 10));

                if (index < 0) {
                    break;
                }
            }
            sections.unshift(cs.substr(index + 1));
            cs = cs.substr(0, index + 1);
            lastWasDigit = thisIsDigit;
        }

        // build words, section by section
        var s = [];

        for (var i in sections) {
            if (isNaN(parseInt(sections[i], 10))) {
                // alpha section
                s.push(radio_spellOut(sections[i]));
            } else {
                // numeric section
                switch (sections[i].length) {
                    case 0:
                        s.push(sections[i]);
                        break;
                    case 1:
                        s.push(radio_names[sections[i]]);
                        break;
                    case 2:
                        s.push(getGrouping(sections[i]));
                        break;
                    case 3:
                        s.push(radio_names[sections[i][0]] + ' ' + getGrouping(sections[i].substr(1)));
                        break;
                    case 4:
                        s.push(getGrouping(sections[i].substr(0, 2)) + ' ' + getGrouping(sections[i].substr(2)));
                        break;
                    default:
                        s.push(radio_spellOut(sections[i]));
                        break;
                }
            }
        }

        return s.join(' ');
    } else {
        // FIXME: this block is unreachable
        switch (callsign.length) {
            case 0:
                return callsign;break;
            case 1:
                return radio_names[callsign];break;
            case 2:
                return getGrouping(callsign);break;
            case 3:
                return radio_names[callsign[0]] + ' ' + getGrouping(callsign.substr(1));
                break;
            case 4:
                return getGrouping(callsign.substr(0, 2)) + ' ' + getGrouping(callsign.substr(2));
                break;
            default:
                return callsign;
        }
    }
};

/**
 *
 * @funtion radio_runway
 * @param input {string}
 * @return
 */
var radio_runway = exports.radio_runway = function radio_runway(input) {
    input = input + ' ';
    input = input.toLowerCase();

    return (0, _compact3.default)((0, _map3.default)(input, function (letterOrNumber, i) {
        return radio_runway_names[input[i]];
    })).join(' ');
};

/**
 *
 * @function radio_heading
 * @param heading {string}
 * @return {string}
 */
var radio_heading = exports.radio_heading = function radio_heading(heading) {
    var str = heading.toString();

    switch (str.length) {
        case 1:
            return 'zero zero ' + radio_names[str];
        case 2:
            return 'zero ' + radio_names[str[0]] + ' ' + radio_names[str[1]];
        default:
            return radio_names[str[0]] + ' ' + radio_names[str[1]] + ' ' + radio_names[str[2]];
    }

    return heading;
};

/**
 *
 * @function radio_spellOut
 * @param alphanumeric
 * @return
 */
var radio_spellOut = exports.radio_spellOut = function radio_spellOut(alphanumeric) {
    var str = alphanumeric.toString();
    var arr = [];

    if (!str) {
        return;
    }

    // TODO: change to _map()
    for (var i = 0; i < str.length; i++) {
        arr.push(radio_names[str[i]]);
    }

    return arr.join(' ');
};

/**
 *
 * @function radio_altitude
 * @param altitude
 * @return
 */
var radio_altitude = exports.radio_altitude = function radio_altitude(altitude) {
    var alt_s = altitude.toString();
    var s = [];

    // TODO can this block be simplified?
    if (altitude >= 18000) {
        s.push('flight level', radio_names[alt_s[0]], radio_names[alt_s[1]], radio_names[alt_s[2]]);
    } else if (altitude >= 10000) {
        s.push(radio_names[alt_s[0]], radio_names[alt_s[1]], 'thousand');

        if (!(altitude % (Math.floor(altitude / 1000) * 1000) === 0)) {
            s.push(radio_names[alt_s[2]], 'hundred');
        }
    } else if (altitude >= 1000) {
        s.push(radio_names[alt_s[0]], 'thousand');

        if (!(altitude % (Math.floor(altitude / 1000) * 1000) === 0)) {
            s.push(radio_names[alt_s[1]], 'hundred');
        }
    } else if (altitude >= 100) {
        s.push(radio_names[alt_s[0]], 'hundred');
    } else {
        return altitude;
    }

    return s.join(' ');
};

/**
 *
 * @function radio_trend
 * @param category
 * @param measured
 * @param target
 * @return {string}
 */
var radio_trend = exports.radio_trend = function radio_trend(category, measured, target) {
    var CATEGORIES = {
        altitude: ['descend and maintain', 'climb and maintain', 'maintain'],
        speed: ['reduce speed to', 'increase speed to', 'maintain present speed of']
    };

    if (measured > target) {
        return CATEGORIES[category][0];
    }

    if (measured < target) {
        return CATEGORIES[category][1];
    }

    return CATEGORIES[category][2];
};

/**
 *
 * @function getCardinalDirection
 * @param angle
 * @return {string}
 */
var getCardinalDirection = exports.getCardinalDirection = function getCardinalDirection(angle) {
    return CARDINAL_DIRECTION[(0, _core.round)(angle / (0, _circle.tau)() * 8)];
};

},{"../math/circle":583,"../math/core":584,"lodash/clone":460,"lodash/compact":462,"lodash/map":496}],594:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @property TIME_SECONDS_OFFSET
 * @type {number}
 * @final
 */
var TIME_SECONDS_OFFSET = 0.001;

// TODO: rename function
/**
 * @function time
 * @return {number} current time in seconds
 */
var time = exports.time = function time() {
  return new Date().getTime() * TIME_SECONDS_OFFSET;
};

/**
 * @function calculateDeltaTime
 * @param  {number} lastFrame
 * @return {number}
 */
var calculateDeltaTime = exports.calculateDeltaTime = function calculateDeltaTime(lastFrame) {
  return Math.min(time() - lastFrame, 1 / 20);
};

},{}],595:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseElevation = exports.parseCoordinate = exports.heading_to_string = exports.convertStringToNumber = exports.convertToThousands = exports.convertMinutesToSeconds = exports.km_to_px = exports.px_to_km = exports.degreesToRadians = exports.radiansToDegrees = exports.kn_ms = exports.ft_km = exports.km_ft = exports.m_ft = exports.nm = exports.km = exports.NUMBER_CONSTANTS = exports.UNIT_CONVERSION_CONSTANTS = undefined;

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _startsWith2 = require('lodash/startsWith');

var _startsWith3 = _interopRequireDefault(_startsWith2);

var _circle = require('../math/circle');

var _core = require('../math/core');

var _globalConstants = require('../constants/globalConstants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @property DECIMAL_RADIX
 * @type {number}
 * @final
 */
var DECIMAL_RADIX = 10;

// TODO: This should be moved to its own file once it has been filled in a little more
/**
 * @property UNIT_CONVERSION_CONSTANTS
 * @type {Object}
 */
var UNIT_CONVERSION_CONSTANTS = exports.UNIT_CONVERSION_CONSTANTS = {
  /**
   * nautical mile per kilometer ratio
   *
   * @property NM_KM
   * @type {number}
   * @final
   */
  NM_KM: 1.852,
  /**
   * Meters to feet ratio
   *
   * @property M_FT
   * @type {number}
   * @final
   */
  M_FT: 0.3048,
  /**
   * kilometer per foot ratio
   *
   * @property KM_FT
   * @type {number}
   * @final
   */
  KM_FT: 0.0003048,
  /**
   * knots per m/s ratio
   *
   * @property KN_MS
   * @type {number}
   * @final
   */
  KN_MS: 0.51444444,
  /**
   * Number used to obtain feet from a flight level number
   *
   * @property FL_TO_FT_MULTIPLIER
   * @type {number}
   * @final
   */
  FL_TO_FT_MULTIPLIER: 100
};

// TODO: This should be moved to its own file once it has been filled in a little more
/**
 * @property NUMBER_CONSTANTS
 * @type {Object}
 * @final
 */
var NUMBER_CONSTANTS = exports.NUMBER_CONSTANTS = {
  /**
   * Degrees in a circle
   *
   * @property FULL_CIRCLE_DEGREES
   * @type {number}
   * @final
   */
  FULL_CIRCLE_DEGREES: 360
};

/**
 * nautical miles --> kilometers
 *
 * @function km
 * @param nm {number}
 * @return {number}
 */
var km = exports.km = function km() {
  var nm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return nm * UNIT_CONVERSION_CONSTANTS.NM_KM;
};

/**
 * kilometers --> nautical miles
 *
 * @function nm
 * @param kilometers {number}
 * @return {number}
 */
var nm = exports.nm = function nm() {
  var kilometers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return kilometers / UNIT_CONVERSION_CONSTANTS.NM_KM;
};

/**
 * meters -> feet
 *
 * @function m_ft
 * @param {number} [meters=0]
 * @return {number}
 */
var m_ft = exports.m_ft = function m_ft() {
  var meters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return meters / UNIT_CONVERSION_CONSTANTS.M_FT;
};

/**
 * kilometers --> feet
 *
 * @function km_ft
 * @param kilometers {number}
 * @return {number}
 */
var km_ft = exports.km_ft = function km_ft() {
  var kilometers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return kilometers / UNIT_CONVERSION_CONSTANTS.KM_FT;
};

/**
 * feet --> kilometers
 *
 * @function ft_km
 * @param nm {number}
 * @return {number}
 */
var ft_km = exports.ft_km = function ft_km() {
  var ft = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return ft * UNIT_CONVERSION_CONSTANTS.KM_FT;
};

/**
 * knots to m/s
 *
 * @function kn_ms
 * @param kn {number}
 * @return {number}
 */
var kn_ms = exports.kn_ms = function kn_ms() {
  var kn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return kn * UNIT_CONVERSION_CONSTANTS.KN_MS;
};

/**
 * convert radians to degrees
 *
 * @function radiansToDegrees
 * @param radians {number}
 * @return {number}
 */
var radiansToDegrees = exports.radiansToDegrees = function radiansToDegrees(radians) {
  return radians / (0, _circle.tau)() * NUMBER_CONSTANTS.FULL_CIRCLE_DEGREES;
};

/**
 * convert degrees to radians
 *
 * @function degreesToRadians
 * @param degrees {number}
 * @return {number}
 */
var degreesToRadians = exports.degreesToRadians = function degreesToRadians(degrees) {
  return degrees / NUMBER_CONSTANTS.FULL_CIRCLE_DEGREES * (0, _circle.tau)();
};

/**
 * NOT IN USE
 * convert pixels to kilometers at the current scale
 *
 * @function px_to_km
 * @param  {number} pixels
 * @param  {number} scale
 * @return {number}
 */
var px_to_km = exports.px_to_km = function px_to_km(pixels, scale) {
  return pixels / scale;
};

/**
 * NOT IN USE
 * convert kilometers to pixels at the current scale
 *
 * @function km_to_px
 * @param  {number} kilometers
 * @return {number}
 */
var km_to_px = exports.km_to_px = function km_to_px(kilometers, scale) {
  return kilometers * scale;
};

/**
 * @function convertMinutesToSeconds
 * @param minutes {number}
 * @return {number}
 */
var convertMinutesToSeconds = exports.convertMinutesToSeconds = function convertMinutesToSeconds(minutes) {
  return minutes * 60;
};

/**
 * Utility function to convert a number to thousands.
 *
 * Given a flightlevel FL180, this function outputs 18,000
 *
 * @function covertToThousands
 * @param  {number} value
 * @return {number}
 */
var convertToThousands = exports.convertToThousands = function convertToThousands(value) {
  return parseInt(value, DECIMAL_RADIX) * UNIT_CONVERSION_CONSTANTS.FL_TO_FT_MULTIPLIER;
};

/**
 * Attempt to convert a string to a number
 *
 * The implementor will have to handle the case where `parseInt` returns `NaN`
 *
 * @function convertStringToNumber
 * @param  value {string|*}
 * @return {number|NaN}
 */
var convertStringToNumber = exports.convertStringToNumber = function convertStringToNumber(value) {
  return parseInt(value, DECIMAL_RADIX);
};

/**
 *
 * @function heading_to_string
 * @param heading {string}
 * @return {string}
 */
var heading_to_string = exports.heading_to_string = function heading_to_string(heading) {
  heading = (0, _core.round)((0, _core.mod)(radiansToDegrees(heading), 360)).toString();

  if (heading === '0') {
    heading = '360';
  }

  if (heading.length === 1) {
    heading = '00' + heading;
  }

  if (heading.length === 2) {
    heading = '0' + heading;
  }

  return heading;
};

/**
 * Accept a lat/long coordinate and return a value in decimal notation
 *
 * Latitude and Longitude numbers may be one of the following forms:
 *   Decimal degrees - 'N47.112388112'
 *   Decimal minutes - 'N38d38.109808'
 *   Decimal seconds - 'N58d27m12.138'
 *
 * @function parseCoordinate
 * @param coordinate {string}
 * @return transformedCoordinate {number}
 */
var parseCoordinate = exports.parseCoordinate = function parseCoordinate(coordinate) {
  var match = _globalConstants.REGEX.LAT_LONG.exec(coordinate);

  // If coordinate already in WGS84 ESPG:4326 form ('39.427618, -75.296011'), just return it as-is
  if (match == null) {
    return coordinate;
  }

  var degrees = parseFloat(match[2]);
  var minutes = 0;
  var seconds = 0;

  // Gather minutes/seconds as decimal of a degree, if available
  if (match[5] != null) {
    minutes = parseFloat(match[5]) * _globalConstants.TIME.ONE_MINUTE_IN_HOURS;

    if (match[8] != null) {
      seconds = parseFloat(match[8]) * _globalConstants.TIME.ONE_SECOND_IN_HOURS;
    }
  }

  var decimalDegrees = degrees + minutes + seconds;

  // Apply negative to value if coordinate is "South" or "West"
  if (_globalConstants.REGEX.SW.test(match[1])) {
    decimalDegrees *= -1;
  }

  return decimalDegrees;
};

/**
 * Accept a string elevation and return a number representing elevation in ft.
 *
 * @function parseElevation
 * @param elevation {string}    ex: 13.4ft, 3m, 5ft
 * @return {number}             elevation in feet
 */
var parseElevation = exports.parseElevation = function parseElevation(elevation) {
  // TODO: move to master REGEX constant
  // this regex will catch the following: `-`, `m`, `ft`, `Infinity`, and is used to extract a number
  // from a string containing these symbols.
  var REGEX = /(-)|(m|ft|Infinity)/gi;

  // if its a number, we're done here.
  // This will catch whole numbers, floats, Infinity and -Infinity.
  // This checks if strings are given will skip the regex and exit early
  // Also stops the function from returning NaN
  if ((0, _isNumber3.default)(elevation) || elevation === 'Infinity' || elevation === '-Infinity') {
    return parseFloat(elevation);
  }

  var parsedElevation = elevation.replace(REGEX, '');
  var elevationUnit = elevation.match(REGEX);

  // if its in meters, convert it to feet
  if ((0, _includes3.default)(elevationUnit, 'm')) {
    parsedElevation = m_ft(parsedElevation);
  }

  // if it came in as a negative number,return it as a negative number
  if ((0, _startsWith3.default)(elevation, '-')) {
    parsedElevation *= -1;
  }

  return parseFloat(parsedElevation);
};

},{"../constants/globalConstants":573,"../math/circle":583,"../math/core":584,"lodash/includes":474,"lodash/isNumber":486,"lodash/startsWith":502}]},{},[582])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hZGRNYXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZFNldEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpV29yZHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xhbXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RTbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUZpbmQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWJ1cnJMZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZVdvcmQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVdvcmRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb21wYWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGVidXJyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hlYWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNOaWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sYXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sb3dlckNhc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdGFydENhc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0YXJ0c1dpdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90YWlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3VuaXF1ZUlkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91cHBlckZpcnN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3dpdGhvdXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3dvcmRzLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL0FwcC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9JbnB1dENvbnRyb2xsZXIuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvTG9hZGluZ1ZpZXcuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvVWlDb250cm9sbGVyLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0FpcmNyYWZ0Q29uZmxpY3QuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlyY3JhZnQvQWlyY3JhZnRDb250cm9sbGVyLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0FpcmNyYWZ0SW5zdGFuY2VNb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJjcmFmdC9BaXJjcmFmdE1vZGVsLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0FpcmNyYWZ0U3RyaXBWaWV3LmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vQWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vTGVnLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcmNyYWZ0L0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vV2F5cG9pbnQuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlybGluZS9BaXJsaW5lQ29udHJvbGxlci5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJsaW5lL0FpcmxpbmVNb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJsaW5lL3JhbmRvbUFpcmxpbmVTZWxlY3Rpb25IZWxwZXIuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9BaXJwb3J0Q29udHJvbGxlci5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L0FpcnBvcnRNb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L0FpcnNwYWNlTW9kZWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9BcnJpdmFsL0Fycml2YWxCYXNlLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvQXJyaXZhbC9BcnJpdmFsQ3ljbGljLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvQXJyaXZhbC9BcnJpdmFsU3VyZ2UuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9BcnJpdmFsL0Fycml2YWxXYXZlLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvQXJyaXZhbC9hcnJpdmFsRmFjdG9yeS5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L0RlcGFydHVyZS9EZXBhcnR1cmVCYXNlLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvRGVwYXJ0dXJlL0RlcGFydHVyZUN5Y2xpYy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L0RlcGFydHVyZS9EZXBhcnR1cmVXYXZlLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvRGVwYXJ0dXJlL2RlcGFydHVyZUZhY3RvcnkuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9GaXgvRml4Q29sbGVjdGlvbi5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L0ZpeC9GaXhNb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L1JvdXRlL1JvdXRlTW9kZWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9SdW53YXlNb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L1N0YW5kYXJkUm91dGUvUm91dGVTZWdtZW50Q29sbGVjdGlvbi5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9haXJwb3J0L1N0YW5kYXJkUm91dGUvUm91dGVTZWdtZW50TW9kZWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9TdGFuZGFyZFJvdXRlL1N0YW5kYXJkUm91dGVDb2xsZWN0aW9uLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2FpcnBvcnQvU3RhbmRhcmRSb3V0ZS9TdGFuZGFyZFJvdXRlTW9kZWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYWlycG9ydC9TdGFuZGFyZFJvdXRlL1N0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2Jhc2UvQmFzZUNvbGxlY3Rpb24uanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYmFzZS9CYXNlTW9kZWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYmFzZS9Nb2RlbFNvdXJjZS9Nb2RlbFNvdXJjZUZhY3RvcnkuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYmFzZS9Nb2RlbFNvdXJjZS9Nb2RlbFNvdXJjZVBvb2wuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvYmFzZS9Nb2RlbFNvdXJjZS9tb2RlbFNvdXJjZUNsYXNzTWFwLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2Jhc2UvUG9zaXRpb25Nb2RlbC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9iYXNlL3Bvc2l0aW9uTW9kZWxIZWxwZXJzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NhbnZhcy9DYW52YXNDb250cm9sbGVyLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbW1hbmRQYXJzZXIvQ29tbWFuZE1vZGVsLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbW1hbmRQYXJzZXIvQ29tbWFuZFBhcnNlci5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9jb21tYW5kUGFyc2VyL2FyZ3VtZW50UGFyc2Vycy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9jb21tYW5kUGFyc2VyL2FyZ3VtZW50VmFsaWRhdG9ycy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9jb21tYW5kUGFyc2VyL2NvbW1hbmREZWZpbml0aW9ucy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9jb21tYW5kUGFyc2VyL2NvbW1hbmRNYXAuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvY29tbWFuZFBhcnNlci9jb21tYW5kUGFyc2VyTWVzc2FnZXMuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvY29uc3RhbnRzL2FpcmNyYWZ0Q29uc3RhbnRzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbnN0YW50cy9haXJwb3J0Q29uc3RhbnRzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbnN0YW50cy9nYW1lT3B0aW9uQ29uc3RhbnRzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbnN0YW50cy9nbG9iYWxDb25zdGFudHMuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvY29uc3RhbnRzL2xvZ0xldmVsLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbnN0YW50cy9zZWxlY3RvcnMuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvY29uc3RhbnRzL3N0b3JhZ2VLZXlzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2NvbnRlbnRRdWV1ZS9Db250ZW50UXVldWUuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvY29udGVudFF1ZXVlL0xvYWRhYmxlQ29udGVudE1vZGVsLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2dhbWUvR2FtZUNsb2NrVmlldy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy9nYW1lL0dhbWVDb250cm9sbGVyLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL2dhbWUvR2FtZU9wdGlvbnMuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvaW5kZXguanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvbWF0aC9jaXJjbGUuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvbWF0aC9jb3JlLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL21hdGgvZGlzdGFuY2UuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvbWF0aC9mbGlnaHRNYXRoLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL21hdGgvdmVjdG9yLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL3NwZWVjaC5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy90dXRvcmlhbC9UdXRvcmlhbFN0ZXAuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvdHV0b3JpYWwvVHV0b3JpYWxWaWV3LmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL3V0aWwuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvdXRpbGl0aWVzL2dlbmVyYWxVdGlsaXRpZXMuanMiLCJzcmMvYXNzZXRzL3NjcmlwdHMvdXRpbGl0aWVzL3JhZGlvVXRpbGl0aWVzLmpzIiwic3JjL2Fzc2V0cy9zY3JpcHRzL3V0aWxpdGllcy90aW1lSGVscGVycy5qcyIsInNyYy9hc3NldHMvc2NyaXB0cy91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1K1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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TUFBTSxDQUFOLENBQVgsSUFBdUIsc0JBQUssbUJBQXZDOztBQUVBLFFBQUksTUFBTSxDQUFOLEtBQVksSUFBaEIsRUFBc0I7QUFDbEIsZ0JBQVcsV0FBVyxNQUFNLENBQU4sQ0FBWCxJQUF1QixzQkFBSyxtQkFBdkM7QUFDSDtBQUNKOztBQUVELE1BQUksaUJBQWlCLFVBQVUsT0FBVixHQUFvQixPQUF6Qzs7QUFFQTtBQUNBLE1BQUksdUJBQU0sRUFBTixDQUFTLElBQVQsQ0FBYyxNQUFNLENBQU4sQ0FBZCxDQUFKLEVBQTZCO0FBQ3pCLHNCQUFrQixDQUFDLENBQW5CO0FBQ0g7O0FBRUQsU0FBTyxjQUFQO0FBQ0gsQ0E3Qk07O0FBK0JQOzs7Ozs7O0FBT08sSUFBTSwwQ0FBaUIsU0FBakIsY0FBaUIsQ0FBQyxTQUFELEVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLHVCQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSx3QkFBVSxTQUFWLEtBQXdCLGNBQWMsVUFBdEMsSUFBb0QsY0FBYyxXQUF0RSxFQUFtRjtBQUMvRSxXQUFPLFdBQVcsU0FBWCxDQUFQO0FBQ0g7O0FBRUQsTUFBSSxrQkFBa0IsVUFBVSxPQUFWLENBQWtCLEtBQWxCLEVBQXlCLEVBQXpCLENBQXRCO0FBQ0EsTUFBTSxnQkFBZ0IsVUFBVSxLQUFWLENBQWdCLEtBQWhCLENBQXRCOztBQUVBO0FBQ0EsTUFBSSx3QkFBVSxhQUFWLEVBQXlCLEdBQXpCLENBQUosRUFBbUM7QUFDL0Isc0JBQWtCLEtBQUssZUFBTCxDQUFsQjtBQUNIOztBQUVEO0FBQ0EsTUFBSSwwQkFBWSxTQUFaLEVBQXVCLEdBQXZCLENBQUosRUFBaUM7QUFDN0IsdUJBQW1CLENBQUMsQ0FBcEI7QUFDSDs7QUFFRCxTQUFPLFdBQVcsZUFBWCxDQUFQO0FBQ0gsQ0E1Qk0iLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59OyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZ2V0V2VhayAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2Vha1xuICAsIGFuT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICwgJGhhcyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGFycmF5RmluZCAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgLCBhcnJheUZpbmRJbmRleCAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgICAgICAgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24odGhhdCl7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZih+aW5kZXgpdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYoZGF0YSA9PT0gdHJ1ZSl1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgbWV0YSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRpdGVyRGV0ZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnICAgID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24oS0VZKXtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYil7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZih0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlICAgICAgICAgICAgID0gbmV3IENcbiAgICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICAgICwgSEFTTlRfQ0hBSU5JTkcgICAgICAgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlXG4gICAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICwgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbigpeyBpbnN0YW5jZS5oYXMoMSk7IH0pXG4gICAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgICAsIEFDQ0VQVF9JVEVSQUJMRVMgICAgID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7IG5ldyBDKGl0ZXIpOyB9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgICAsIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKClcbiAgICAgICAgICAsIGluZGV4ICAgICA9IDU7XG4gICAgICAgIHdoaWxlKGluZGV4LS0pJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgICAgfSk7XG4gICAgaWYoIUFDQ0VQVF9JVEVSQUJMRVMpeyBcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UsIHRhcmdldCwgQyk7XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZihUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKXtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGludCl7XG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBmYWlscyAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHdrcyAgICAgID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBsZW5ndGgsIGV4ZWMpe1xuICB2YXIgU1lNQk9MICAgPSB3a3MoS0VZKVxuICAgICwgZm5zICAgICAgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSlcbiAgICAsIHN0cmZuICAgID0gZm5zWzBdXG4gICAgLCByeGZuICAgICA9IGZuc1sxXTtcbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uKHN0cmluZywgYXJnKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgICA9IGFuT2JqZWN0KHRoaXMpXG4gICAgLCByZXN1bHQgPSAnJztcbiAgaWYodGhhdC5nbG9iYWwpICAgICByZXN1bHQgKz0gJ2cnO1xuICBpZih0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmKHRoYXQubXVsdGlsaW5lKSAgcmVzdWx0ICs9ICdtJztcbiAgaWYodGhhdC51bmljb2RlKSAgICByZXN1bHQgKz0gJ3UnO1xuICBpZih0aGF0LnN0aWNreSkgICAgIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xuICB2YXIgUCwgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgaWYoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZil7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTsiLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pOyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0XG4gICwgJHRyaW0gICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKVxuICAgICwgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0OyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDsiLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59OyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpe1xuICB2YXIgUyAgICAgICAgICAgID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgLCBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aFxuICAgICwgZmlsbFN0ciAgICAgID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpXG4gICAgLCBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZihpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoXG4gICAgLCBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKXN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyOyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJzsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldzsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTsiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTsiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5sYXN0SW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gQFsqLTFdICovKXtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJG1hcCAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUoYUxlbiA+IGluZGV4KWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkc29tZSAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTsiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcblxudmFyIGx6ID0gZnVuY3Rpb24obnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZSgtNWUxMyAtIDEpLnRvSVNPU3RyaW5nKCkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgbmV3IERhdGUoTmFOKS50b0lTT1N0cmluZygpO1xufSkpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCl7XG4gICAgaWYoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gICAgdmFyIGQgPSB0aGlzXG4gICAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAgICwgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgICAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArXG4gICAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7IiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSlyZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7IiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufSIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIEhBU19JTlNUQU5DRSAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvICA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHt2YWx1ZTogZnVuY3Rpb24oTyl7XG4gIGlmKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pOyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbG9nMXAgICA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxuICAsIHNxcnQgICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU4gXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXNpbmggID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge2FzaW5oOiBhc2luaH0pOyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXRhbmggID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTsiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG4gICwgcG93ICAgICAgID0gTWF0aC5wb3dcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IE1hdGguYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7IiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTsiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGNvZiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGdPUEQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgJHRyaW0gICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCBOVU1CRVIgICAgICAgICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICAgICAgICAgPSBnbG9iYWxbTlVNQkVSXVxuICAsIEJhc2UgICAgICAgICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgICAgICAgID0gJE51bWJlci5wcm90b3R5cGVcbiAgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG4gICwgQlJPS0VOX0NPRiAgICAgICAgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSXG4gICwgVFJJTSAgICAgICAgICAgICAgPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihhcmd1bWVudCl7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKXtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKVxuICAgICAgLCB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSl7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZih0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMClyZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmKGZpcnN0ID09PSA0OCl7XG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspe1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZihjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSl7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWVcbiAgICAgICwgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24oKXsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKyl7XG4gICAgaWYoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSl7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59IiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge0VQU0lMT046IE1hdGgucG93KDIsIC01Mil9KTsiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKX0pOyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKVxuICAsIGFicyAgICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpe1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pOyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmZ9KTsiLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0ludGVnZXIgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXG4gICwgcmVwZWF0ICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgJHRvRml4ZWQgICAgID0gMS4udG9GaXhlZFxuICAsIGZsb29yICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBkYXRhICAgICAgICAgPSBbMCwgMCwgMCwgMCwgMCwgMF1cbiAgLCBFUlJPUiAgICAgICAgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISdcbiAgLCBaRVJPICAgICAgICAgPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uKG4sIGMpe1xuICB2YXIgaSAgPSAtMVxuICAgICwgYzIgPSBjO1xuICB3aGlsZSgrK2kgPCA2KXtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24obil7XG4gIHZhciBpID0gNlxuICAgICwgYyA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpID0gNlxuICAgICwgcyA9ICcnO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgaWYocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKXtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uKHgsIG4sIGFjYyl7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24oeCl7XG4gIHZhciBuICA9IDBcbiAgICAsIHgyID0geDtcbiAgd2hpbGUoeDIgPj0gNDA5Nil7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlKHgyID49IDIpe1xuICAgIG4gICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4udG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKXtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUilcbiAgICAgICwgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cylcbiAgICAgICwgcyA9ICcnXG4gICAgICAsIG0gPSBaRVJPXG4gICAgICAsIGUsIHosIGosIGs7XG4gICAgaWYoZiA8IDAgfHwgZiA+IDIwKXRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIGlmKHggIT0geClyZXR1cm4gJ05hTic7XG4gICAgaWYoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZih4IDwgMCl7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZih4ID4gMWUtMjEpe1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZihlID4gMCl7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUoaiA+PSA3KXtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZShqID49IDIzKXtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGYgPiAwKXtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pOyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uKCRpc0Zyb3plbil7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCByQXBwbHkgICAgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHlcbiAgLCBmQXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByQXBwbHkoZnVuY3Rpb24oKXt9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpXG4gICAgICAsIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTsiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7IiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpe1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7IiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7IiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7IiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpOyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTsiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTsiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7IiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7IiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIEVORFNfV0lUSCA9ICdlbmRzV2l0aCdcbiAgLCAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJ1xuICAsICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSClcbiAgICAgICwgaW5kZXggID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSlcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHR5cGVkICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGJ1ZmZlciAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICwgYW5PYmplY3QgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0luZGV4ICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIEFycmF5QnVmZmVyICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyXG4gICwgJERhdGFWaWV3ICAgID0gYnVmZmVyLkRhdGFWaWV3XG4gICwgJGlzVmlldyAgICAgID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgLCAkc2xpY2UgICAgICAgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlXG4gICwgVklFVyAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgLCBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge0FycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJ9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KXtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIGlmKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKXJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuICAgID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aFxuICAgICAgLCBmaXJzdCAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGZpbmFsICA9IHRvSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbilcbiAgICAgICwgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpXG4gICAgICAsIHZpZXdTICA9IG5ldyAkRGF0YVZpZXcodGhpcylcbiAgICAgICwgdmlld1QgID0gbmV3ICREYXRhVmlldyhyZXN1bHQpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgd2hpbGUoZmlyc3QgPCBmaW5hbCl7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvZiAgICAgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCl7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7c2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgbWljcm90YXNrICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgT0JTRVJWQUJMRSAgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oZm4pe1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZihjbGVhbnVwKXtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpe1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgICAgICA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpXG4gICAgICAsIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcbiAgICAgIGlmKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKWNsZWFudXAgPSBmdW5jdGlvbigpeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZihzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZihtKXJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmKCFtKXRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpe1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKXtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpe1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYobWV0aG9kKXtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICBpZihkb25lKXRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHtkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwXG4gICwgc3RvcmUgICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoe2RlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICB2YXIgdGFyZ2V0S2V5ICAgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pXG4gICAgLCBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpcmV0dXJuIGZhbHNlO1xuICBpZihtZXRhZGF0YU1hcC5zaXplKXJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59fSk7IiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7aGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHttZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpe1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn19KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBnZXRGbGFncyAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbihyZWdleHAsIHN0cmluZyl7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHt2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZighaXNSZWdFeHAocmVnZXhwKSl0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXG4gICAgICAsIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApXG4gICAgICAsIHJ4ICAgID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7Z2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKX0pOyIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDktMjJUMjI6MzBaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjEuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2csXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW1wbGUgc2VsZWN0b3IgdGhhdCBjYW4gYmUgZmlsdGVyZWQgZGlyZWN0bHksIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdH1cblxuXHQvLyBDb21wbGV4IHNlbGVjdG9yLCBjb21wYXJlIHRoZSB0d28gc2V0cywgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0XHRyZXNvbHZlLmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0ICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGksXG5cdFx0dmFsID0gMDtcblxuXHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0aWYgKCBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdGkgPSA0O1xuXG5cdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0fSBlbHNlIHtcblx0XHRpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbCxcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0dmFsID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdO1xuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiByYWYoKSB7XG5cdGlmICggdGltZXJJZCApIHtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKTtcblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZiBvciBpZiBkb2N1bWVudCBpcyBoaWRkZW5cblx0aWYgKCBqUXVlcnkuZngub2ZmIHx8IGRvY3VtZW50LmhpZGRlbiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgP1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICkgOlxuXHRcdFx0d2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGlmICggd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSggdGltZXJJZCApO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdH1cblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbiwgcmVjdCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBlbGVtZW50IGlzIG5vdCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpXG5cdFx0aWYgKCByZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0ICkge1xuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRNYXBFbnRyeTtcbiIsIi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTZXRFbnRyeTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlUb0FycmF5O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlXb3JkcztcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgfVxuICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xhbXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaXRlcmF0ZWUpIHtcbiAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZURpZmZlcmVuY2U7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICB2YWx1ZSA9IE9iamVjdCh2YWx1ZSk7XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gdmFsdWUpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eU9mO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJhbmRvbTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9fYmFzZVNsaWNlJyk7XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFNsaWNlO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwidmFyIGFkZE1hcEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkTWFwRW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZU1hcDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgY2FzdFNsaWNlID0gcmVxdWlyZSgnLi9fY2FzdFNsaWNlJyksXG4gICAgaGFzVW5pY29kZSA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGUnKSxcbiAgICBzdHJpbmdUb0FycmF5ID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9BcnJheScpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2FzZUZpcnN0O1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBkZWJ1cnIgPSByZXF1aXJlKCcuL2RlYnVycicpLFxuICAgIHdvcmRzID0gcmVxdWlyZSgnLi93b3JkcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbXBvdW5kZXI7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBiYXNlUHJvcGVydHlPZiA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eU9mJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyTGV0dGVyO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9IG5hdGl2ZUdldFN5bWJvbHMgPyBvdmVyQXJnKG5hdGl2ZUdldFN5bWJvbHMsIE9iamVjdCkgOiBzdHViQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG4iLCIvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZVdvcmQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVNYXAgPSByZXF1aXJlKCcuL19jbG9uZU1hcCcpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVNldCA9IHJlcXVpcmUoJy4vX2Nsb25lU2V0JyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGFzY2lpVG9BcnJheSA9IHJlcXVpcmUoJy4vX2FzY2lpVG9BcnJheScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVRvQXJyYXkgPSByZXF1aXJlKCcuL191bmljb2RlVG9BcnJheScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb0FycmF5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86KD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aClcXFxcYiknLFxuICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86KD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSClcXFxcYiknLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gIHJzT3JkVXBwZXIsXG4gIHJzT3JkTG93ZXIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVXb3JkcztcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICogLy8gPT4gWzEsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFjdDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGRlYnVyckxldHRlciA9IHJlcXVpcmUoJy4vX2RlYnVyckxldHRlcicpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1cnI7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi9fY3JlYXRlRmluZCcpLFxuICAgIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXMob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob3RoZXIsICdhJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBmaXJzdFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDFcbiAqXG4gKiBfLmhlYWQoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9pc1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluY2x1ZGVzO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9pc051bWJlcicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYU4oTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogaXNOYU4odW5kZWZpbmVkKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05hTjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05pbChudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05pbChOYU4pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOaWw7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gKiAvLyA9PiAnZm9vIGJhcidcbiAqXG4gKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gKiAvLyA9PiAnZm9vIGJhcidcbiAqXG4gKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb28gYmFyJ1xuICovXG52YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb3dlckNhc2U7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAqIEBzZWUgXy5tYXBLZXlzXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gKiB9O1xuICpcbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgYmFzZVJhbmRvbSA9IHJlcXVpcmUoJy4vX2Jhc2VSYW5kb20nKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC43LjBcbiAqIEBjYXRlZ29yeSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJhbmRvbSgwLCA1KTtcbiAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gKlxuICogXy5yYW5kb20oNSk7XG4gKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gKlxuICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAqXG4gKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvd2VyID0gMDtcbiAgICB1cHBlciA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICBsb3dlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgIH1cbiAgfVxuICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgbG93ZXIgPSB1cHBlcjtcbiAgICB1cHBlciA9IHRlbXA7XG4gIH1cbiAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgfVxuICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmRvbTtcbiIsInZhciBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpLFxuICAgIHVwcGVyRmlyc3QgPSByZXF1aXJlKCcuL3VwcGVyRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjEuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gKiAvLyA9PiAnRm9vIEJhcidcbiAqXG4gKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gKiAvLyA9PiAnRm9vIEJhcidcbiAqXG4gKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdGT08gQkFSJ1xuICovXG52YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhcnRDYXNlO1xuIiwidmFyIGJhc2VDbGFtcCA9IHJlcXVpcmUoJy4vX2Jhc2VDbGFtcCcpLFxuICAgIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBvc2l0aW9uID0gYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhcnRzV2l0aDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50YWlsKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBbMiwgM11cbiAqL1xuZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0YWlsO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG4iLCJ2YXIgY3JlYXRlQ2FzZUZpcnN0ID0gcmVxdWlyZSgnLi9fY3JlYXRlQ2FzZUZpcnN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVwcGVyRmlyc3Q7XG4iLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcbiIsInZhciBiYXNlRGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vX2Jhc2VEaWZmZXJlbmNlJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAqIEBleGFtcGxlXG4gKlxuICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gKiAvLyA9PiBbM11cbiAqL1xudmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgOiBbXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhvdXQ7XG4iLCJ2YXIgYXNjaWlXb3JkcyA9IHJlcXVpcmUoJy4vX2FzY2lpV29yZHMnKSxcbiAgICBoYXNVbmljb2RlV29yZCA9IHJlcXVpcmUoJy4vX2hhc1VuaWNvZGVXb3JkJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyksXG4gICAgdW5pY29kZVdvcmRzID0gcmVxdWlyZSgnLi9fdW5pY29kZVdvcmRzJyk7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdvcmRzO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24oKSB7XG4gIHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIHJvb3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IENvbnRlbnRRdWV1ZSBmcm9tICcuL2NvbnRlbnRRdWV1ZS9Db250ZW50UXVldWUnO1xuaW1wb3J0IExvYWRpbmdWaWV3IGZyb20gJy4vTG9hZGluZ1ZpZXcnO1xuaW1wb3J0IEFpcnBvcnRDb250cm9sbGVyIGZyb20gJy4vYWlycG9ydC9BaXJwb3J0Q29udHJvbGxlcic7XG5pbXBvcnQgR2FtZUNvbnRyb2xsZXIgZnJvbSAnLi9nYW1lL0dhbWVDb250cm9sbGVyJztcbmltcG9ydCBUdXRvcmlhbFZpZXcgZnJvbSAnLi90dXRvcmlhbC9UdXRvcmlhbFZpZXcnO1xuaW1wb3J0IElucHV0Q29udHJvbGxlciBmcm9tICcuL0lucHV0Q29udHJvbGxlcic7XG5pbXBvcnQgVWlDb250cm9sbGVyIGZyb20gJy4vVWlDb250cm9sbGVyJztcbmltcG9ydCBDYW52YXNDb250cm9sbGVyIGZyb20gJy4vY2FudmFzL0NhbnZhc0NvbnRyb2xsZXInO1xuaW1wb3J0IEdhbWVDbG9ja1ZpZXcgZnJvbSAnLi9nYW1lL0dhbWVDbG9ja1ZpZXcnO1xuaW1wb3J0IHsgc3BlZWNoX2luaXQgfSBmcm9tICcuL3NwZWVjaCc7XG5pbXBvcnQgeyB0aW1lLCBjYWxjdWxhdGVEZWx0YVRpbWUgfSBmcm9tICcuL3V0aWxpdGllcy90aW1lSGVscGVycyc7XG5pbXBvcnQgeyBMT0cgfSBmcm9tICcuL2NvbnN0YW50cy9sb2dMZXZlbCc7XG5cbndpbmRvdy56bHNhID0ge307XG53aW5kb3cuemxzYS5hdGMgPSB7fTtcbmNvbnN0IHByb3AgPSB7fTtcblxuLy8gSUlFRnMgYXJlIHB1bGxlZCBpbiBoZXJlIHRvIGFkZCBmdW5jdGlvbnMgdG8gdGhlIGdsb2JhbCBzcGFjZS5cbi8vXG4vLyBUaGlzIHdpbGwgbmVlZCB0byBiZSByZS13b3JrZWQsIGFuZCBjdXJyZW50IGdsb2JhbCBmdW5jdGlvbnMgc2hvdWxkIGJlIGV4cG9ydGVkIGFuZFxuLy8gaW1wb3J0ZWQgYXMgbmVlZGVkIGluIGVhY2ggZmlsZS5cbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzYXZlZCBhcyB0aGlzLnByb3AudmVyc2lvbiBhbmQgdGhpcy5wcm9wLnZlcnNpb25fc3RyaW5nXG5jb25zdCBWRVJTSU9OID0gWzMsIDIsIDBdO1xuXG4vLyBhcmUgeW91IHVzaW5nIGEgbWFpbiBsb29wPyAoeW91IG11c3QgY2FsbCB1cGRhdGUoKSBhZnRlcndhcmQgZGlzYWJsZS9yZS1lbmFibGUpXG5sZXQgVVBEQVRFID0gdHJ1ZTtcblxuLy8gdGhlIGZyYW1lcmF0ZSBpcyB1cGRhdGVkIHRoaXMgb2Z0ZW4gKHNlY29uZHMpXG5jb25zdCBGUkFNRV9ERUxBWSA9IDE7XG5cbi8vIGlzIHRoaXMgYSByZWxlYXNlIGJ1aWxkP1xuY29uc3QgUkVMRUFTRSA9IGZhbHNlO1xuXG4vKipcbiAqIEBjbGFzcyBBcHBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSAkZWxlbWVudCB7SFRNTCBFbGVtZW50fG51bGx9XG4gICAgICogQHBhcmFtIGFpcnBvcnRMb2FkTGlzdCB7YXJyYXk8b2JqZWN0Pn0gIExpc3Qgb2YgYWlycG9ydHMgdG8gbG9hZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGFpcnBvcnRMb2FkTGlzdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUm9vdCBET00gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5ICRlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtqUXVlcnl8SFRNTCBFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCBib2R5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgdGhpcy5sb2FkaW5nVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5haXJwb3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMudHV0b3JpYWxWaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnB1dENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnVpQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICAgICAgd2luZG93LnByb3AgPSBwcm9wO1xuXG4gICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgIHRoaXMucHJvcC5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3AudGVtcCA9ICdub3RoaW5nIGhlcmUnO1xuICAgICAgICB0aGlzLnByb3AudmVyc2lvbiA9IFZFUlNJT047XG4gICAgICAgIHRoaXMucHJvcC52ZXJzaW9uX3N0cmluZyA9IGB2JHtWRVJTSU9OLmpvaW4oJy4nKX1gO1xuICAgICAgICB0aGlzLnByb3AudGltZSA9IHt9O1xuICAgICAgICB0aGlzLnByb3AudGltZS5zdGFydCA9IHRpbWUoKTtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUuc3RhcnQgPSB0aW1lKCk7XG4gICAgICAgIHRoaXMucHJvcC50aW1lLmZyYW1lLmRlbGF5ID0gRlJBTUVfREVMQVk7XG4gICAgICAgIHRoaXMucHJvcC50aW1lLmZyYW1lLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUubGFzdCA9IHRpbWUoKTtcbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUuZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLnByb3AudGltZS5mcHMgPSAwO1xuICAgICAgICB0aGlzLnByb3AubG9nID0gTE9HLkRFQlVHO1xuICAgICAgICB0aGlzLnByb3AubG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKFJFTEVBU0UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcC5sb2cgPSBMT0cuV0FSTklORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwQ2hpbGRyZW4oYWlycG9ydExvYWRMaXN0KVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIG1ldGhvZC4gU2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2Ugb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIHNldHVwIHByb3BlcnRpZXMgYW5kIGluaXRpYWxpemUgZGVwZW5kYW50IGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBtZXRob2Qgc2V0dXBDaGlsZHJlblxuICAgICAqIEBwYXJhbSBhaXJwb3J0TG9hZExpc3Qge2FycmF5PG9iamVjdD59ICBMaXN0IG9mIGFpcnBvcnRzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBzZXR1cENoaWxkcmVuKGFpcnBvcnRMb2FkTGlzdCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdWaWV3ID0gbmV3IExvYWRpbmdWaWV3KCk7XG4gICAgICAgIHRoaXMuY29udGVudFF1ZXVlID0gbmV3IENvbnRlbnRRdWV1ZSh0aGlzLmxvYWRpbmdWaWV3KTtcbiAgICAgICAgdGhpcy5haXJwb3J0Q29udHJvbGxlciA9IG5ldyBBaXJwb3J0Q29udHJvbGxlcihhaXJwb3J0TG9hZExpc3QsIHRoaXMudXBkYXRlUnVuKTtcbiAgICAgICAgdGhpcy5nYW1lQ29udHJvbGxlciA9IG5ldyBHYW1lQ29udHJvbGxlcih0aGlzLmdldERlbHRhVGltZSk7XG4gICAgICAgIHRoaXMudHV0b3JpYWxWaWV3ID0gbmV3IFR1dG9yaWFsVmlldyh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgdGhpcy5pbnB1dENvbnRyb2xsZXIgPSBuZXcgSW5wdXRDb250cm9sbGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnVpQ29udHJvbGxlciA9IG5ldyBVaUNvbnRyb2xsZXIodGhpcy4kZWxlbWVudCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udHJvbGxlciA9IG5ldyBDYW52YXNDb250cm9sbGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICB0aGlzLmdhbWVDbG9ja1ZpZXcgPSBuZXcgR2FtZUNsb2NrVmlldyh0aGlzLiRlbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgbWV0aG9kLiBTaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gZmlyZSBvZmYgYGluaXRgIGFuZCBgaW5pdF9wcmVgIG1ldGhvZHMgYW5kIGFsc28gc3RhcnQgdGhlIGdhbWUgbG9vcFxuICAgICAqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgemxzYS5hdGMubG9hZEFzc2V0ID0gKG9wdGlvbnMpID0+IHRoaXMuY29udGVudFF1ZXVlLmFkZChvcHRpb25zKTtcbiAgICAgICAgLy8gVEVNUE9SQVJZIVxuICAgICAgICAvLyB0aGVzZSBpbnN0YW5jZXMgYXJlIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cgaGVyZSBhcyBhbiBpbnRlcm1lZGlhdGUgc3RlcCBhd2F5IGZyb20gZ2xvYmFsIGZ1bmN0aW9ucy5cbiAgICAgICAgLy8gdGhpcyBhbGxvd3MgZm9yIGFueSBtb2R1bGUgZmlsZSB0byBjYWxsIHdpbmRvdy57bW9kdWxlfS57bWV0aG9kfSBhbmQgd2lsbCBtYWtlIHRoZSB0cmFuc2l0aW9uIHRvXG4gICAgICAgIC8vIGV4cGxpY2l0IGluc3RhbmNlIHBhcmFtZXRlcnMgZWFzaWVyLlxuICAgICAgICB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIgPSB0aGlzLmFpcnBvcnRDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIgPSB0aGlzLmdhbWVDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cudHV0b3JpYWxWaWV3ID0gdGhpcy50dXRvcmlhbFZpZXc7XG4gICAgICAgIHdpbmRvdy5pbnB1dENvbnRyb2xsZXIgPSB0aGlzLmlucHV0Q29udHJvbGxlcjtcbiAgICAgICAgd2luZG93LnVpQ29udHJvbGxlciA9IHRoaXMudWlDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cuY2FudmFzQ29udHJvbGxlciA9IHRoaXMuY2FudmFzQ29udHJvbGxlcjtcblxuICAgICAgICBsb2coYFZlcnNpb24gJHt0aGlzLnByb3AudmVyc2lvbl9zdHJpbmd9YCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdF9wcmUoKVxuICAgICAgICAgICAgICAgICAgIC5pbml0KClcbiAgICAgICAgICAgICAgICAgICAuZG9uZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBkaXNhYmxlXG4gICAgICovXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlYXIgZG93biB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgZGlyZWN0bHksIG9ubHkgY2lhIGB0aGlzLmRpc2FibGUoKWBcbiAgICAgKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkaW5nVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWlycG9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmdhbWVDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50dXRvcmlhbFZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmlucHV0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMudWlDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXNDb250cm9sbGVyID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyA9PT0gQ0FMTEJBQ0tTIChhbGwgb3B0aW9uYWwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGRlZmluZWQpID09PVxuICAgIC8vIElOSVQ6XG4gICAgLy8gbW9kdWxlX2luaXRfcHJlKClcbiAgICAvLyBtb2R1bGVfaW5pdCgpXG4gICAgLy8gbW9kdWxlX2luaXRfcG9zdCgpXG5cbiAgICAvLyBtb2R1bGVfZG9uZSgpXG4gICAgLy8gLS0gd2FpdCB1bnRpbCBhbGwgYXN5bmMgaGFzIGZpbmlzaGVkIChjb3VsZCB0YWtlIGEgbG9uZyB0aW1lKVxuICAgIC8vIG1vZHVsZV9yZWFkeSgpXG4gICAgLy8gLS0gd2FpdCB1bnRpbCBmaXJzdCBmcmFtZSBpcyByZWFkeSAob25seSB0cmlnZ2VyZWQgaWYgVVBEQVRFID09IHRydWUpXG4gICAgLy8gbW9kdWxlX2NvbXBsZXRlKClcblxuICAgIC8vIFVQREFURTpcbiAgICAvLyBtb2R1bGVfdXBkYXRlX3ByZSgpXG4gICAgLy8gbW9kdWxlX3VwZGF0ZSgpXG4gICAgLy8gbW9kdWxlX3VwZGF0ZV9wb3N0KClcblxuICAgIC8vIFJFU0laRSAoY2FsbGVkIGF0IGxlYXN0IG9uY2UgZHVyaW5nIGluaXQgYW5kIHdoZW5ldmVyIHBhZ2UgY2hhbmdlcyBzaXplKVxuICAgIC8vIG1vZHVsZV9yZXNpemUoKVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIGluaXRfcHJlXG4gICAgICovXG4gICAgaW5pdF9wcmUoKSB7XG4gICAgICAgIHRoaXMudHV0b3JpYWxWaWV3LnR1dG9yaWFsX2luaXRfcHJlKCk7XG4gICAgICAgIHRoaXMuZ2FtZUNvbnRyb2xsZXIuaW5pdF9wcmUoKTtcbiAgICAgICAgdGhpcy5pbnB1dENvbnRyb2xsZXIuaW5wdXRfaW5pdF9wcmUoKTtcbiAgICAgICAgdGhpcy5haXJwb3J0Q29udHJvbGxlci5pbml0X3ByZSgpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRyb2xsZXIuY2FudmFzX2luaXRfcHJlKCk7XG4gICAgICAgIHRoaXMudWlDb250cm9sbGVyLnVpX2luaXRfcHJlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBzcGVlY2hfaW5pdCgpO1xuXG4gICAgICAgIHRoaXMuYWlycG9ydENvbnRyb2xsZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRyb2xsZXIuY2FudmFzX2luaXQoKTtcbiAgICAgICAgdGhpcy51aUNvbnRyb2xsZXIudWlfaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBpbml0X3Bvc3RcbiAgICAgKi9cbiAgICBpbml0X3Bvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBkb25lXG4gICAgICovXG4gICAgZG9uZSgpIHtcbiAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSh0aGlzLnJlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5wcm9wLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuXG4gICAgICAgIGlmIChVUERBVEUpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIHJlYWR5XG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuYWlycG9ydENvbnRyb2xsZXIucmVhZHkoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBtZXRob2QgcmVzaXplXG4gICAgICovXG4gICAgcmVzaXplKCkge1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRyb2xsZXIuY2FudmFzX3Jlc2l6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBjb21wbGV0ZVxuICAgICAqL1xuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmdhbWVDb250cm9sbGVyLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udHJvbGxlci5jYW52YXNfY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51aUNvbnRyb2xsZXIudWlfY29tcGxldGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBtZXRob2QgdXBkYXRlUHJlXG4gICAgICovXG4gICAgdXBkYXRlUHJlKCkge1xuICAgICAgICB0aGlzLmdhbWVDb250cm9sbGVyLnVwZGF0ZV9wcmUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBtZXRob2QgdXBkYXRlUG9zdFxuICAgICAqL1xuICAgIHVwZGF0ZVBvc3QoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udHJvbGxlci5jYW52YXNfdXBkYXRlX3Bvc3QoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFwcFxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nVmlldy5jb21wbGV0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLnByb3AuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFVUERBVEUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlKCkpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlUHJlKCk7XG4gICAgICAgIHRoaXMuYWlycG9ydENvbnRyb2xsZXIucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQb3N0KCk7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50RnJhbWUoKTtcbiAgICAgICAgdGhpcy5nYW1lQ2xvY2tWaWV3LnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXBwXG4gICAgICogQG1ldGhvZCBpbmNyZW1lbnRGcmFtZVxuICAgICAqL1xuICAgIGluY3JlbWVudEZyYW1lKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWUoKTtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5wcm9wLnRpbWUuZnJhbWUuc3RhcnQ7XG5cbiAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWVzICs9IDE7XG4gICAgICAgIHRoaXMucHJvcC50aW1lLmZyYW1lLmNvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKGVsYXBzZWQgPiB0aGlzLnByb3AudGltZS5mcmFtZS5kZWxheSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnBzID0gdGhpcy5wcm9wLnRpbWUuZnJhbWUuY291bnQgLyBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wcm9wLnRpbWUuZnJhbWUuc3RhcnQgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvcC50aW1lLmZyYW1lLmRlbHRhID0gY2FsY3VsYXRlRGVsdGFUaW1lKHRoaXMucHJvcC50aW1lLmZyYW1lLmxhc3QpO1xuICAgICAgICB0aGlzLnByb3AudGltZS5mcmFtZS5sYXN0ID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIGdldERlbHRhVGltZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXREZWx0YVRpbWUgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3AudGltZS5mcmFtZS5kZWx0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZvciBBcHBcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVJ1blxuICAgICAqIEBwYXJhbSBzaG91bGRVcGRhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdXBkYXRlUnVuID0gKHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3VwZGF0ZVJ1bjogJywgc2hvdWxkVXBkYXRlKTtcbiAgICAgICAgaWYgKCFVUERBVEUgJiYgc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy51cGRhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBVUERBVEUgPSBzaG91bGRVcGRhdGU7XG4gICAgfTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tbWl4ZWQtb3BlcmF0b3JzLCBvYmplY3Qtc2hvcnRoYW5kLCBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCBuby11bmRlZiwgZXhwZWN0ZWQtcmV0dXJuKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgQ29tbWFuZFBhcnNlciBmcm9tICcuL2NvbW1hbmRQYXJzZXIvQ29tbWFuZFBhcnNlcic7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vbWF0aC9jb3JlJztcbmltcG9ydCB7IEdBTUVfT1BUSU9OX05BTUVTIH0gZnJvbSAnLi9jb25zdGFudHMvZ2FtZU9wdGlvbkNvbnN0YW50cyc7XG5pbXBvcnQgeyBTRUxFQ1RPUlMgfSBmcm9tICcuL2NvbnN0YW50cy9zZWxlY3RvcnMnO1xuXG4vLyBUZW1wb3JhcnkgY29uc3QgZGVjbGFyYXRpb24gaGVyZSB0byBhdHRhY2ggdG8gdGhlIHdpbmRvdyBBTkQgdXNlIGFzIGludGVybmFsIHByb3BlcnRcbmNvbnN0IGlucHV0ID0ge307XG5cbi8qKlxuICogTmFtZSBvZiBhIGNvbW1hbmQgcmV0dXJuZWQgZnJvbSB0aGUgUGFyc2VyXG4gKlxuICogQHByb3BlcnR5IFBBUlNFRF9DT01NQU5EX05BTUVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgUEFSU0VEX0NPTU1BTkRfTkFNRSA9IHtcbiAgICBWRVJTSU9OOiAndmVyc2lvbicsXG4gICAgVFVUT1JJQUw6ICd0dXRvcmlhbCcsXG4gICAgQVVUTzogJ2F1dG8nLFxuICAgIFBBVVNFOiAncGF1c2UnLFxuICAgIFRJTUVXQVJQOiAndGltZXdhcnAnLFxuICAgIENMRUFSOiAnY2xlYXInLFxuICAgIEFJUlBPUlQ6ICdhaXJwb3J0JyxcbiAgICBSQVRFOiAncmF0ZScsXG4gICAgVFJBTlNNSVQ6ICd0cmFuc21pdCdcbn07XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgbW91c2UgZXZlbnRzIHJldHVybmVkIGZyb20gJGV2ZW50LndoaWNoXG4gKlxuICogVGhlc2UgY29kZXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGpRdWVyeSBldmVudCBvYmplY3QuXG4gKlxuICogQHByb3BlcnR5IE1PVVNFX0VWRU5UX0NPREVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgTU9VU0VfRVZFTlRfQ09ERSA9IHtcbiAgICBMRUZUX1BSRVNTOiAxLFxuICAgIE1JRERMRV9QRVNTOiAyLFxuICAgIFJJR0hUX1BSRVNTOiAzXG59O1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIGtleSBjb2RlcyB1c2VkIGZvciBpbnB1dHMuXG4gKlxuICogQHByb3BlcnR5IEtFWV9DT0RFU1xuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBLRVlfQ09ERVMgPSB7XG4gICAgLy8gK1xuICAgIEFERDogMTA3LFxuICAgIC8vIC1cbiAgICBEQVNIOiAxODksXG4gICAgREFTSF9GSVJFRk9YOiAxNzMsXG4gICAgRElWSURFOiAxMTEsXG4gICAgRE9XTl9BUlJPVzogNDAsXG4gICAgRU5URVI6IDEzLFxuICAgIC8vID1cbiAgICBFUVVBTFM6IDE4NyxcbiAgICBFUVVBTFNfRklSRUZPWDogNjEsXG4gICAgLy8gZXNjXG4gICAgRVNDQVBFOiAyNyxcbiAgICBMRUZUX0FSUk9XOiAzNyxcbiAgICBNVUxUSVBMWTogMTA2LFxuICAgIFBBR0VfVVA6IDMzLFxuICAgIFBBR0VfRE9XTjogMzQsXG4gICAgUklHSFRfQVJST1c6IDM5LFxuICAgIFNVQlRSQUNUOiAxMDksXG4gICAgVEFCOiA5LFxuICAgIFVQX0FSUk9XOiAzOCxcbiAgICAvLyBgXG4gICAgQkFUX1RJQ0s6IDE5MlxufTtcblxuLyoqXG4gKiBAY2xhc3MgSW5wdXRDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0Q29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoJGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgICAgICB0aGlzLiR3aW5kb3cgPSBudWxsO1xuICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLiRjYW52YXNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHNpZGViYXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5pbnB1dC5jb21tYW5kID0gJyc7XG4gICAgICAgIHRoaXMuaW5wdXQuY2FsbHNpZ24gPSAnJztcbiAgICAgICAgdGhpcy5pbnB1dC5kYXRhID0gJyc7XG4gICAgICAgIHRoaXMuaW5wdXQuaGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0Lmhpc3RvcnlfaXRlbSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXQuY2xpY2sgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuaW5wdXQucG9zaXRpb25zID0gJyc7XG4gICAgICAgIHRoaXMuaW5wdXQudGFiX2NvbXBsID0ge307XG4gICAgICAgIHRoaXMuaW5wdXQubW91c2VEZWx0YSA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5pbnB1dC5tb3VzZURvd24gPSBbMCwgMF07XG4gICAgICAgIHRoaXMuaW5wdXQuaXNNb3VzZURvd24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9pbml0KClcbiAgICAgICAgICAgIC5zZXR1cEhhbmRsZXJzKClcbiAgICAgICAgICAgIC5lbmFibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuQ09NTUFORCk7XG4gICAgICAgIHRoaXMuJGNhbnZhc2VzID0gdGhpcy4kZWxlbWVudC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkNBTlZBU0VTKTtcbiAgICAgICAgdGhpcy4kc2lkZWJhciA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5TSURFQkFSKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2Qgc2V0dXBIYW5kbGVyc1xuICAgICAqL1xuICAgIHNldHVwSGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBlbmFibGVcbiAgICAgKi9cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuJHdpbmRvdy5vbigna2V5ZG93bicsIChldmVudCkgPT4gdGhpcy5vbktleWRvd25IYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC5vbigna2V5ZG93bicsIChldmVudCkgPT4gdGhpcy5vbkNvbW1hbmRJbnB1dEtleWRvd25IYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC5vbignaW5wdXQnLCAoZXZlbnQpID0+IHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIC8vIEZJWE1FOiB0aGVzZSBhcmUgbm9uLXN0YW5kYXJkIGV2ZW50cyBhbmQgd2lsbCBiZSBkZXByZWNhdGVkIHNvb24uIHRoaXMgc2hvdWxkIGJlIG1vdmVkXG4gICAgICAgIC8vIG92ZXIgdG8gdGhlIGB3aGVlbGAgZXZlbnQuIFRoaXMgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3ZlciB0byBgLm9uKClgIGluc3RlYWQgb2YgYC5iaW5kKClgXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbFxuICAgICAgICAvLyB0aGlzLiRjb21tYW5kSW5wdXQub24oJ0RPTU1vdXNlU2Nyb2xsIG1vdXNld2hlZWwnLCAoZXZlbnQpID0+IHRoaXMub25Nb3VzZVNjcm9sbEhhbmRsZXIoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kY2FudmFzZXMuYmluZCgnRE9NTW91c2VTY3JvbGwgbW91c2V3aGVlbCcsIChldmVudCkgPT4gdGhpcy5vbk1vdXNlU2Nyb2xsSGFuZGxlcihldmVudCkpO1xuICAgICAgICB0aGlzLiRjYW52YXNlcy5vbignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB0aGlzLm9uTW91c2VNb3ZlSGFuZGxlcihldmVudCkpO1xuICAgICAgICB0aGlzLiRjYW52YXNlcy5vbignbW91c2V1cCcsIChldmVudCkgPT4gdGhpcy5vbk1vdXNlVXBIYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGNhbnZhc2VzLm9uKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+IHRoaXMub25Nb3VzZURvd25IYW5kbGVyKGV2ZW50KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGRpc2FibGVcbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLiR3aW5kb3cub2ZmKCdrZXlkb3duJywgKGV2ZW50KSA9PiB0aGlzLm9uS2V5ZG93bkhhbmRsZXIoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kY29tbWFuZElucHV0Lm9mZigna2V5ZG93bicsIChldmVudCkgPT4gdGhpcy5vbkNvbW1hbmRJbnB1dEtleWRvd25IYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC5vZmYoJ2lucHV0JywgKGV2ZW50KSA9PiB0aGlzLm9uQ29tbWFuZElucHV0Q2hhbmdlSGFuZGxlcihldmVudCkpO1xuICAgICAgICAvLyB1bmNvbW1lbnQgb25seSBhZnRlciBgLm9uKClgIGZvciB0aGlzIGV2ZW50IGhhcyBiZWVuIGltcGxlbWVudGVkLlxuICAgICAgICAvLyB0aGlzLiRjb21tYW5kSW5wdXQub2ZmKCdET01Nb3VzZVNjcm9sbCBtb3VzZXdoZWVsJywgKGV2ZW50KSA9PiB0aGlzLm9uTW91c2VTY3JvbGxIYW5kbGVyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGNhbnZhc2VzLm9mZignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB0aGlzLm9uTW91c2VNb3ZlSGFuZGxlcihldmVudCkpO1xuICAgICAgICB0aGlzLiRjYW52YXNlcy5vZmYoJ21vdXNldXAnLCAoZXZlbnQpID0+IHRoaXMub25Nb3VzZVVwSGFuZGxlcihldmVudCkpO1xuICAgICAgICB0aGlzLiRjYW52YXNlcy5vZmYoJ21vdXNlZG93bicsIChldmVudCkgPT4gdGhpcy5vbk1vdXNlRG93bkhhbmRsZXIoZXZlbnQpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kd2luZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kY29tbWFuZElucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kY2FudmFzZXMgPSBudWxsO1xuICAgICAgICB0aGlzLiRzaWRlYmFyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuY29tbWFuZCA9ICcnO1xuICAgICAgICB0aGlzLmlucHV0LmNhbGxzaWduID0gJyc7XG4gICAgICAgIC8vIHRoaXMuaW5wdXQuZGF0YSA9ICcnO1xuICAgICAgICB0aGlzLmlucHV0Lmhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dC5oaXN0b3J5X2l0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmlucHV0LmNsaWNrID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmlucHV0LnBvc2l0aW9ucyA9ICcnO1xuICAgICAgICB0aGlzLmlucHV0LnRhYl9jb21wbCA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0Lm1vdXNlRGVsdGEgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuaW5wdXQubW91c2VEb3duID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmlucHV0LmlzTW91c2VEb3duID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGlucHV0X2luaXRfcHJlXG4gICAgICovXG4gICAgaW5wdXRfaW5pdF9wcmUoKSB7XG4gICAgICAgIC8vIFRPRE86IHRoZXNlIHByb3AgcHJvcGVydGllcyBjYW4gYmUgcmVtb3ZlZCBleGNlcHQgZm9yIGBwcm9wLmlucHV0YFxuICAgICAgICBwcm9wLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHByb3AuaW5wdXQuY29tbWFuZCA9ICcnO1xuICAgICAgICBwcm9wLmlucHV0LmNhbGxzaWduID0gJyc7XG4gICAgICAgIHByb3AuaW5wdXQuZGF0YSA9ICcnO1xuICAgICAgICBwcm9wLmlucHV0Lmhpc3RvcnkgPSBbXTtcbiAgICAgICAgcHJvcC5pbnB1dC5oaXN0b3J5X2l0ZW0gPSBudWxsO1xuICAgICAgICBwcm9wLmlucHV0LmNsaWNrID0gWzAsIDBdO1xuICAgICAgICBwcm9wLmlucHV0LnBvc2l0aW9ucyA9ICcnO1xuICAgICAgICBwcm9wLmlucHV0LnRhYl9jb21wbCA9IHt9O1xuICAgICAgICBwcm9wLmlucHV0Lm1vdXNlRGVsdGEgPSBbMCwgMF07XG4gICAgICAgIHByb3AuaW5wdXQubW91c2VEb3duID0gWzAsIDBdO1xuICAgICAgICBwcm9wLmlucHV0LmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIG9uTW91c2VTY3JvbGxIYW5kbGVyXG4gICAgICogQHBhcmFtIGV2ZW50IHtqcXVlcnkgRXZlbnR9XG4gICAgICovXG4gICAgb25Nb3VzZVNjcm9sbEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSA+IDAgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5kZXRhaWwgPCAwKSB7XG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX3pvb21faW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfem9vbV9vdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBvbk1vdXNlTW92ZUhhbmRsZXJcbiAgICAgKiBAcGFyYW0gZXZlbnQge2pxdWVyeSBFdmVudH1cbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFwcm9wLmlucHV0LmlzTW91c2VEb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AuaW5wdXQubW91c2VEZWx0YSA9IFtcbiAgICAgICAgICAgIGV2ZW50LnBhZ2VYIC0gcHJvcC5pbnB1dC5tb3VzZURvd25bMF0sXG4gICAgICAgICAgICBldmVudC5wYWdlWSAtIHByb3AuaW5wdXQubW91c2VEb3duWzFdXG4gICAgICAgIF07XG4gICAgICAgIHByb3AuY2FudmFzLnBhblggPSBwcm9wLmlucHV0Lm1vdXNlRGVsdGFbMF07XG4gICAgICAgIHByb3AuY2FudmFzLnBhblkgPSBwcm9wLmlucHV0Lm1vdXNlRGVsdGFbMV07XG4gICAgICAgIHByb3AuY2FudmFzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2Qgb25Nb3VzZVVwSGFuZGxlclxuICAgICAqIEBwYXJhbSBldmVudCB7anF1ZXJ5IEV2ZW50fVxuICAgICAqL1xuICAgIG9uTW91c2VVcEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgcHJvcC5pbnB1dC5pc01vdXNlRG93biA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBvbk1vdXNlRG93bkhhbmRsZXJcbiAgICAgKiBAcGFyYW0gZXZlbnQge2pxdWVyeSBFdmVudH1cbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IE1PVVNFX0VWRU5UX0NPREUuTUlERExFX1BFU1MpIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfem9vbV9yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSBNT1VTRV9FVkVOVF9DT0RFLkxFRlRfUFJFU1MpIHtcbiAgICAgICAgICAgIC8vIFJlY29yZCBtb3VzZSBkb3duIHBvc2l0aW9uIGZvciBwYW5uaW5nXG4gICAgICAgICAgICBwcm9wLmlucHV0Lm1vdXNlRG93biA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5wYWdlWCAtIHByb3AuY2FudmFzLnBhblgsXG4gICAgICAgICAgICAgICAgZXZlbnQucGFnZVkgLSBwcm9wLmNhbnZhcy5wYW5ZXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcHJvcC5pbnB1dC5pc01vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEFpcmNyYWZ0IGxhYmVsIHNlbGVjdGlvblxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gW2V2ZW50LnBhZ2VYLCAtZXZlbnQucGFnZVldO1xuICAgICAgICAgICAgcG9zaXRpb25bMF0gLT0gcHJvcC5jYW52YXMuc2l6ZS53aWR0aCAvIDI7XG4gICAgICAgICAgICBwb3NpdGlvblsxXSArPSBwcm9wLmNhbnZhcy5zaXplLmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IG5lYXJlc3QgPSB3aW5kb3cuYWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0X2dldF9uZWFyZXN0KFtcbiAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnB4X3RvX2ttKHBvc2l0aW9uWzBdIC0gcHJvcC5jYW52YXMucGFuWCksXG4gICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5weF90b19rbShwb3NpdGlvblsxXSArIHByb3AuY2FudmFzLnBhblkpXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgaWYgKG5lYXJlc3RbMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdFsxXSA8IHdpbmRvdy51aUNvbnRyb2xsZXIucHhfdG9fa20oODApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY2FsbHNpZ24gPSBuZWFyZXN0WzBdLmdldENhbGxzaWduKCkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0X3NlbGVjdCh0aGlzLmlucHV0LmNhbGxzaWduKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0X3NlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24gPSBbXG4gICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5weF90b19rbShwb3NpdGlvblswXSksXG4gICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5weF90b19rbShwb3NpdGlvblsxXSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHBvc2l0aW9uWzBdID0gcGFyc2VGbG9hdChwb3NpdGlvblswXS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgIHBvc2l0aW9uWzFdID0gcGFyc2VGbG9hdChwb3NpdGlvblsxXS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgIHByb3AuaW5wdXQucG9zaXRpb25zICs9IGBbJHtwb3NpdGlvbi5qb2luKCcsJyl9XWA7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBvbktleWRvd25IYW5kbGVyXG4gICAgICogQHBhcmFtIGV2ZW50IHtqUXVlcnkgRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbktleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIC8vIEZvciBmaXJlZm94IHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZVxuICAgICAgICBjb25zdCBpc19maXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xO1xuXG4gICAgICAgIGlmICghd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfcGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBLRVlfQ09ERVMuRVNDQVBFKSB7XG4gICAgICAgICAgICBpZiAocHJvcC50dXRvcmlhbC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnR1dG9yaWFsVmlldy50dXRvcmlhbF9jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkFJUlBPUlRfU1dJVENIKS5oYXNDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5PUEVOKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfYWlycG9ydF9jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBLRVlfQ09ERVMuREFTSCB8fCAoaXNfZmlyZWZveCAmJiBldmVudC53aGljaCA9PT0gS0VZX0NPREVTLkRBU0hfRklSRUZPWCkpIHtcbiAgICAgICAgICAgIC8vIE1pbnVzIGtleSB0byB6b29tIG91dCwgcGx1cyB0byB6b29tIGluXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX3pvb21fb3V0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IEtFWV9DT0RFUy5FUVVBTFMgfHwgKGlzX2ZpcmVmb3ggJiYgZXZlbnQud2hpY2ggPT09IEtFWV9DT0RFUy5FUVVBTFNfRklSRUZPWCkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfem9vbV9pbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX3pvb21fcmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wLnR1dG9yaWFsLm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gS0VZX0NPREVTLlBBR0VfVVApIHtcbiAgICAgICAgICAgIHdpbmRvdy50dXRvcmlhbFZpZXcudHV0b3JpYWxfcHJldigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gS0VZX0NPREVTLlBBR0VfRE9XTikge1xuICAgICAgICAgICAgd2luZG93LnR1dG9yaWFsVmlldy50dXRvcmlhbF9uZXh0KCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGlucHV0X3BhcnNlXG4gICAgICovXG4gICAgaW5wdXRfcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0ICRzdHJpcCA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5TVFJJUCk7XG4gICAgICAgICRzdHJpcC5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuXG4gICAgICAgIHByb3AuaW5wdXQuY2FsbHNpZ24gPSAnJztcbiAgICAgICAgcHJvcC5pbnB1dC5kYXRhID0gJyc7XG5cbiAgICAgICAgaWYgKHByb3AuaW5wdXQuY29tbWFuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IG1vdmUgdG8gbWFzdGVyIFJFR0VYIGNvbnN0YW50XG4gICAgICAgIGxldCBtYXRjaCA9IC9eXFxzKihcXHcrKS8uZXhlYyhwcm9wLmlucHV0LmNvbW1hbmQpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AuaW5wdXQuY2FsbHNpZ24gPSBtYXRjaFsxXTtcbiAgICAgICAgbGV0IG51bWJlciA9IDA7XG4gICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgdmVyeSBtdXRhYmxlIHByb3BlcnR5LiBwZXJoYXBzIGl0IHNob3VsZCBiZSBzb21ldGhpbmcgZWxzZT9cbiAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICBwcm9wLmNhbnZhcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFpcmNyYWZ0ID0gcHJvcC5haXJjcmFmdC5saXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAoYWlyY3JhZnQubWF0Y2hDYWxsc2lnbihwcm9wLmlucHV0LmNhbGxzaWduKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gYWlyY3JhZnQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgZnJvbSBhbiBlbmNhcHN1bGF0ZWQgY2xhc3Mgb24gdGhlIHdpbmRvdy5cbiAgICAgICAgICAgICAgICBhaXJjcmFmdC4kaHRtbC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBsb2dpYyBibG9jayBzaG91bGQgYmUgZWl0aGVyIGFic3RyYWN0ZWQgb3Igc2ltcGxpZmllZC5cbiAgICAgICAgaWYgKG51bWJlciA9PT0gMSAmJiAoXG4gICAgICAgICAgICAgICAgbWF0Y2guJGh0bWwub2Zmc2V0KCkudG9wIDwgMCB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoLiRodG1sLm9mZnNldCgpLnRvcCArIG1hdGNoLiRodG1sLmhlaWdodCgpIC0gdGhpcy4kc2lkZWJhci5vZmZzZXQoKS50b3ApID5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2lkZWJhci5oZWlnaHQoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLiRzaWRlYmFyLnNjcm9sbFRvcCh0aGlzLiRzaWRlYmFyLnNjcm9sbFRvcCgpICsgbWF0Y2guJGh0bWwub2Zmc2V0KCkudG9wIC0gKHRoaXMuJHNpZGViYXIuaGVpZ2h0KCkgLyAyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2Qgb25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyXG4gICAgICovXG4gICAgb25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnRhYl9jb21wbGV0aW9uX3Jlc2V0KCk7XG5cbiAgICAgICAgcHJvcC5pbnB1dC5jb21tYW5kID0gdGhpcy4kY29tbWFuZElucHV0LnZhbCgpO1xuXG4gICAgICAgIHRoaXMuaW5wdXRfcGFyc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaW5wdXRfc2VsZWN0XG4gICAgICogQHBhcmFtIGNhbGxzaWduIHtzdHJpbmd9XG4gICAgICovXG4gICAgaW5wdXRfc2VsZWN0KGNhbGxzaWduKSB7XG4gICAgICAgIGlmIChjYWxsc2lnbikge1xuICAgICAgICAgICAgdGhpcy4kY29tbWFuZElucHV0LnZhbChgJHtjYWxsc2lnbn0gYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIG9uQ29tbWFuZElucHV0S2V5ZG93bkhhbmRsZXJcbiAgICAgKi9cbiAgICBvbkNvbW1hbmRJbnB1dEtleWRvd25IYW5kbGVyKGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1hbmRJbnB1dFZhbHVlID0gdGhpcy4kY29tbWFuZElucHV0LnZhbCgpO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgc3d0aWNoIGNhbiBiZSBzaW1wbGlmaWVkLCB0aGVyZSBpcyBhIGxvdCBvZiByZXBldGl0aW9uIGhlcmVcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFUy5CQVRfVElDSzpcbiAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKGAke2N1cnJlbnRDb21tYW5kSW5wdXRWYWx1ZX1cXGAgYCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLkVOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRfcGFyc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0X3J1bigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AuaW5wdXQuaGlzdG9yeS51bnNoaWZ0KHByb3AuaW5wdXQuY2FsbHNpZ24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcC5pbnB1dC5jb21tYW5kID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJfY29tcGxldGlvbl9yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0X3BhcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcC5pbnB1dC5oaXN0b3J5X2l0ZW0gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlBBR0VfVVA6XG4gICAgICAgICAgICAgICAgLy8gcmVjYWxsIHByZXZpb3VzIGNhbGxzaWduXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dF9oaXN0b3J5X3ByZXYoKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlBBR0VfRE9XTjpcbiAgICAgICAgICAgICAgICAvLyByZWNhbGwgc3Vic2VxdWVudCBjYWxsc2lnblxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRfaGlzdG9yeV9uZXh0KCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFUy5MRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIC8vIHNob3J0S2V5cyBpbiB1c2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBcnJvd0NvbnRyb2xNZXRob2QoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKGAke2N1cnJlbnRDb21tYW5kSW5wdXRWYWx1ZX0gdCBsIGApO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0Fycm93Q29udHJvbE1ldGhvZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoYCR7Y3VycmVudENvbW1hbmRJbnB1dFZhbHVlfSBcXHUyQjYxIGApO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjYWxsIHByZXZpb3VzIGNhbGxzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRfaGlzdG9yeV9wcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIC8vIHNob3J0S2V5cyBpbiB1c2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBcnJvd0NvbnRyb2xNZXRob2QoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKGAke2N1cnJlbnRDb21tYW5kSW5wdXRWYWx1ZX0gdCByIGApO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLkRPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQXJyb3dDb250cm9sTWV0aG9kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29tbWFuZElucHV0LnZhbChgJHtjdXJyZW50Q29tbWFuZElucHV0VmFsdWV9IFxcdTJCNjMgYCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbW1hbmRJbnB1dENoYW5nZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNhbGwgcHJldmlvdXMgY2FsbHNpZ25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF9oaXN0b3J5X3ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFUy5NVUxUSVBMWTpcbiAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKGAke2N1cnJlbnRDb21tYW5kSW5wdXRWYWx1ZX0gXFx1MkI1MCBgKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbW1hbmRJbnB1dENoYW5nZUhhbmRsZXIoKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFUy5BREQ6XG4gICAgICAgICAgICAgICAgdGhpcy4kY29tbWFuZElucHV0LnZhbChgJHtjdXJyZW50Q29tbWFuZElucHV0VmFsdWV9ICsgYCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERVMuRVFVQUxTOiAvLyBtYWMgKyAoYWN0dWFsbHkgYD1gKVxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoYCR7Y3VycmVudENvbW1hbmRJbnB1dFZhbHVlfSArIGApO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWFuZElucHV0Q2hhbmdlSGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlNVQlRSQUNUOlxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoYCR7Y3VycmVudENvbW1hbmRJbnB1dFZhbHVlfSAtIGApO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWFuZElucHV0Q2hhbmdlSGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLkRBU0g6IC8vIG1hYyAtXG4gICAgICAgICAgICAgICAgdGhpcy4kY29tbWFuZElucHV0LnZhbChgJHtjdXJyZW50Q29tbWFuZElucHV0VmFsdWV9IC0gYCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERVMuRElWSURFOlxuICAgICAgICAgICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoYCR7Y3VycmVudENvbW1hbmRJbnB1dFZhbHVlfSB0YWtlb2ZmIGApO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWFuZElucHV0Q2hhbmdlSGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLlRBQjpcbiAgICAgICAgICAgICAgICBpZiAoIXByb3AuaW5wdXQudGFiX2NvbXBsLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJfY29tcGxldGlvbl9tYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudGFiX2NvbXBsZXRpb25fY3ljbGUoeyBiYWNrd2FyZHM6IGUuc2hpZnRLZXkgfSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREVTLkVTQ0FQRTpcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29tbWFuZFZhbHVlID0gdGhpcy4kY29tbWFuZElucHV0LnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgY29tbWFuZElucHV0IHZhbHVlIGNvbnRhaW5zIGEgY2FsbHNpZ24gYW5kIGNvbW1hbmRzLCBvbmx5IGNsZWFyIHRoZSBjb21tYW5kc1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29tbWFuZFZhbHVlLnRyaW0oKSAhPT0gdGhpcy5pbnB1dC5jYWxsc2lnbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKGAke3RoaXMuaW5wdXQuY2FsbHNpZ259IGApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKCcnKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB0YWJfY29tcGxldGlvbl9jeWNsZVxuICAgICAqIEBwYXJhbSBvcHRcbiAgICAgKi9cbiAgICB0YWJfY29tcGxldGlvbl9jeWNsZShvcHQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHByb3AuaW5wdXQudGFiX2NvbXBsLm1hdGNoZXM7XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGJsb2NrIG5lZWRzIHNvbWUgd29yay4gdGhpcyBpbml0aWFsIGFzc2lnbm1lbnQgbG9va3MgdG8gYmUgb3ZlcndyaXR0ZW4gZXZlcnkgdGltZS5cbiAgICAgICAgbGV0IGkgPSBwcm9wLmlucHV0LnRhYl9jb21wbC5jeWNsZV9pdGVtO1xuICAgICAgICBpZiAob3B0LmJhY2t3YXJkcykge1xuICAgICAgICAgICAgaSA9IChpIDw9IDApID8gbWF0Y2hlcy5sZW5ndGggLSAxIDogaSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpID0gKGkgPj0gbWF0Y2hlcy5sZW5ndGggLSAxKSA/IDAgOiBpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoYCR7bWF0Y2hlc1tpXX0gYCk7XG5cbiAgICAgICAgcHJvcC5pbnB1dC5jb21tYW5kID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgcHJvcC5pbnB1dC50YWJfY29tcGwuY3ljbGVfaXRlbSA9IGk7XG5cbiAgICAgICAgdGhpcy5pbnB1dF9wYXJzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB0YWJfY29tcGxldGlvbl9tYXRjaFxuICAgICAqL1xuICAgIHRhYl9jb21wbGV0aW9uX21hdGNoKCkge1xuICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy4kY29tbWFuZElucHV0LnZhbCgpO1xuICAgICAgICBsZXQgYWlyY3JhZnRzID0gcHJvcC5haXJjcmFmdC5saXN0O1xuXG4gICAgICAgIGlmIChwcm9wLmlucHV0LmNhbGxzaWduKSB7XG4gICAgICAgICAgICBhaXJjcmFmdHMgPSBhaXJjcmFmdHMuZmlsdGVyKChhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubWF0Y2hDYWxsc2lnbihwcm9wLmlucHV0LmNhbGxzaWduKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hlcyA9IF9tYXAoYWlyY3JhZnRzLCAoYWlyY3JhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhaXJjcmFmdC5nZXRDYWxsc2lnbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYWlyY3JhZnRzLmxlbmd0aCA9PT0gMSAmJiAocHJvcC5pbnB1dC5kYXRhIHx8IHZhbFt2YWwubGVuZ3RoIC0gMV0gPT09ICcgJykpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHVwZGF0ZSBpbmxpbmUgZnVuY3Rpb25zXG4gICAgICAgICAgICBtYXRjaGVzID0gYWlyY3JhZnRzWzBdLkNPTU1BTkRTLmZpbHRlcigoYykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9wLmlucHV0LmRhdGEudG9Mb3dlckNhc2UoKSkgPT09IDA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwuc3Vic3RyaW5nKDAsIHByb3AuaW5wdXQuY2FsbHNpZ24ubGVuZ3RoICsgMSkgKyBjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhYl9jb21wbGV0aW9uX3Jlc2V0KCk7XG5cbiAgICAgICAgcHJvcC5pbnB1dC50YWJfY29tcGwubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgICAgIHByb3AuaW5wdXQudGFiX2NvbXBsLmN5Y2xlX2l0ZW0gPSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgdGFiX2NvbXBsZXRpb25fcmVzZXRcbiAgICAgKi9cbiAgICB0YWJfY29tcGxldGlvbl9yZXNldCgpIHtcbiAgICAgICAgcHJvcC5pbnB1dC50YWJfY29tcGwgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaW5wdXRfaGlzdG9yeV9jbGFtcFxuICAgICAqL1xuICAgIGlucHV0X2hpc3RvcnlfY2xhbXAoKSB7XG4gICAgICAgIHByb3AuaW5wdXQuaGlzdG9yeV9pdGVtID0gY2xhbXAoMCwgcHJvcC5pbnB1dC5oaXN0b3J5X2l0ZW0sIHByb3AuaW5wdXQuaGlzdG9yeS5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaW5wdXRfaGlzdG9yeV9wcmV2XG4gICAgICovXG4gICAgaW5wdXRfaGlzdG9yeV9wcmV2KCkge1xuICAgICAgICBpZiAocHJvcC5pbnB1dC5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3AuaW5wdXQuaGlzdG9yeV9pdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3AuaW5wdXQuaGlzdG9yeS51bnNoaWZ0KHByb3AuaW5wdXQuY29tbWFuZCk7XG4gICAgICAgICAgICBwcm9wLmlucHV0Lmhpc3RvcnlfaXRlbSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wLmlucHV0Lmhpc3RvcnlfaXRlbSArPSAxO1xuICAgICAgICB0aGlzLmlucHV0X2hpc3RvcnlfY2xhbXAoKTtcblxuICAgICAgICBjb25zdCBjb21tYW5kID0gYCR7cHJvcC5pbnB1dC5oaXN0b3J5W3Byb3AuaW5wdXQuaGlzdG9yeV9pdGVtXX0gYDtcbiAgICAgICAgdGhpcy4kY29tbWFuZElucHV0LnZhbChjb21tYW5kLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBJbnB1dENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGlucHV0X2hpc3RvcnlfbmV4dFxuICAgICAqL1xuICAgIGlucHV0X2hpc3RvcnlfbmV4dCgpIHtcbiAgICAgICAgaWYgKHByb3AuaW5wdXQuaGlzdG9yeS5sZW5ndGggPT09IDAgfHwgIXByb3AuaW5wdXQuaGlzdG9yeV9pdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wLmlucHV0Lmhpc3RvcnlfaXRlbSAtPSAxO1xuXG4gICAgICAgIGlmIChwcm9wLmlucHV0Lmhpc3RvcnlfaXRlbSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiRjb21tYW5kSW5wdXQudmFsKHByb3AuaW5wdXQuaGlzdG9yeVswXSk7XG5cbiAgICAgICAgICAgIHRoaXMub25Db21tYW5kSW5wdXRDaGFuZ2VIYW5kbGVyKCk7XG5cbiAgICAgICAgICAgIHByb3AuaW5wdXQuaGlzdG9yeS5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICBwcm9wLmlucHV0Lmhpc3RvcnlfaXRlbSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXRfaGlzdG9yeV9jbGFtcCgpO1xuXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBgJHtwcm9wLmlucHV0Lmhpc3RvcnlbcHJvcC5pbnB1dC5oaXN0b3J5X2l0ZW1dfSBgO1xuXG4gICAgICAgIHRoaXMuJGNvbW1hbmRJbnB1dC52YWwoY29tbWFuZC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgdGhpcy5vbkNvbW1hbmRJbnB1dENoYW5nZUhhbmRsZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNhcHN1bGF0aW9uIG9mIHJlcGVhdGVkIGJvb2xlYW4gbG9naWNcbiAgICAgKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBfaXNBcnJvd0NvbnRyb2xNZXRob2RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc0Fycm93Q29udHJvbE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLm9wdGlvbi5nZXQoR0FNRV9PUFRJT05fTkFNRVMuQ09OVFJPTF9NRVRIT0QpID09PSAnYXJyb3dzJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgX3BhcnNlVXNlckNvbW1hbmRcbiAgICAgKiBAcmV0dXJuIHJlc3VsdCB7Q29tbWFuZFBhcnNlcn1cbiAgICAgKi9cbiAgICBfcGFyc2VVc2VyQ29tbWFuZCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCB1c2UgJGNvbW1hbmRJbnB1dC52YWwoKSBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgICAgICBjb25zdCB1c2VyQ29tbWFuZCA9IHByb3AuaW5wdXQuY29tbWFuZC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBVc2luZyB0cnkvY2F0Y2ggaGVyZSB2ZXJ5IG11Y2ggb24gcHVycG9zZS4gdGhlIGBDb21tYW5kUGFyc2VyYCB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBhbnkga2luZFxuICAgICAgICAvLyBvZiBlcnJvcjsgaW52YWxpZCBsZW5ndGgsIHZhbGlkYXRpb24sIHBhcnNlLCBldGMuIEhlcmUgd2UgY2F0Y2ggdGhvc2UgZXJyb3JzLCBsb2cgdGhlbSB0byB0aGUgc2NyZWVuXG4gICAgICAgIC8vIGFuZCB0aGVuIHRocm93IHRoZW0gYWxsIGF0IG9uY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21tYW5kUGFyc2VyKHVzZXJDb21tYW5kKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKCdDb21tYW5kIG5vdCB1bmRlcnN0b29kJyk7XG5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaW5wdXRfcnVuXG4gICAgICovXG4gICAgaW5wdXRfcnVuKCkge1xuICAgICAgICBjb25zdCBjb21tYW5kUGFyc2VyID0gdGhpcy5fcGFyc2VVc2VyQ29tbWFuZCgpO1xuXG4gICAgICAgIGlmIChjb21tYW5kUGFyc2VyLmNvbW1hbmQgIT09ICd0cmFuc21pdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTeXN0ZW1Db21tYW5kKGNvbW1hbmRQYXJzZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1RyYW5zbWl0Q29tbWFuZChjb21tYW5kUGFyc2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIElucHV0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgcHJvY2Vzc1N5c3RlbUNvbW1hbmRcbiAgICAgKiBAcGFyYW0gY29tbWFuZFBhcnNlciB7Q29tbWFuZFBhcnNlcn1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIHByb2Nlc3NTeXN0ZW1Db21tYW5kKGNvbW1hbmRQYXJzZXIpIHtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kUGFyc2VyLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgUEFSU0VEX0NPTU1BTkRfTkFNRS5WRVJTSU9OOlxuICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGBBaXIgVHJhZmZpYyBDb250cm9sIHNpbXVsYXRvciB2ZXJzaW9uICR7cHJvcC52ZXJzaW9uLmpvaW4oJy4nKX1gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFBBUlNFRF9DT01NQU5EX05BTUUuVFVUT1JJQUw6XG4gICAgICAgICAgICAgICAgd2luZG93LnR1dG9yaWFsVmlldy50dXRvcmlhbF90b2dnbGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFBBUlNFRF9DT01NQU5EX05BTUUuQVVUTzpcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogZG9lcyB0aGlzIGZ1bmN0aW9uIGV4aXN0IGFueXdoZXJlP1xuICAgICAgICAgICAgICAgIC8vIGFpcmNyYWZ0X3RvZ2dsZV9hdXRvKCk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpZiAocHJvcC5haXJjcmFmdC5hdXRvLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coJ2F1dG9tYXRpYyBjb250cm9sbGVyIEVOR0FHRUQnKTtcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZygnYXV0b21hdGljIGNvbnRyb2xsZXIgT0ZGJyk7XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgUEFSU0VEX0NPTU1BTkRfTkFNRS5QQVVTRTpcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9wYXVzZV90b2dnbGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFBBUlNFRF9DT01NQU5EX05BTUUuVElNRVdBUlA6XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRQYXJzZXIuYXJncykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS5zcGVlZHVwID0gY29tbWFuZFBhcnNlci5hcmdzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWV3YXJwX3RvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFBBUlNFRF9DT01NQU5EX05BTUUuQ0xFQVI6XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG5cbiAgICAgICAgICAgIGNhc2UgUEFSU0VEX0NPTU1BTkRfTkFNRS5BSVJQT1JUOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGl0IG1heSBiZSBiZXR0ZXIgdG8gZG8gdGhpcyBpbiB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgY29uc3QgYWlycG9ydEljYW8gPSBjb21tYW5kUGFyc2VyLmFyZ3NbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hhcyhwcm9wLmFpcnBvcnQuYWlycG9ydHMsIGFpcnBvcnRJY2FvKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9zZXQoYWlycG9ydEljYW8pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFBBUlNFRF9DT01NQU5EX05BTUUuUkFURTpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIGlmIGV2ZW4gbmVlZGVkP1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kUGFyc2VyLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUuZnJlcXVlbmN5ID0gY29tbWFuZFBhcnNlci5hcmdzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgSW5wdXRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBwcm9jZXNzVHJhbnNtaXRDb21tYW5kXG4gICAgICogQHBhcmFtIGNvbW1hbmRQYXJzZXIge0NvbW1hbmRQYXJzZXJ9XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm9jZXNzVHJhbnNtaXRDb21tYW5kKGNvbW1hbmRQYXJzZXIpIHtcbiAgICAgICAgLy8gVE9ETzogYWJzdHJhY3QgdGhlIGFpcmNyYWZ0IGNhbGxzaWduIG1hdGNoaW5nXG4gICAgICAgIGxldCBtYXRjaGVzID0gMDtcbiAgICAgICAgbGV0IG1hdGNoID0gLTE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFpcmNyYWZ0ID0gcHJvcC5haXJjcmFmdC5saXN0W2ldO1xuXG4gICAgICAgICAgICBpZiAoYWlyY3JhZnQubWF0Y2hDYWxsc2lnbihjb21tYW5kUGFyc2VyLmNhbGxzaWduKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgKz0gMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlcyA+IDEpIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKCdtdWx0aXBsZSBhaXJjcmFmdCBtYXRjaCB0aGUgY2FsbHNpZ24sIHNheSBhZ2FpbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKCdubyBzdWNoIGFpcmNyYWZ0LCBzYXkgYWdhaW4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhaXJjcmFmdCA9IHByb3AuYWlyY3JhZnQubGlzdFttYXRjaF07XG5cbiAgICAgICAgcmV0dXJuIGFpcmNyYWZ0LnJ1bkNvbW1hbmRzKGNvbW1hbmRQYXJzZXIuYXJncyk7XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi91dGlsaXRpZXMvdGltZUhlbHBlcnMnO1xuaW1wb3J0IHsgU0VMRUNUT1JTIH0gZnJvbSAnLi9jb25zdGFudHMvc2VsZWN0b3JzJztcblxuLyoqXG4gKiBAcHJvcGVydHkgTUlOX0RJU1BMQVlfU0VDT05EU1xuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBNSU5fRElTUExBWV9TRUNPTkRTID0gMjtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBlbmNhcHN1bGF0ZWQgY2xhc3MgdGhhdCBkaXNwbGF5cyBhIHRydW5jYXRlZCBmaWxlbmFtZSBmb3IgYSBmaWxlIGN1cnJlbnRseSBiZWluZyBsb2FkZWQuXG4gKlxuICogT25seSB1c2VkIG9uY2UgdGhlIGVudGlyZSB2aWV3IGhhcyBsb2FkZWQuXG4gKiBleDogYSB1c2VyIGNoYW5nZXMgYWlycG9ydHMgYWZ0ZXIgaW5pdGFsaXppbmcgdGhlIHNpbXVsYXRvci5cbiAqXG4gKiBAY2xhc3MgTG9hZGluZ1ZpZXdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGluZ1ZpZXcge1xuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSAkZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7anF1ZXJ5fG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5ICRsb2FkaW5nSW5kaWNhdG9yXG4gICAgICAgICAqIEB0eXBlIHtqcXVlcnl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGxvYWRpbmdJZGljYXRvciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSAkbG9hZGluZ01lc3NhZ2VcbiAgICAgICAgICogQHR5cGUge2pxdWVyeXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kbG9hZGluZ01lc3NhZ2UgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgbG9hZGluZ1N0YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdGUgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY2FsbGJhY2tcbiAgICAgICAgICAgICAqIEBtZXRob2QgY2FsbGJhY2tcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge30sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGxvYWRpbmdTdGF0ZVxuICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzdGFydFRpbWVcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0YXJ0VGltZTogLTFcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9zZXR1cENoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBMb2FkaW5nVmlld1xuICAgICAqIEBtZXRob2QgX3NldHVwQ2hpbGRyZW5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0dXBDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuTE9BRElORyk7XG4gICAgICAgIHRoaXMuJGxvYWRpbmdJZGljYXRvciA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuTE9BRElOR19JTkRJQ0FUT1IpO1xuICAgICAgICB0aGlzLiRsb2FkaW5nTWVzc2FnZSA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5NRVNTQUdFKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIExvYWRpbmdWaWV3XG4gICAgICogQG1ldGhvZCBfZGlzYWJsZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNhYmxlKCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0ZS5jYWxsYmFjayA9ICgpID0+IHt9O1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXRlLnN0YXJ0VGltZSA9IC0xO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAbWV0aG9kIF9yZXNldENhbGxiYWNrXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Q2FsbGJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIExvYWRpbmdWaWV3XG4gICAgICogQG1ldGhvZCBfZGlkRXhjZWVkTWluaW11bVdhaXRUaW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlkRXhjZWVkTWluaW11bVdhaXRUaW1lKCkge1xuICAgICAgICBjb25zdCB0aW1lTm93ID0gdGltZSgpO1xuXG4gICAgICAgIHJldHVybiAodGltZU5vdyAtIHRoaXMubG9hZGluZ1N0YXRlLnN0YXJ0VGltZSkgPiBNSU5fRElTUExBWV9TRUNPTkRTO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAbWV0aG9kIF9mb3JtYXRMb2FkaW5nTWVzc2FnZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmd9ICBhIHN0cmluZyB0byBiZSBmb3JtYXR0ZWRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0TG9hZGluZ01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtaW5pbXVtVHJ1bmNhdGlvbkxlbmd0aCA9IDE1O1xuXG4gICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCA8PSBtaW5pbXVtVHJ1bmNhdGlvbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYC4uLiR7bWVzc2FnZS5zdWJzdHIoLTEyKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAbWV0aG9kIHN0YXJ0TG9hZFxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gIHRoZSB1cmwgZm9yIGEgZmlsZSBiZWluZyBsb2FkZWRcbiAgICAgKi9cbiAgICBzdGFydExvYWQodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAkKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkxPQURJTkdfSU5ESUNBVE9SKS5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0ZS5zdGFydFRpbWUgPSB0aW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9mb3JtYXRMb2FkaW5nTWVzc2FnZSh1cmwpO1xuICAgICAgICB0aGlzLiRsb2FkaW5nTWVzc2FnZS50ZXh0KG1zZyk7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAbWV0aG9kIHN0b3BMb2FkXG4gICAgICovXG4gICAgc3RvcExvYWQoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVOb3cgPSB0aW1lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RpZEV4Y2VlZE1pbmltdW1XYWl0VGltZSgpKSB7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nSWRpY2F0b3IuaGlkZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGVsYXlUaW1lID0gKE1JTl9ESVNQTEFZX1NFQ09ORFMgLSAodGltZU5vdyAtIHRoaXMuc3RhcnQpKSAqIDEwMDA7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5MT0FESU5HX0lORElDQVRPUikuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZSgpO1xuICAgICAgICAgICAgfSwgZGVsYXlUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTG9hZGluZ1ZpZXdcbiAgICAgKiBAbWV0aG9kIGNvbXBsZXRlXG4gICAgICovXG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmFkZU91dCgxMDAwKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLW1peGVkLW9wZXJhdG9ycywgZnVuYy1uYW1lcywgb2JqZWN0LXNob3J0aGFuZCwgbm8tdW5kZWYsXG5uby1wYXJhbS1yZWFzc2lnbiwgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2hhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBfa2V5cyBmcm9tICdsb2Rhc2gva2V5cyc7XG5pbXBvcnQgX3N0YXJ0Q2FzZSBmcm9tICdsb2Rhc2gvc3RhcnRDYXNlJztcbmltcG9ydCB7IHNwZWVjaF90b2dnbGUgfSBmcm9tICcuL3NwZWVjaCc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4vbWF0aC9jb3JlJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4vY29uc3RhbnRzL3NlbGVjdG9ycyc7XG5pbXBvcnQgeyBTVE9SQUdFX0tFWSB9IGZyb20gJy4vY29uc3RhbnRzL3N0b3JhZ2VLZXlzJztcblxuLy8gVGVtcG9yYXJ5IGNvbnN0IGRlY2xhcmF0aW9uIGhlcmUgdG8gYXR0YWNoIHRvIHRoZSB3aW5kb3cgQU5EIHVzZSBhcyBpbnRlcm5hbCBwcm9wZXJ0eVxuY29uc3QgdWkgPSB7fTtcblxuLyoqXG4gKiBAcHJvcGVydHkgVEVSUkFJTl9DT0xPUlNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgVEVSUkFJTl9DT0xPUlMgPSB7XG4gICAgMTAwMDogJzI2LCAxNTAsIDY1JyxcbiAgICAyMDAwOiAnMTE5LCAxOTQsIDkyJyxcbiAgICAzMDAwOiAnMjU1LCAyNTUsIDE5MicsXG4gICAgNDAwMDogJzI1MywgMjAxLCAxMjgnLFxuICAgIDUwMDA6ICcyNDAsIDEyNCwgNzQnLFxuICAgIDYwMDA6ICcxNTYsIDgxLCAzMSdcbn07XG5cbi8qKlxuICogQHByb3BlcnR5IFVJX09QVElPTlNfVEVNUExBVEVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgVUlfT1BUSU9OU19URU1QTEFURSA9ICc8ZGl2IGlkPVwib3B0aW9ucy1kaWFsb2dcIiBjbGFzcz1cImRpYWxvZ1wiPjwvZGl2Pic7XG5cbi8qKlxuICogQHByb3BlcnR5IFVJX09QVElPTl9DT05UQUlORVJfVEVNUExBVEVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgVUlfT1BUSU9OX0NPTlRBSU5FUl9URU1QTEFURSA9ICc8ZGl2IGNsYXNzPVwib3B0aW9uXCI+PC9kaXY+JztcblxuLyoqXG4gKiBAcHJvcGVydHkgVUlfT1BUSU9OX1NFTEVDVE9SX1RFTVBMQVRFXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFVJX09QVElPTl9TRUxFQ1RPUl9URU1QTEFURSA9ICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1zZWxlY3RvciBvcHRpb24tdHlwZS1zZWxlY3RcIj48L3NwYW4+JztcblxuLyoqXG4gKiBAY2xhc3MgVWlDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVpVmlldyB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoJGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgICAgICB0aGlzLiRhaXJwb3J0TGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0Tm90ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0b2dnbGVUdXRvcmlhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGZhc3RGb3J3YXJkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHBhdXNlVG9nZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcGF1c2VkSW1nID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3BlZWNoVG9nZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZUxhYmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVJlc3RyaWN0ZWRBcmVhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVNpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0b2dnbGVUZXJyYWluID0gbnVsbDtcbiAgICAgICAgdGhpcy4kdG9nZ2xlT3B0aW9ucyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgICAgICB0aGlzLnVpLnNjYWxlX2RlZmF1bHQgPSA4OyAvLyBwaXhlbHMgcGVyIGttXG4gICAgICAgIHRoaXMudWkuc2NhbGVfbWF4ID0gODA7IC8vIG1heCBzY2FsZVxuICAgICAgICB0aGlzLnVpLnNjYWxlX21pbiA9IDE7IC8vIG1pbiBzY2FsZVxuICAgICAgICB0aGlzLnVpLnNjYWxlID0gdGhpcy51aS5zY2FsZV9kZWZhdWx0O1xuICAgICAgICB0aGlzLnVpLnRlcnJhaW4gPSB7XG4gICAgICAgICAgICBjb2xvcnM6IFRFUlJBSU5fQ09MT1JTLFxuICAgICAgICAgICAgYm9yZGVyX29wYWNpdHk6IDEsXG4gICAgICAgICAgICBmaWxsX29wYWNpdHk6IDAuMVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoKVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIF9pbml0XG4gICAgICovXG4gICAgX2luaXQoKSB7XG4gICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0ID0gdGhpcy4kZWxlbWVudC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkFJUlBPUlRfTElTVCk7XG4gICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0Tm90ZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuQUlSUE9SVF9MSVNUX05PVEVTKTtcbiAgICAgICAgdGhpcy4kYWlycG9ydFN3aXRjaCA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5BSVJQT1JUX1NXSVRDSCk7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVR1dG9yaWFsID0gdGhpcy4kZWxlbWVudC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLlRPR0dMRV9UVVRPUklBTCk7XG4gICAgICAgIHRoaXMuJGZhc3RGb3J3YXJkcyA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5GQVNUX0ZPUldBUkRTKTtcbiAgICAgICAgdGhpcy4kcGF1c2VUb2dnbGUgPSB0aGlzLiRlbGVtZW50LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuUEFVU0VfVE9HR0xFKTtcbiAgICAgICAgdGhpcy4kcGF1c2VkSW1nID0gdGhpcy4kZWxlbWVudC5maW5kKGAke1NFTEVDVE9SUy5ET01fU0VMRUNUT1JTLlBBVVNFRH0gaW1nYCk7XG4gICAgICAgIHRoaXMuJHNwZWVjaFRvZ2dsZSA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5TUEVFQ0hfVE9HR0xFKTtcbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydCA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5TV0lUQ0hfQUlSUE9SVCk7XG4gICAgICAgIHRoaXMuJHRvZ2dsZUxhYmVscyA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5UT0dHTEVfTEFCRUxTKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlUmVzdHJpY3RlZEFyZWFzID0gdGhpcy4kZWxlbWVudC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLlRPR0dMRV9SRVNUUklDVEVEX0FSRUFTKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlU2lkcyA9IHRoaXMuJGVsZW1lbnQuZmluZChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5UT0dHTEVfU0lEUyk7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVRlcnJhaW4gPSB0aGlzLiRlbGVtZW50LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuVE9HR0xFX1RFUlJBSU4pO1xuICAgICAgICB0aGlzLiR0b2dnbGVPcHRpb25zID0gdGhpcy4kZWxlbWVudC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLlRPR0dMRV9PUFRJT05TKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZW5hYmxlXG4gICAgICovXG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLiR0b2dnbGVUdXRvcmlhbC5vbignY2xpY2snLCAoZXZlbnQpID0+IHdpbmRvdy50dXRvcmlhbFZpZXcudHV0b3JpYWxfdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGZhc3RGb3J3YXJkcy5vbignY2xpY2snLCAoZXZlbnQpID0+IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWV3YXJwX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiRwYXVzZVRvZ2dsZS5vbignY2xpY2snLCAoZXZlbnQpID0+IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3BhdXNlX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiRwYXVzZWRJbWcub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV91bnBhdXNlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHNwZWVjaFRvZ2dsZS5vbignY2xpY2snLCAoZXZlbnQpID0+IHNwZWVjaF90b2dnbGUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydC5vbignY2xpY2snLCAoZXZlbnQpID0+IHRoaXMudWlfYWlycG9ydF90b2dnbGUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlTGFiZWxzLm9uKCdjbGljaycsIChldmVudCkgPT4gdGhpcy5jYW52YXNfbGFiZWxzX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiR0b2dnbGVSZXN0cmljdGVkQXJlYXMub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc19yZXN0cmljdGVkX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiR0b2dnbGVTaWRzLm9uKCdjbGljaycsIChldmVudCkgPT4gdGhpcy5jYW52YXNfc2lkc190b2dnbGUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlVGVycmFpbi5vbignY2xpY2snLCAoZXZlbnQpID0+IHRoaXMuY2FudmFzX3RlcnJhaW5fdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHRvZ2dsZU9wdGlvbnMub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLnVpX29wdGlvbnNfdG9nZ2xlKGV2ZW50KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGRpc2FibGVcbiAgICAgKi9cbiAgICBkaWFibGUoKSB7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVR1dG9yaWFsLm9mZignY2xpY2snLCAoZXZlbnQpID0+IHdpbmRvdy50dXRvcmlhbFZpZXcudHV0b3JpYWxfdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJGZhc3RGb3J3YXJkcy5vZmYoJ2NsaWNrJywgKGV2ZW50KSA9PiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1ld2FycF90b2dnbGUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kcGF1c2VUb2dnbGUub2ZmKCdjbGljaycsIChldmVudCkgPT4gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfcGF1c2VfdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHBhdXNlZEltZy5vZmYoJ2NsaWNrJywgKGV2ZW50KSA9PiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV91bnBhdXNlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHNwZWVjaFRvZ2dsZS5vZmYoJ2NsaWNrJywgKGV2ZW50KSA9PiBzcGVlY2hfdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHN3aXRjaEFpcnBvcnQub2ZmKCdjbGljaycsIChldmVudCkgPT4gdGhpcy51aV9haXJwb3J0X3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiR0b2dnbGVMYWJlbHMub2ZmKCdjbGljaycsIChldmVudCkgPT4gdGhpcy5jYW52YXNfbGFiZWxzX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiR0b2dnbGVSZXN0cmljdGVkQXJlYXMub2ZmKCdjbGljaycsIChldmVudCkgPT4gdGhpcy5jYW52YXNfcmVzdHJpY3RlZF90b2dnbGUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlU2lkcy5vZmYoJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc19zaWRzX3RvZ2dsZShldmVudCkpO1xuICAgICAgICB0aGlzLiR0b2dnbGVUZXJyYWluLm9mZignY2xpY2snLCAoZXZlbnQpID0+IHRoaXMuY2FudmFzX3RlcnJhaW5fdG9nZ2xlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuJHRvZ2dsZU9wdGlvbnMub2ZmKCdjbGljaycsIChldmVudCkgPT4gdGhpcy51aV9vcHRpb25zX3RvZ2dsZShldmVudCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRhaXJwb3J0TGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0Tm90ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0b2dnbGVUdXRvcmlhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGZhc3RGb3J3YXJkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHBhdXNlVG9nZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcGF1c2VkSW1nID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3BlZWNoVG9nZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZUxhYmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVJlc3RyaWN0ZWRBcmVhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuJHRvZ2dsZVNpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0b2dnbGVUZXJyYWluID0gbnVsbDtcbiAgICAgICAgdGhpcy4kdG9nZ2xlT3B0aW9ucyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy51aSA9IHt9O1xuICAgICAgICB0aGlzLnVpLnNjYWxlX2RlZmF1bHQgPSAtMTtcbiAgICAgICAgdGhpcy51aS5zY2FsZV9tYXggPSAtMTtcbiAgICAgICAgdGhpcy51aS5zY2FsZV9taW4gPSAtMTtcbiAgICAgICAgdGhpcy51aS5zY2FsZSA9IC0xO1xuICAgICAgICB0aGlzLnVpLnRlcnJhaW4gPSB7fTtcblxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9pbml0X3ByZVxuICAgICAqL1xuICAgIHVpX2luaXRfcHJlKCkge1xuICAgICAgICBwcm9wLnVpID0gdWk7XG4gICAgICAgIHByb3AudWkuc2NhbGVfZGVmYXVsdCA9IDg7IC8vIHBpeGVscyBwZXIga21cbiAgICAgICAgcHJvcC51aS5zY2FsZV9tYXggPSA4MDsgLy8gbWF4IHNjYWxlXG4gICAgICAgIHByb3AudWkuc2NhbGVfbWluID0gMTsgLy8gbWluIHNjYWxlXG4gICAgICAgIHByb3AudWkuc2NhbGUgPSBwcm9wLnVpLnNjYWxlX2RlZmF1bHQ7XG4gICAgICAgIHByb3AudWkudGVycmFpbiA9IHtcbiAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgIDEwMDA6ICcyNiwgMTUwLCA2NScsXG4gICAgICAgICAgICAgICAgMjAwMDogJzExOSwgMTk0LCA5MicsXG4gICAgICAgICAgICAgICAgMzAwMDogJzI1NSwgMjU1LCAxOTInLFxuICAgICAgICAgICAgICAgIDQwMDA6ICcyNTMsIDIwMSwgMTI4JyxcbiAgICAgICAgICAgICAgICA1MDAwOiAnMjQwLCAxMjQsIDc0JyxcbiAgICAgICAgICAgICAgICA2MDAwOiAnMTU2LCA4MSwgMzEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9yZGVyX29wYWNpdHk6IDEsXG4gICAgICAgICAgICBmaWxsX29wYWNpdHk6IDAuMVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudWlfc2V0X3NjYWxlX2Zyb21fc3RvcmFnZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgdWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9pbml0XG4gICAgICovXG4gICAgdWlfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZmFzdEZvcndhcmRzLnByb3AoJ3RpdGxlJywgJ1NldCB0aW1lIHdhcnAgdG8gMicpO1xuXG4gICAgICAgIGNvbnN0ICRvcHRpb25zID0gJChVSV9PUFRJT05TX1RFTVBMQVRFKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25zID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUub3B0aW9uLmdldERlc2NyaXB0aW9ucygpO1xuXG4gICAgICAgIF9mb3JFYWNoKGRlc2NyaXB0aW9ucywgKG9wdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgJGNvbnRhaW5lciA9IHRoaXMuX2J1aWxkT3B0aW9uVGVtcGxhdGUob3B0KTtcbiAgICAgICAgICAgICRvcHRpb25zLmFwcGVuZCgkY29udGFpbmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCgkb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIGh0bWwgZm9yIGEgZ2FtZSBvcHRpb24gYW5kIGl0cyBjb29yZXNwb25kaW5nIHZhbHVlIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIF9idWlsZE9wdGlvblRlbXBsYXRlXG4gICAgICogQHBhcmFtIG9wdGlvbiB7b2JqZWN0fVxuICAgICAqIEByZXR1cm4gJGNvbnRhaW5lciB7anF1ZXJ5IEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRPcHRpb25UZW1wbGF0ZShvcHRpb24pIHtcbiAgICAgICAgY29uc3QgJGNvbnRhaW5lciA9ICQoVUlfT1BUSU9OX0NPTlRBSU5FUl9URU1QTEFURSk7XG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKGA8c3BhbiBjbGFzcz1cIm9wdGlvbi1kZXNjcmlwdGlvblwiPiR7b3B0aW9uLmRlc2NyaXB0aW9ufTwvc3Bhbj5gKTtcblxuICAgICAgICBjb25zdCAkb3B0aW9uU2VsZWN0b3IgPSAkKFVJX09QVElPTl9TRUxFQ1RPUl9URU1QTEFURSk7XG4gICAgICAgIGNvbnN0ICRzZWxlY3RvciA9ICQoYDxzZWxlY3QgaWQ9XCJvcHQtJHtvcHRpb24ubmFtZX1cIiBuYW1lPVwiJHtvcHRpb24ubmFtZX1cIj48L3NlbGVjdD5gKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS5vcHRpb24uZ2V0KG9wdGlvbi5uYW1lKTtcblxuICAgICAgICAvLyB0aGlzIGNvdWxkIG1lIGRvbmUgd2l0aCBhIF9tYXAoKSwgYnV0IHZlcmJvc2l0eSBoZXJlIG1ha2VzIHRoZSBjb2RlIGVhc2llciB0byByZWFkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0ICRvcHRpb25TZWxlY3RUZW1wYWxhdGUgPSB0aGlzLl9idWlsZE9wdGlvblNlbGVjdFRlbXBsYXRlKG9wdGlvbi5kYXRhW2ldWzFdLCBzZWxlY3RlZE9wdGlvbik7XG5cbiAgICAgICAgICAgICRzZWxlY3Rvci5hcHBlbmQoJG9wdGlvblNlbGVjdFRlbXBhbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBtb3ZlZCB0byBhIGBzZXR1cEhhbmRsZXJzKClgIG9yIGEgY2xpY2sgaGFuZGxlclxuICAgICAgICAkc2VsZWN0b3IuY2hhbmdlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJGN1cnJlbnRUYXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS5vcHRpb24uc2V0KCRjdXJyZW50VGFyZ2V0LmF0dHIoJ25hbWUnKSwgJGN1cnJlbnRUYXJnZXQudmFsKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkb3B0aW9uU2VsZWN0b3IuYXBwZW5kKCRzZWxlY3Rvcik7XG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKCRvcHRpb25TZWxlY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuICRjb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIGh0bWwgZm9yIGEgc2VsZWN0IG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBfYnVpbGRPcHRpb25UZW1wbGF0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25EYXRhXG4gICAgICogQHBhcmFtIHNlbGVjdGVkT3B0aW9uIHtzdHJpbmd9XG4gICAgICogQHJldHVybiBvcHRpb25TZWxlY3RUZW1wYWxhdGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9idWlsZE9wdGlvblNlbGVjdFRlbXBsYXRlKG9wdGlvbkRhdGEsIHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICAgIGxldCBvcHRpb25TZWxlY3RUZW1wYWxhdGUgPSBgPG9wdGlvbiB2YWx1ZT1cIiR7b3B0aW9uRGF0YX1cIj4ke19zdGFydENhc2Uob3B0aW9uRGF0YSl9PC9vcHRpb24+YDtcblxuICAgICAgICBpZiAob3B0aW9uRGF0YSA9PT0gc2VsZWN0ZWRPcHRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvblNlbGVjdFRlbXBhbGF0ZSA9IGA8b3B0aW9uIHZhbHVlPVwiJHtvcHRpb25EYXRhfVwiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIj4ke19zdGFydENhc2Uob3B0aW9uRGF0YSl9PC9vcHRpb24+YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25TZWxlY3RUZW1wYWxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciB1aUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIG9uQ2xpY2tBaXJwb3J0TGlzdEl0ZW1IYW5kbGVyXG4gICAgICogQHBhYW0gZXZlbnQge2pxdWVyeSBldmVudH1cbiAgICAgKi9cbiAgICBvbkNsaWNrQWlycG9ydExpc3RJdGVtSGFuZGxlcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSAhPT0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuaWNhbykge1xuICAgICAgICAgICAgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfc2V0KGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy51aV9haXJwb3J0X2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIHVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYnVpbGRBaXJwb3J0TGlzdEl0ZW1UZW1wbGF0ZVxuICAgICAqIEBwYXJhbSBpY2FvIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGRpZmZpY3VsdHkge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge0RPTSBlbGVtZW50fHN0cmluZ31cbiAgICAgKi9cbiAgICBidWlsZEFpcnBvcnRMaXN0SXRlbVRlbXBsYXRlKGljYW8sIGRpZmZpY3VsdHksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGA8bGkgY2xhc3M9XCJhaXJwb3J0IGljYW8tJHtpY2FvLnRvTG93ZXJDYXNlKCl9XCI+YCArXG4gICAgICAgICAgICAgICAgICAgIGA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogN3B0XCIgY2xhc3M9XCJkaWZmaWN1bHR5XCI+JHtkaWZmaWN1bHR5fTwvc3Bhbj5gICtcbiAgICAgICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwiaWNhb1wiPiR7aWNhby50b1VwcGVyQ2FzZSgpfTwvc3Bhbj5gICtcbiAgICAgICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwibmFtZVwiPiR7bmFtZX08L3NwYW4+YCArXG4gICAgICAgICAgICAgICAgJzwvbGk+JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgdWlfY29tcGxldGVcbiAgICAgKi9cbiAgICB1aV9jb21wbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgYWlycG9ydHMgPSBfa2V5cyhwcm9wLmFpcnBvcnQuYWlycG9ydHMpLnNvcnQoKTtcbiAgICAgICAgY29uc3QgaWNvbiA9ICcmIzk5OTI7JztcbiAgICAgICAgbGV0IGRpZmZpY3VsdHkgPSAnJztcbiAgICAgICAgbGV0IGFpcnBvcnQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhaXJwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWlycG9ydCA9IHByb3AuYWlycG9ydC5haXJwb3J0c1thaXJwb3J0c1tpXV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYWlycG9ydC5sZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JlZ2lubmVyJzpcbiAgICAgICAgICAgICAgICAgICAgZGlmZmljdWx0eSA9IGljb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vhc3knOlxuICAgICAgICAgICAgICAgICAgICBkaWZmaWN1bHR5ID0gaWNvbi5yZXBlYXQoMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgICAgIGRpZmZpY3VsdHkgPSBpY29uLnJlcGVhdCgzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGFyZCc6XG4gICAgICAgICAgICAgICAgICAgIGRpZmZpY3VsdHkgPSBpY29uLnJlcGVhdCg0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwZXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgZGlmZmljdWx0eSA9IGljb24ucmVwZWF0KDUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkaWZmaWN1bHR5ID0gJz8nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBhIHRlbXBsYXRlIGNvbnN0XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGljYW8gfSA9IGFpcnBvcnQ7XG4gICAgICAgICAgICBjb25zdCAkYWlycG9ydExpc3RJdGVtID0gJCh0aGlzLmJ1aWxkQWlycG9ydExpc3RJdGVtVGVtcGxhdGUoaWNhbywgZGlmZmljdWx0eSwgbmFtZSkpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYW4gb25DbGljaygpIGhhbmRsZXJcbiAgICAgICAgICAgICRhaXJwb3J0TGlzdEl0ZW0uY2xpY2soYWlycG9ydC5pY2FvLnRvTG93ZXJDYXNlKCksIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhICE9PSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5pY2FvKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X3NldChldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51aV9haXJwb3J0X2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0LmFwcGVuZCgkYWlycG9ydExpc3RJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0FpcnBvcnRMaXN0Rm9vdGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGRyYXdBaXJwb3J0TGlzdEZvb3RlclxuICAgICAqL1xuICAgIGRyYXdBaXJwb3J0TGlzdEZvb3RlcigpIHtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gJCgnPHNwYW4gY2xhc3M9XCJzeW1ib2xcIj4mIzk5ODM8L3NwYW4+Jyk7XG4gICAgICAgIHRoaXMuJGFpcnBvcnRMaXN0Tm90ZXMuYXBwZW5kKHN5bWJvbCk7XG5cbiAgICAgICAgY29uc3Qgbm90ZXMgPSAkKCc8c3BhbiBjbGFzcz1cIndvcmRzXCI+aW5kaWNhdGVzIGFpcnBvcnQgaXMgYSB3b3JrIGluIHByb2dyZXNzPC9zcGFuPicpO1xuICAgICAgICB0aGlzLiRhaXJwb3J0TGlzdE5vdGVzLmFwcGVuZChub3Rlcyk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsaXZlIGluIGEgaGVscGVyIGZpbGUgc29tZXdoZXJlXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHB4X3RvX2ttXG4gICAgICogQHBhcmFtIHBpeGVscyB7bnVtYmVyfVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBweF90b19rbShwaXhlbHMpIHtcbiAgICAgICAgcmV0dXJuIHBpeGVscyAvIHByb3AudWkuc2NhbGU7XG4gICAgfVxuXG4gICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsaXZlIGluIGEgaGVscGVyIGZpbGUgc29tZXdoZXJlXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGttX3RvX3B4XG4gICAgICogQHBhcmFtIGtpbG9tZXRlcnMge251bWJlcn1cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAga21fdG9fcHgoa2lsb21ldGVycykge1xuICAgICAgICByZXR1cm4ga2lsb21ldGVycyAqIHByb3AudWkuc2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHVpX2FmdGVyX3pvb21cbiAgICAgKi9cbiAgICB1aV9hZnRlcl96b29tKCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2VbU1RPUkFHRV9LRVkuQVRDX1NDQUxFXSA9IHByb3AudWkuc2NhbGU7XG5cbiAgICAgICAgcHJvcC5jYW52YXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV96b29tX291dFxuICAgICAqL1xuICAgIHVpX3pvb21fb3V0KCkge1xuICAgICAgICBjb25zdCBsYXN0cG9zID0gW1xuICAgICAgICAgICAgcm91bmQodGhpcy5weF90b19rbShwcm9wLmNhbnZhcy5wYW5YKSksXG4gICAgICAgICAgICByb3VuZCh0aGlzLnB4X3RvX2ttKHByb3AuY2FudmFzLnBhblkpKVxuICAgICAgICBdO1xuXG4gICAgICAgIHByb3AudWkuc2NhbGUgKj0gMC45O1xuXG4gICAgICAgIGlmIChwcm9wLnVpLnNjYWxlIDwgcHJvcC51aS5zY2FsZV9taW4pIHtcbiAgICAgICAgICAgIHByb3AudWkuc2NhbGUgPSBwcm9wLnVpLnNjYWxlX21pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudWlfYWZ0ZXJfem9vbSgpO1xuXG4gICAgICAgIHByb3AuY2FudmFzLnBhblggPSByb3VuZCh0aGlzLmttX3RvX3B4KGxhc3Rwb3NbMF0pKTtcbiAgICAgICAgcHJvcC5jYW52YXMucGFuWSA9IHJvdW5kKHRoaXMua21fdG9fcHgobGFzdHBvc1sxXSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV96b29tX2luXG4gICAgICovXG4gICAgdWlfem9vbV9pbigpIHtcbiAgICAgICAgY29uc3QgbGFzdHBvcyA9IFtcbiAgICAgICAgICAgIHJvdW5kKHRoaXMucHhfdG9fa20ocHJvcC5jYW52YXMucGFuWCkpLFxuICAgICAgICAgICAgcm91bmQodGhpcy5weF90b19rbShwcm9wLmNhbnZhcy5wYW5ZKSlcbiAgICAgICAgXTtcblxuICAgICAgICBwcm9wLnVpLnNjYWxlIC89IDAuOTtcbiAgICAgICAgaWYgKHByb3AudWkuc2NhbGUgPiBwcm9wLnVpLnNjYWxlX21heCkge1xuICAgICAgICAgICAgcHJvcC51aS5zY2FsZSA9IHByb3AudWkuc2NhbGVfbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51aV9hZnRlcl96b29tKCk7XG5cbiAgICAgICAgcHJvcC5jYW52YXMucGFuWCA9IHJvdW5kKHRoaXMua21fdG9fcHgobGFzdHBvc1swXSkpO1xuICAgICAgICBwcm9wLmNhbnZhcy5wYW5ZID0gcm91bmQodGhpcy5rbV90b19weChsYXN0cG9zWzFdKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHVpX3pvb21fcmVzZXRcbiAgICAgKi9cbiAgICB1aV96b29tX3Jlc2V0KCkge1xuICAgICAgICBwcm9wLnVpLnNjYWxlID0gcHJvcC51aS5zY2FsZV9kZWZhdWx0O1xuXG4gICAgICAgIHRoaXMudWlfYWZ0ZXJfem9vbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9sb2dcbiAgICAgKi9cbiAgICB1aV9sb2cobWVzc2FnZSwgd2FybiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSAkKGA8c3BhbiBjbGFzcz1cIml0ZW1cIj48c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIj4ke21lc3NhZ2V9PC9zcGFuPjwvc3Bhbj5gKTtcblxuICAgICAgICBpZiAod2Fybikge1xuICAgICAgICAgICAgaHRtbC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5XQVJOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0ICRsb2cgPSAkKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkxPRyk7XG4gICAgICAgICRsb2cuYXBwZW5kKGh0bWwpO1xuICAgICAgICAkbG9nLnNjcm9sbFRvcCgkbG9nLmdldCgwKS5zY3JvbGxIZWlnaHQpO1xuXG4gICAgICAgIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWVvdXQoKHVpTG9nVmlldykgPT4ge1xuICAgICAgICAgICAgdWlMb2dWaWV3LmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkhJRERFTik7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVpTG9nVmlldy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgfSwgMywgd2luZG93LCBodG1sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgdWlfYWlycG9ydF9vcGVuXG4gICAgICovXG4gICAgdWlfYWlycG9ydF9vcGVuKCkge1xuICAgICAgICB0aGlzLiRhaXJwb3J0U3dpdGNoLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLk9QRU4pO1xuXG4gICAgICAgIGNvbnN0ICRwcmV2aW91c0FjdGl2ZUFpcnBvcnQgPSB0aGlzLiRhaXJwb3J0TGlzdC5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkFDVElWRSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbSBhIG5vLWxvbmdlci1zZWxlY3RlZCBhaXJwb3J0IGluIHRoZSBsaXN0LlxuICAgICAgICBpZiAoJHByZXZpb3VzQWN0aXZlQWlycG9ydC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICRwcmV2aW91c0FjdGl2ZUFpcnBvcnQucmVtb3ZlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGljYW8gPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5pY2FvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICQoYC5haXJwb3J0LmljYW8tJHtpY2FvfWApLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkFDVElWRSk7XG5cbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9haXJwb3J0X2Nsb3NlXG4gICAgICovXG4gICAgdWlfYWlycG9ydF9jbG9zZSgpIHtcbiAgICAgICAgdGhpcy4kYWlycG9ydFN3aXRjaC5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5PUEVOKTtcbiAgICAgICAgdGhpcy4kc3dpdGNoQWlycG9ydC5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9haXJwb3J0X3RvZ2dsZVxuICAgICAqL1xuICAgIHVpX2FpcnBvcnRfdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy4kYWlycG9ydFN3aXRjaC5oYXNDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5PUEVOKSkge1xuICAgICAgICAgICAgdGhpcy51aV9haXJwb3J0X2Nsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVpX2FpcnBvcnRfb3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19sYWJlbHNfdG9nZ2xlXG4gICAgICogQHBhcmFtIHtqcXVlcnkgZXZlbnR9XG4gICAgICovXG4gICAgY2FudmFzX2xhYmVsc190b2dnbGUoZXZlbnQpIHtcbiAgICAgICAgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuQ09OVFJPTCkudG9nZ2xlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFKTtcblxuICAgICAgICBwcm9wLmNhbnZhcy5kcmF3X2xhYmVscyA9ICFwcm9wLmNhbnZhcy5kcmF3X2xhYmVscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFVpQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX3Jlc3RyaWN0ZWRfdG9nZ2xlXG4gICAgICovXG4gICAgY2FudmFzX3Jlc3RyaWN0ZWRfdG9nZ2xlKGV2ZW50KSB7XG4gICAgICAgICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLkNPTlRST0wpXG4gICAgICAgICAgICAudG9nZ2xlQ2xhc3MoYCR7U0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuV0FSTklOR19CVVRUT059ICR7U0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFfWApO1xuXG4gICAgICAgIHByb3AuY2FudmFzLmRyYXdfcmVzdHJpY3RlZCA9ICFwcm9wLmNhbnZhcy5kcmF3X3Jlc3RyaWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19zaWRzX3RvZ2dsZVxuICAgICAqIEBwYXJhbSBldmVudCB7anF1ZXJ5IGV2ZW50fVxuICAgICAqL1xuICAgIGNhbnZhc19zaWRzX3RvZ2dsZShldmVudCkge1xuICAgICAgICAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5DT05UUk9MKS50b2dnbGVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuXG4gICAgICAgIHByb3AuY2FudmFzLmRyYXdfc2lkcyA9ICFwcm9wLmNhbnZhcy5kcmF3X3NpZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc190ZXJyYWluX3RvZ2dsZVxuICAgICAqIEBwYXJhbSBldmVudCB7anF1ZXJ5IGV2ZW50fVxuICAgICAqL1xuICAgIGNhbnZhc190ZXJyYWluX3RvZ2dsZShldmVudCkge1xuICAgICAgICAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5DT05UUk9MKS50b2dnbGVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICBwcm9wLmNhbnZhcy5kcmF3X3RlcnJhaW4gPSAhcHJvcC5jYW52YXMuZHJhd190ZXJyYWluO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVWlDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1aV9vcHRpb25zX3RvZ2dsZVxuICAgICAqL1xuICAgIHVpX29wdGlvbnNfdG9nZ2xlKCkge1xuICAgICAgICBjb25zdCAkb3B0aW9uc0RpYWxvZyA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuT1BUSU9OU19ESUFMT0cpO1xuXG4gICAgICAgIGlmICgkb3B0aW9uc0RpYWxvZy5oYXNDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5PUEVOKSkge1xuICAgICAgICAgICAgJG9wdGlvbnNEaWFsb2cucmVtb3ZlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuT1BFTik7XG4gICAgICAgICAgICAkb3B0aW9uc0RpYWxvZy5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG9wdGlvbnNEaWFsb2cuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuT1BFTik7XG4gICAgICAgICAgICAkb3B0aW9uc0RpYWxvZy5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBVaUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHVpX3NldF9zY2FsZV9mcm9tX3N0b3JhZ2VcbiAgICAgKi9cbiAgICB1aV9zZXRfc2NhbGVfZnJvbV9zdG9yYWdlKCkge1xuICAgICAgICBpZiAoIV9oYXMobG9jYWxTdG9yYWdlLCBTVE9SQUdFX0tFWS5BVENfU0NBTEUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wLnVpLnNjYWxlID0gbG9jYWxTdG9yYWdlW1NUT1JBR0VfS0VZLkFUQ19TQ0FMRV07XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tbWl4ZWQtb3BlcmF0b3JzLCBmdW5jLW5hbWVzLCBvYmplY3Qtc2hvcnRoYW5kLCBuby1wYXJhbS1yZWFzc2lnbiwgbm8tdW5kZWYgKi9cbmltcG9ydCB7IGFicyB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyBhbmdsZV9vZmZzZXQgfSBmcm9tICcuLi9tYXRoL2NpcmNsZSc7XG5pbXBvcnQgeyB2bGVuLCB2c3ViLCB2dHVybiB9IGZyb20gJy4uL21hdGgvdmVjdG9yJztcbmltcG9ydCB7IGttX2Z0LCBkZWdyZWVzVG9SYWRpYW5zIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IEdBTUVfRVZFTlRTIH0gZnJvbSAnLi4vZ2FtZS9HYW1lQ29udHJvbGxlcic7XG5cbi8vIFRPRE86IG1vdmUgdGhlc2UgdG8gYSBjb25zdGFudHMgZmlsZVxuLy8gMTQuODE2a20gPSA4bm0gKG1heCBwb3NzaWJsZSBzZXAgbWlubXVtKVxuY29uc3QgTUFYSU1VTV9TRVBBUkFUSU9OX0tNID0gMTQuODE2O1xuLy8gU3RhbmRhcmQgQmFzaWMgTGF0ZXJhbCBTZXBhcmF0aW9uIE1pbmltdW1cbmNvbnN0IFNUQU5EQVJEX0xBVEVSQUxfU0VQQVJBVElPTl9NSU5JTVVNX0tNID0gNS41NTY7IC8vIDNubVxuLy8gTWluaW11bSB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGluIGZlZXRcbmNvbnN0IE1JTl9WRVJUSUNBTF9TRVBBUkFUSU9OX0ZUID0gMTAwMDtcblxuLyoqXG4gKiBEZXRhaWxzIGFib3V0IGFpcmNyYWZ0IGluIGNsb3NlIHByb3hpbWl0eSBpbiByZWxhdGlvbiB0byAndGhlIHJ1bGVzJ1xuICpcbiAqIEBjbGFzcyBBaXJjcmFmdENvbmZsaWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpcmNyYWZ0Q29uZmxpY3Qge1xuICAgIGNvbnN0cnVjdG9yKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdGhpcy5haXJjcmFmdCA9IFtmaXJzdCwgc2Vjb25kXTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHZsZW4odnN1YihmaXJzdC5wb3NpdGlvbiwgc2Vjb25kLnBvc2l0aW9uKSk7XG4gICAgICAgIHRoaXMuZGlzdGFuY2VfZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLmFsdGl0dWRlID0gYWJzKGZpcnN0LmFsdGl0dWRlIC0gc2Vjb25kLmFsdGl0dWRlKTtcblxuICAgICAgICB0aGlzLmNvbGxpZGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jb25mbGljdHMgPSB7fTtcbiAgICAgICAgdGhpcy52aW9sYXRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy5haXJjcmFmdFswXS5hZGRDb25mbGljdCh0aGlzLCBzZWNvbmQpO1xuICAgICAgICB0aGlzLmFpcmNyYWZ0WzFdLmFkZENvbmZsaWN0KHRoaXMsIGZpcnN0KTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoZXJlIGFueXRoaW5nIHdoaWNoIHNob3VsZCBiZSBicm91Z2h0IHRvIHRoZSBjb250cm9sbGVycyBhdHRlbnRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheSBvZiBCb29sZWFufSBGaXJzdCBlbGVtZW50IHRydWUgaWYgYW55IGNvbmZsaWN0cy93YXJuaW5ncyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2Vjb25kIGVsZW1lbnQgdHJ1ZSBpZiBhbnkgdmlvbGF0aW9ucy5cbiAgICAgKi9cbiAgICBoYXNBbGVydHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oYXNDb25mbGljdCgpLCB0aGlzLmhhc1Zpb2xhdGlvbigpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgV2hldGhlciBhbnkgY29uZmxpY3RzIGFyZSBjdXJyZW50bHkgYWN0aXZlXG4gICAgICovXG4gICAgaGFzQ29uZmxpY3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmNvbmZsaWN0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmxpY3RzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgYW55IHZpb2xhdGlvbnMgYXJlIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgKi9cbiAgICBoYXNWaW9sYXRpb24oKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnZpb2xhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpb2xhdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29uZmxpY3QgYW5kIHZpb2xhdGlvbiBjaGVja3MsIHBvdGVudGlhbGx5IHJlbW92aW5nIHRoaXMgY29uZmxpY3QuXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyBBdm9pZCB0cmlnZ2VyaW5nIGFueSBtb3JlIGNvbmZsaWN0cyBpZiB0aGUgdHdvIGFpcmNyYWZ0IGhhdmUgY29sbGlkZWRcbiAgICAgICAgaWYgKHRoaXMuY29sbGlkZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpc3RhbmNlO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdmxlbih2c3ViKHRoaXMuYWlyY3JhZnRbMF0ucG9zaXRpb24sIHRoaXMuYWlyY3JhZnRbMV0ucG9zaXRpb24pKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZV9kZWx0YSA9IHRoaXMuZGlzdGFuY2UgLSBkO1xuICAgICAgICB0aGlzLmFsdGl0dWRlID0gYWJzKHRoaXMuYWlyY3JhZnRbMF0uYWx0aXR1ZGUgLSB0aGlzLmFpcmNyYWZ0WzFdLmFsdGl0dWRlKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VwYXJhdGlvbiBpcyBub3cgYmV5b25kIHRoZSBib3VuZGluZyBib3ggY2hlY2tcbiAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2UgPiBNQVhJTVVNX1NFUEFSQVRJT05fS00pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrQ29sbGlzaW9uKCk7XG4gICAgICAgIHRoaXMuY2hlY2tSdW53YXlDb2xsaXNpb24oKTtcblxuICAgICAgICAvLyBJZ25vcmUgYWlyY3JhZnQgYmVsb3cgYWJvdXQgMTAwMCBmZWV0XG4gICAgICAgIGNvbnN0IGFpcnBvcnRFbGV2YXRpb24gPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5lbGV2YXRpb247XG4gICAgICAgIGlmICgoKHRoaXMuYWlyY3JhZnRbMF0uYWx0aXR1ZGUgLSBhaXJwb3J0RWxldmF0aW9uKSA8IDk5MCkgfHxcbiAgICAgICAgICAgICgodGhpcy5haXJjcmFmdFsxXS5hbHRpdHVkZSAtIGFpcnBvcnRFbGV2YXRpb24pIDwgOTkwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBJZ25vcmUgYWlyY3JhZnQgaW4gdGhlIGZpcnN0IG1pbnV0ZSBvZiB0aGVpciBmbGlnaHRcbiAgICAgICAgaWYgKCh3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkgLSB0aGlzLmFpcmNyYWZ0WzBdLnRha2VvZmZUaW1lIDwgNjApIHx8XG4gICAgICAgICAgICAod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZSgpIC0gdGhpcy5haXJjcmFmdFswXS50YWtlb2ZmVGltZSA8IDYwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja1Byb3hpbWl0eSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjb25mbGljdCBmb3IgYm90aCBhaXJjcmFmdFxuICAgICAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5haXJjcmFmdFswXS5yZW1vdmVDb25mbGljdCh0aGlzLmFpcmNyYWZ0WzFdKTtcbiAgICAgICAgdGhpcy5haXJjcmFmdFsxXS5yZW1vdmVDb25mbGljdCh0aGlzLmFpcmNyYWZ0WzBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgY29sbGlzaW9uXG4gICAgICovXG4gICAgY2hlY2tDb2xsaXNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFpcmNyYWZ0WzBdLmlzT25Hcm91bmQoKSB8fCB0aGlzLmFpcmNyYWZ0WzFdLmlzT25Hcm91bmQoKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAgLy8gVEVNUE9SQVJZIEZJWCBGT1IgQ1JBU0hFUyBCVFdOIEFSUklWQUxTIEFORCBUQVhJSUVEIEEvQ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJzLlxuICAgICAgICAvLyBDb2xsaWRlIHdpdGhpbiAxNjAgZmVldFxuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG5cbiAgICAgICAgaWYgKCgodGhpcy5kaXN0YW5jZSA8IDAuMDUpICYmICh0aGlzLmFsdGl0dWRlIDwgMTYwKSkgJiZcbiAgICAgICAgICAgICh0aGlzLmFpcmNyYWZ0WzBdLmlzSW5zaWRlQWlyc3BhY2UoYWlycG9ydCkgJiYgdGhpcy5haXJjcmFmdFsxXS5pc0luc2lkZUFpcnNwYWNlKGFpcnBvcnQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGlkZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3RoaXMuYWlyY3JhZnRbMF0uZ2V0Q2FsbHNpZ24oKX0gY29sbGlkZWQgd2l0aCAke3RoaXMuYWlyY3JhZnRbMV0uZ2V0Q2FsbHNpZ24oKX1gLCBpc1dhcm5pbmcpO1xuXG4gICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZXZlbnRzX3JlY29yZE5ldyhHQU1FX0VWRU5UUy5DT0xMSVNJT04pO1xuICAgICAgICAgICAgdGhpcy5haXJjcmFmdFswXS5oaXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5haXJjcmFmdFsxXS5oaXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZiBlaXRoZXIgYXJlIGluIGEgcnVud2F5IHF1ZXVlLCByZW1vdmUgdGhlbSBmcm9tIGl0XG4gICAgICAgICAgICB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIucmVtb3ZlQWlyY3JhZnRGcm9tQWxsUnVud2F5UXVldWVzKHRoaXMuYWlyY3JhZnRbMF0pO1xuICAgICAgICAgICAgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLnJlbW92ZUFpcmNyYWZ0RnJvbUFsbFJ1bndheVF1ZXVlcyh0aGlzLmFpcmNyYWZ0WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHBvdGVudGlhbCBoZWFkLW9uIGNvbGxpc2lvbiBvbiBhIHJ1bndheVxuICAgICAqL1xuICAgIGNoZWNrUnVud2F5Q29sbGlzaW9uKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYWlyY3JhZnQgYXJlIG9uIGEgcG90ZW50aWFsIGNvbGxpc2lvbiBjb3Vyc2VcbiAgICAgICAgLy8gb24gdGhlIHJ1bndheVxuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBsb2dpYyBibG9jayBuZWVkcyBpdHMgb3duIG1ldGhvZC5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzYW1lIHJ1bndheSwgZGlmZmVyZW50IGVuZHMgYW5kIHVuZGVyIGFib3V0IDYgbWlsZXNcbiAgICAgICAgaWYgKCghdGhpcy5haXJjcmFmdFswXS5pc1RheGlpbmcoKSAmJiAhdGhpcy5haXJjcmFmdFsxXS5pc1RheGlpbmcoKSkgJiZcbiAgICAgICAgICAgICh0aGlzLmFpcmNyYWZ0WzBdLnJ3eV9kZXAgIT09IG51bGwpICYmXG4gICAgICAgICAgICAodGhpcy5haXJjcmFmdFswXS5yd3lfZGVwICE9PSB0aGlzLmFpcmNyYWZ0WzFdLnJ3eV9kZXApICYmXG4gICAgICAgICAgICAoYWlycG9ydC5nZXRSdW53YXkodGhpcy5haXJjcmFmdFsxXS5yd3lfZGVwKSA9PT0gYWlycG9ydC5nZXRSdW53YXkodGhpcy5haXJjcmFmdFswXS5yd3lfZGVwKSkgJiZcbiAgICAgICAgICAgICh0aGlzLmRpc3RhbmNlIDwgMTApXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZsaWN0cy5ydW53YXlDb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZsaWN0cy5ydW53YXlDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKFxuICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmFpcmNyYWZ0WzBdLmdldENhbGxzaWduKCl9IGFwcGVhcnMgb24gYSBjb2xsaXNpb24gY291cnNlIHdpdGhgICtcbiAgICAgICAgICAgICAgICAgICAgYCAke3RoaXMuYWlyY3JhZnRbMV0uZ2V0Q2FsbHNpZ24oKX0gb24gdGhlIHNhbWUgcnVud2F5XCJgLFxuICAgICAgICAgICAgICAgICAgICBpc1dhcm5pbmdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25mbGljdHMucnVud2F5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIG1ldGhvZCBpcyByaXBlIGZvciByZWZhY3Rvci4gbG90cyBvZiBsb2dpYyB0aGF0IGNhbiBiZSBwdWxsZWQgb3V0IHRvXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9ucyBvciBvdGhlciBjbGFzcyBtZXRob2RzLlxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBwaHlzaWNhbCBwcm94aW1pdHkgYW5kIHRyaWdnZXIgY3Jhc2hlcyBpZiBuZWNlc3NhcnlcbiAgICAgKi9cbiAgICBjaGVja1Byb3hpbWl0eSgpIHtcbiAgICAgICAgLy8gTm8gY29uZmxpY3Qgb3Igd2FybmluZyBpZiB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuYWx0aXR1ZGUgPj0gTUlOX1ZFUlRJQ0FMX1NFUEFSQVRJT05fRlQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmxpY3RzLnByb3hpbWl0eUNvbmZsaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbmZsaWN0cy5wcm94aW1pdHlWaW9sYXRpb24gPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbmZsaWN0ID0gZmFsc2U7XG4gICAgICAgIGxldCB2aW9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IGRpc2FibGVOb3RpY2VzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGExID0gdGhpcy5haXJjcmFmdFswXTtcbiAgICAgICAgY29uc3QgYTIgPSB0aGlzLmFpcmNyYWZ0WzFdO1xuICAgICAgICBsZXQgYXBwbGljYWJsZUxhdFNlcE1pbiA9IFNUQU5EQVJEX0xBVEVSQUxfU0VQQVJBVElPTl9NSU5JTVVNX0tNO1xuXG5cbiAgICAgICAgLy8gRXN0YWJsaXNoZWQgb24gcHJlY2lzaW9uIGd1aWRlZCBhcHByb2FjaGVzICYmIGJvdGggYXJlIGZvbGxvd2luZyBkaWZmZXJlbnQgaW5zdHJ1bWVudCBhcHByb2FjaGVzXG4gICAgICAgIGlmICgoYTEuaXNQcmVjaXNpb25HdWlkZWQoKSAmJiBhMi5pc1ByZWNpc2lvbkd1aWRlZCgpKSAmJiAoYTEucnd5X2FyciAhPT0gYTIucnd5X2FycikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bndheVJlbGF0aW9uc2hpcCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLm1ldGFkYXRhLnJ3eVthMS5yd3lfYXJyXVthMi5yd3lfYXJyXTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGFwcGxpY2FibGUgbGF0ZXJhbCBzZXBhcmF0aW9uIG1pbmltYSBmb3IgY29uZHVjdGluZ1xuICAgICAgICAgICAgLy8gcGFyYWxsZWwgc2ltdWx0YW5lb3VzIGRlcGVuZGVudCBhcHByb2FjaGVzIG9uIHRoZXNlIHJ1bndheXM6XG4gICAgICAgICAgICBpZiAocnVud2F5UmVsYXRpb25zaGlwLnBhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlkZSBub3RpY2VzIGZvciBhaXJjcmFmdCBvbiBhZGphY2VudCBmaW5hbCBhcHByb2FjaCBjb3Vyc2VzXG4gICAgICAgICAgICAgICAgZGlzYWJsZU5vdGljZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYSBoZWxwZXIgZnVuY3Rpb246IGZpbmRTZXBhcmF0aW9uTWluaW11bSA9IChmZWV0QmV0d2VlbikgPT4ge307XG4gICAgICAgICAgICAgICAgY29uc3QgZmVldEJldHdlZW4gPSBrbV9mdChydW53YXlSZWxhdGlvbnNoaXAubGF0ZXJhbF9kaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmVldEJldHdlZW4gPCAyNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1bndheXMgc2VwYXJhdGVkIGJ5IDwyNTAwJ1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlTGF0U2VwTWluID0gU1RBTkRBUkRfTEFURVJBTF9TRVBBUkFUSU9OX01JTklNVU1fS007ICAvLyAzLjBubVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVldEJldHdlZW4gPj0gMjUwMCAmJiBmZWV0QmV0d2VlbiA8PSAzNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDI1MDAnLTM2MDAnXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGVMYXRTZXBNaW4gPSAxLjg1MjsgIC8vIDEuMG5tXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmZWV0QmV0d2VlbiA+IDM2MDAgJiYgZmVldEJldHdlZW4gPD0gNDMwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAzNjAwJy00MzAwJ1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlTGF0U2VwTWluID0gMi43Nzg7ICAvLyAxLjVubVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVldEJldHdlZW4gPiA0MzAwICYmIGZlZXRCZXR3ZWVuIDw9IDkwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNDMwMCctOTAwMCdcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZUxhdFNlcE1pbiA9IDMuNzA0OyAgLy8gMi4wbm1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZlZXRCZXR3ZWVuID4gOTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSdW53YXlzIHNlcGFyYXRlZCBieSA+OTAwMCdcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZUxhdFNlcE1pbiA9IFNUQU5EQVJEX0xBVEVSQUxfU0VQQVJBVElPTl9NSU5JTVVNX0tNOyAgLy8gMy4wbm1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIGFib3ZlIGRvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHRoZSAobW9yZSBjb21wbGljYXRlZClcbiAgICAgICAgICAgICAgICAvLyBydWxlcyBmb3IgZHVhbC90cmlwbGUgc2ltdWx0YW5lb3VzIHBhcmFsbGVsIGRlcGVuZGVudCBhcHByb2FjaGVzIGFzXG4gICAgICAgICAgICAgICAgLy8gb3V0bGluZWQgYnkgRkFBIEpPIDcxMTAuNjUsIHBhcmEgNS05LTcuIFVzZXJzIHBsYXlpbmcgYXQgYW55IG9mIG91clxuICAgICAgICAgICAgICAgIC8vIGFpcnBvcnRzIHRoYXQgaGF2ZSB0cmlwbGUgcGFyYWxsZWxzIG1heSBiZSBhYmxlIHRvIFwiZ2V0IGF3YXkgd2l0aFwiXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxlc3MgcmVzdHJpY3RpdmUgcnVsZXMsIHdoaWxzdCB0aGVpciB0cmFmZmljIG1heSBub3QgYmUgMTAwJVxuICAgICAgICAgICAgICAgIC8vIGxlZ2FsLiBJdCdzIGp1c3QgY29tcGxpY2F0ZWQgYW5kIG5vdCBjdXJyZW50bHkgd29ydGh3aGlsZSB0byBhZGRcbiAgICAgICAgICAgICAgICAvLyBydWxlcyBmb3IgcnVubmluZyB0cmlwcyBhdCB0aGlzIHBvaW50Li4uIG1heWJlIGxhdGVyLiAtQGVyaWtxdWlublxuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZTogRkFBIEpPIDcxMTAuNjUsIHNlY3Rpb24gNS05LTZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGFub3RoZXIgY2xhc3MgbWV0aG9kOiBoYXNTZXBhcmF0aW9uVmlvbGF0aW9uKGFwcGxpY2FibGVMYXRTZXBNaW4pXG4gICAgICAgIC8vIENvbnNpZGVyaW5nIGFsbCBvZiB0aGUgYWJvdmUgY2FzZXMsLi4uXG4gICAgICAgIHZpb2xhdGlvbiA9ICh0aGlzLmRpc3RhbmNlIDwgYXBwbGljYWJsZUxhdFNlcE1pbik7XG4gICAgICAgIC8vIFRPRE86IGVudW1lcmF0ZSB0aGUgbWFnaWMgbnVtYmVyLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbm90aGVyIGNsYXNzIG1ldGhvZFxuICAgICAgICBjb25mbGljdCA9ICh0aGlzLmRpc3RhbmNlIDwgYXBwbGljYWJsZUxhdFNlcE1pbiArIDEuODUyICYmICFkaXNhYmxlTm90aWNlcykgfHwgdmlvbGF0aW9uOyAgLy8gKzEuMG5tXG5cbiAgICAgICAgLy8gXCJQYXNzaW5nICYgRGl2ZXJnaW5nXCIgUnVsZXMgKHRoZSBcImV4Y2VwdGlvblwiIHRvIGFsbCBvZiB0aGUgYWJvdmUgcnVsZXMpXG4gICAgICAgIC8vIHRlc3QgdGhlIGJlbG93IG9ubHkgaWYgc2VwYXJhdGlvbiBpcyBjdXJyZW50bHkgY29uc2lkZXJlZCBpbnN1ZmZpY2llbnRcbiAgICAgICAgaWYgKGNvbmZsaWN0KSB7XG4gICAgICAgICAgICBjb25zdCBoZGdfZGlmZmVyZW5jZSA9IGFicyhhbmdsZV9vZmZzZXQoYTEuZ3JvdW5kVHJhY2ssIGEyLmdyb3VuZFRyYWNrKSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBjb3VsZG50IHRoZXNlIHR3byBpZnMgYmUgY29tYmluZWQgdG8gc29tZXRoaW5nIGxpa2U6XG4gICAgICAgICAgICAvLyBpZiAoaGRnX2RpZmZlcmVuY2UgPj0gZGVncmVlc1RvUmFkaWFucygxNSkgJiYgaGRnX2RpZmZlcmVuY2UgPiBkZWdyZWVzVG9SYWRpYW5zKDE2NSkpIHt9XG4gICAgICAgICAgICBpZiAoaGRnX2RpZmZlcmVuY2UgPj0gZGVncmVlc1RvUmFkaWFucygxNSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGRnX2RpZmZlcmVuY2UgPiBkZWdyZWVzVG9SYWRpYW5zKDE2NSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ29wcG9zaXRlJyBjb3Vyc2VzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3RhbmNlX2RlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT0tBWSBJRiB0aGUgZGlzdGFuY2UgaXMgaW5jcmVhc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgZGVmaW5pdGVseSBiZSBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IGxpdmVzIGluIG9uZSBvZiB0aGUgbWF0aC8gZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gJ3NhbWUnIG9yICdjcm9zc2luZycgY291cnNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBSYXkgaW50ZXJzZWN0aW9uIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjkzMjYwMVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZCA9IHZ0dXJuKGExLmdyb3VuZFRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmQgPSB2dHVybihhMi5ncm91bmRUcmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gYTIucG9zaXRpb25bMF0gLSBhMS5wb3NpdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBhMi5wb3NpdGlvblsxXSAtIGExLnBvc2l0aW9uWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXQgPSBiZFswXSAqIGFkWzFdIC0gYmRbMV0gKiBhZFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdSA9IChkeSAqIGJkWzBdIC0gZHggKiBiZFsxXSkgLyBkZXQ7ICAvLyBhMSdzIGRpc3RhbmNlIGZyb20gcG9pbnQgb2YgY29udmVyZ2VuY2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IChkeSAqIGFkWzBdIC0gZHggKiBhZFsxXSkgLyBkZXQ7ICAvLyBhMidzIGRpc3RhbmNlIGZyb20gcG9pbnQgb2YgY29udmVyZ2VuY2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IGxpdmUgaW4gb25lIG9mIHRoZSBtYXRoLyBmaWxlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHUgPCAwKSB8fCAodiA8IDApKSB7IC8vIGNoZWNrIGlmIGVpdGhlciBhL2MgaGFzIHBhc3NlZCB0aGUgcG9pbnQgb2YgY29udmVyZ2VuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0ID0gZmFsc2U7ICAvLyB0YXJnZXRzIGFyZSBkaXZlcmdpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpb2xhdGlvbiA9IGZhbHNlOyAgLy8gdGFyZ2V0cyBhcmUgZGl2ZXJnaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlOiBGQUEgSk8gNzExMC42NSwgc2VjdGlvbiA1LTUtNy1hLTE6XG4gICAgICAgICAgICAgICAgICAgIC8vIChhKSBBaXJjcmFmdCBhcmUgb24gb3Bwb3NpdGUvcmVjaXByb2NhbCBjb3Vyc2VzIGFuZCB5b3UgaGF2ZSBvYnNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZXkgaGF2ZSBwYXNzZWQgZWFjaCBvdGhlcjsgb3IgYWlyY3JhZnQgYXJlIG9uIHNhbWUgb3IgY3Jvc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gY291cnNlcy9hc3NpZ25lZCByYWRhciB2ZWN0b3JzIGFuZCBvbmUgYWlyY3JhZnQgaGFzIGNyb3NzZWQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2plY3RlZCBjb3Vyc2Ugb2YgdGhlIG90aGVyLCBhbmQgdGhlIGFuZ3VsYXIgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZWlyIGNvdXJzZXMvYXNzaWduZWQgcmFkYXIgdmVjdG9ycyBpcyBhdCBsZWFzdCAxNSBkZWdyZWVzLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBDb25mbGljdHNcbiAgICAgICAgaWYgKGNvbmZsaWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZsaWN0cy5wcm94aW1pdHlDb25mbGljdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZsaWN0cy5wcm94aW1pdHlDb25mbGljdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpb2xhdGlvbikge1xuICAgICAgICAgICAgdGhpcy52aW9sYXRpb25zLnByb3hpbWl0eVZpb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgc2NvcmUgcGVuYWx0eSBmb3IgJ1NFUEFSQVRJT05fTE9TUycsIGJ1dCBvbmx5IE9OQ0VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlvbGF0aW9ucy5wcm94aW1pdHlWaW9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby11bnVzZWQtdmFycywgbm8tdW5kZWYsIGdsb2JhbC1yZXF1aXJlICovXG5pbXBvcnQgX3dpdGhvdXQgZnJvbSAnbG9kYXNoL3dpdGhvdXQnO1xuaW1wb3J0IEFpcmNyYWZ0Q29uZmxpY3QgZnJvbSAnLi9BaXJjcmFmdENvbmZsaWN0JztcbmltcG9ydCBBaXJjcmFmdE1vZGVsIGZyb20gJy4vQWlyY3JhZnRNb2RlbCc7XG5pbXBvcnQgeyBzcGVlY2hfc2F5IH0gZnJvbSAnLi4vc3BlZWNoJztcbmltcG9ydCB7IGFicyB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyBkaXN0YW5jZTJkIH0gZnJvbSAnLi4vbWF0aC9kaXN0YW5jZSc7XG5pbXBvcnQgeyB2bGVuLCB2cmFkaWFsLCB2c3ViIH0gZnJvbSAnLi4vbWF0aC92ZWN0b3InO1xuaW1wb3J0IHsga25fbXMsIHJhZGlhbnNUb0RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMgfSBmcm9tICcuLi91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMnO1xuaW1wb3J0IHsgY2FsY1R1cm5Jbml0aWF0aW9uRGlzdGFuY2UgfSBmcm9tICcuLi9tYXRoL2ZsaWdodE1hdGgnO1xuaW1wb3J0IHsgdGF1IH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsgR0FNRV9FVkVOVFMgfSBmcm9tICcuLi9nYW1lL0dhbWVDb250cm9sbGVyJztcblxuLy8gVGVtcG9yYXJ5IGNvbnN0IGRlY2xhcmF0aW9uIGhlcmUgdG8gYXR0YWNoIHRvIHRoZSB3aW5kb3cgQU5EIHVzZSBhcyBpbnRlcm5hbCBwcm9wZXJ0eVxuY29uc3QgYWlyY3JhZnQgPSB7fTtcblxuLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgcmVuYW1lZCB0byBgQWlyY3JhZnRDb2xsZWN0aW9uYFxuLyoqXG4gKiBAY2xhc3MgQWlyY3JhZnRDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpcmNyYWZ0Q29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWlyY3JhZnQgPSBhaXJjcmFmdDtcbiAgICAgICAgdGhpcy5haXJjcmFmdC5tb2RlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5haXJjcmFmdC5jYWxsc2lnbnMgPSBbXTtcbiAgICAgICAgdGhpcy5haXJjcmFmdC5saXN0ID0gW107XG4gICAgICAgIHRoaXMuYWlyY3JhZnQuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWlyY3JhZnQuYXV0byA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgICAgcHJvcC5haXJjcmFmdCA9IGFpcmNyYWZ0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBhaXJjcmFmdF9hdXRvX3RvZ2dsZVxuICAgICAqL1xuICAgIGFpcmNyYWZ0X2F1dG9fdG9nZ2xlKCkge1xuICAgICAgICBwcm9wLmFpcmNyYWZ0LmF1dG8uZW5hYmxlZCA9ICF0aGlzLmFpcmNyYWZ0LmF1dG8uZW5hYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaXNDYWxsc2lnbkluTGlzdFxuICAgICAqIEBwYXJhbSBjYWxsc2lnbiB7c3RyaW5nfVxuICAgICAqIHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NhbGxzaWduSW5MaXN0KGNhbGxzaWduKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFpcmNyYWZ0LmNhbGxzaWducy5pbmRleE9mKGNhbGxzaWduKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IGNhbGxzaWduIHRvIGBhaXJjcmFmdC5jYWxsc2lnbnNgXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmNyYWZ0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYWRkQ2FsbHNpZ25Ub0xpc3RcbiAgICAgKiBAcGFyYW0gY2FsbHNpZ24ge3N0cmluZ31cbiAgICAgKi9cbiAgICBhZGRDYWxsc2lnblRvTGlzdChjYWxsc2lnbikge1xuICAgICAgICBpZiAodGhpcy5pc0NhbGxzaWduSW5MaXN0KGNhbGxzaWduKSkge1xuICAgICAgICAgICAgLy8gaWYgeW91J3ZlIG1hZGUgaXQgaGVyZSBzb21ldGhpbmcgaGFzIGdvbmUgdmVyeSB3cm9uZy4gZ2VuZXJhdGlvbiBvZiBhIGNhbGxzaWduL2ZsaWdodE51bWJlciBzaG91bGRcbiAgICAgICAgICAgIC8vIGFsc28gaW5jbHVkZSB2ZXJpZmljYXRpb24gdGhhdCB0aGUgY2FsbHNpZ24vZmxpZ2h0TnVtYmVyIGlzIHVuaXF1ZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhbGxzaWdufSBhbHJlYWR5IGV4aXN0cyB3aXRoaW4gdGhlIGNhbGxzaWducyBsaXN0IWApO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFpcmNyYWZ0LmNhbGxzaWducy5wdXNoKGNhbGxzaWduKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYWlyY3JhZnRfbmV3XG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBhaXJjcmFmdF9uZXcob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhaXJsaW5lID0gd2luZG93LmFpcmxpbmVDb250cm9sbGVyLmFpcmxpbmVfZ2V0KG9wdGlvbnMuYWlybGluZSk7XG5cbiAgICAgICAgcmV0dXJuIGFpcmxpbmUuZ2VuZXJhdGVBaXJjcmFmdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYWlyY3JhZnRfZ2V0X25lYXJlc3RcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBhaXJjcmFmdF9nZXRfbmVhcmVzdChwb3NpdGlvbikge1xuICAgICAgICBsZXQgbmVhcmVzdCA9IG51bGw7XG4gICAgICAgIGxldCBkaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5haXJjcmFmdC5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhaXJjcmFmdCA9IHRoaXMuYWlyY3JhZnQubGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZTJkKGFpcmNyYWZ0LnBvc2l0aW9uLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChkIDwgZGlzdGFuY2UgJiYgYWlyY3JhZnQuaXNWaXNpYmxlKCkgJiYgIWFpcmNyYWZ0LmhpdCkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICBuZWFyZXN0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbdGhpcy5haXJjcmFmdC5saXN0W25lYXJlc3RdLCBkaXN0YW5jZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcmNyYWZ0X2FkZFxuICAgICAqIEBwYXJhbSBtb2RlbCB7QWlyY3JhZnRNb2RlbHxvYmplY3R9XG4gICAgICovXG4gICAgYWlyY3JhZnRfYWRkKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuYWlyY3JhZnQubW9kZWxzW21vZGVsLmljYW8udG9Mb3dlckNhc2UoKV0gPSBtb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0Q29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYWlyY3JhZnRfdmlzaWJsZVxuICAgICAqIEBwYXJhbSBhaXJjcmFmdFxuICAgICAqIEBwYXJhbSBmYWN0b3JcbiAgICAgKi9cbiAgICBhaXJjcmFmdF92aXNpYmxlKGFpcmNyYWZ0LCBmYWN0b3IgPSAxKSB7XG4gICAgICAgIHJldHVybiB2bGVuKGFpcmNyYWZ0LnBvc2l0aW9uKSA8IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmN0cl9yYWRpdXMgKiBmYWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcmNyYWZ0X3JlbW92ZV9hbGxcbiAgICAgKi9cbiAgICBhaXJjcmFmdF9yZW1vdmVfYWxsKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWlyY3JhZnQubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5haXJjcmFmdC5saXN0W2ldLmNsZWFudXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWlyY3JhZnQubGlzdCA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBhaXJjcmFmdF9yZW1vdmVcbiAgICAgKi9cbiAgICBhaXJjcmFmdF9yZW1vdmUoYWlyY3JhZnQpIHtcbiAgICAgICAgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLnJlbW92ZUFpcmNyYWZ0RnJvbUFsbFJ1bndheVF1ZXVlcyhhaXJjcmFmdCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2FsbHNpZ25Gcm9tTGlzdChhaXJjcmFmdC5jYWxsc2lnbik7XG4gICAgICAgIHRoaXMucmVtb3ZlQWlyY3JhZnRJbnN0YW5jZU1vZGVsRnJvbUxpc3QoYWlyY3JhZnQpO1xuICAgICAgICBhaXJjcmFmdC5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcmNyYWZ0X3VwZGF0ZVxuICAgICAqL1xuICAgIGFpcmNyYWZ0X3VwZGF0ZSgpIHtcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRvIF9mb3JFYWNoKClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWlyY3JhZnQubGlzdFtpXS51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuYWlyY3JhZnQubGlzdFtpXS51cGRhdGVXYXJuaW5nKCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdGhpcyBJbm5lckxvb3AgdGhpbmcgdG8gYSBmdW5jdGlvbiBzbyB3ZSBjYW4gZ2V0IHJpZCBvZiB0aGUgY29udGludWUgSW5uZXJMb29wIHRoaW5nLlxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5haXJjcmFmdC5saXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCBiZXR0ZXIgbmFtZXMgaGVyZS4gd2hhdCBpcyBgdGhhdGA/ICB3aGF0IGlzIGBvdGhlcmA/XG4gICAgICAgICAgICAgICAgY29uc3QgYWlyY3JhZnQgPSB0aGlzLmFpcmNyYWZ0Lmxpc3RbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJBaXJjcmFmdCA9IHRoaXMuYWlyY3JhZnQubGlzdFtqXTtcblxuICAgICAgICAgICAgICAgIGlmIChhaXJjcmFmdC5jaGVja0NvbmZsaWN0KG90aGVyQWlyY3JhZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhc3QgMkQgYm91bmRpbmcgYm94IGNoZWNrLCB0aGVyZSBhcmUgbm8gY29uZmxpY3RzIG92ZXIgOG5tIGFwYXJ0ICgxNC44MTZrbSlcbiAgICAgICAgICAgICAgICAvLyBubyB2aW9sYXRpb24gY2FuIG9jY3VyIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICAvLyBWYXJpYXRpb24gb2Y6XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU4Ni93aGF0LWlzLXRoZS1mYXN0ZXN0LXdheS10by13b3JrLW91dC0yZC1ib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBhYnMoYWlyY3JhZnQucG9zaXRpb25bMF0gLSBvdGhlckFpcmNyYWZ0LnBvc2l0aW9uWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeSA9IGFicyhhaXJjcmFmdC5wb3NpdGlvblsxXSAtIG90aGVyQWlyY3JhZnQucG9zaXRpb25bMV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0aGlzIHZhbHVlIHRvIGEgY29uc3RhbnRcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlmL2Vsc2UgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDE0LjgxNikgfHwgKGR5ID4gMTQuODE2KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBnbyBzb21ld2hlcmUgYW5kIG5vdCBqdXN0IGJlIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgICBuZXcgQWlyY3JhZnRDb25mbGljdChhaXJjcmFmdCwgb3RoZXJBaXJjcmFmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWlyY3JhZnQubGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJlbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgYWlyY3JhZnQgPSB0aGlzLmFpcmNyYWZ0Lmxpc3RbaV07XG4gICAgICAgICAgICAvLyBsZXQgaXNfdmlzaWJsZSA9IGFpcmNyYWZ0X3Zpc2libGUoYWlyY3JhZnQpO1xuXG4gICAgICAgICAgICBpZiAoYWlyY3JhZnQuaXNTdG9wcGVkKCkgJiYgYWlyY3JhZnQuY2F0ZWdvcnkgPT09ICdhcnJpdmFsJykge1xuICAgICAgICAgICAgICAgIGFpcmNyYWZ0LnNjb3JlV2luZCgnbGFuZGVkJyk7XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgJHthaXJjcmFmdC5nZXRDYWxsc2lnbigpfSBzd2l0Y2hpbmcgdG8gZ3JvdW5kLCBnb29kIGRheWApO1xuICAgICAgICAgICAgICAgIHNwZWVjaF9zYXkoW1xuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdjYWxsc2lnbicsIGNvbnRlbnQ6IGFpcmNyYWZ0IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnLCBzd2l0Y2hpbmcgdG8gZ3JvdW5kLCBnb29kIGRheScgfVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuQVJSSVZBTCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFpcmNyYWZ0LmhpdCAmJiBhaXJjcmFmdC5pc09uR3JvdW5kKCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgTG9zdCByYWRhciBjb250YWN0IHdpdGggJHthaXJjcmFmdC5nZXRDYWxsc2lnbigpfWApO1xuICAgICAgICAgICAgICAgIHNwZWVjaF9zYXkoW1xuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdjYWxsc2lnbicsIGNvbnRlbnQ6IGFpcmNyYWZ0IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnLCByYWRhciBjb250YWN0IGxvc3QnIH1cbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBzY3JlZW4gZnJvbSBhaXJjcmFmdCB0aGF0IGFyZSB0b28gZmFyXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKCF0aGlzLmFpcmNyYWZ0X3Zpc2libGUoYWlyY3JhZnQsIDIpICYmICFhaXJjcmFmdC5pbnNpZGVfY3RyKSAmJlxuICAgICAgICAgICAgICAgIGFpcmNyYWZ0LmZtcy5jdXJyZW50V2F5cG9pbnQubmF2bW9kZSA9PT0gJ2hlYWRpbmcnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoYWlyY3JhZnQuY2F0ZWdvcnkgPT09ICdhcnJpdmFsJyB8fCBhaXJjcmFmdC5jYXRlZ29yeSA9PT0gJ2RlcGFydHVyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFpcmNyYWZ0X3JlbW92ZShhaXJjcmFmdCk7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSB0dXJuIGluaXRpYXRpb24gZGlzdGFuY2UgZm9yIGFuIGFpcmNyYWZ0IHRvIG5hdmlnYXRlIGJldHdlZW4gdHdvIGZpeGVzLlxuICAgICAqXG4gICAgICogUmVmZXJlbmNlczpcbiAgICAgKiAtIGh0dHA6Ly93d3cub2hpby5lZHUvcGVvcGxlL3VpanRkZWhhL2VlNjkwMF9mbXNfMDBfb3ZlcnZpZXcucGRmLCBGbHktYnkgd2F5cG9pbnRcbiAgICAgKiAtIFRoZSBBdmlvbmljcyBIYW5kYm9vaywgY2ggMTVcbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBhaXJjcmFmdF90dXJuX2luaXRpYXRpb25fZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0gYWlyY3JhZnQge0FpcmNyYWZ0SW5zdGFuY2VNb2RlbH1cbiAgICAgKiBAcGFyYW0gZml4XG4gICAgICovXG4gICAgYWlyY3JhZnRfdHVybl9pbml0aWF0aW9uX2Rpc3RhbmNlKGFpcmNyYWZ0LCBmaXgpIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBpcyByaXBlIGZvciByZWZhY3Rvci4gdGhlcmUgaXMgYSBsb3Qgb2YgaW5saW5lIGxvZ2ljIHRoYXQgY2FuIGJlIGFic3RyYWN0ZWQgYW5kL29yIHB1bGxlZCBvdXRcbiAgICAgICAgY29uc3QgaW5kZXggPSBhaXJjcmFmdC5mbXMuaW5kZXhPZkN1cnJlbnRXYXlwb2ludCgpLndwO1xuICAgICAgICBpZiAoaW5kZXggPj0gYWlyY3JhZnQuZm1zLndheXBvaW50cygpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBzdWJzZXF1ZW50IGZpeGVzLCBmbHkgb3ZlciAnZml4J1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IGtub3RzIHRvIG0vc1xuICAgICAgICBjb25zdCBzcGVlZCA9IGtuX21zKGFpcmNyYWZ0LnNwZWVkKTtcbiAgICAgICAgLy8gYXNzdW1lIG5vbWluYWwgYmFuayBhbmdsZSBvZiAyNSBkZWdyZWVzIGZvciBhbGwgYWlyY3JhZnRcbiAgICAgICAgY29uc3QgYmFua19hbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnMoMjUpO1xuXG4gICAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgZ2V0TmV4dFdheXBvaW50KCkgZnVuY3Rpb24/XG4gICAgICAgIGNvbnN0IG5leHRmaXggPSBhaXJjcmFmdC5mbXMud2F5cG9pbnQoYWlyY3JhZnQuZm1zLmluZGV4T2ZDdXJyZW50V2F5cG9pbnQoKS53cCArIDEpLmxvY2F0aW9uO1xuICAgICAgICBpZiAoIW5leHRmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vbWluYWxfbmV3X2NvdXJzZSA9IHZyYWRpYWwodnN1YihuZXh0Zml4LCBmaXgpKTtcbiAgICAgICAgaWYgKG5vbWluYWxfbmV3X2NvdXJzZSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhpcyBkb2luZz8gdGhpcyBzaG91bGQgZ28gaW4gYSBuZXcgbWV0aG9kLlxuICAgICAgICAgICAgbm9taW5hbF9uZXdfY291cnNlICs9IHRhdSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRfaGVhZGluZyA9IGFpcmNyYWZ0LmhlYWRpbmc7XG4gICAgICAgIGlmIChjdXJyZW50X2hlYWRpbmcgPCAwKSB7XG4gICAgICAgICAgICBjdXJyZW50X2hlYWRpbmcgKz0gdGF1KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIGZ1bmN0aW9uXG4gICAgICAgIGxldCBjb3Vyc2VfY2hhbmdlID0gYWJzKHJhZGlhbnNUb0RlZ3JlZXMoY3VycmVudF9oZWFkaW5nKSAtIHJhZGlhbnNUb0RlZ3JlZXMobm9taW5hbF9uZXdfY291cnNlKSk7XG4gICAgICAgIGlmIChjb3Vyc2VfY2hhbmdlID4gMTgwKSB7XG4gICAgICAgICAgICBjb3Vyc2VfY2hhbmdlID0gMzYwIC0gY291cnNlX2NoYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdXJzZV9jaGFuZ2UgPSBkZWdyZWVzVG9SYWRpYW5zKGNvdXJzZV9jaGFuZ2UpO1xuICAgICAgICAvLyBtZXRlcnMsIGJhbmsgZXN0YWJsaXNobWVudCBpbiAxc1xuICAgICAgICBjb25zdCB0dXJuX2luaXRpYXRpb25fZGlzdGFuY2UgPSBjYWxjVHVybkluaXRpYXRpb25EaXN0YW5jZShzcGVlZCwgYmFua19hbmdsZSwgY291cnNlX2NoYW5nZSk7XG5cbiAgICAgICAgcmV0dXJuIHR1cm5faW5pdGlhdGlvbl9kaXN0YW5jZSAvIDEwMDA7IC8vIGNvbnZlcnQgbSB0byBrbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBhaXJjcmFmdF9nZXRcbiAgICAgKiBAcGFyYW0gZWlkXG4gICAgICovXG4gICAgYWlyY3JhZnRfZ2V0KGVpZCA9IG51bGwpIHtcbiAgICAgICAgaWYgKGVpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IG91dC1vZi1yYW5nZSBlcnJvclxuICAgICAgICBpZiAodGhpcy5haXJjcmFmdC5saXN0Lmxlbmd0aCA+IGVpZCAmJiBlaWQgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWlyY3JhZnQubGlzdFtlaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcmNyYWZ0X2dldF9ieV9jYWxsc2lnblxuICAgICAqIEBwYXJhbSBjYWxsc2lnbiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFpcmNyYWZ0X2dldF9ieV9jYWxsc2lnbihjYWxsc2lnbikge1xuICAgICAgICBjYWxsc2lnbiA9IFN0cmluZyhjYWxsc2lnbik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFpcmNyYWZ0Lmxpc3RbaV0uY2FsbHNpZ24gPT09IGNhbGxzaWduLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5haXJjcmFmdC5saXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcmNyYWZ0X2dldF9laWRfYnlfY2FsbHNpZ25cbiAgICAgKiBAcGFyYW0gY2FsbHNpZ24ge3N0cmluZ31cbiAgICAgKi9cbiAgICBhaXJjcmFmdF9nZXRfZWlkX2J5X2NhbGxzaWduKGNhbGxzaWduKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5haXJjcmFmdC5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhaXJjcmFmdCA9IHRoaXMuYWlyY3JhZnQubGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKGFpcmNyYWZ0LmNhbGxzaWduID09PSBjYWxsc2lnbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFpcmNyYWZ0LmVpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBhaXJjcmFmdF9tb2RlbF9nZXRcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFpcmNyYWZ0X21vZGVsX2dldChpY2FvKSB7XG4gICAgICAgIGlmICghKHRoaXMuYWlyY3JhZnQubW9kZWxzW2ljYW9dKSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgQWlyY3JhZnRNb2RlbCh7XG4gICAgICAgICAgICAgICAgaWNhbyxcbiAgICAgICAgICAgICAgICB1cmw6IGBhc3NldHMvYWlyY3JhZnQvJHtpY2FvfS5qc29uYFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuYWlyY3JhZnQubW9kZWxzW2ljYW9dID0gbW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5haXJjcmFmdC5tb2RlbHNbaWNhb107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgYWlyY3JhZnQgZnJvbSBgQWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0YFxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWlyY3JhZnRJbnN0YW5jZU1vZGVsRnJvbUxpc3RcbiAgICAgKiBAcGFyYW0gIHtBaXJjcmFmdH0gYWlyY3JhZnQgdGhlIGFpcmNyYWZ0IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZUFpcmNyYWZ0SW5zdGFuY2VNb2RlbEZyb21MaXN0KGFpcmNyYWZ0KSB7XG4gICAgICAgIHRoaXMuYWlyY3JhZnQubGlzdCA9IF93aXRob3V0KHRoaXMuYWlyY3JhZnQubGlzdCwgYWlyY3JhZnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZsaWdodCBudW1iZXIgZnJvbSB0aGUgbGlzdCBzdG9yZWQgaW4gYEFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdC5jYWxsc2lnbnNgXG4gICAgICogQGZvciBBaXJjcmFmdENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNhbGxzaWduRnJvbUxpc3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxzaWduIHRoZSBmbGlnaHQgbnVtYmVyIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZUNhbGxzaWduRnJvbUxpc3QoY2FsbHNpZ24pIHtcbiAgICAgICAgdGhpcy5haXJjcmFmdC5jYWxsc2lnbnMgPSBfd2l0aG91dCh0aGlzLmFpcmNyYWZ0LmNhbGxzaWducywgY2FsbHNpZ24pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdoYXQgaXMgYW4gYGVpZGAgYW5kIHdoeSB3b3VsZCBpdCBiZWVkIHRvIGJlIHVwZGF0ZWQ/XG4gICAgLyoqXG4gICAgICogQWRqdXN0IGFsbCBhaXJjcmFmdCdzIGVpZCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCB1cGRhdGVfYWlyY3JhZnRfZWlkc1xuICAgICAqL1xuICAgIHVwZGF0ZV9haXJjcmFmdF9laWRzKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWlyY3JhZnQubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGVpZCBpbiBhaXJjcmFmdFxuICAgICAgICAgICAgdGhpcy5haXJjcmFmdC5saXN0W2ldLmVpZCA9IGk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZWlkIGluIGFpcmNyYWZ0J3MgZm1zXG4gICAgICAgICAgICB0aGlzLmFpcmNyYWZ0Lmxpc3RbaV0uZm1zLm15X2FpcmNyYWZ0c19laWQgPSBpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9pc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCBfaXNOYU4gZnJvbSAnbG9kYXNoL2lzTmFOJztcbmltcG9ydCBfaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2lzU3RyaW5nJztcbmltcG9ydCBfbWFwIGZyb20gJ2xvZGFzaC9tYXAnO1xuaW1wb3J0IEFpcmNyYWZ0RmxpZ2h0TWFuYWdlbWVudFN5c3RlbSBmcm9tICcuL0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vQWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtJztcbmltcG9ydCBBaXJjcmFmdFN0cmlwVmlldyBmcm9tICcuL0FpcmNyYWZ0U3RyaXBWaWV3JztcbmltcG9ydCBXYXlwb2ludCBmcm9tICcuL0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vV2F5cG9pbnQnO1xuaW1wb3J0IFJvdXRlTW9kZWwgZnJvbSAnLi4vYWlycG9ydC9Sb3V0ZS9Sb3V0ZU1vZGVsJztcbmltcG9ydCB7IHNwZWVjaF9zYXkgfSBmcm9tICcuLi9zcGVlY2gnO1xuaW1wb3J0IHsgdGF1LCByYWRpYW5zX25vcm1hbGl6ZSwgYW5nbGVfb2Zmc2V0IH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsgcm91bmQsIGFicywgc2luLCBjb3MsIGV4dHJhcG9sYXRlX3JhbmdlX2NsYW1wLCBjbGFtcCB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyBkaXN0YW5jZTJkIH0gZnJvbSAnLi4vbWF0aC9kaXN0YW5jZSc7XG5pbXBvcnQgeyBnZXRPZmZzZXQgfSBmcm9tICcuLi9tYXRoL2ZsaWdodE1hdGgnO1xuaW1wb3J0IHtcbiAgICB2bGVuLFxuICAgIHZyYWRpYWwsXG4gICAgdnN1YixcbiAgICB2YWRkLFxuICAgIHZzY2FsZSxcbiAgICB2dHVybixcbiAgICBkaXN0YW5jZV90b19wb2x5LFxuICAgIHBvaW50X3RvX21wb2x5LFxuICAgIHBvaW50X2luX3BvbHksXG4gICAgcG9pbnRfaW5fYXJlYVxufSBmcm9tICcuLi9tYXRoL3ZlY3Rvcic7XG5pbXBvcnQge1xuICAgIHJhZGlvX2NhcmRpbmFsRGlyX25hbWVzLFxuICAgIGRpZ2l0c19kZWNpbWFsLFxuICAgIGdyb3VwTnVtYmVycyxcbiAgICByYWRpb19ydW53YXksXG4gICAgcmFkaW9faGVhZGluZyxcbiAgICByYWRpb19zcGVsbE91dCxcbiAgICByYWRpb19hbHRpdHVkZSxcbiAgICByYWRpb190cmVuZCxcbiAgICBnZXRDYXJkaW5hbERpcmVjdGlvblxufSBmcm9tICcuLi91dGlsaXRpZXMvcmFkaW9VdGlsaXRpZXMnO1xuaW1wb3J0IHsga20sIHJhZGlhbnNUb0RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMsIGhlYWRpbmdfdG9fc3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7XG4gICAgRkxJR0hUX01PREVTLFxuICAgIEZMSUdIVF9DQVRFR09SWSxcbiAgICBXQVlQT0lOVF9OQVZfTU9ERSxcbiAgICBGUF9MRUdfVFlQRVxufSBmcm9tICcuLi9jb25zdGFudHMvYWlyY3JhZnRDb25zdGFudHMnO1xuaW1wb3J0IHsgU0VMRUNUT1JTIH0gZnJvbSAnLi4vY29uc3RhbnRzL3NlbGVjdG9ycyc7XG5pbXBvcnQgeyBHQU1FX0VWRU5UUyB9IGZyb20gJy4uL2dhbWUvR2FtZUNvbnRyb2xsZXInO1xuXG4vKipcbiAqIEVudW0gb2YgY29tbWFuZHMgYW5kIHRoaWVyIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24uXG4gKlxuICogVXNlZCB0byBidWlsZCBhIGNhbGwgdG8gdGhlIGNvcnJlY3QgZnVuY3Rpb24gd2hlbiBhIFVJIGNvbW1hbmQsIG9yIGNvbW1hbmRzLFxuICogZm9yIGFuIGFpcmNyYWZ0IGhhdmUgYmVlbiBpc3N1ZWQuXG4gKlxuICogQHByb3BlcnR5IENPTU1BTkRTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IENPTU1BTkRTID0ge1xuICAgIGFib3J0OiAncnVuQWJvcnQnLFxuICAgIGFsdGl0dWRlOiAncnVuQWx0aXR1ZGUnLFxuICAgIGNsZWFyZWRBc0ZpbGVkOiAncnVuQ2xlYXJlZEFzRmlsZWQnLFxuICAgIGNsaW1iVmlhU0lEOiAncnVuQ2xpbWJWaWFTSUQnLFxuICAgIGRlYnVnOiAncnVuRGVidWcnLFxuICAgIGRlbGV0ZTogJ3J1bkRlbGV0ZScsXG4gICAgZGVzY2VuZFZpYVNUQVI6ICdydW5EZXNjZW5kVmlhU1RBUicsXG4gICAgZGlyZWN0OiAncnVuRGlyZWN0JyxcbiAgICBmaXg6ICdydW5GaXgnLFxuICAgIGZseVByZXNlbnRIZWFkaW5nOiAncnVuRmx5UHJlc2VudEhlYWRpbmcnLFxuICAgIGhlYWRpbmc6ICdydW5IZWFkaW5nJyxcbiAgICBob2xkOiAncnVuSG9sZCcsXG4gICAgbGFuZDogJ3J1bkxhbmRpbmcnLFxuICAgIG1vdmVEYXRhQmxvY2s6ICdydW5Nb3ZlRGF0YUJsb2NrJyxcbiAgICByb3V0ZTogJ3J1blJvdXRlJyxcbiAgICByZXJvdXRlOiAncnVuUmVyb3V0ZScsXG4gICAgc2F5Um91dGU6ICdydW5TYXlSb3V0ZScsXG4gICAgc2lkOiAncnVuU0lEJyxcbiAgICBzcGVlZDogJ3J1blNwZWVkJyxcbiAgICBzdGFyOiAncnVuU1RBUicsXG4gICAgdGFrZW9mZjogJ3J1blRha2VvZmYnLFxuICAgIHRheGk6ICdydW5UYXhpJ1xufTtcblxuLyoqXG4gKiBAcHJvcGVydHkgRkxJR0hUX1JVTEVTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IEZMSUdIVF9SVUxFUyA9IHtcbiAgICBWRlI6ICd2ZnInLFxuICAgIElGUjogJ2lmcidcbn07XG5cbi8qKlxuICogRWFjaCBzaW11bGF0ZWQgYWlyY3JhZnQgaW4gdGhlIGdhbWUuIENvbnRhaW5zIGEgbW9kZWwsIGZtcywgYW5kIGNvbmZsaWN0cy5cbiAqXG4gKiBAY2xhc3MgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpcmNyYWZ0IHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcyovXG4gICAgICAgIHRoaXMuZWlkICAgICAgICAgID0gcHJvcC5haXJjcmFmdC5saXN0Lmxlbmd0aDsgIC8vIGVudGl0eSBJRFxuICAgICAgICB0aGlzLnBvc2l0aW9uICAgICA9IFswLCAwXTsgICAgIC8vIEFpcmNyYWZ0IFBvc2l0aW9uLCBpbiBrbSwgcmVsYXRpdmUgdG8gYWlycG9ydCBwb3NpdGlvblxuICAgICAgICB0aGlzLm1vZGVsICAgICAgICA9IG51bGw7ICAgICAgIC8vIEFpcmNyYWZ0IHR5cGVcbiAgICAgICAgdGhpcy5haXJsaW5lICAgICAgPSAnJzsgICAgICAgICAvLyBBaXJsaW5lIElkZW50aWZpZXIgKGVnLiAnQUFMJylcbiAgICAgICAgdGhpcy5jYWxsc2lnbiAgICAgPSAnJzsgICAgICAgICAvLyBGbGlnaHQgTnVtYmVyIE9OTFkgKGVnLiAnNTUxJylcbiAgICAgICAgdGhpcy5oZWFkaW5nICAgICAgPSAwOyAgICAgICAgICAvLyBNYWduZXRpYyBIZWFkaW5nXG4gICAgICAgIHRoaXMuYWx0aXR1ZGUgICAgID0gMDsgICAgICAgICAgLy8gQWx0aXR1ZGUsIGZ0IE1TTFxuICAgICAgICB0aGlzLnNwZWVkICAgICAgICA9IDA7ICAgICAgICAgIC8vIEluZGljYXRlZCBBaXJzcGVlZCAoSUFTKSwga25vdHNcbiAgICAgICAgdGhpcy5ncm91bmRTcGVlZCAgPSAwOyAgICAgICAgICAvLyBHcm91bmRzcGVlZCAoR1MpLCBrbm90c1xuICAgICAgICB0aGlzLmdyb3VuZFRyYWNrICA9IDA7ICAgICAgICAgIC8vXG4gICAgICAgIHRoaXMuZHMgICAgICAgICAgID0gMDsgICAgICAgICAgLy9cbiAgICAgICAgdGhpcy50YWtlb2ZmVGltZSAgPSAwOyAgICAgICAgICAvL1xuICAgICAgICB0aGlzLnJ3eV9kZXAgICAgICA9IG51bGw7ICAgICAgIC8vIERlcGFydHVyZSBSdW53YXkgKHRvIHVzZSwgY3VycmVudGx5IHVzaW5nLCBvciB1c2VkKVxuICAgICAgICB0aGlzLnJ3eV9hcnIgICAgICA9IG51bGw7ICAgICAgIC8vIEFycml2YWwgUnVud2F5ICh0byB1c2UsIGN1cnJlbnRseSB1c2luZywgb3IgdXNlZClcbiAgICAgICAgdGhpcy5hcHByb2FjaE9mZnNldCA9IDA7ICAgICAgICAvLyBEaXN0YW5jZSBsYXRlcmFsbHkgZnJvbSB0aGUgYXBwcm9hY2ggcGF0aFxuICAgICAgICB0aGlzLmFwcHJvYWNoRGlzdGFuY2UgPSAwOyAgICAgIC8vIERpc3RhbmNlIGxvbmdpdHVkaW5hbGx5IGZyb20gdGhlIHRocmVzaG9sZFxuICAgICAgICB0aGlzLnJhZGlhbCAgICAgICA9IDA7ICAgICAgICAgIC8vIEFuZ2xlIGZyb20gYWlycG9ydCBjZW50ZXIgdG8gYWlyY3JhZnRcbiAgICAgICAgdGhpcy5kaXN0YW5jZSAgICAgPSAwOyAgICAgICAgICAvL1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uICA9IG51bGw7ICAgICAgIC8vIERlc3RpbmF0aW9uIHRoZXkncmUgZmx5aW5nIHRvXG4gICAgICAgIHRoaXMudHJlbmQgICAgICAgID0gMDsgICAgICAgICAgLy8gSW5kaWNhdG9yIG9mIGRlc2NlbnQvbGV2ZWwvY2xpbWIgKDEsIDAsIG9yIDEpXG4gICAgICAgIHRoaXMuaGlzdG9yeSAgICAgID0gW107ICAgICAgICAgLy8gQXJyYXkgb2YgcHJldmlvdXMgcG9zaXRpb25zXG4gICAgICAgIHRoaXMucmVzdHJpY3RlZCAgID0geyBsaXN0OiBbXSB9O1xuICAgICAgICB0aGlzLm5vdGljZSAgICAgICA9IGZhbHNlOyAgICAgIC8vIFdoZXRoZXIgYWlyY3JhZnRcbiAgICAgICAgdGhpcy53YXJuaW5nICAgICAgPSBmYWxzZTsgICAgICAvL1xuICAgICAgICB0aGlzLmhpdCAgICAgICAgICA9IGZhbHNlOyAgICAgIC8vIFdoZXRoZXIgYWlyY3JhZnQgaGFzIGNyYXNoZWRcbiAgICAgICAgdGhpcy50YXhpX25leHQgICAgPSBmYWxzZTsgICAgICAvL1xuICAgICAgICB0aGlzLnRheGlfc3RhcnQgICA9IDA7ICAgICAgICAgIC8vXG4gICAgICAgIHRoaXMudGF4aV90aW1lICAgID0gMzsgICAgICAgICAgLy8gVGltZSBzcGVudCB0YXhpaW5nIHRvIHRoZSBydW53YXkuICpOT1RFKiB0aGlzIHNob3VsZCBiZSBJTkNSRUFTRUQgdG8gYXJvdW5kIDYwIG9uY2UgdGhlIHRheGkgdnMgTFVBVyBpc3N1ZSBpcyByZXNvbHZlZCAoIzQwNilcbiAgICAgICAgdGhpcy5ydWxlcyAgICAgICAgPSBGTElHSFRfUlVMRVMuSUZSOyAgICAgIC8vIEVpdGhlciBJRlIgb3IgVkZSIChJbnN0cnVtZW50L1Zpc3VhbCBGbGlnaHQgUnVsZXMpXG4gICAgICAgIHRoaXMuaW5zaWRlX2N0ciAgID0gZmFsc2U7ICAgICAgLy8gSW5zaWRlIEFUQyBBaXJzcGFjZVxuICAgICAgICB0aGlzLmRhdGFibG9ja0RpciA9IC0xOyAgICAgICAgIC8vIERpcmVjdGlvbiB0aGUgZGF0YSBibG9jayBwb2ludHMgKC0xIG1lYW5zIHRvIGlnbm9yZSlcbiAgICAgICAgdGhpcy5jb25mbGljdHMgICAgPSB7fTsgICAgICAgICAvLyBMaXN0IG9mIGFpcmNyYWZ0IHRoYXQgTUFZIGJlIGluIGNvbmZsaWN0IChib3VuZGluZyBib3gpXG4gICAgICAgIHRoaXMudGVycmFpbl9yYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gRklYTUU6IGNoYW5nZSBuYW1lLCBhbmQgdXBkYXRlIHJlZnMgaW4gYElucHV0Q29udHJvbGxlcmAuIHBlcmhhcHMgY2hhbmdlIHRvIGJlIGEgcmVmIHRvIHRoZSBBaXJjcmFmdFN0cmlwVmlldyBjbGFzcyBpbnN0ZWFkIG9mIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgaHRtbD9cbiAgICAgICAgdGhpcy5haXJjcmFmdFN0cmlwVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuJGh0bWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuJHN0cmlwcyA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuU1RSSVBTKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtdWx0aS1zcGFjZXMqL1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHdoZW4gc2ltdWxhdGluZyBmdXR1cmUgbW92ZW1lbnRzIG9mIHRoZSBhaXJjcmFmdFxuICAgICAgICAvLyBTaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgdXBkYXRpbmcgZ2xvYmFsIHN0YXRlIHN1Y2ggYXMgc2NvcmVcbiAgICAgICAgLy8gb3IgSFRNTC5cbiAgICAgICAgdGhpcy5wcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9oaXN0b3J5ID0gW107XG5cbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IG9wdGlvbnMuY2F0ZWdvcnk7IC8vICdhcnJpdmFsJyBvciAnZGVwYXJ0dXJlJ1xuICAgICAgICB0aGlzLm1vZGUgPSBGTElHSFRfTU9ERVMuQ1JVSVNFO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHRoZSBmb2xsb3dpbmcgZGlhZ3JhbSBpbGx1c3RyYXRlcyBhbGwgYWxsb3dlZCBtb2RlIHRyYW5zaXRpb25zOlxuICAgICAgICAgKlxuICAgICAgICAgKiBhcHJvbiAtPiB0YXhpIC0+IHdhaXRpbmcgLT4gdGFrZW9mZiAtPiBjcnVpc2UgPC0+IGxhbmRpbmdcbiAgICAgICAgICogICBeICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgKiAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqIG5ldyBwbGFuZXMgd2l0aCAgICAgICAgICAgICAgICAgICAgICBuZXcgcGxhbmVzIHdpdGhcbiAgICAgICAgICogY2F0ZWdvcnkgJ2RlcGFydHVyZScgICAgICAgICAgICAgICAgIGNhdGVnb3J5ICdhcnJpdmFsJ1xuICAgICAgICAgKi9cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBGTVNcbiAgICAgICAgdGhpcy5mbXMgPSBuZXcgQWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtKHtcbiAgICAgICAgICAgIGFpcmNyYWZ0OiB0aGlzLFxuICAgICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGFyZ2V0IHJlcHJlc2VudHMgd2hhdCB0aGUgcGlsb3QgbWFrZXMgb2YgdGhlIHRvd2VyJ3MgY29tbWFuZHMuIEl0IGlzXG4gICAgICAgIC8vIG1vc3QgaW1wb3J0YW50IHdoZW4gdGhlIHBsYW5lIGlzIGluIGEgJ2d1aWRlZCcgc2l0dWF0aW9uLCB0aGF0IGlzIGl0IGlzXG4gICAgICAgIC8vIG5vdCBnaXZlbiBhIGhlYWRpbmcgZGlyZWN0bHksIGJ1dCBoYXMgYSBmaXggb3IgaXMgZm9sbG93aW5nIGFuIElMUyBwYXRoXG4gICAgICAgIHRoaXMudGFyZ2V0ID0ge1xuICAgICAgICAgICAgaGVhZGluZzogbnVsbCxcbiAgICAgICAgICAgIHR1cm46IG51bGwsXG4gICAgICAgICAgICBhbHRpdHVkZTogMCxcbiAgICAgICAgICAgIGV4cGVkaXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHNwZWVkOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbWVyZ2VuY3kgPSB7fTtcbiAgICAgICAgdGhpcy50YWtlb2ZmVGltZSA9IG9wdGlvbnMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5BUlJJVkFMXG4gICAgICAgICAgICA/IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKVxuICAgICAgICAgICAgOiBudWxsO1xuXG5cbiAgICAgICAgdGhpcy5idWlsZEN1cnJlbnRUZXJyYWluUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMuYnVpbGRSZXN0cmljdGVkQXJlYUxpbmtzKCk7XG4gICAgICAgIHRoaXMuYXNzaWduSW5pdGlhbFJ1bndheShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgdGhpcy51cGRhdGVGbXNBZnRlckluaXRpYWxMb2FkKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0cmlwKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RyaXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgYnVpbGRDdXJyZW50VGVycmFpblJhbmdlc1xuICAgICAqL1xuICAgIGJ1aWxkQ3VycmVudFRlcnJhaW5SYW5nZXMoKSB7XG4gICAgICAgIGNvbnN0IHRlcnJhaW4gPSBfZ2V0KHByb3AsICdhaXJwb3J0LmN1cnJlbnQudGVycmFpbicsIG51bGwpO1xuXG4gICAgICAgIGlmICghdGVycmFpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXJyYWluX3JhbmdlcyA9IHt9O1xuICAgICAgICB0aGlzLnRlcnJhaW5fbGV2ZWwgPSAwO1xuXG4gICAgICAgIF9mb3JFYWNoKHRlcnJhaW4sICh0ZXJyYWluUmFuZ2UsIGspID0+IHtcbiAgICAgICAgICAgIHRoaXMudGVycmFpbl9yYW5nZXNba10gPSB7fTtcblxuICAgICAgICAgICAgX2ZvckVhY2godGVycmFpblJhbmdlLCAocmFuZ2UsIGopID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcnJhaW5fcmFuZ2VzW2tdW2pdID0gSW5maW5pdHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIGxpbmtzIHRvIHJlc3RyaWN0ZWQgYXJlYXNcbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBidWlsZFJlc3RyaWN0ZWRBcmVhTGlua3NcbiAgICAgKi9cbiAgICBidWlsZFJlc3RyaWN0ZWRBcmVhTGlua3MoKSB7XG4gICAgICAgIGNvbnN0IHJlc3RyaWN0ZWRBcmVhcyA9IHByb3AuYWlycG9ydC5jdXJyZW50LnJlc3RyaWN0ZWRfYXJlYXM7XG5cbiAgICAgICAgX2ZvckVhY2gocmVzdHJpY3RlZEFyZWFzLCAoYXJlYSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXN0cmljdGVkLmxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJlYSxcbiAgICAgICAgICAgICAgICByYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICBpbnNpZGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbCBSdW53YXkgQXNzaWdubWVudFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGFzc2lnbkluaXRpYWxSdW53YXlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGFzc2lnbkluaXRpYWxSdW53YXkob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5jYXRlZ29yeSA9PT0gRkxJR0hUX0NBVEVHT1JZLkFSUklWQUwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJyaXZhbFJ1bndheSh3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5ydW53YXkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVwYXJ0dXJlUnVud2F5KHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLnJ1bndheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBfZ2V0KGRhdGEsICdwb3NpdGlvbicsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLm1vZGVsID0gX2dldChkYXRhLCAnbW9kZWwnLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgdGhpcy5haXJsaW5lID0gX2dldChkYXRhLCAnYWlybGluZScsIHRoaXMuYWlybGluZSk7XG4gICAgICAgIHRoaXMuY2FsbHNpZ24gPSBfZ2V0KGRhdGEsICdjYWxsc2lnbicsIHRoaXMuY2FsbHNpZ24pO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gX2dldChkYXRhLCAnY2F0ZWdvcnknLCB0aGlzLmNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gX2dldChkYXRhLCAnaGVhZGluZycsIHRoaXMuaGVhZGluZyk7XG4gICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBfZ2V0KGRhdGEsICdhbHRpdHVkZScsIHRoaXMuYWx0aXR1ZGUpO1xuICAgICAgICB0aGlzLnNwZWVkID0gX2dldChkYXRhLCAnc3BlZWQnLCB0aGlzLnNwZWVkKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGbXNBZnRlckluaXRpYWxMb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5BUlJJVkFMKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS53YXlwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXJyaXZhbFdheXBvaW50cyhkYXRhLndheXBvaW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkYXRhLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZXRBcnJpdmFsUnVud2F5KHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCh0aGlzLmRlc3RpbmF0aW9uKS5ydW53YXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IEZMSUdIVF9NT0RFUy5BUFJPTjtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkYXRhLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZXREZXBhcnR1cmVSdW53YXkoYWlycG9ydC5ydW53YXkpO1xuICAgICAgICAgICAgdGhpcy5hbHRpdHVkZSA9IGFpcnBvcnQucG9zaXRpb24uZWxldmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBjb21iaW5lIHRoZXNlIHR3byB0byBhc2luZ2xlIGNvbnN0YW50XG4gICAgICAgIGlmIChkYXRhLmhlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZm1zLnNldEN1cnJlbnQoeyBoZWFkaW5nOiBkYXRhLmhlYWRpbmcgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5hbHRpdHVkZSkge1xuICAgICAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7IGFsdGl0dWRlOiBkYXRhLmFsdGl0dWRlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BlZWQgPSBfZ2V0KGRhdGEsICdzcGVlZCcsIHRoaXMubW9kZWwuc3BlZWQuY3J1aXNlKTtcbiAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7IHNwZWVkOiBzcGVlZCB9KTtcblxuICAgICAgICBpZiAoZGF0YS5yb3V0ZSkge1xuICAgICAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLmZtcy5mb3JtYXRSb3V0ZShkYXRhLnJvdXRlKTtcblxuICAgICAgICAgICAgdGhpcy5mbXMuY3VzdG9tUm91dGUocm91dGUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5mbXMuZGVzY2VuZFZpYVNUQVIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLm5leHRGaXgpIHtcbiAgICAgICAgICAgIHRoaXMuZm1zLnNraXBUb0ZpeChkYXRhLm5leHRGaXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QXJyaXZhbFdheXBvaW50cyh3YXlwb2ludHMpIHtcbiAgICAgICAgLy8gYWRkIGFycml2YWwgZml4ZXMgdG8gZm1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F5cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmZtcy5hcHBlbmRMZWcoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmaXgnLFxuICAgICAgICAgICAgICAgIHJvdXRlOiB3YXlwb2ludHNbaV0uZml4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgYW5vdGhlciBjbGFzcyBtZXRob2QgZm9yIEZNU1xuICAgICAgICBpZiAodGhpcy5mbXMuY3VycmVudFdheXBvaW50Lm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLkhFQURJTkcpIHtcbiAgICAgICAgICAgIC8vIGFpbSBhaXJjcmFmdCBhdCBhaXJwb3J0XG4gICAgICAgICAgICB0aGlzLmZtcy5zZXRDdXJyZW50KHtcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiB2cmFkaWFsKHRoaXMucG9zaXRpb24pICsgTWF0aC5QSVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mbXMubGVncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBnbyB0byB0aGUgZmlyc3QgZml4IVxuICAgICAgICAgICAgdGhpcy5mbXMubmV4dFdheXBvaW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRBcnJpdmFsUnVud2F5KHJ3eSkge1xuICAgICAgICB0aGlzLnJ3eV9hcnIgPSByd3k7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhc3NpZ25lZCBTVEFSIHRvIHVzZSB0aGUgZml4ZXMgZm9yIHRoZSBzcGVjaWZpZWQgcnVud2F5LCBpZiB0aGV5IGV4aXN0XG4gICAgfVxuXG4gICAgc2V0RGVwYXJ0dXJlUnVud2F5KHJ3eSkge1xuICAgICAgICB0aGlzLnJ3eV9kZXAgPSByd3k7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhc3NpZ25lZCBTSUQgdG8gdXNlIHRoZSBwb3J0aW9uIGZvciB0aGUgbmV3IHJ1bndheVxuICAgICAgICBjb25zdCBsZWcgPSB0aGlzLmZtcy5jdXJyZW50TGVnO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIHJldHVybiBlYXJseVxuICAgICAgICAvLyBUT0RPOiB1c2UgZXhpc3RpbmcgZW51bWVyYXRpb24gZm9yIGBzaWRgXG4gICAgICAgIGlmIChsZWcudHlwZSA9PT0gJ3NpZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBfbWFwKGxlZy53YXlwb2ludHMsICh2KSA9PiB2LmFsdGl0dWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGN2cyA9ICFhLmV2ZXJ5KCh2KSA9PiB2ID09PSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5pbml0aWFsX2FsdCk7XG4gICAgICAgICAgICB0aGlzLmZtcy5mb2xsb3dTSUQobGVnLnJvdXRlLnJvdXRlQ29kZSk7XG5cbiAgICAgICAgICAgIGlmIChjdnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZtcy5jbGltYlZpYVNJRCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy4kaHRtbC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGFpcmNyYWZ0J3MgZmxpZ2h0IHN0cmlwIGFuZCBhZGQgdG8gc3RyaXAgYmF5XG4gICAgICovXG4gICAgY3JlYXRlU3RyaXAoKSB7XG4gICAgICAgIHRoaXMuYWlyY3JhZnRTdHJpcFZpZXcgPSBuZXcgQWlyY3JhZnRTdHJpcFZpZXcoXG4gICAgICAgICAgICB0aGlzLmdldENhbGxzaWduKCksXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy4kaHRtbCA9IHRoaXMuYWlyY3JhZnRTdHJpcFZpZXcuJGVsZW1lbnQ7XG4gICAgICAgIC8vIEFkZCB0aGUgc3RyaXAgdG8gdGhlIGh0bWxcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gdGhpcy4kc3RyaXBzLnNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLiRzdHJpcHMucHJlcGVuZCh0aGlzLmFpcmNyYWZ0U3RyaXBWaWV3LiRlbGVtZW50KTtcbiAgICAgICAgLy8gc2hpZnQgc2Nyb2xsIGRvd24gb25lIHN0cmlwJ3MgaGVpZ2h0XG4gICAgICAgIHRoaXMuJHN0cmlwcy5zY3JvbGxUb3Aoc2Nyb2xsUG9zICsgdGhpcy5haXJjcmFmdFN0cmlwVmlldy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSBzdHJpcCBpbiBvdXIgYmF5XG4gICAgICAgIGlmICh0aGlzLmNhdGVnb3J5ID09PSBGTElHSFRfQ0FURUdPUlkuQVJSSVZBTCkge1xuICAgICAgICAgICAgdGhpcy5haXJjcmFmdFN0cmlwVmlldy5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jYXRlZ29yeSA9PT0gRkxJR0hUX0NBVEVHT1JZLkRFUEFSVFVSRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogZG9lcyB0aGlzIGhhdmUgYW55dGhpbmcgdG8gZG8gd2l0aCB0aGUgYWlyY3JhZnQgc3RyaXA/IGlmIG5vdCB0aGlzIHNob3VsZCBsaXZlIHNvbWV3aGVyZSBlbHNlLlxuICAgICAgICAgICAgdGhpcy5pbnNpZGVfY3RyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBhaXJjcmFmdCBjcm9zc2VzIHRoZSBjZW50ZXIgYm91bmRhcnkgKGllLCBsZWF2aW5nIG91ciBhaXJzcGFjZSlcbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgY3Jvc3NCb3VuZGFyeVxuICAgICAqIEBwYXJhbSBpbmJvdW5kIHt9XG4gICAgICovXG4gICAgY3Jvc3NCb3VuZGFyeShpbmJvdW5kKSB7XG4gICAgICAgIHRoaXMuaW5zaWRlX2N0ciA9IGluYm91bmQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcm9zc2luZyBpbnRvIHRoZSBjZW50ZXJcbiAgICAgICAgaWYgKGluYm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1N0cmlwKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxVcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGVhdmluZyBhaXJzcGFjZVxuICAgICAgICAgICAgdGhpcy5vbkFpcnNwYWNlRXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIG9uQWlyc3BhY2VFeGl0XG4gICAgICovXG4gICAgb25BaXJzcGFjZUV4aXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhdGVnb3J5ID09PSBGTElHSFRfQ0FURUdPUlkuQVJSSVZBTCkge1xuICAgICAgICAgICAgdGhpcy5hcnJpdmFsRXhpdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGVhdmluZyB0aGUgZmFjaWxpdHkncyBhaXJzcGFjZVxuICAgICAgICB0aGlzLmhpZGVTdHJpcCgpO1xuXG4gICAgICAgIC8vIFRPRE86IGlzIHRoaXMgc3VwcG9zZWQgdG8gYmUgYHR5cGVvZiA9PT0gJ251bWJlcidgIG9yIGlzIGRlc3RpbmF0aW9uIGEgbGl0ZXJhbCBzdHJpbmcgJ251bWJlcicgaGVyZT9cbiAgICAgICAgaWYgKHRoaXMuZGVzdGluYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBhbiBhaXJjcmFmdCB3YXMgZ2l2ZW4gYSByYWRpYWwgIGNsZWFyYW5jZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkaW5nSW5zaWRlRGVwYXJ0dXJlV2luZG93KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvQ2FsbCgnc3dpdGNoaW5nIHRvIGNlbnRlciwgZ29vZCBkYXknLCAnZGVwJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuREVQQVJUVVJFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0NhbGwoJ2xlYXZpbmcgcmFkYXIgY292ZXJhZ2Ugb3V0c2lkZSBkZXBhcnR1cmUgd2luZG93JywgJ2RlcCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5nYW1lQ29udHJvbGxlci5ldmVudHNfcmVjb3JkTmV3KEdBTUVfRVZFTlRTLk5PVF9DTEVBUkVEX09OX1JPVVRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyBhIFN0YW5kYXJkIEluc3RydW1lbnQgRGVwYXJ0dXJlIHByb2NlZHVyZVxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZGVzaXJlZCBTSUQgZXhpdFBvaW50XG4gICAgICAgICAgICBsZXQgZXhpdDtcblxuICAgICAgICAgICAgLy8gVE9ETzogaWYgd2UganVzdCBuZWVkIHRoZSBsYXN0IGZpeCBpbiB0aGUgbGlzdCwgd2h5IGxvb3AgdGhyb3VnaCBhbGwgdGhlIGxlZ3M/XG4gICAgICAgICAgICBfZm9yRWFjaCh0aGlzLmZtcy5sZWdzLCAobGVnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZy50eXBlID09PSAnc2lkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgbG9kYXNoIGBfbGFzdCgpYCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGV4aXQgPSBsZWcud2F5cG9pbnRzW2xlZy53YXlwb2ludHMubGVuZ3RoIC0gMV0uZml4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBhaXJjcmFmdCB3YXMgY2xlYXJlZCB0byBkZXBhcnR1cmUgZml4XG4gICAgICAgICAgICBjb25zdCBvayA9IHRoaXMuZm1zLmhhc1dheXBvaW50KGV4aXQpO1xuXG4gICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvQ2FsbCgnc3dpdGNoaW5nIHRvIGNlbnRlciwgZ29vZCBkYXknLCAnZGVwJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuREVQQVJUVVJFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggZm9yIGByZWxlYXNlLzMuMC4wYC4gdGhpcyB3aWxsIG5lZWQgdG8gYmUgcmVmYWN0b3JlZFxuICAgICAgICAgICAgICAgIGxldCBmbXNEZXN0aW5hdGlvbiA9IHRoaXMuZm1zLmZwLnJvdXRlWzFdLmluZGV4T2YoJy4nKSAhPT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmZtcy5mcC5yb3V0ZVsxXS5zcGxpdCgnLicpWzFdXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5mbXMuZnAucm91dGVbMV07XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgaGVscGVyIG1ldGhvZCB0byBGTVMgY2xhc3MgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvQ2FsbChgbGVhdmluZyByYWRhciBjb3ZlcmFnZSB3aXRob3V0IGJlaW5nIGNsZWFyZWQgdG8gJHtmbXNEZXN0aW5hdGlvbn1gLCAnZGVwJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuTk9UX0NMRUFSRURfT05fUk9VVEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7XG4gICAgICAgICAgICBhbHRpdHVkZTogdGhpcy5mbXMuZnAuYWx0aXR1ZGUsXG4gICAgICAgICAgICBzcGVlZDogdGhpcy5tb2RlbC5zcGVlZC5jcnVpc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyaXZpbmcgYWlyY3JhZnQgaXMgZXhpdGluZyB0aGUgYWlycHNhY2VcbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBhcnJpdmFsRXhpdFxuICAgICAqL1xuICAgIGFycml2YWxFeGl0KCkge1xuICAgICAgICB0aGlzLnJhZGlvQ2FsbCgnbGVhdmluZyByYWRhciBjb3ZlcmFnZSBhcyBhcnJpdmFsJywgJ2FwcCcsIHRydWUpO1xuICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZXZlbnRzX3JlY29yZE5ldyhHQU1FX0VWRU5UUy5BSVJTUEFDRV9CVVNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyBhbiBhaXJjcmFmdCdzIGN1cnJlbnQgaGVhZGluZyB3aXRoaW4gYSBzcGVjaWZpYyByYW5nZVxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGlzSGVhZGluZ0luc2lkZURlcGFydHVyZVdpbmRvd1xuICAgICAqL1xuICAgIGlzSGVhZGluZ0luc2lkZURlcGFydHVyZVdpbmRvdygpIHtcbiAgICAgICAgLy8gVE9ETzogZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJcbiAgICAgICAgLy8gV2l0aGluIDUgZGVncmVlcyBvZiBkZXN0aW5hdGlvbiBoZWFkaW5nXG4gICAgICAgIHJldHVybiBhYnModGhpcy5yYWRpYWwgLSB0aGlzLmRlc3RpbmF0aW9uKSA8IDAuMDg3MjY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIG1hdGNoQ2FsbHNpZ25cbiAgICAgKiBAcGFyYW0gY2FsbHNpZ24ge3N0cmluZ31cbiAgICAgKi9cbiAgICBtYXRjaENhbGxzaWduKGNhbGxzaWduVG9NYXRjaCkge1xuICAgICAgICBpZiAoY2FsbHNpZ25Ub01hdGNoID09PSAnKicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9pc0VxdWFsKGNhbGxzaWduVG9NYXRjaC50b1VwcGVyQ2FzZSgpLCB0aGlzLmdldENhbGxzaWduKCkpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgYSBnZXR0ZXJcbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgZ2V0Q2FsbHNpZ25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2FsbHNpZ24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRBaXJsaW5lKCkuaWNhbyArIHRoaXMuY2FsbHNpZ24pLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBhIGdldHRlclxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBnZXRBaXJsaW5lXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEFpcmxpbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYWlybGluZUNvbnRyb2xsZXIuYWlybGluZV9nZXQodGhpcy5haXJsaW5lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgZ2V0UmFkaW9DYWxsc2lnblxuICAgICAqIEBwYXJhbSBjb25kZW5zZWRcbiAgICAgKi9cbiAgICBnZXRSYWRpb0NhbGxzaWduKGNvbmRlbnNlZCkge1xuICAgICAgICBsZXQgaGVhdnkgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5tb2RlbC53ZWlnaHRjbGFzcyA9PT0gJ0gnKSB7XG4gICAgICAgICAgICBoZWF2eSA9ICcgaGVhdnknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwud2VpZ2h0Y2xhc3MgPT09ICdVJykge1xuICAgICAgICAgICAgaGVhdnkgPSAnIHN1cGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYWxsc2lnbiA9IHRoaXMuY2FsbHNpZ247XG4gICAgICAgIGlmIChjb25kZW5zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IDI7XG4gICAgICAgICAgICBjYWxsc2lnbiA9IGNhbGxzaWduLnN1YnN0cihjYWxsc2lnbi5sZW5ndGggLSBsZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNzID0gd2luZG93LmFpcmxpbmVDb250cm9sbGVyLmFpcmxpbmVfZ2V0KHRoaXMuYWlybGluZSkuY2FsbHNpZ247XG5cbiAgICAgICAgaWYgKGNzID09PSAnTm92ZW1iZXInKSB7XG4gICAgICAgICAgICBjcyArPSBgICR7cmFkaW9fc3BlbGxPdXQoY2FsbHNpZ24pfSAke2hlYXZ5fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcyArPSBgICR7Z3JvdXBOdW1iZXJzKGNhbGxzaWduLCB0aGlzLmFpcmxpbmUpfSAke2hlYXZ5fWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGdldENsaW1iUmF0ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDbGltYlJhdGUoKSB7XG4gICAgICAgIGNvbnN0IGFsdGl0dWRlID0gdGhpcy5hbHRpdHVkZTtcbiAgICAgICAgY29uc3QgcmF0ZSA9IHRoaXMubW9kZWwucmF0ZS5jbGltYjtcbiAgICAgICAgY29uc3QgY2VpbGluZyA9IHRoaXMubW9kZWwuY2VpbGluZztcbiAgICAgICAgbGV0IHNlcnZpY2VDZWlsaW5nQ2xpbWJSYXRlO1xuICAgICAgICBsZXQgY3JfdW5jb3JyO1xuICAgICAgICBsZXQgY3JfY3VycmVudDtcblxuICAgICAgICBpZiAodGhpcy5tb2RlbC5lbmdpbmVzLnR5cGUgPT09ICdKJykge1xuICAgICAgICAgICAgc2VydmljZUNlaWxpbmdDbGltYlJhdGUgPSA1MDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJ2aWNlQ2VpbGluZ0NsaW1iUmF0ZSA9IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGVudW1lcmF0ZSB0aGUgbWFnaWMgbnVtYmVyXG4gICAgICAgIC8vIGluIHRyb3Bvc3BoZXJlXG4gICAgICAgIGlmICh0aGlzLmFsdGl0dWRlIDwgMzYxNTIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGJyZWFrIHRoaXMgYXNzaWduZW1udCB1cCBpbnRvIHNtYWxsZXIgcGFydHMgYW5kIGhvbHkgbWFnaWMgbnVtYmVycyEgZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJzXG4gICAgICAgICAgICBjcl91bmNvcnIgPSByYXRlICogNDIwLjcgKiAoKDEuMjMyICogTWF0aC5wb3coKDUxOC42IC0gMC4wMDM1NiAqIGFsdGl0dWRlKSAvIDUxOC42LCA1LjI1NikpIC8gKDUxOC42IC0gMC4wMDM1NiAqIGFsdGl0dWRlKSk7XG4gICAgICAgICAgICBjcl9jdXJyZW50ID0gY3JfdW5jb3JyIC0gKGFsdGl0dWRlIC8gY2VpbGluZyAqIGNyX3VuY29ycikgKyAoYWx0aXR1ZGUgLyBjZWlsaW5nICogc2VydmljZUNlaWxpbmdDbGltYlJhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gbG93ZXIgc3RyYXRvc3BoZXJlXG4gICAgICAgICAgICAvLyByZS1kbyBmb3IgbG93ZXIgc3RyYXRvc3BoZXJlXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vd3d3LmdyYy5uYXNhLmdvdi93d3cvay0xMi9yb2NrZXQvYXRtb3MuaHRtbFxuICAgICAgICAgICAgLy8gYWxzbyByZWNvbW1lbmQgdXNpbmcgZ3JhcGhpbmcgY2FsYyBmcm9tIGRlc21vcy5jb21cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnJhdGUuY2xpbWI7IC8vIDwtLSBOT1QgVkFMSUQhIEp1c3QgYSBwbGFjZWhvbGRlciFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcl9jdXJyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBoaWRlU3RyaXBcbiAgICAgKi9cbiAgICBoaWRlU3RyaXAoKSB7XG4gICAgICAgIHRoaXMuJGh0bWwuaGlkZSg2MDApO1xuICAgIH1cblxuXG4gICAgLy8gVE9ETzogbW92ZSBhaXJjcmFmdENvbW1hbmRzIHRvIGEgbmV3IGNsYXNzXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1bkNvbW1hbmRzXG4gICAgICogQHBhcmFtIGNvbW1hbmRzXG4gICAgICovXG4gICAgcnVuQ29tbWFuZHMoY29tbWFuZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluc2lkZV9jdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gW107XG4gICAgICAgIGxldCByZXNwb25zZV9lbmQgPSAnJztcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gY29tbWFuZHNbaV1bMF07XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gY29tbWFuZHNbaV0uc3BsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gRkxJR0hUX01PREVTLlRBS0VPRkYpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5wdXNoKFtjb21tYW5kLCBhcmdzXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXR2YWwgPSB0aGlzLnJ1bihjb21tYW5kLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJldHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICghX2hhcyhyZXR2YWxbMV0sICdsb2cnKSB8fCAhX2hhcyhyZXR2YWxbMV0sICdzYXknKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWFzc2lnbmluZyBhIHZhbHVlIHVzaW5nIGl0c2VsZiBpcyBkYW5nZXJvdXMuIHRoaXMgc2hvdWxkIGJlIHJlLXdyb2tlZFxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWxbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nOiByZXR2YWxbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F5OiByZXR2YWxbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNwb25zZS5wdXNoKHJldHZhbFsxXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmV0dmFsWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlX2VuZCA9IHJldHZhbFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gZGVmZXJyZWRbaV1bMF07XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gZGVmZXJyZWRbaV1bMV07XG4gICAgICAgICAgICBjb25zdCByZXR2YWwgID0gdGhpcy5ydW4oY29tbWFuZCwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXR2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaXggdGhlIGxvZ2ljIGhlcmUgdGhpcyB2ZXJ5IHB1cnBvc2x5IHVzaW5nIGAhPWAuIGxlbmd0aCBpcyBub3QgYW4gb2JqZWN0IGFuZCB0aHVzLFxuICAgICAgICAgICAgICAgIC8vIG5ldmVyIG51bGwgYnV0IGJ5IHVzaW5nIGNvZXJjaW9uIGl0IGV2YWx1YXRlcyB0byBmYWxzZXkgaWYgaXRzIG5vdCBhbiBhcnJheVxuICAgICAgICAgICAgICAgIC8vIHRydWUgaWYgYXJyYXksIGFuZCBub3QgbG9nL3NheSBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAocmV0dmFsWzFdLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgaW50byBsb2cvc2F5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXk6IHJldHZhbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZzogcmV0dmFsWzFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucHVzaChyZXR2YWxbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBbe1xuICAgICAgICAgICAgICAgIHNheTogJ25vdCB1bmRlcnN0b29kJyxcbiAgICAgICAgICAgICAgICBsb2c6ICdub3QgdW5kZXJzdG9vZCdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcmVzcG9uc2VfZW5kID0gJ3NheSBhZ2Fpbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZV9lbmQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZV9lbmQgPSBgLCAke3Jlc3BvbnNlX2VuZH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByX2xvZyA9IF9tYXAocmVzcG9uc2UsIChyKSA9PiByLmxvZykuam9pbignLCAnKTtcbiAgICAgICAgICAgIGNvbnN0IHJfc2F5ID0gX21hcChyZXNwb25zZSwgKHIpID0+IHIuc2F5KS5qb2luKCcsICcpO1xuXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgJHt0aGlzLmdldENhbGxzaWduKCl9LCAke3JfbG9nfSAke3Jlc3BvbnNlX2VuZH1gKTtcbiAgICAgICAgICAgIHNwZWVjaF9zYXkoW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2NhbGxzaWduJywgY29udGVudDogdGhpcyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBgJHtyX3NheX0gJHtyZXNwb25zZV9lbmR9YCB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU3RyaXAoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQHBhcmFtIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHJ1bihjb21tYW5kLCBkYXRhKSB7XG4gICAgICAgIGxldCBjYWxsX2Z1bmM7XG5cbiAgICAgICAgaWYgKENPTU1BTkRTW2NvbW1hbmRdKSB7XG4gICAgICAgICAgICBjYWxsX2Z1bmMgPSBDT01NQU5EU1tjb21tYW5kXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbF9mdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgJ25vdCB1bmRlcnN0b29kJ107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1tjYWxsX2Z1bmNdKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5IZWFkaW5nXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBydW5IZWFkaW5nKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBkYXRhWzBdO1xuICAgICAgICBsZXQgaGVhZGluZyA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IGluY3JlbWVudGFsID0gZGF0YVsyXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IDA7XG4gICAgICAgIGxldCBpbnN0cnVjdGlvbjtcblxuICAgICAgICBpZiAoX2lzTmFOKGhlYWRpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgJ2hlYWRpbmcgbm90IHVuZGVyc3Rvb2QnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNyZW1lbnRhbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gaGVhZGluZztcblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZyA9IHJhZGlhbnNUb0RlZ3JlZXModGhpcy5oZWFkaW5nKSAtIGFtb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZyA9IHJhZGlhbnNUb0RlZ3JlZXModGhpcy5oZWFkaW5nKSArIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHRoZSBBaXJjcmFmdEluc3RhbmNlTW9kZWwncyBqb2IuIHRoaXMgbG9naWMgc2hvdWxkIGJlbG9uZyBzb21ld2hlcmUgZWxzZS5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBGTVNcbiAgICAgICAgbGV0IHdwID0gdGhpcy5mbXMuY3VycmVudFdheXBvaW50O1xuICAgICAgICBjb25zdCBsZWcgPSB0aGlzLmZtcy5jdXJyZW50TGVnO1xuICAgICAgICBjb25zdCBmID0gdGhpcy5mbXMuZm9sbG93aW5nO1xuXG4gICAgICAgIGlmICh3cC5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5SV1kpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGFuZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxyZWFkeSBiZWluZyB2ZWN0b3JlZCBvciBob2xkaW5nLiBXaWxsIG5vdyBqdXN0IGNoYW5nZSB0aGUgYXNzaWduZWQgaGVhZGluZy5cbiAgICAgICAgaWYgKHdwLm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLkhFQURJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuZm1zLnNldEN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIGFsdGl0dWRlOiB3cC5hbHRpdHVkZSxcbiAgICAgICAgICAgICAgICBuYXZtb2RlOiBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HLFxuICAgICAgICAgICAgICAgIGhlYWRpbmc6IGRlZ3JlZXNUb1JhZGlhbnMoaGVhZGluZyksXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHdwLnNwZWVkLFxuICAgICAgICAgICAgICAgIHR1cm46IGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBob2xkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod3AubmF2bW9kZSA9PT0gV0FZUE9JTlRfTkFWX01PREUuSE9MRCkge1xuICAgICAgICAgICAgLy8gaW4gaG9sZC4gU2hvdWxkIGxlYXZlIHRoZSBob2xkLCBhbmQgYWRkIGxlZyBmb3IgdmVjdG9yc1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZtcy5jdXJyZW50WzBdICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHdheXBvaW50VG9BZGQgPSBuZXcgV2F5cG9pbnQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZTogd3AuYWx0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgIG5hdm1vZGU6IFdBWVBPSU5UX05BVl9NT0RFLkhFQURJTkcsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRpbmc6IGRlZ3JlZXNUb1JhZGlhbnMoaGVhZGluZyksXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiB3cC5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgdHVybjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBob2xkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWlycG9ydFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gYWRkIG5ldyBMZWcgYWZ0ZXIgaG9sZCBsZWdcbiAgICAgICAgICAgIHRoaXMuZm1zLmluc2VydExlZyh7XG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgd2F5cG9pbnRzOiBbd2F5cG9pbnRUb0FkZF1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGZyb20gaG9sZCBsZWcgdG8gdmVjdG9yIGxlZy5cbiAgICAgICAgICAgIHRoaXMuZm1zLm5leHRXYXlwb2ludCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGYuc2lkIHx8IGYuc3RhciB8fCBmLmF3eSkge1xuICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnRUb0FkZCA9IG5ldyBXYXlwb2ludChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFsdGl0dWRlOiB3cC5hbHRpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgbmF2bW9kZTogV0FZUE9JTlRfTkFWX01PREUuSEVBRElORyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZzogZGVncmVlc1RvUmFkaWFucyhoZWFkaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IHdwLnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICB0dXJuOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGhvbGQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhaXJwb3J0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbiBGTVMgY2xhc3MgbWV0aG9kIHRoYXQgYWNjZXB0cyBhIG5ldyBgd2F5cG9pbnRUb0FkZGBcbiAgICAgICAgICAgIC8vIGluc2VydCB3cCB3aXRoIGhlYWRpbmcgYXQgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gdGhlIGFscmVhZHkgYWN0aXZlIGxlZ1xuICAgICAgICAgICAgbGVnLndheXBvaW50cy5zcGxpY2UodGhpcy5mbXMuY3VycmVudFsxXSwgMCwgd2F5cG9pbnRUb0FkZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVnLnJvdXRlICE9PSAnW3JhZGFyIHZlY3RvcnNdJykge1xuICAgICAgICAgICAgLy8gbmVlZHMgbmV3IGxlZyBhZGRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZm1zLmF0TGFzdFdheXBvaW50KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXlwb2ludFRvQWRkID0gbmV3IFdheXBvaW50KFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZTogd3AuYWx0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZtb2RlOiBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZzogZGVncmVlc1RvUmFkaWFucyhoZWFkaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkOiB3cC5zcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cm46IGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFpcnBvcnRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mbXMuYXBwZW5kTGVnKHtcbiAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnRzOiBbd2F5cG9pbnRUb0FkZF1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZm1zLm5leHRMZWcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnRUb0FkZCA9IG5ldyBXYXlwb2ludChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0aXR1ZGU6IHdwLmFsdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2bW9kZTogV0FZUE9JTlRfTkFWX01PREUuSEVBRElORyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmc6IGRlZ3JlZXNUb1JhZGlhbnMoaGVhZGluZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVlZDogd3Auc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXJuOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhaXJwb3J0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZm1zLmluc2VydExlZ0hlcmUoe1xuICAgICAgICAgICAgICAgICAgICB3YXlwb2ludHM6IFt3YXlwb2ludFRvQWRkXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd3AgPSB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQ7ICAvLyB1cGRhdGUgJ3dwJ1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcmVhZGJhY2tcbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSAnZmx5IGhlYWRpbmcnO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGB0dXJuICR7ZGlyZWN0aW9ufSBoZWFkaW5nYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge307XG4gICAgICAgIHJlYWRiYWNrLmxvZyA9IGAke2luc3RydWN0aW9ufSAke2hlYWRpbmdfdG9fc3RyaW5nKHdwLmhlYWRpbmcpfWA7XG4gICAgICAgIHJlYWRiYWNrLnNheSA9IGAke2luc3RydWN0aW9ufSAke3JhZGlvX2hlYWRpbmcoaGVhZGluZ190b19zdHJpbmcod3AuaGVhZGluZykpfWA7XG5cbiAgICAgICAgaWYgKGluY3JlbWVudGFsKSB7XG4gICAgICAgICAgICByZWFkYmFjay5sb2cgPSBgdHVybiAke2Ftb3VudH0gZGVncmVlcyAke2RpcmVjdGlvbn1gO1xuICAgICAgICAgICAgcmVhZGJhY2suc2F5ID0gYHR1cm4gJHtncm91cE51bWJlcnMoYW1vdW50KX0gZGVncmVlcyAke2RpcmVjdGlvbn1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1bkFsdGl0dWRlXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBydW5BbHRpdHVkZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFsdGl0dWRlID0gZGF0YVswXTtcbiAgICAgICAgbGV0IGV4cGVkaXRlID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCByYWRpb1RyZW5kQWx0aXR1ZGUgPSByYWRpb190cmVuZCgnYWx0aXR1ZGUnLCB0aGlzLmFsdGl0dWRlLCB0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpKTtcbiAgICAgICAgY29uc3QgY3VycmVudFdheXBvaW50UmFkaW9BbHRpdHVkZSA9IHJhZGlvX2FsdGl0dWRlKHRoaXMuZm1zLmFsdGl0dWRlRm9yQ3VycmVudFdheXBvaW50KCkpO1xuXG4gICAgICAgIGlmICgoYWx0aXR1ZGUgPT0gbnVsbCkgfHwgaXNOYU4oYWx0aXR1ZGUpKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogbW92ZSB0aGlzIHRvIGl0J3Mgb3duIGNvbW1hbmQuIGlmIGV4cGVkaXRlIGNhbiBiZSBwYXNzZWQgYXMgYSBzb2xlIGNvbW1hbmQgaXQgc2hvdWxkIGJlIGl0cyBvd24gY29tbWFuZFxuICAgICAgICAgICAgaWYgKGV4cGVkaXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7IGV4cGVkaXRlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnb2snLCBgJHtyYWRpb1RyZW5kQWx0aXR1ZGV9ICR7dGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKX0gZXhwZWRpdGVgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICdhbHRpdHVkZSBub3QgdW5kZXJzdG9vZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGFuZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNlaWxpbmcgPSBhaXJwb3J0LmN0cl9jZWlsaW5nO1xuICAgICAgICBpZiAod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUub3B0aW9uLmdldCgnc29mdENlaWxpbmcnKSA9PT0gJ3llcycpIHtcbiAgICAgICAgICAgIGNlaWxpbmcgKz0gMTAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm1zLnNldEFsbCh7XG4gICAgICAgICAgICAvLyBUT0RPOiBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICAgIGFsdGl0dWRlOiBjbGFtcChyb3VuZChhaXJwb3J0LmVsZXZhdGlvbiAvIDEwMCkgKiAxMDAgKyAxMDAwLCBhbHRpdHVkZSwgY2VpbGluZyksXG4gICAgICAgICAgICBleHBlZGl0ZTogZXhwZWRpdGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGlzRXhwZWRpdGluZ1N0cmluZyA9ICcnO1xuICAgICAgICBpZiAoZXhwZWRpdGUpIHtcbiAgICAgICAgICAgIGlzRXhwZWRpdGluZ1N0cmluZyA9ICdhbmQgZXhwZWRpdGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZGJhY2sgPSB7XG4gICAgICAgICAgICBsb2c6IGAke3JhZGlvVHJlbmRBbHRpdHVkZX0gJHt0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpfSAke2lzRXhwZWRpdGluZ1N0cmluZ31gLFxuICAgICAgICAgICAgc2F5OiBgJHtyYWRpb1RyZW5kQWx0aXR1ZGV9ICR7Y3VycmVudFdheXBvaW50UmFkaW9BbHRpdHVkZX0gJHtpc0V4cGVkaXRpbmdTdHJpbmd9YFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBbJ29rJywgcmVhZGJhY2tdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5DbGVhcmVkQXNGaWxlZFxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIHJ1bkNsZWFyZWRBc0ZpbGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMucnVuU0lEKFt0aGlzLmRlc3RpbmF0aW9uXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgJ3VuYWJsZSB0byBjbGVhciBhcyBmaWxlZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCB7IG5hbWU6IHByb2NlZHVyZU5hbWUgfSA9IGFpcnBvcnQuc2lkQ29sbGVjdGlvbi5maW5kUm91dGVCeUljYW8odGhpcy5kZXN0aW5hdGlvbik7XG4gICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge307XG5cbiAgICAgICAgcmVhZGJhY2subG9nID0gYGNsZWFyZWQgdG8gZGVzdGluYXRpb24gdmlhIHRoZSAke3RoaXMuZGVzdGluYXRpb259IGRlcGFydHVyZSwgdGhlbiBhcyBmaWxlZC4gQ2xpbWIgYW5kIGAgK1xuICAgICAgICAgICAgYG1haW50YWluICR7YWlycG9ydC5pbml0aWFsX2FsdH0sIGV4cGVjdCAke3RoaXMuZm1zLmZwLmFsdGl0dWRlfSAxMCBtaW51dGVzIGFmdGVyIGRlcGFydHVyZSBgO1xuICAgICAgICByZWFkYmFjay5zYXkgPSBgY2xlYXJlZCB0byBkZXN0aW5hdGlvbiB2aWEgdGhlICR7cHJvY2VkdXJlTmFtZX0gYCArXG4gICAgICAgICAgICBgZGVwYXJ0dXJlLCB0aGVuIGFzIGZpbGVkLiBDbGltYiBhbmQgbWFpbnRhaW4gJHtyYWRpb19hbHRpdHVkZShhaXJwb3J0LmluaXRpYWxfYWx0KX0sIGAgK1xuICAgICAgICAgICAgYGV4cGVjdCAke3JhZGlvX2FsdGl0dWRlKHRoaXMuZm1zLmZwLmFsdGl0dWRlKX0sICR7cmFkaW9fc3BlbGxPdXQoJzEwJyl9IG1pbnV0ZXMgYWZ0ZXIgZGVwYXJ0dXJlJ2A7XG5cbiAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1bkNsaW1iVmlhU0lEXG4gICAgICovXG4gICAgcnVuQ2xpbWJWaWFTSUQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZtcy5jdXJyZW50TGVnLnR5cGUgIT09IEZQX0xFR19UWVBFLlNJRCB8fCAhdGhpcy5mbXMuY2xpbWJWaWFTSUQoKSkge1xuICAgICAgICAgICAgY29uc3QgaXNXYXJuaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSB1bmFibGUgdG8gY2xpbWIgdmlhIFNJRGAsIGlzV2FybmluZyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBwcm9jZWR1cmVOYW1lIH0gPSBhaXJwb3J0LnNpZENvbGxlY3Rpb24uZmluZFJvdXRlQnlJY2FvKHRoaXMuZm1zLmN1cnJlbnRMZWcucm91dGUucHJvY2VkdXJlKTtcbiAgICAgICAgY29uc3QgcmVhZGJhY2sgPSB7XG4gICAgICAgICAgICBsb2c6IGBjbGltYiB2aWEgdGhlICR7dGhpcy5mbXMuY3VycmVudExlZy5yb3V0ZS5wcm9jZWR1cmV9IGRlcGFydHVyZWAsXG4gICAgICAgICAgICBzYXk6IGBjbGltYiB2aWEgdGhlICR7cHJvY2VkdXJlTmFtZX0gZGVwYXJ0dXJlYFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBbJ29rJywgcmVhZGJhY2tdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5EZXNjZW5kVmlhU1RBUlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgcnVuRGVzY2VuZFZpYVNUQVIoKSB7XG4gICAgICAgIGlmICghdGhpcy5mbXMuZGVzY2VuZFZpYVNUQVIoKSB8fCAhdGhpcy5mbXMuZm9sbG93aW5nLnN0YXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgJHt0aGlzLmdldENhbGxzaWduKCl9LCB1bmFibGUgdG8gZGVzY2VuZCB2aWEgU1RBUmAsIGlzV2FybmluZyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBwcm9jZWR1cmVOYW1lIH0gPSBhaXJwb3J0LnN0YXJDb2xsZWN0aW9uLmZpbmRSb3V0ZUJ5SWNhbyh0aGlzLmZtcy5jdXJyZW50TGVnLnJvdXRlLnByb2NlZHVyZSk7XG4gICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge1xuICAgICAgICAgICAgbG9nOiBgZGVzY2VuZCB2aWEgdGhlICR7dGhpcy5mbXMuZm9sbG93aW5nLnN0YXJ9IGFycml2YWxgLFxuICAgICAgICAgICAgc2F5OiBgZGVzY2VuZCB2aWEgdGhlICR7cHJvY2VkdXJlTmFtZX0gYXJyaXZhbGBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gWydvaycsIHJlYWRiYWNrXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuU3BlZWRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJ1blNwZWVkKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBkYXRhWzBdO1xuXG4gICAgICAgIGlmIChfaXNOYU4oc3BlZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgJ3NwZWVkIG5vdCB1bmRlcnN0b29kJ107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGFtcGVkU3BlZWQgPSBjbGFtcCh0aGlzLm1vZGVsLnNwZWVkLm1pbiwgc3BlZWQsIHRoaXMubW9kZWwuc3BlZWQubWF4KTtcbiAgICAgICAgdGhpcy5mbXMuc2V0QWxsKHsgc3BlZWQ6IGNsYW1wZWRTcGVlZCB9KTtcblxuICAgICAgICBjb25zdCByYWRpb1RyZW5kU3BlZWQgPSByYWRpb190cmVuZCgnc3BlZWQnLCB0aGlzLnNwZWVkLCB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWQpO1xuICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgIGxvZzogYCR7cmFkaW9UcmVuZFNwZWVkfSAke3RoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5zcGVlZH1gLFxuICAgICAgICAgICAgc2F5OiBgJHtyYWRpb1RyZW5kU3BlZWR9ICR7cmFkaW9fc3BlbGxPdXQodGhpcy5mbXMuY3VycmVudFdheXBvaW50LnNwZWVkKX1gXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1bkhvbGRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJ1bkhvbGQoZGF0YSkge1xuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGxldCBkaXJUdXJucyA9IGRhdGFbMF07XG4gICAgICAgIGxldCBsZWdMZW5ndGggPSBkYXRhWzFdO1xuICAgICAgICBsZXQgaG9sZEZpeCA9IGRhdGFbMl07XG4gICAgICAgIGxldCBob2xkRml4TG9jYXRpb24gPSBudWxsO1xuICAgICAgICBsZXQgaW5ib3VuZEhkZztcbiAgICAgICAgLy8gbGV0IGluYm91bmREaXI7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBtaWdodCBiZSBiZXR0ZXIgaGFuZGxlZCBmcm9tIHdpdGhpbiB0aGUgcGFyc2VyXG4gICAgICAgIGlmIChkaXJUdXJucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzdGFuZGFyZCBmb3IgaG9sZGluZyBwYXR0ZXJucyBpcyByaWdodC10dXJuc1xuICAgICAgICAgICAgZGlyVHVybnMgPSAncmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBtaWdodCBiZSBiZXR0ZXIgaGFuZGxlZCBmcm9tIHdpdGhpbiB0aGUgcGFyc2VyXG4gICAgICAgIGlmIChsZWdMZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbGVnTGVuZ3RoID0gJzFtaW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogc2ltcGxpZnkgdGhpcyBuZXN0ZWQgaWYuXG4gICAgICAgIGlmIChob2xkRml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBob2xkRml4ID0gaG9sZEZpeC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaG9sZEZpeExvY2F0aW9uID0gYWlycG9ydC5nZXRGaXhQb3NpdGlvbihob2xkRml4KTtcblxuICAgICAgICAgICAgaWYgKCFob2xkRml4TG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmYWlsJywgYHVuYWJsZSB0byBmaW5kIGZpeCAke2hvbGRGaXh9YF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1Rha2VvZmYoKSAmJiAhaG9sZEZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICd3aGVyZSBkbyB5b3Ugd2FudCB1cyB0byBob2xkPyddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGVudGVyIHRoZSBob2xkIGZyb20gcHJlc2VudCBwb3NpdGlvblxuICAgICAgICBpZiAoaG9sZEZpeCkge1xuICAgICAgICAgICAgLy8gaG9sZGluZyBvdmVyIGEgc3BlY2lmaWMgZml4IChjdXJyZW50bHkgb25seSBhYmxlIHRvIGRvIHNvIG9uIGluYm91bmQgY291cnNlKVxuICAgICAgICAgICAgaW5ib3VuZEhkZyA9IHZyYWRpYWwodnN1Yih0aGlzLnBvc2l0aW9uLCBob2xkRml4TG9jYXRpb24pKTtcblxuICAgICAgICAgICAgaWYgKGhvbGRGaXggIT09IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5maXgpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgeWV0IGhlYWRlZCB0byB0aGUgaG9sZCBmaXhcbiAgICAgICAgICAgICAgICB0aGlzLmZtcy5pbnNlcnRMZWdIZXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpeCcsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiAnW0dQUy9STkFWXScsXG4gICAgICAgICAgICAgICAgICAgIHdheXBvaW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VlZCBkaXJlY3QgdG8gaG9sZGluZyBmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBXYXlwb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeDogaG9sZEZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0aXR1ZGU6IHRoaXMuZm1zLmFsdGl0dWRlRm9yQ3VycmVudFdheXBvaW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkOiB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFpcnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGVudGVyIHRoZSBob2xkXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgV2F5cG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZtb2RlOiBXQVlQT0lOVF9OQVZfTU9ERS5IT0xELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVlZDogdGhpcy5mbXMuY3VycmVudFdheXBvaW50LnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZTogdGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhOYW1lOiBob2xkRml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4UG9zOiBob2xkRml4TG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJUdXJuczogZGlyVHVybnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdMZW5ndGg6IGxlZ0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluYm91bmRIZGc6IGluYm91bmRIZGcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhaXJwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYSBgV2F5cG9pbnRgXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBjdXJyZW50bHkgZ29pbmcgdG8gdGhlIGhvbGQgZml4XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdGhlIGluaXRpYWwgdHVybiB0byBvdXRib3VuZCBoZWFkaW5nIHdoZW4gZW50ZXJpbmcgdGhlIGhvbGRcbiAgICAgICAgICAgICAgICB0aGlzLmZtcy5hcHBlbmRXYXlwb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIG5hdm1vZGU6IFdBWVBPSU5UX05BVl9NT0RFLkhPTEQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgIGFsdGl0dWRlOiB0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpLFxuICAgICAgICAgICAgICAgICAgICBmaXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhvbGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeE5hbWU6IGhvbGRGaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhQb3M6IGhvbGRGaXhMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpclR1cm5zOiBkaXJUdXJucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ0xlbmd0aDogbGVnTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5ib3VuZEhkZzogaW5ib3VuZEhkZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhvbGRpbmcgb3ZlciBwcmVzZW50IHBvc2l0aW9uIChjdXJyZW50bHkgb25seSBhYmxlIHRvIGRvIHNvIG9uIHByZXNlbnQgY291cnNlKVxuICAgICAgICAgICAgaG9sZEZpeExvY2F0aW9uID0gdGhpcy5wb3NpdGlvbjsgLy8gbWFrZSBhL2MgaG9sZCBvdmVyIHRoZWlyIHByZXNlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGluYm91bmRIZGcgPSB0aGlzLmhlYWRpbmc7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXNlIGFyZW4ndCBgV2F5cG9pbnRzYCBhbmQgdGhleSBzaG91bGQgYmVcbiAgICAgICAgICAgIHRoaXMuZm1zLmluc2VydExlZ0hlcmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmaXgnLFxuICAgICAgICAgICAgICAgIHdheXBvaW50czogW1xuICAgICAgICAgICAgICAgICAgICB7IC8vIGRvY3VtZW50IHRoZSBwcmVzZW50IHBvc2l0aW9uIGFzIHRoZSAnZml4JyB3ZSdyZSBob2xkaW5nIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1vZGU6IFdBWVBPSU5UX05BVl9NT0RFLkZJWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeDogJ1tjdXN0b21dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBob2xkRml4TG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZTogdGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkOiB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBGb3JjZSB0aGUgaW5pdGlhbCB0dXJuIHRvIG91dGJvdW5kIGhlYWRpbmcgd2hlbiBlbnRlcmluZyB0aGUgaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2bW9kZTogV0FZUE9JTlRfTkFWX01PREUuSE9MRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkOiB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZTogdGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhOYW1lOiBob2xkRml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeFBvczogaG9sZEZpeExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpclR1cm5zOiBkaXJUdXJucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdMZW5ndGg6IGxlZ0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmJvdW5kSGRnOiBpbmJvdW5kSGRnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFic3RyYWN0IHRvIG1ldGhvZCBgLmdldEluYm91bmRDYXJkaW5hbERpcmVjdGlvbigpYFxuICAgICAgICBjb25zdCBpbmJvdW5kRGlyID0gcmFkaW9fY2FyZGluYWxEaXJfbmFtZXNbZ2V0Q2FyZGluYWxEaXJlY3Rpb24ocmFkaWFuc19ub3JtYWxpemUoaW5ib3VuZEhkZyArIE1hdGguUEkpKS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoaG9sZEZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnb2snLCBgcHJvY2VlZCBkaXJlY3QgJHtob2xkRml4fSBhbmQgaG9sZCBpbmJvdW5kLCAke2RpclR1cm5zfSB0dXJucywgJHtsZWdMZW5ndGh9IGxlZ3NgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbJ29rJywgYGhvbGQgJHtpbmJvdW5kRGlyfSBvZiBwcmVzZW50IHBvc2l0aW9uLCAke2RpclR1cm5zfSB0dXJucywgJHtsZWdMZW5ndGh9IGxlZ3NgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuRGlyZWN0XG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBydW5EaXJlY3QoZGF0YSkge1xuICAgICAgICBjb25zdCBmaXhuYW1lID0gZGF0YVswXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBGaXhDb2xsZWN0aW9uXG4gICAgICAgIGNvbnN0IGZpeCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmdldEZpeFBvc2l0aW9uKGZpeG5hbWUpO1xuXG4gICAgICAgIGlmICghZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgYHVuYWJsZSB0byBmaW5kIGZpeCBjYWxsZWQgJHtmaXhuYW1lfWBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGludGVybWVkaWF0ZSBmaXhlc1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuVEFLRU9GRikge1xuICAgICAgICAgICAgdGhpcy5mbXMuc2tpcFRvRml4KGZpeG5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmZtcy5za2lwVG9GaXgoZml4bmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCBgJHtmaXhuYW1lfSBpcyBub3QgaW4gb3VyIGZsaWdodHBsYW5gXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbJ29rJywgYHByb2NlZWQgZGlyZWN0ICR7Zml4bmFtZX1gXTtcbiAgICB9XG5cbiAgICBydW5GaXgoZGF0YSkge1xuICAgICAgICBsZXQgbGFzdF9maXg7XG4gICAgICAgIGxldCBmYWlsO1xuICAgICAgICBjb25zdCBmaXhlcyA9IF9tYXAoZGF0YSwgKGZpeG5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbWF5IGJlZWQgdG8gYmUgdGhlIEZpeENvbGxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGZpeCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmdldEZpeFBvc2l0aW9uKGZpeG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoIWZpeCkge1xuICAgICAgICAgICAgICAgIGZhaWwgPSBbJ2ZhaWwnLCBgdW5hYmxlIHRvIGZpbmQgZml4IGNhbGxlZCAke2ZpeG5hbWV9YF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHJlcGV0aXRpb24sIGNvbXBhcmUgbmFtZSB3aXRoIHRoZSBwcmV2aW91cyBmaXhcbiAgICAgICAgICAgIGlmIChmaXhuYW1lID09PSBsYXN0X2ZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdF9maXggPSBmaXhuYW1lO1xuXG4gICAgICAgICAgICByZXR1cm4gZml4bmFtZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gRklYTUU6IHVzZSBlbnVtZXJhdGVkIGNvbnN0YW50IGZvciB0eXBlXG4gICAgICAgICAgICB0aGlzLmZtcy5pbnNlcnRMZWdIZXJlKHsgdHlwZTogJ2ZpeCcsIHJvdXRlOiBmaXhlc1tpXSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09IEZMSUdIVF9NT0RFUy5XQUlUSU5HICYmXG4gICAgICAgICAgICB0aGlzLm1vZGUgIT09IEZMSUdIVF9NT0RFUy5UQUtFT0ZGICYmXG4gICAgICAgICAgICB0aGlzLm1vZGUgIT09IEZMSUdIVF9NT0RFUy5BUFJPTiAmJlxuICAgICAgICAgICAgdGhpcy5tb2RlICE9PSBGTElHSFRfTU9ERVMuVEFYSVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGFuZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsnb2snLCBgcHJvY2VlZCBkaXJlY3QgJHtmaXhlcy5qb2luKCcsICcpfWBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5GbHlQcmVzZW50SGVhZGluZ1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgcnVuRmx5UHJlc2VudEhlYWRpbmcoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbmNlbEZpeCgpO1xuICAgICAgICB0aGlzLnJ1bkhlYWRpbmcoW251bGwsIHJhZGlhbnNUb0RlZ3JlZXModGhpcy5oZWFkaW5nKV0pO1xuXG4gICAgICAgIHJldHVybiBbJ29rJywgJ2ZseSBwcmVzZW50IGhlYWRpbmcnXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuU2F5Um91dGVcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJ1blNheVJvdXRlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFsnb2snLCB7XG4gICAgICAgICAgICBsb2c6IGByb3V0ZTogJHt0aGlzLmZtcy5mcC5yb3V0ZS5qb2luKCcgJyl9YCxcbiAgICAgICAgICAgIHNheTogJ2hlcmVcXCdzIG91ciByb3V0ZSdcbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1blNJRFxuICAgICAqL1xuICAgIHJ1blNJRChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgY29uc3QgeyBzaWRDb2xsZWN0aW9uIH0gPSBhaXJwb3J0O1xuICAgICAgICBjb25zdCBzaWRJZCA9IGRhdGFbMF07XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkUm91dGVNb2RlbCA9IHNpZENvbGxlY3Rpb24uZmluZFJvdXRlQnlJY2FvKHNpZElkKTtcbiAgICAgICAgY29uc3QgZXhpdCA9IGFpcnBvcnQuZ2V0U0lERXhpdFBvaW50KHNpZElkKTtcbiAgICAgICAgLy8gVE9ETzogcGVyaGFwcyB0aGlzIHNob3VsZCB1c2UgdGhlIGBSb3V0ZU1vZGVsYD9cbiAgICAgICAgY29uc3Qgcm91dGUgPSBgJHthaXJwb3J0LmljYW99LiR7c2lkSWR9LiR7ZXhpdH1gO1xuXG4gICAgICAgIGlmIChfaXNOaWwoc3RhbmRhcmRSb3V0ZU1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICdTSUQgbmFtZSBub3QgdW5kZXJzdG9vZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcnkgIT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCAndW5hYmxlIHRvIGZseSBTSUQsIHdlIGFyZSBhbiBpbmJvdW5kJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucnd5X2RlcCkge1xuICAgICAgICAgICAgdGhpcy5zZXREZXBhcnR1cmVSdW53YXkoYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5ydW53YXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFuZGFyZFJvdXRlTW9kZWwuaGFzRml4TmFtZSh0aGlzLnJ3eV9kZXApKSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgYHVuYWJsZSwgdGhlICR7c3RhbmRhcmRSb3V0ZU1vZGVsLm5hbWV9IGRlcGFydHVyZSBub3QgdmFsaWQgZnJvbSBSdW53YXkgJHt0aGlzLnJ3eV9kZXB9YF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHRoZSB3cm9uZyBwbGFjZSBmb3IgdGhpcyBgLnRvVXBwZXJDYXNlKClgXG4gICAgICAgIHRoaXMuZm1zLmZvbGxvd1NJRChyb3V0ZS50b1VwcGVyQ2FzZSgpKTtcblxuICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgIGxvZzogYGNsZWFyZWQgdG8gZGVzdGluYXRpb24gdmlhIHRoZSAke3NpZElkfSBkZXBhcnR1cmUsIHRoZW4gYXMgZmlsZWRgLFxuICAgICAgICAgICAgc2F5OiBgY2xlYXJlZCB0byBkZXN0aW5hdGlvbiB2aWEgdGhlICR7c3RhbmRhcmRSb3V0ZU1vZGVsLm5hbWV9IGRlcGFydHVyZSwgdGhlbiBhcyBmaWxlZGBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gWydvaycsIHJlYWRiYWNrXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuU1RBUlxuICAgICAqIEBwYXJhbSBkYXRhIHthcnJheTxzdHJpbmc+fSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU1RBUiwgZXg6IGBRVUlOTi5CREVHQTIuS1NGT2BcbiAgICAgKi9cbiAgICBydW5TVEFSKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgcm91dGVNb2RlbCA9IG5ldyBSb3V0ZU1vZGVsKGRhdGFbMF0pO1xuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogc3Rhck5hbWUgfSA9IGFpcnBvcnQuc3RhckNvbGxlY3Rpb24uZmluZFJvdXRlQnlJY2FvKHJvdXRlTW9kZWwucHJvY2VkdXJlKTtcblxuICAgICAgICBpZiAodGhpcy5jYXRlZ29yeSAhPT0gRkxJR0hUX0NBVEVHT1JZLkFSUklWQUwpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCAndW5hYmxlIHRvIGZseSBTVEFSLCB3ZSBhcmUgYSBkZXBhcnR1cmUhJ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGUgZGF0YVswXS5sZW5ndGggY2hlY2sgbWlnaHQgbm90IGJlIG5lZWRlZC4gdGhpcyBpcyBjb3ZlcmVkIHZpYSB0aGUgQ29tbWFuZFBhcnNlciB3aGVuXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIHJ1bnMgYXMgdGhlIHJlc3VsdCBvZiBhIGNvbW1hbmQuXG4gICAgICAgIGlmIChkYXRhWzBdLmxlbmd0aCA9PT0gMCB8fCAhYWlycG9ydC5zdGFyQ29sbGVjdGlvbi5oYXNSb3V0ZShyb3V0ZU1vZGVsLnByb2NlZHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCAnU1RBUiBuYW1lIG5vdCB1bmRlcnN0b29kJ107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZtcy5mb2xsb3dTVEFSKHJvdXRlTW9kZWwucm91dGVDb2RlKTtcblxuICAgICAgICAvLyBUT0RPOiBjYXNpbmcgbWF5IGJlIGFuIGlzc3VlIGhlcmUuXG4gICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge1xuICAgICAgICAgICAgbG9nOiBgY2xlYXJlZCB0byB0aGUgJHthaXJwb3J0Lm5hbWV9IHZpYSB0aGUgJHtyb3V0ZU1vZGVsLnByb2NlZHVyZX0gYXJyaXZhbGAsXG4gICAgICAgICAgICBzYXk6IGBjbGVhcmVkIHRvIHRoZSAke2FpcnBvcnQubmFtZX0gdmlhIHRoZSAke3N0YXJOYW1lfSBhcnJpdmFsYFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBbJ29rJywgcmVhZGJhY2tdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5Nb3ZlRGF0YUJsb2NrXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBydW5Nb3ZlRGF0YUJsb2NrKGRpcikge1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGRvIGFsbCB0aGVzZSBudW1iZXJzIG1lYW4/XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHsgODogMzYwLCA5OiA0NSwgNjogOTAsIDM6IDEzNSwgMjogMTgwLCAxOiAyMjUsIDQ6IDI3MCwgNzogMzE1LCA1OiAnY3RyJyB9O1xuXG4gICAgICAgIGlmICghX2hhcyhwb3NpdGlvbnMsIGRpclswXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YWJsb2NrRGlyID0gcG9zaXRpb25zW2RpclswXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBMZWcgdG8gZm1zIHdpdGggYSB1c2VyIHNwZWNpZmllZCByb3V0ZVxuICAgICAqIE5vdGU6IFNlZSBub3RlcyBvbiAncnVuUmVyb3V0ZScgZm9yIGhvdyB0byBmb3JtYXQgaW5wdXQgZm9yIHRoaXMgY29tbWFuZFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1blJvdXRlXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBydW5Sb3V0ZShkYXRhKSB7XG4gICAgICAgICAvLyBjYXBpdGFsaXplIGV2ZXJ5dGhpbmdcbiAgICAgICAgZGF0YSA9IGRhdGFbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgbGV0IHdvcmtlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJvdXRlID0gdGhpcy5mbXMuZm9ybWF0Um91dGUoZGF0YSk7XG5cbiAgICAgICAgaWYgKHdvcmtlZCAmJiByb3V0ZSkge1xuICAgICAgICAgICAgLy8gQWRkIHRvIGZtc1xuICAgICAgICAgICAgd29ya2VkID0gdGhpcy5mbXMuY3VzdG9tUm91dGUocm91dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm91dGUgfHwgIWRhdGEgfHwgZGF0YS5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICAgICAgd29ya2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCB0aGUgcmVzcG9uc2VcbiAgICAgICAgaWYgKHdvcmtlZCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGJhY2sgPSB7XG4gICAgICAgICAgICAgICAgbG9nOiBgcmVyb3V0aW5nIHRvIDoke3RoaXMuZm1zLmZwLnJvdXRlLmpvaW4oJyAnKX1gLFxuICAgICAgICAgICAgICAgIHNheTogJ3Jlcm91dGluZyBhcyByZXF1ZXN0ZWQnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gWydvaycsIHJlYWRiYWNrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge1xuICAgICAgICAgICAgbG9nOiBgeW91ciByb3V0ZSBcIiR7ZGF0YX1cIiBpcyBpbnZhbGlkIWAsXG4gICAgICAgICAgICBzYXk6ICd0aGF0IHJvdXRlIGlzIGludmFsaWQhJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBbJ2ZhaWwnLCByZWFkYmFja107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFJlbW92ZXMgYWxsIGxlZ3MsIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggdGhlIHNwZWNpZmllZCByb3V0ZVxuICAgICAgKiBOb3RlOiBJbnB1dCBkYXRhIG5lZWRzIHRvIGJlIHByb3ZpZGVkIHdpdGggc2luZ2xlIGRvdHMgY29ubmVjdGluZyBhbGxcbiAgICAgICogcHJvY2VkdXJhbGx5LWxpbmtlZCBwb2ludHMgKGVnIEtTRk8uT0ZGU0g5LlNYQyBvciBTR0QuVjg3Lk1PVkVSKSwgYW5kXG4gICAgICAqIGFsbCBvdGhlciBwb2ludHMgdGhhdCB3aWxsIGJlIHNpbXBseSBhIGZpeCBkaXJlY3QgdG8gYW5vdGhlciBmaXggbmVlZFxuICAgICAgKiB0byBiZSBjb25uZWN0ZWQgd2l0aCBkb3VibGUtZG90cyAoZWcgSExJLi5TUVMuLkJFUlJBLi5KQU4uLktKQU4pXG4gICAgICAqXG4gICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICAqIEBtZXRob2QgcnVuUmVyb3V0ZVxuICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgKi9cbiAgICBydW5SZXJvdXRlKGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogY2FwaXRhbGl6ZSBldmVyeXRoaW5nP1xuICAgICAgICBkYXRhID0gZGF0YVswXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBsZXQgd29ya2VkID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLmZtcy5mb3JtYXRSb3V0ZShkYXRhKTtcblxuICAgICAgICBpZiAod29ya2VkICYmIHJvdXRlKSB7XG4gICAgICAgICAgICAvLyBSZXNldCBmbXNcbiAgICAgICAgICAgIHdvcmtlZCA9IHRoaXMuZm1zLmN1c3RvbVJvdXRlKHJvdXRlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHdoYXQgZXhhY3RseSBhcmUgd2UgY2hlY2tpbmcgaGVyZT9cbiAgICAgICAgaWYgKCFyb3V0ZSB8fCAhZGF0YSB8fCBkYXRhLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICB3b3JrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSByZXNwb25zZVxuICAgICAgICBpZiAod29ya2VkKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgICAgICBsb2c6IGByZXJvdXRpbmcgdG86ICR7dGhpcy5mbXMuZnAucm91dGUuam9pbignICcpfWAsXG4gICAgICAgICAgICAgICAgc2F5OiAncmVyb3V0aW5nIGFzIHJlcXVlc3RlZCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBbJ29rJywgcmVhZGJhY2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZGJhY2sgPSB7XG4gICAgICAgICAgICBsb2c6IGB5b3VyIHJvdXRlIFwiJHtkYXRhfVwiIGlzIGludmFsaWQhYCxcbiAgICAgICAgICAgIHNheTogJ3RoYXQgcm91dGUgaXMgaW52YWxpZCEnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFsnZmFpbCcsIHJlYWRiYWNrXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuVGF4aVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgcnVuVGF4aShkYXRhKSB7XG4gICAgICAgIC8vIFRPRE86IGFsbCB0aGlzIGlmIGxvZ2ljIHNob3VsZCBiZSBzaW1wbGlmaWVkIG9yIGFic3RyYWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcnkgIT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCAnaW5ib3VuZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLlRBWEkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCBgYWxyZWFkeSB0YXhpaW5nIHRvICR7cmFkaW9fcnVud2F5KHRoaXMucnd5X2RlcCl9YF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuV0FJVElORykge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICdhbHJlYWR5IHdhaXRpbmcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09IEZMSUdIVF9NT0RFUy5BUFJPTikge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICd3cm9uZyBtb2RlJ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIHJ1bndheSB0byB0YXhpIHRvXG4gICAgICAgIGlmIChkYXRhWzBdKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuZ2V0UnVud2F5KGRhdGFbMF0udG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERlcGFydHVyZVJ1bndheShkYXRhWzBdLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmYWlsJywgYG5vIHJ1bndheSAke2RhdGFbMF0udG9VcHBlckNhc2UoKX1gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0YXhpXG4gICAgICAgIHRoaXMudGF4aV9zdGFydCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKTtcbiAgICAgICAgY29uc3QgcnVud2F5ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuZ2V0UnVud2F5KHRoaXMucnd5X2RlcCk7XG5cbiAgICAgICAgcnVud2F5LmFkZFF1ZXVlKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGUgPSBGTElHSFRfTU9ERVMuVEFYSTtcblxuICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgIGxvZzogYHRheGkgdG8gcnVud2F5ICR7cnVud2F5Lm5hbWV9YCxcbiAgICAgICAgICAgIHNheTogYHRheGkgdG8gcnVud2F5ICR7cmFkaW9fcnVud2F5KHJ1bndheS5uYW1lKX1gXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1blRha2VvZmZcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJ1blRha2VvZmYoZGF0YSkge1xuICAgICAgICAvLyBUT0RPOiBhbGwgdGhpcyBpZiBsb2dpYyBzaG91bGQgYmUgc2ltcGxpZmllZCBvciBhYnN0cmFjdGVkXG4gICAgICAgIGlmICh0aGlzLmNhdGVnb3J5ICE9PSAnZGVwYXJ0dXJlJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICdpbmJvdW5kJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNPbkdyb3VuZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgJ2FscmVhZHkgYWlyYm9ybmUnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuQVBST04pIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCAndW5hYmxlLCB3ZVxcJ3JlIHN0aWxsIGluIHRoZSBwYXJraW5nIGFyZWEnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuVEFYSSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsIGB0YXhpIHRvIHJ1bndheSAke3JhZGlvX3J1bndheSh0aGlzLnJ3eV9kZXApfSBub3QgeWV0IGNvbXBsZXRlYF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLlRBS0VPRkYpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIHNob3dpbmcgaW1tZWRpYXRlbHkgYWZ0ZXIgYSB0byBjbGVhcmFuY2UuXG4gICAgICAgICAgICByZXR1cm4gWydmYWlsJywgJ2FscmVhZHkgdGFraW5nIG9mZiddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZm1zLmFsdGl0dWRlRm9yQ3VycmVudFdheXBvaW50KCkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICdubyBhbHRpdHVkZSBhc3NpZ25lZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcnVud2F5ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuZ2V0UnVud2F5KHRoaXMucnd5X2RlcCk7XG5cbiAgICAgICAgaWYgKHJ1bndheS5yZW1vdmVRdWV1ZSh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gRkxJR0hUX01PREVTLlRBS0VPRkY7XG4gICAgICAgICAgICB0aGlzLnNjb3JlV2luZCgndGFraW5nIG9mZicpO1xuICAgICAgICAgICAgdGhpcy50YWtlb2ZmVGltZSA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5zcGVlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7IHNwZWVkOiB0aGlzLm1vZGVsLnNwZWVkLmNydWlzZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgd2luZCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmdldFdpbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRfZGlyID0gcm91bmQocmFkaWFuc1RvRGVncmVlcyh3aW5kLmFuZ2xlKSk7XG4gICAgICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGUgd2luZF9kaXIgY2FsY3VsYXRpb24gc2hvdWxkIGJlIGFic3RyYWN0ZWRcbiAgICAgICAgICAgICAgICBsb2c6IGB3aW5kICR7cm91bmQod2luZF9kaXIgLyAxMCkgKiAxMH0gJHtyb3VuZCh3aW5kLnNwZWVkKX0sIHJ1bndheSAke3RoaXMucnd5X2RlcH0gLCBjbGVhcmVkIGZvciB0YWtlb2ZmYCxcbiAgICAgICAgICAgICAgICBzYXk6IGB3aW5kICR7cmFkaW9fc3BlbGxPdXQocm91bmQod2luZF9kaXIgLyAxMCkgKiAxMCl9IGF0ICR7cmFkaW9fc3BlbGxPdXQocm91bmQod2luZC5zcGVlZCkpfSwgcnVud2F5ICR7cmFkaW9fcnVud2F5KHRoaXMucnd5X2RlcCl9LCBjbGVhcmVkIGZvciB0YWtlb2ZmYFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3YWl0aW5nID0gcnVud2F5LmluUXVldWUodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIFsnZmFpbCcsIGBudW1iZXIgJHt3YWl0aW5nfSBiZWhpbmQgJHtydW53YXkucXVldWVbd2FpdGluZyAtIDFdLmdldFJhZGlvQ2FsbHNpZ24oKX1gLCAnJ107XG4gICAgfVxuXG4gICAgcnVuTGFuZGluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSBkYXRhWzBdO1xuICAgICAgICBjb25zdCBydW53YXkgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5nZXRSdW53YXkoZGF0YVsxXSk7XG5cbiAgICAgICAgaWYgKCFydW53YXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ZhaWwnLCBgdGhlcmUgaXMgbm8gcnVud2F5ICR7cmFkaW9fcnVud2F5KGRhdGFbMV0pfWBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRBcnJpdmFsUnVud2F5KGRhdGFbMV0udG9VcHBlckNhc2UoKSk7XG4gICAgICAgIC8vIHRlbGwgZm1zIHRvIGZvbGxvdyBJTFMgYXBwcm9hY2hcbiAgICAgICAgdGhpcy5mbXMuZm9sbG93QXBwcm9hY2goJ2lscycsIHRoaXMucnd5X2FyciwgdmFyaWFudCk7XG5cbiAgICAgICAgY29uc3QgcmVhZGJhY2sgPSB7XG4gICAgICAgICAgICBsb2c6IGBjbGVhcmVkIElMUyBydW53YXkgJHt0aGlzLnJ3eV9hcnJ9IGFwcHJvYWNoYCxcbiAgICAgICAgICAgIHNheTogYGNsZWFyZWQgSUxTIHJ1bndheSAke3JhZGlvX3J1bndheSh0aGlzLnJ3eV9hcnIpfSBhcHByb2FjaGBcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gWydvaycsIHJlYWRiYWNrXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuQWJvcnRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHJ1bkFib3J0KGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogdGhlc2UgaWZzIG9uIGBtb2RlYCBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3dpdGNoXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5UQVhJKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBGTElHSFRfTU9ERVMuQVBST047XG4gICAgICAgICAgICB0aGlzLnRheGlfc3RhcnQgPSAwO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWJvcnRlZCB0YXhpIHRvIHJ1bndheScpO1xuXG4gICAgICAgICAgICBjb25zdCBpc1dhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSBhYm9ydGVkIHRheGkgdG8gcnVud2F5YCwgaXNXYXJuaW5nKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsnb2snLCAndGF4aWluZyBiYWNrIHRvIHRlcm1pbmFsJ107XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuV0FJVElORykge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmFpbCcsICd1bmFibGUgdG8gcmV0dXJuIHRvIHRoZSB0ZXJtaW5hbCddO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGFuZGluZygpO1xuXG4gICAgICAgICAgICBjb25zdCByZWFkYmFjayA9IHtcbiAgICAgICAgICAgICAgICBsb2c6IGBnbyBhcm91bmQsIGZseSBwcmVzZW50IGhlYWRpbmcsIG1haW50YWluICR7dGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKX1gLFxuICAgICAgICAgICAgICAgIHNheTogYGdvIGFyb3VuZCwgZmx5IHByZXNlbnQgaGVhZGluZywgbWFpbnRhaW4gJHtyYWRpb19hbHRpdHVkZSh0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpKX1gXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gWydvaycsIHJlYWRiYWNrXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5DUlVJU0UgJiYgdGhpcy5mbXMuY3VycmVudFdheXBvaW50Lm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLlJXWSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxMYW5kaW5nKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlYWRiYWNrID0ge1xuICAgICAgICAgICAgICAgIGxvZzogYGNhbmNlbCBhcHByb2FjaCBjbGVhcmFuY2UsIGZseSBwcmVzZW50IGhlYWRpbmcsIG1haW50YWluICR7dGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKX1gLFxuICAgICAgICAgICAgICAgIHNheTogYGNhbmNlbCBhcHByb2FjaCBjbGVhcmFuY2UsIGZseSBwcmVzZW50IGhlYWRpbmcsIG1haW50YWluICR7cmFkaW9fYWx0aXR1ZGUodGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKSl9YFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFsnb2snLCByZWFkYmFja107XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuQ1JVSVNFICYmIHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5GSVgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsRml4KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhdGVnb3J5ID09PSBGTElHSFRfQ0FURUdPUlkuQVJSSVZBTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ29rJywgJ2ZseSBwcmVzZW50IGhlYWRpbmcsIHZlY3RvciB0byBmaW5hbCBhcHByb2FjaCBjb3Vyc2UnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYXRlZ29yeSA9PT0gJ2RlcGFydHVyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydvaycsICdmbHkgcHJlc2VudCBoZWFkaW5nLCB2ZWN0b3IgZm9yIGVudHJhaWwgc3BhY2luZyddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9kZXMgJ2Fwcm9uJywgJ3Rha2VvZmYnLCAoJ2NydWlzZScgZm9yIHNvbWUgbmF2bW9kZXMpXG4gICAgICAgIHJldHVybiBbJ2ZhaWwnLCAndW5hYmxlIHRvIGFib3J0J107XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGlzIHRoaXMgaW4gdXNlP1xuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBydW5EZWJ1Z1xuICAgICAqL1xuICAgIHJ1bkRlYnVnKCkge1xuICAgICAgICB3aW5kb3cuYWlyY3JhZnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gWydvaycsIHsgbG9nOiAnaW4gdGhlIGNvbnNvbGUsIGxvb2sgYXQgdGhlIHZhcmlhYmxlICZsc3F1bzthaXJjcmFmdCZyc3F1bzsnLCBzYXk6ICcnIH1dO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiBpcyB0aGlzIGluIHVzZT9cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuRGVsZXRlXG4gICAgICovXG4gICAgcnVuRGVsZXRlKCkge1xuICAgICAgICB3aW5kb3cuYWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0X3JlbW92ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBtb3ZlIHRvIGBmbXMuY2FuY2VsRml4KClgXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGNhbmNlbEZpeFxuICAgICAqL1xuICAgIGNhbmNlbEZpeCgpIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBsb2dpYyBjb3VsZCBiZSBzaW1wbGlmaWVkLiBkbyBhbiBlYXJseSByZXR1cm4gaW5zdGVhZCBvZiB3cmFwcGluZyB0aGUgZW50aXJlIGZ1bmN0aW9uIGluIGFuIGlmLlxuICAgICAgICBpZiAodGhpcy5mbXMuY3VycmVudFdheXBvaW50Lm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLkZJWCkge1xuICAgICAgICAgICAgY29uc3QgY3VyciA9IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludDtcblxuICAgICAgICAgICAgdGhpcy5mbXMuYXBwZW5kTGVnKHtcbiAgICAgICAgICAgICAgICBhbHRpdHVkZTogY3Vyci5hbHRpdHVkZSxcbiAgICAgICAgICAgICAgICBuYXZtb2RlOiBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HLFxuICAgICAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMuaGVhZGluZyxcbiAgICAgICAgICAgICAgICBzcGVlZDogY3Vyci5zcGVlZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm1zLm5leHRMZWcoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RyaXAoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGNhbmNlbExhbmRpbmdcbiAgICAgKi9cbiAgICBjYW5jZWxMYW5kaW5nKCkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGxvZ2ljIGNvdWxkIGJlIHNpbXBsaWZpZWQuIGRvIGFuIGVhcmx5IHJldHVybiBpbnN0ZWFkIG9mIHdyYXBwaW5nIHRoZSBlbnRpcmUgZnVuY3Rpb24gaW4gYW4gaWYuXG4gICAgICAgIGlmICh0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQubmF2bW9kZSA9PT0gV0FZUE9JTlRfTkFWX01PREUuUldZKSB7XG4gICAgICAgICAgICBjb25zdCBydW53YXkgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5nZXRSdW53YXkodGhpcy5yd3lfYXJyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICAgICAgICB0aGlzLmZtcy5zZXRDdXJyZW50KHtcbiAgICAgICAgICAgICAgICAgICAgYWx0aXR1ZGU6IE1hdGgubWF4KDIwMDAsIHJvdW5kKCh0aGlzLmFsdGl0dWRlIC8gMTAwMCkpICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRpbmc6IHJ1bndheS5hbmdsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZtcy5zZXRDdXJyZW50KHtcbiAgICAgICAgICAgICAgICBuYXZtb2RlOiBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HLFxuICAgICAgICAgICAgICAgIHJ1bndheTogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubW9kZSA9IEZMSUdIVF9NT0RFUy5DUlVJU0U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlwKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbXMuc2V0Q3VycmVudCh7IHJ1bndheTogbnVsbCB9KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGlzIHRoaXMgbWV0aG9kIHN0aWxsIGluIHVzZT9cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcHVzaEhpc3RvcnlcbiAgICAgKi9cbiAgICBwdXNoSGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goW3RoaXMucG9zaXRpb25bMF0sIHRoaXMucG9zaXRpb25bMV1dKTtcblxuICAgICAgICBpZiAodGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3Rvcnkuc3BsaWNlKDAsIHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgbW92ZUZvcndhcmRcbiAgICAgKi9cbiAgICBtb3ZlRm9yd2FyZCgpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gRkxJR0hUX01PREVTLlRBWEk7XG4gICAgICAgIHRoaXMudGF4aV9uZXh0ICA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWlyY3JhZnQgaXMgZXN0YWJsaXNoZWQgb24gRklOQUwgQVBQUk9BQ0ggQ09VUlNFXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJ1blRha2VvZmZcbiAgICAgKi9cbiAgICBpc0VzdGFibGlzaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSBGTElHSFRfTU9ERVMuTEFORElORykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogd2h5IDQ4bT8gIHdoYXRzIHRoZSBzaWduaWZpY2FuY2Ugb2YgdGhhdCBudW1iZXI/XG4gICAgICAgIC8vIDE2MCBmZWV0IG9yIDQ4IG1ldGVyc1xuICAgICAgICByZXR1cm4gdGhpcy5hcHByb2FjaE9mZnNldCA8PSAwLjA0ODtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGFpcmNyYWZ0IGlzIGluc2lkZSB0aGUgYWlyc3BhY2Ugb2YgYSBzcGVjaWZpZWQgYWlycG9ydFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGlzSW5zaWRlQWlyc3BhY2VcbiAgICAgKiBAcGFyYW0gIHthaXJwb3J0fSBhaXJwb3J0IHRoZSBhaXJwb3J0IHdob3NlIGFpcnNwYWNlIHdlIGFyZSBjaGVja2luZ1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpc0luc2lkZUFpcnNwYWNlKGFpcnBvcnQpIHtcbiAgICAgICAgbGV0IHdpdGhpbkFpcnNwYWNlTGF0ZXJhbEJvdW5kYXJpZXMgPSB0aGlzLmRpc3RhbmNlIDw9IGFpcnBvcnQuY3RyX3JhZGl1cztcbiAgICAgICAgY29uc3Qgd2l0aGluQWlyc3BhY2VBbHRpdHVkZVJhbmdlID0gdGhpcy5hbHRpdHVkZSA8PSBhaXJwb3J0LmN0cl9jZWlsaW5nO1xuXG4gICAgICAgIGlmICghX2lzTmlsKGFpcnBvcnQucGVyaW1ldGVyKSkgeyAgICAvLyBwb2x5Z29uYWwgYWlyc3BhY2UgYm91bmRhcnlcbiAgICAgICAgICAgIHdpdGhpbkFpcnNwYWNlTGF0ZXJhbEJvdW5kYXJpZXMgPSBwb2ludF9pbl9hcmVhKHRoaXMucG9zaXRpb24sIGFpcnBvcnQucGVyaW1ldGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aXRoaW5BaXJzcGFjZUFsdGl0dWRlUmFuZ2UgJiYgd2l0aGluQWlyc3BhY2VMYXRlcmFsQm91bmRhcmllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBaXJjcmFmdCBoYXMgXCJ3ZWlnaHQtb24td2hlZWxzXCIgKG9uIHRoZSBncm91bmQpXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGlzT25Hcm91bmRcbiAgICAgKi9cbiAgICBpc09uR3JvdW5kKCkge1xuICAgICAgICBjb25zdCBlcnJvcl9hbGxvd2FuY2VfZnQgPSA1O1xuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGNvbnN0IHJ1bndheSA9IGFpcnBvcnQuZ2V0UnVud2F5KHRoaXMucnd5X2RlcCB8fCB0aGlzLnJ3eV9hcnIpO1xuICAgICAgICBjb25zdCBuZWFyUnVud2F5QWx0aXR1ZGUgPSBhYnModGhpcy5hbHRpdHVkZSAtIHJ1bndheS5lbGV2YXRpb24pIDwgZXJyb3JfYWxsb3dhbmNlX2Z0O1xuICAgICAgICBjb25zdCBuZWFyQWlycG9ydEFsdGl0dWRlID0gYWJzKHRoaXMuYWx0aXR1ZGUgLSBhaXJwb3J0LnBvc2l0aW9uLmVsZXZhdGlvbikgPCBlcnJvcl9hbGxvd2FuY2VfZnQ7XG5cbiAgICAgICAgcmV0dXJuIG5lYXJSdW53YXlBbHRpdHVkZSB8fCBuZWFyQWlycG9ydEFsdGl0dWRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFpcmNyYWZ0IGlzIGFjdGl2ZWx5IGZvbGxvd2luZyBhbiBpbnN0cnVtZW50IGFwcHJvYWNoIGFuZCBpcyBlbGVnaWJsZSBmb3IgcmVkdWNlZCBzZXBhcmF0aW9uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZ2FtZSBldmVyIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBJTFMvTUxTL0xBQVNcbiAgICAgKiBhcHByb2FjaGVzIGFuZCB2aXN1YWwvbG9jYWxpemVyL1ZPUi9ldGMuIHRoaXMgc2hvdWxkXG4gICAgICogZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtLiAgVW50aWwgdGhlbiwgcHJlc3VtZSBsYW5kaW5nIGlzIHZpYVxuICAgICAqIElMUyB3aXRoIGFwcHJvcHJpYXRlIHByb2NlZHVyZXMgaW4gcGxhY2UuXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcnVuVGFrZW9mZlxuICAgICAqL1xuICAgIGlzUHJlY2lzaW9uR3VpZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuTEFORElORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgaXNTdG9wcGVkXG4gICAgICovXG4gICAgaXNTdG9wcGVkKCkge1xuICAgICAgICAvLyBUT0RPOiBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlci5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPbkdyb3VuZCgpICYmIHRoaXMuc3BlZWQgPCA1O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBpc1RheGlpbmdcbiAgICAgKi9cbiAgICBpc1RheGlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5BUFJPTiB8fFxuICAgICAgICAgICAgdGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuVEFYSSB8fFxuICAgICAgICAgICAgdGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuV0FJVElORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgaXNUYWtlb2ZmXG4gICAgICovXG4gICAgaXNUYWtlb2ZmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RheGlpbmcoKSB8fCB0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5UQUtFT0ZGO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoZSBsb2dpYyBpbiB0aGlzIG1ldGhvZCBjYW4gYmUgY2xlYW5lZCB1cCBhbmQgc2ltcGxpZmllZFxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBpc1Zpc2libGVcbiAgICAgKi9cbiAgICBpc1Zpc2libGUoKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaWYvZWxzZSBpZiB3b3VsZCBiZSBjbGVhbmVyIHdpdGgganVzdCBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuV0FJVElORykge31cbiAgICAgICAgLy8gaGlkZSBhaXJjcmFmdCBvbiB0d3lzXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5BUFJPTiB8fCB0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5UQVhJKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1RheGlpbmcoKSkge1xuICAgICAgICAgICAgLy8gc2hvdyBvbmx5IHRoZSBmaXJzdCBhaXJjcmFmdCBpbiB0aGUgdGFrZW9mZiBxdWV1ZVxuICAgICAgICAgICAgY29uc3QgcnVud2F5ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuZ2V0UnVud2F5KHRoaXMucnd5X2RlcCk7XG4gICAgICAgICAgICBjb25zdCB3YWl0aW5nID0gcnVud2F5LmluUXVldWUodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5XQUlUSU5HICYmIHdhaXRpbmcgPT09IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgZ2V0V2luZFxuICAgICAqL1xuICAgIGdldFdpbmQoKSB7XG4gICAgICAgIGNvbnN0IHdpbmRGb3JSdW53YXkgPSB7XG4gICAgICAgICAgICBjcm9zczogMCxcbiAgICAgICAgICAgIGhlYWQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5yd3lfZGVwKSB7XG4gICAgICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB3aW5kID0gYWlycG9ydC53aW5kO1xuICAgICAgICAgICAgY29uc3QgcnVud2F5ID0gYWlycG9ydC5nZXRSdW53YXkodGhpcy5yd3lfZGVwKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gIGFicyhhbmdsZV9vZmZzZXQocnVud2F5LmFuZ2xlLCB3aW5kLmFuZ2xlKSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZXNlIHR3byBiaXRzIG9mIG1hdGggc2hvdWxkIGJlIGFic3RyYWN0ZWQgdG8gYSBoZWxwZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIHdpbmRGb3JSdW53YXkuY3Jvc3MgPSBzaW4oYW5nbGUpICogd2luZC5zcGVlZDtcbiAgICAgICAgICAgIHdpbmRGb3JSdW53YXkuaGVhZCA9IGNvcyhhbmdsZSkgKiB3aW5kLnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpbmRGb3JSdW53YXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJhZGlvQ2FsbFxuICAgICAqIEBwYXJhbSBtc2cge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2VjdG9yVHlwZSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBhbGVydCB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJhZGlvQ2FsbChtc2csIHNlY3RvclR5cGUsIGFsZXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIGlzIHVudXNlZFxuICAgICAgICBsZXQgY2FsbCA9ICcnO1xuICAgICAgICBjb25zdCBjYWxsc2lnbl9MID0gdGhpcy5nZXRDYWxsc2lnbigpO1xuICAgICAgICBjb25zdCBjYWxsc2lnbl9TID0gdGhpcy5nZXRSYWRpb0NhbGxzaWduKCk7XG5cbiAgICAgICAgaWYgKHNlY3RvclR5cGUpIHtcbiAgICAgICAgICAgIGNhbGwgKz0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkucmFkaW9bc2VjdG9yVHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsICs9IFwiLCBcIiArIHRoaXMuZ2V0Q2FsbHNpZ24oKSArIFwiIFwiICsgbXNnO1xuXG4gICAgICAgIC8vIFRPRE86IHF1aWNrIGFic3RyYWN0aW9uLCB0aGlzIGRvZXNuJ3QgYmVsb25nIGhlcmUuXG4gICAgICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSAoY2FsbHNpZ24pID0+IGAke3dpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLnJhZGlvW3NlY3RvclR5cGVdfSwgJHtjYWxsc2lnbn0gJHttc2d9YDtcblxuICAgICAgICBpZiAoYWxlcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhsb2dNZXNzYWdlKGNhbGxzaWduX0wpLCBpc1dhcm5pbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2cobG9nTWVzc2FnZShjYWxsc2lnbl9MKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVlY2hfc2F5KFt7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiBsb2dNZXNzYWdlKGNhbGxzaWduX1MpXG4gICAgICAgIH1dKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgY2FsbFVwXG4gICAgICovXG4gICAgY2FsbFVwKCkge1xuICAgICAgICBsZXQgYWx0X2xvZztcbiAgICAgICAgbGV0IGFsdF9zYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5BUlJJVkFMKSB7XG4gICAgICAgICAgICBjb25zdCBhbHRkaWZmID0gdGhpcy5hbHRpdHVkZSAtIHRoaXMuZm1zLmFsdGl0dWRlRm9yQ3VycmVudFdheXBvaW50KCk7XG4gICAgICAgICAgICBjb25zdCBhbHQgPSBkaWdpdHNfZGVjaW1hbCh0aGlzLmFsdGl0dWRlLCAtMik7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhhbHRkaWZmKSA+IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChhbHRkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhbHRfbG9nID0gYGRlc2NlbmRpbmcgdGhyb3VnaCAke2FsdH0gZm9yICR7dGhpcy50YXJnZXQuYWx0aXR1ZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgYWx0X3NheSA9IGBkZXNjZW5kaW5nIHRocm91Z2ggJHtyYWRpb19hbHRpdHVkZShhbHQpfSBmb3IgJHtyYWRpb19hbHRpdHVkZSh0aGlzLnRhcmdldC5hbHRpdHVkZSl9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsdGRpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdF9sb2cgPSBgIGNsaW1iaW5nIHRocm91Z2ggJHthbHR9IGZvciAke3RoaXMudGFyZ2V0LmFsdGl0dWRlfWA7XG4gICAgICAgICAgICAgICAgICAgIGFsdF9zYXkgPSBgIGNsaW1iaW5nIHRocm91Z2ggJHtyYWRpb19hbHRpdHVkZShhbHQpfSBmb3IgJHtyYWRpb19hbHRpdHVkZSh0aGlzLnRhcmdldC5hbHRpdHVkZSl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsdF9sb2cgPSBgYXQgJHthbHR9YDtcbiAgICAgICAgICAgICAgICBhbHRfc2F5ID0gYGF0ICR7cmFkaW9fYWx0aXR1ZGUoYWx0KX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgJHt3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5yYWRpby5hcHB9LCAke3RoaXMuZ2V0Q2FsbHNpZ24oKX0gd2l0aCB5b3UgJHthbHRfbG9nfWApO1xuICAgICAgICAgICAgc3BlZWNoX3NheShbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IGAke3dpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLnJhZGlvLmFwcH0sIGAgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjYWxsc2lnbicsIGNvbnRlbnQ6IHRoaXMgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogYHdpdGggeW91ICR7YWx0X3NheX1gIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3dpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLnJhZGlvLnR3cn0sICR7dGhpcy5nZXRDYWxsc2lnbigpfSwgcmVhZHkgdG8gdGF4aWApO1xuICAgICAgICAgICAgc3BlZWNoX3NheShbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLnJhZGlvLnR3ciB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2NhbGxzaWduJywgY29udGVudDogdGhpcyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnLCByZWFkeSB0byB0YXhpJyB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFRoaXMgbWV0aG9kIHNob3VsZCBiZSBtb3ZlZCBlbHNld2hlcmUsIHNpbmNlIGl0IGRvZXNuJ3QgcmVhbGx5IGJlbG9uZyB0byB0aGUgYWlyY3JhZnQgaXRzZWxmXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHNjb3JlV2luZFxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKi9cbiAgICBzY29yZVdpbmQoYWN0aW9uKSB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmdldFdpbmQoKTtcbiAgICAgICAgY29uc3QgaXNXYXJuaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBUT0RPOiB0aGVzZSB0d28gaWYgYmxvY2tzIGNvdWxkIGJlIGRvbmUgaW4gYSBzaW5nbGUgc3dpdGNoIHN0YXRlbWVudFxuICAgICAgICBpZiAoY29tcG9uZW50cy5jcm9zcyA+PSAyMCkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuRVhUUkVNRV9DUk9TU1dJTkRfT1BFUkFUSU9OKTtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3RoaXMuZ2V0Q2FsbHNpZ24oKX0gJHthY3Rpb259IHdpdGggbWFqb3IgY3Jvc3N3aW5kJ2AsIGlzV2FybmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5jcm9zcyA+PSAxMCkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuSElHSF9DUk9TU1dJTkRfT1BFUkFUSU9OKTtcbiAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3RoaXMuZ2V0Q2FsbHNpZ24oKX0gJHthY3Rpb259IHdpdGggY3Jvc3N3aW5kJ2AsIGlzV2FybmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcG9uZW50cy5oZWFkIDw9IC0xMCkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuRVhUUkVNRV9UQUlMV0lORF9PUEVSQVRJT04pO1xuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSAke2FjdGlvbn0gd2l0aCBtYWpvciB0YWlsd2luZCdgLCBpc1dhcm5pbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuaGVhZCA8PSAtMSkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuSElHSF9UQUlMV0lORF9PUEVSQVRJT04pO1xuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSAke2FjdGlvbn0gd2l0aCB0YWlsd2luZCdgLCBpc1dhcm5pbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCBzaG93U3RyaXBcbiAgICAgKi9cbiAgICBzaG93U3RyaXAoKSB7XG4gICAgICAgIHRoaXMuJGh0bWwuZGV0YWNoKCk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gdGhpcy4kc3RyaXBzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIHRoaXMuJHN0cmlwcy5wcmVwZW5kKHRoaXMuJGh0bWwpO1xuICAgICAgICB0aGlzLiRodG1sLnNob3coKTtcbiAgICAgICAgLy8gVE9ETyBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlclxuICAgICAgICAvLyBzaGlmdCBzY3JvbGwgZG93biBvbmUgc3RyaXAncyBoZWlnaHRcbiAgICAgICAgdGhpcy4kc3RyaXBzLnNjcm9sbFRvcChzY3JvbGxQb3MgKyA0NSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBtZXRob2QgbmVlZHMgYSBsb3Qgb2YgbG92ZS4gaXRzIG11Y2ggdG9vIGxvbmcgd2l0aCB3YWFheSB0b28gbWFueSBuZXN0ZWQgaWYvZWxzZSBpZnMuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVRhcmdldFxuICAgICAqL1xuICAgIHVwZGF0ZVRhcmdldCgpIHtcbiAgICAgICAgbGV0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgbGV0IHJ1bndheSA9IG51bGw7XG4gICAgICAgIGxldCBvZmZzZXQgPSBudWxsO1xuICAgICAgICBsZXQgb2Zmc2V0X2FuZ2xlID0gbnVsbDtcbiAgICAgICAgbGV0IGdsaWRlc2xvcGVfYWx0aXR1ZGUgPSBudWxsO1xuICAgICAgICBsZXQgYW5nbGUgPSBudWxsO1xuICAgICAgICBsZXQgcnVud2F5X2VsZXZhdGlvbiA9IDA7XG4gICAgICAgIGxldCBwb3NpdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5yd3lfYXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBydW53YXlfZWxldmF0aW9uID0gYWlycG9ydC5nZXRSdW53YXkodGhpcy5yd3lfYXJyKS5lbGV2YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm1zLnNldEN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIGFsdGl0dWRlOiBNYXRoLm1heCgxMDAwLCB0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mbXMuY3VycmVudFdheXBvaW50Lm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLlJXWSkge1xuICAgICAgICAgICAgcnVud2F5ICA9IGFpcnBvcnQuZ2V0UnVud2F5KHRoaXMucnd5X2Fycik7XG4gICAgICAgICAgICBvZmZzZXQgPSBnZXRPZmZzZXQodGhpcywgcnVud2F5LnBvc2l0aW9uLCBydW53YXkuYW5nbGUpO1xuICAgICAgICAgICAgb2Zmc2V0X2FuZ2xlID0gdnJhZGlhbChvZmZzZXQpO1xuICAgICAgICAgICAgYW5nbGUgPSByYWRpYW5zX25vcm1hbGl6ZShydW53YXkuYW5nbGUpO1xuICAgICAgICAgICAgZ2xpZGVzbG9wZV9hbHRpdHVkZSA9IGNsYW1wKHJ1bndheS5lbGV2YXRpb24sIHJ1bndheS5nZXRHbGlkZXNsb3BlQWx0aXR1ZGUob2Zmc2V0WzFdKSwgdGhpcy5hbHRpdHVkZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25lZEhkZyA9IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5oZWFkaW5nO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVyUmFuZ2UgPSBydW53YXkuaWxzLmVuYWJsZWQgPyBydW53YXkuaWxzLmxvY19tYXhEaXN0IDogNDA7XG4gICAgICAgICAgICB0aGlzLm9mZnNldF9hbmdsZSA9IG9mZnNldF9hbmdsZTtcbiAgICAgICAgICAgIHRoaXMuYXBwcm9hY2hPZmZzZXQgPSBhYnMob2Zmc2V0WzBdKTtcbiAgICAgICAgICAgIHRoaXMuYXBwcm9hY2hEaXN0YW5jZSA9IG9mZnNldFsxXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmhlYWRpbmcgPSBhc3NpZ25lZEhkZztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnR1cm4gPSB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQudHVybjtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFsdGl0dWRlID0gdGhpcy5mbXMuY3VycmVudFdheXBvaW50LmFsdGl0dWRlO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuc3BlZWQgPSB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWQ7XG5cbiAgICAgICAgICAgIC8vIEVzdGFibGlzaGVkIG9uIElMU1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbCBBcHByb2FjaCBIZWFkaW5nIENvbnRyb2xcbiAgICAgICAgICAgICAgICBjb25zdCBzZXZlcml0eV9vZl9jb3JyZWN0aW9uID0gMjU7ICAvLyBjb250cm9scyBzdGVlcG5lc3Mgb2YgaGVhZGluZyBhZGp1c3RtZW50cyBkdXJpbmcgbG9jYWxpemVyIHRyYWNraW5nXG4gICAgICAgICAgICAgICAgY29uc3QgdGd0SGRnID0gYW5nbGUgKyAob2Zmc2V0X2FuZ2xlICogLXNldmVyaXR5X29mX2NvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkhkZyA9IGFuZ2xlIC0gZGVncmVlc1RvUmFkaWFucygzMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4SGRnID0gYW5nbGUgKyBkZWdyZWVzVG9SYWRpYW5zKDMwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5oZWFkaW5nID0gY2xhbXAodGd0SGRnLCBtaW5IZGcsIG1heEhkZyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5hbCBBcHByb2FjaCBBbHRpdHVkZSBDb250cm9sXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYWx0aXR1ZGUgPSBNYXRoLm1pbih0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuYWx0aXR1ZGUsIGdsaWRlc2xvcGVfYWx0aXR1ZGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluYWwgQXBwcm9hY2ggU3BlZWQgQ29udHJvbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm1zLnNldEN1cnJlbnQoeyBzdGFydF9zcGVlZDogdGhpcy5mbXMuY3VycmVudFdheXBvaW50LnNwZWVkIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT25Hcm91bmQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5hbHRpdHVkZSA9IHJ1bndheS5lbGV2YXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNwZWVkID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0X2ZpbmFsX2FwcF9zcGQgPSAzLjU7IC8vIDMuNWttIH49IDJubVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0X2Fzc2lnbmVkX3NwZCA9IDkuNTsgIC8vIDkuNWttIH49IDVubVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zcGVlZCA9IGV4dHJhcG9sYXRlX3JhbmdlX2NsYW1wKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdF9maW5hbF9hcHBfc3BkLCBvZmZzZXRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0X2Fzc2lnbmVkX3NwZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc3BlZWQubGFuZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5zdGFydF9zcGVlZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCBBcHByb2FjaFxuICAgICAgICAgICAgICAgIGlmIChhYnMob2Zmc2V0WzBdKSA+IDAuMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RyaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsTGFuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3RoaXMuZ2V0UmFkaW9DYWxsc2lnbigpfSBhYm9ydGluZyBsYW5kaW5nLCBsb3N0IElMU2AsIGlzV2FybmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVlY2hfc2F5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdjYWxsc2lnbicsIGNvbnRlbnQ6IHRoaXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogJyBnb2luZyBhcm91bmQnIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuR09fQVJPVU5EKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0WzFdIDwgbG9jYWxpemVyUmFuZ2UpIHsgIC8vIEpvaW5pbmcgdGhlIElMU1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFpcmNyYWZ0IGhhcyBqdXN0IGJlY29tZSBlc3RhYmxpc2hlZCBvbiB0aGUgbG9jYWxpemVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxpZ25lZFdpdGhSdW53YXkgPSBhYnMob2Zmc2V0WzBdKSA8IDAuMDUwOyAgLy8gd2l0aGluIDUwbVxuICAgICAgICAgICAgICAgIGNvbnN0IG9uUnVud2F5SGVhZGluZyA9IGFicyh0aGlzLmhlYWRpbmcgLSBhbmdsZSkgPCBkZWdyZWVzVG9SYWRpYW5zKDUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bndheU5vbWluYWxIZWFkaW5nID0gZGVncmVlc1RvUmFkaWFucyhwYXJzZUludCh0aGlzLnJ3eV9hcnIuc3Vic3RyKDAsIDIpLCAxMCkgKiAxMCwgMTApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEludGVyY2VwdEFuZ2xlID0gZGVncmVlc1RvUmFkaWFucygzMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4QWJvdmVHbGlkZXNsb3BlID0gMjUwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyY2VwdEFuZ2xlID0gYWJzKGFuZ2xlX29mZnNldChhc3NpZ25lZEhkZywgcnVud2F5Tm9taW5hbEhlYWRpbmcpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3Vyc2VEaWZmZXJlbmNlID0gYWJzKGFuZ2xlX29mZnNldCh0aGlzLmhlYWRpbmcsIHJ1bndheU5vbWluYWxIZWFkaW5nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduZWRXaXRoUnVud2F5ICYmIG9uUnVud2F5SGVhZGluZyAmJiB0aGlzLm1vZGUgIT09IEZMSUdIVF9NT0RFUy5MQU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZSA9IEZMSUdIVF9NT0RFUy5MQU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5oZWFkaW5nID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGxlZ2FsaXR5IG9mIGxvY2FsaXplciBpbnRlcmNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3RlZCkgeyAgLy8gZG8gbm90IGdpdmUgcGVuYWx0eSBkdXJpbmcgYSBmdXR1cmUgcHJvamVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWJzdHJhY3Rpb24gb24gdGhlIGJlbG93LCB0byByZW1vdmUgZHVwbGljYXRlIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVyY2VwdCBBbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3NpZ25lZEhkZyAmJiBjb3Vyc2VEaWZmZXJlbmNlID4gbWF4SW50ZXJjZXB0QW5nbGUpIHsgLy8gaW50ZXJjZXB0IHZpYSBmaXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSBhcHByb2FjaCBjb3Vyc2UgaW50ZXJjZXB0IGFuZ2xlIHdhcyBncmVhdGVyIHRoYW4gMzAgZGVncmVlc2AsIGlzV2FybmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuSUxMRUdBTF9BUFBST0FDSF9DTEVBUkFOQ0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcmNlcHRBbmdsZSA+IG1heEludGVyY2VwdEFuZ2xlKSB7ICAgIC8vIGludGVyY2VwdCB2aWEgdmVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSBhcHByb2FjaCBjb3Vyc2UgaW50ZXJjZXB0IGFuZ2xlIHdhcyBncmVhdGVyIHRoYW4gMzAgZGVncmVlc2AsIGlzV2FybmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmV2ZW50c19yZWNvcmROZXcoR0FNRV9FVkVOVFMuSUxMRUdBTF9BUFBST0FDSF9DTEVBUkFOQ0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHbGlkZXNsb3BlIGludGVyY2VwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWx0aXR1ZGUgPiBnbGlkZXNsb3BlX2FsdGl0dWRlICsgbWF4QWJvdmVHbGlkZXNsb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhgJHt0aGlzLmdldFJhZGlvQ2FsbHNpZ24oKX0gam9pbmVkIGxvY2FsaXplciBhYm92ZSBnbGlkZXNsb3BlIGFsdGl0dWRlYCwgaXNXYXJuaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZXZlbnRzX3JlY29yZE5ldyhHQU1FX0VWRU5UUy5JTExFR0FMX0FQUFJPQUNIX0NMRUFSQU5DRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlwKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnR1cm4gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbWF0aCBzZWN0aW9uIHNob3VsZCBiZSBhYnNjdHJhY3RlZCB0byBhIGhlbHBlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIEd1aWRlIGFpcmNyYWZ0IG9udG8gdGhlIGxvY2FsaXplclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlX2RpZmYgPSBhbmdsZV9vZmZzZXQoYW5nbGUsIHRoaXMuaGVhZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHVybmluZ190aW1lID0gTWF0aC5hYnMocmFkaWFuc1RvRGVncmVlcyhhbmdsZV9kaWZmKSkgLyAzOyAvLyB0aW1lIHRvIHR1cm4gYW5nbGVfZGlmZiBkZWdyZWVzIGF0IDMgZGVnL3NcbiAgICAgICAgICAgICAgICBjb25zdCB0dXJuaW5nX3JhZGl1cyA9IGttKHRoaXMuc3BlZWQpIC8gMzYwMCAqIHR1cm5pbmdfdGltZTsgLy8gZGlzdCBjb3ZlcmVkIGluIHRoZSB0dXJuLCBrbVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RfdG9fbG9jYWxpemVyID0gb2Zmc2V0WzBdIC8gc2luKGFuZ2xlX2RpZmYpOyAvLyBkaXN0IGZyb20gdGhlIGxvY2FsaXplciBpbnRlcmNlcHQgcG9pbnQsIGttXG4gICAgICAgICAgICAgICAgY29uc3QgdHVybl9lYXJseV9rbSA9IDE7ICAgIC8vIHN0YXJ0IHR1cm4gMWttIGVhcmx5LCB0byBhdm9pZCBvdmVyc2hvb3RzIGZyb20gdGFpbHdpbmRcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRfYXR0ZW1wdF9pbnRlcmNlcHQgPSAoMCA8IGRpc3RfdG9fbG9jYWxpemVyICYmIGRpc3RfdG9fbG9jYWxpemVyIDw9IHR1cm5pbmdfcmFkaXVzICsgdHVybl9lYXJseV9rbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5fdGhlX3dpbmRvdyA9IGFicyhvZmZzZXRfYW5nbGUpIDwgZGVncmVlc1RvUmFkaWFucygxLjUpOyAgLy8gaWYgdHJ1ZSwgYWlyY3JhZnQgd2lsbCBtb3ZlIHRvIGxvY2FsaXplciwgcmVnYXJkbGVzcyBvZiBhc3NpZ25lZCBoZWFkaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkX2F0dGVtcHRfaW50ZXJjZXB0IHx8IGluX3RoZV93aW5kb3cpIHsgIC8vIHRpbWUgdG8gYmVnaW4gdHVyblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXZlcml0eV9vZl9jb3JyZWN0aW9uID0gNTA7ICAvLyBjb250cm9scyBzdGVlcG5lc3Mgb2YgaGVhZGluZyBhZGp1c3RtZW50cyBkdXJpbmcgbG9jYWxpemVyIHRyYWNraW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRndEhkZyA9IGFuZ2xlICsgKG9mZnNldF9hbmdsZSAqIC1zZXZlcml0eV9vZl9jb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluSGRnID0gYW5nbGUgLSBkZWdyZWVzVG9SYWRpYW5zKDMwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4SGRnID0gYW5nbGUgKyBkZWdyZWVzVG9SYWRpYW5zKDMwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuaGVhZGluZyA9IGNsYW1wKHRndEhkZywgbWluSGRnLCBtYXhIZGcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQubmF2bW9kZSA9PT0gV0FZUE9JTlRfTkFWX01PREUuRklYKSB7XG4gICAgICAgICAgICBjb25zdCBmaXggPSB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQubG9jYXRpb247XG4gICAgICAgICAgICBpZiAoIWZpeCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dGhpcy5nZXRDYWxsc2lnbigpfSB1c2luZyBcImZpeFwiIG5hdm1vZGUsIGJ1dCBubyBmaXggbG9jYXRpb24hYCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5mbXMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZlY3Rvcl90b19maXggPSB2c3ViKHRoaXMucG9zaXRpb24sIGZpeCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZV90b19maXggPSBkaXN0YW5jZTJkKHRoaXMucG9zaXRpb24sIGZpeCk7XG5cbiAgICAgICAgICAgIGlmICgoZGlzdGFuY2VfdG9fZml4IDwgMSkgfHxcbiAgICAgICAgICAgICAgICAoKGRpc3RhbmNlX3RvX2ZpeCA8IDEwKSAmJlxuICAgICAgICAgICAgICAgIChkaXN0YW5jZV90b19maXggPCB3aW5kb3cuYWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0X3R1cm5faW5pdGlhdGlvbl9kaXN0YW5jZSh0aGlzLCBmaXgpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHdheXBvaW50cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm1zLmF0TGFzdFdheXBvaW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbXMubmV4dFdheXBvaW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxGaXgoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlwKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmhlYWRpbmcgPSB2cmFkaWFsKHZlY3Rvcl90b19maXgpIC0gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC50dXJuID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQubmF2bW9kZSA9PT0gV0FZUE9JTlRfTkFWX01PREUuSE9MRCkge1xuICAgICAgICAgICAgY29uc3QgaG9sZCA9IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5ob2xkO1xuICAgICAgICAgICAgY29uc3QgYW5nbGVfb2ZmX29mX2xlZ19oZGcgPSBhYnMoYW5nbGVfb2Zmc2V0KHRoaXMuaGVhZGluZywgdGhpcy50YXJnZXQuaGVhZGluZykpO1xuXG4gICAgICAgICAgICAvLyB3aXRoaW4gfjLCsCBvZiB1cHdkL2Rud2RcbiAgICAgICAgICAgIGlmIChhbmdsZV9vZmZfb2ZfbGVnX2hkZyA8IDAuMDM1KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMsIGhvbGQuZml4UG9zKTtcblxuICAgICAgICAgICAgICAgIC8vIGVudGVyaW5nIGhvbGQsIGp1c3QgcGFzc2VkIHRoZSBmaXhcbiAgICAgICAgICAgICAgICBpZiAoaG9sZC50aW1lciA9PT0gbnVsbCAmJiBvZmZzZXRbMV0gPCAwICYmIG9mZnNldFsyXSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYWlyY3JhZnQgdG8gZW50ZXIgdGhlIGhvbGQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgaG9sZC50aW1lciA9IC05OTk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSG9sZGluZyBMb2dpY1xuICAgICAgICAgICAgICAgIC8vIHRpbWUtYmFzZWQgaG9sZCBsZWdzXG4gICAgICAgICAgICAgICAgaWYgKGhvbGQudGltZXIgJiYgaG9sZC5sZWdMZW5ndGguaW5jbHVkZXMoJ21pbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkLnRpbWVyID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZC50aW1lciA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUudGltZSA+PSBob2xkLnRpbWVyICsgcGFyc2VJbnQoaG9sZC5sZWdMZW5ndGgucmVwbGFjZSgnbWluJywgJycpLCAxMCkgKiA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGltZSB0byB0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5oZWFkaW5nICs9IE1hdGguUEk7ICAgLy8gdHVybiB0byBvdGhlciBsZWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnR1cm4gPSBob2xkLmRpclR1cm5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZC50aW1lciA9IC0xOyAvLyByZXNldCB0aGUgdGltZXJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob2xkLmxlZ0xlbmd0aC5pbmNsdWRlcygnbm0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UtYmFzZWQgaG9sZCBsZWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgeWV0IGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5oZWFkaW5nID0gdGhpcy5mbXMuY3VycmVudFdheXBvaW50LmhlYWRpbmc7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC50dXJuID0gdGhpcy5mbXMuY3VycmVudFdheXBvaW50LnR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSBGTElHSFRfTU9ERVMuTEFORElORykge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWx0aXR1ZGUgPSB0aGlzLmZtcy5hbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuZXhwZWRpdGUgPSB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuZXhwZWRpdGU7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hbHRpdHVkZSA9IE1hdGgubWF4KDEwMDAsIHRoaXMudGFyZ2V0LmFsdGl0dWRlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNwZWVkID0gX2dldCh0aGlzLCAnZm1zLmN1cnJlbnRXYXlwb2ludC5zcGVlZCcsIHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuc3BlZWQgPSBjbGFtcCh0aGlzLm1vZGVsLnNwZWVkLm1pbiwgdGhpcy50YXJnZXQuc3BlZWQsIHRoaXMubW9kZWwuc3BlZWQubWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHN0YWxsaW5nLCBtYWtlIGxpa2UgYSBtZXRlb3JpdGUgYW5kIGZhbGwgdG8gdGhlIGVhcnRoIVxuICAgICAgICBpZiAodGhpcy5zcGVlZCA8IHRoaXMubW9kZWwuc3BlZWQubWluICYmICF0aGlzLmlzT25Hcm91bmQoKSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWx0aXR1ZGUgPSBNYXRoLm1pbigwLCB0aGlzLnRhcmdldC5hbHRpdHVkZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCB0YXhpIG92ZXJyaWRlcyBldmVyeXRoaW5nXG4gICAgICAgIGxldCB3YXNfdGF4aSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEZMSUdIVF9NT0RFUy5UQVhJKSB7XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZSgpIC0gdGhpcy50YXhpX3N0YXJ0O1xuXG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IHRoaXMudGF4aV90aW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlID0gRkxJR0hUX01PREVTLldBSVRJTkc7XG4gICAgICAgICAgICAgICAgd2FzX3RheGkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdHJpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLldBSVRJTkcpIHtcbiAgICAgICAgICAgIHJ1bndheSA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmdldFJ1bndheSh0aGlzLnJ3eV9kZXApO1xuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHJ1bndheS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gPSBwb3NpdGlvblswXTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZyA9IHJ1bndheS5hbmdsZTtcbiAgICAgICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBydW53YXkuZWxldmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGVkICYmXG4gICAgICAgICAgICAgICAgcnVud2F5LmluUXVldWUodGhpcykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICB3YXNfdGF4aSA9PT0gdHJ1ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci51aV9sb2coYCR7dGhpcy5nZXRDYWxsc2lnbigpfSwgaG9sZGluZyBzaG9ydCBvZiBydW53YXkgJHt0aGlzLnJ3eV9kZXB9YCk7XG4gICAgICAgICAgICAgICAgc3BlZWNoX3NheShbXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2NhbGxzaWduJywgY29udGVudDogdGhpcyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogYGhvbGRpbmcgc2hvcnQgb2YgcnVud2F5ICR7cmFkaW9fcnVud2F5KHRoaXMucnd5X2RlcCl9YCB9XG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuVEFLRU9GRikge1xuICAgICAgICAgICAgcnVud2F5ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuZ2V0UnVud2F5KHRoaXMucnd5X2RlcCk7XG5cbiAgICAgICAgICAgIC8vIEFsdGl0dWRlIENvbnRyb2xcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkIDwgdGhpcy5tb2RlbC5zcGVlZC5taW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5hbHRpdHVkZSA9IHJ1bndheS5lbGV2YXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFsdGl0dWRlID0gdGhpcy5mbXMuYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGVhZGluZyBDb250cm9sXG4gICAgICAgICAgICBjb25zdCByd3lIZGcgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5nZXRSdW53YXkodGhpcy5yd3lfZGVwKS5hbmdsZTtcbiAgICAgICAgICAgIGlmICgodGhpcy5hbHRpdHVkZSAtIHJ1bndheS5lbGV2YXRpb24pIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuaGVhZGluZyA9IHJ3eUhkZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZtcy5mb2xsb3dDaGVjaygpLnNpZCAmJiB0aGlzLmZtcy5jdXJyZW50V2F5cG9pbnQuaGVhZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBkaXJlY3Rpb25hbCBpbnN0cnVjdGlvbnMgYXZhaWxhYmxlIGFmdGVyIHRha2VvZmZcbiAgICAgICAgICAgICAgICAgICAgLy8gZmx5IHJ1bndheSBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm1zLnNldEN1cnJlbnQoeyBoZWFkaW5nOiByd3lIZGcgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlID0gRkxJR0hUX01PREVTLkNSVUlTRTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlwKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNwZWVkIENvbnRyb2xcbiAgICAgICAgICAgIC8vIGdvIGZhc3QhXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5zcGVlZCA9IHRoaXMubW9kZWwuc3BlZWQuY3J1aXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGltaXQgc3BlZWQgdG8gMjUwIGtub3RzIHdoaWxlIHVuZGVyIDEwLDAwMCBmZWV0IE1TTCAoaXQncyB0aGUgbGF3ISlcbiAgICAgICAgaWYgKHRoaXMuYWx0aXR1ZGUgPCAxMDAwMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmVjaXNpb25HdWlkZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIGJ0d24gMCBhbmQgMjUwXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc3BlZWQgPSBNYXRoLm1pbih0aGlzLnRhcmdldC5zcGVlZCwgMjUwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYnR3biBzY2hlZHVsZWQgc3BlZWQgYW5kIDI1MFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNwZWVkID0gTWF0aC5taW4odGhpcy5mbXMuY3VycmVudFdheXBvaW50LnNwZWVkLCAyNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBtZXRob2QgbmVlZHMgYSBsb3Qgb2YgbG92ZS4gaXRzIG11Y2ggdG9vIGxvbmcgd2l0aCB3YWFheSB0b28gbWFueSBuZXN0ZWQgaWYvZWxzZSBpZnMuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVBoeXNpY3NcbiAgICAgKi9cbiAgICB1cGRhdGVQaHlzaWNzKCkge1xuICAgICAgICBpZiAodGhpcy5pc1RheGlpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGl0KSB7XG4gICAgICAgICAgICAvLyA5MGZwcyBmYWxsIHJhdGU/Li4uXG4gICAgICAgICAgICB0aGlzLmFsdGl0dWRlIC09IDkwICogd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfZGVsdGEoKTtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgKj0gMC45OTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVFVSTklOR1xuICAgICAgICAvLyB0aGlzLnRhcmdldC5oZWFkaW5nID0gcmFkaWFuc19ub3JtYWxpemUodGhpcy50YXJnZXQuaGVhZGluZyk7XG4gICAgICAgIGlmICghdGhpcy5pc09uR3JvdW5kKCkgJiYgdGhpcy5oZWFkaW5nICE9PSB0aGlzLnRhcmdldC5oZWFkaW5nKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIHN0YW5kYXJkIHR1cm5zIDMgZGVnL3Mgb3IgMjUgZGVnIGJhbmssIHdoaWNoZXZlclxuICAgICAgICAgICAgLy8gcmVxdWlyZXMgbGVzcyBiYW5rIGFuZ2xlLlxuICAgICAgICAgICAgLy8gRm9ybXVsYSBiYXNlZCBvbiBodHRwOi8vYXZpYXRpb24uc3RhY2tleGNoYW5nZS5jb20vYS84MDEzXG4gICAgICAgICAgICBjb25zdCB0dXJuX3JhdGUgPSBjbGFtcCgwLCAxIC8gKHRoaXMuc3BlZWQgLyA4Ljg4MzAzMSksIDAuMDUyMzU5ODc3Nik7XG4gICAgICAgICAgICBjb25zdCB0dXJuX2Ftb3VudCA9IHR1cm5fcmF0ZSAqIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX2RlbHRhKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmdsZV9vZmZzZXQodGhpcy50YXJnZXQuaGVhZGluZywgdGhpcy5oZWFkaW5nKTtcblxuICAgICAgICAgICAgaWYgKGFicyhvZmZzZXQpIDwgdHVybl9hbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLnRhcmdldC5oZWFkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgob2Zmc2V0IDwgMCAmJiB0aGlzLnRhcmdldC50dXJuID09PSBudWxsKSB8fCB0aGlzLnRhcmdldC50dXJuID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmcgLT0gdHVybl9hbW91bnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChvZmZzZXQgPiAwICYmIHRoaXMudGFyZ2V0LnR1cm4gPT09IG51bGwpIHx8IHRoaXMudGFyZ2V0LnR1cm4gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRpbmcgKz0gdHVybl9hbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBTFRJVFVERVxuICAgICAgICBsZXQgZGlzdGFuY2UgPSBudWxsO1xuICAgICAgICBjb25zdCBleHBlZGl0ZV9mYWN0b3IgPSAxLjU7XG4gICAgICAgIHRoaXMudHJlbmQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLnRhcmdldC5hbHRpdHVkZSA8IHRoaXMuYWx0aXR1ZGUgLSAwLjAyKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC10aGlzLm1vZGVsLnJhdGUuZGVzY2VudCAvIDYwICogd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfZGVsdGEoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkcpIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSAqPSAzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyZW5kIC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXQuYWx0aXR1ZGUgPiB0aGlzLmFsdGl0dWRlICsgMC4wMikge1xuICAgICAgICAgICAgY29uc3QgY2xpbWJyYXRlID0gdGhpcy5nZXRDbGltYlJhdGUoKTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gY2xpbWJyYXRlIC8gNjAgKiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9kZWx0YSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuTEFORElORykge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlICo9IDEuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmVuZCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldC5leHBlZGl0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlICo9IGV4cGVkaXRlX2ZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5hbHRpdHVkZSAtIHRoaXMudGFyZ2V0LmFsdGl0dWRlO1xuXG4gICAgICAgICAgICBpZiAoYWJzKG9mZnNldCkgPCBhYnMoZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbHRpdHVkZSA9IHRoaXMudGFyZ2V0LmFsdGl0dWRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGl0dWRlICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNPbkdyb3VuZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRyZW5kID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNQRUVEXG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy50YXJnZXQuc3BlZWQgPCB0aGlzLnNwZWVkIC0gMC4wMSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IC10aGlzLm1vZGVsLnJhdGUuZGVjZWxlcmF0ZSAqIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX2RlbHRhKCkgLyAyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc09uR3JvdW5kKCkpIHtcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICo9IDMuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldC5zcGVlZCA+IHRoaXMuc3BlZWQgKyAwLjAxKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlICA9IHRoaXMubW9kZWwucmF0ZS5hY2NlbGVyYXRlICogd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfZGVsdGEoKSAvIDI7XG4gICAgICAgICAgICBkaWZmZXJlbmNlICo9IGV4dHJhcG9sYXRlX3JhbmdlX2NsYW1wKDAsIHRoaXMuc3BlZWQsIHRoaXMubW9kZWwuc3BlZWQubWluLCAyLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnNwZWVkIC0gdGhpcy50YXJnZXQuc3BlZWQ7XG5cbiAgICAgICAgICAgIGlmIChhYnMob2Zmc2V0KSA8IGFicyhkaWZmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLnRhcmdldC5zcGVlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlZCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFpbGxpbmdcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25faGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25faGlzdG9yeS5wdXNoKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdLFxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXG4gICAgICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZSgpIC8gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfc3BlZWR1cCgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIGFic3RyYWN0ZWRcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoKHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKSAvIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3NwZWVkdXAoKSkgLSB0aGlzLnBvc2l0aW9uX2hpc3RvcnlbdGhpcy5wb3NpdGlvbl9oaXN0b3J5Lmxlbmd0aCAtIDFdWzJdKSA+IDQgLyB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9zcGVlZHVwKCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25faGlzdG9yeS5wdXNoKFt0aGlzLnBvc2l0aW9uWzBdLCB0aGlzLnBvc2l0aW9uWzFdLCB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkgLyB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9zcGVlZHVwKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5oZWFkaW5nO1xuICAgICAgICAvLyBGSVhNRTogaXMgdGhpcyByYXRpbyBjb3JyZWN0PyBpcyBpdCAwLjAwMDUxNDQ0NCBvciAwLjUxNDQ0ND9cbiAgICAgICAgbGV0IHNjYWxlU3BlZWQgPSB0aGlzLnNwZWVkICogMC4wMDA1MTQ0NDQgKiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9kZWx0YSgpOyAvLyBrbm90cyB0byBtL3NcblxuICAgICAgICBpZiAod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUub3B0aW9uLmdldCgnc2ltcGxpZnlTcGVlZHMnKSA9PT0gJ25vJykge1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RlZCB0byBhIGhlbHBlciBmdW5jdGlvblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0cnVlIGFpciBzcGVlZCBhcyBpbmRpY2F0ZWQgYWlyc3BlZWQgKiAxLjYlIHBlciAxMDAwJ1xuICAgICAgICAgICAgc2NhbGVTcGVlZCAqPSAxICsgKHRoaXMuYWx0aXR1ZGUgKiAwLjAwMDAxNik7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBtb3ZlbWVudCBpbmNsdWRpbmcgd2luZCBhc3N1bWluZyB3aW5kIHNwZWVkXG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgMiUgcGVyIDEwMDAnXG4gICAgICAgICAgICBjb25zdCB3aW5kID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkud2luZDtcbiAgICAgICAgICAgIGxldCB2ZWN0b3I7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT25Hcm91bmQoKSkge1xuICAgICAgICAgICAgICAgIHZlY3RvciA9IHZzY2FsZShbc2luKGFuZ2xlKSwgY29zKGFuZ2xlKV0sIHNjYWxlU3BlZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY3JhYl9hbmdsZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjcm9zc3dpbmQgd2hpbGUgdHJhY2tpbmcgYSBmaXggb3Igb24gSUxTXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludC5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5GSVggfHwgdGhpcy5tb2RlID09PSBGTElHSFRfTU9ERVMuTEFORElORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhYnN0cmFjdGVkIHRvIGEgaGVscGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGFuZ2xlX29mZnNldCh0aGlzLmhlYWRpbmcsIHdpbmQuYW5nbGUgKyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgY3JhYl9hbmdsZSA9IE1hdGguYXNpbigod2luZC5zcGVlZCAqIHNpbihvZmZzZXQpKSAvIHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0ZWQgdG8gYSBoZWxwZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSB2YWRkKHZzY2FsZShcbiAgICAgICAgICAgICAgICAgICAgdnR1cm4od2luZC5hbmdsZSArIE1hdGguUEkpLFxuICAgICAgICAgICAgICAgICAgICB3aW5kLnNwZWVkICogMC4wMDA1MTQ0NDQgKiB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9kZWx0YSgpKSxcbiAgICAgICAgICAgICAgICAgICAgdnNjYWxlKHZ0dXJuKGFuZ2xlICsgY3JhYl9hbmdsZSksIHNjYWxlU3BlZWQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcyA9IHZsZW4odmVjdG9yKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0ZWQgdG8gYSBoZWxwZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIHRoaXMuZ3JvdW5kU3BlZWQgPSB0aGlzLmRzIC8gMC4wMDA1MTQ0NDQgLyB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9kZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5ncm91bmRUcmFjayA9IHZyYWRpYWwodmVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB2YWRkKHRoaXMucG9zaXRpb24sIHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRzID0gc2NhbGVTcGVlZDtcbiAgICAgICAgICAgIHRoaXMuZ3JvdW5kU3BlZWQgPSB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgdGhpcy5ncm91bmRUcmFjayA9IHRoaXMuaGVhZGluZztcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB2YWRkKHRoaXMucG9zaXRpb24sIHZzY2FsZShbc2luKGFuZ2xlKSwgY29zKGFuZ2xlKV0sIHNjYWxlU3BlZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB2bGVuKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnJhZGlhbCA9IHZyYWRpYWwodGhpcy5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMucmFkaWFsIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpYWwgKz0gdGF1KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0luc2lkZUFpcnNwYWNlID0gdGhpcy5pc0luc2lkZUFpcnNwYWNlKHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpKTtcblxuICAgICAgICBpZiAoaXNJbnNpZGVBaXJzcGFjZSAhPT0gdGhpcy5pbnNpZGVfY3RyKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3NzQm91bmRhcnkoaXNJbnNpZGVBaXJzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIG1ldGhvZCBuZWVkcyBhIGxvdCBvZiBsb3ZlLiBpdHMgbXVjaCB0b28gbG9uZyB3aXRoIHdhYWF5IHRvbyBtYW55IG5lc3RlZCBpZi9lbHNlIGlmcy5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgdXBkYXRlV2FybmluZ1xuICAgICAqL1xuICAgIHVwZGF0ZVdhcm5pbmcoKSB7XG4gICAgICAgIGxldCBhcmVhO1xuICAgICAgICBsZXQgd2FybmluZztcbiAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgbGV0IG5ld19pbnNpZGU7XG5cbiAgICAgICAgLy8gSWdub3JlIG90aGVyIGFpcmNyYWZ0IHdoaWxlIHRheGlpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNUYXhpaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXN0cmljdGVkIGFyZWFzXG4gICAgICAgIC8vIHBsYXllcnMgYXJlIHBlbmFsaXplZCBmb3IgZWFjaCBhcmVhIGVudHJ5XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVzdHJpY3RlZC5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RlZCB0byBhIGhlbHBlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vICAgUG9seWdvbiBtYXRjaGluZyBwcm9jZWR1cmU6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIDEuIEZpbHRlciBwb2x5Z29ucyBieSBhaXJjcmFmdCBhbHRpdHVkZVxuICAgICAgICAgICAgICAgIC8vICAgMi4gRm9yIG90aGVyIHBvbHlnb25zLCBtZWFzdXJlIGRpc3RhbmNlIHRvIGl0IChkaXN0YW5jZV90b19wb2x5KSwgdGhlblxuICAgICAgICAgICAgICAgIC8vICAgICAgc3Vic3RyYWN0IHRyYXZlbGxlZCBkaXN0YW5jZSBldmVyeSB0dXJuXG4gICAgICAgICAgICAgICAgLy8gICAgICBJZiBkaXN0YW5jZSBpcyBhYm91dCBsZXNzIHRoYW4gMTAgc2Vjb25kcyBvZiBmbGlnaHQsXG4gICAgICAgICAgICAgICAgLy8gICAgICBhc3NpZ24gZGlzdGFuY2UgZXF1YWwgdG8gMTAgc2Vjb25kcyBvZiBmbGlnaHQsXG4gICAgICAgICAgICAgICAgLy8gICAgICBvdGhlcndpc2UgcGxhbmVzIGZseWluZyBhbG9uZyB0aGUgYm9yZGVyIG9mIGVudGVyaW5nIGF0IHNoYWxsb3cgYW5nbGVcbiAgICAgICAgICAgICAgICAvLyAgICAgIHdpbGwgY2F1c2UgdG9vIG1hbnkgY2hlY2tzLlxuICAgICAgICAgICAgICAgIC8vICAgMy4gaWYgZGlzdGFuY2UgaGFzIHJlYWNoZWQgMCwgY2hlY2sgaWYgdGhlIGFpcmNyYWZ0IGlzIHdpdGhpbiB0aGUgcG9seS5cbiAgICAgICAgICAgICAgICAvLyAgICAgIElmIG5vdCwgcmVkbyAjMi5cbiAgICAgICAgICAgICAgICBhcmVhID0gdGhpcy5yZXN0cmljdGVkLmxpc3RbaV07XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb25seSB0aG9zZSByZWxldmFudCBieSBoZWlnaHRcbiAgICAgICAgICAgICAgICBpZiAoYXJlYS5kYXRhLmhlaWdodCA8IHRoaXMuYWx0aXR1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYS5yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGFyZWEuaW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvdW50IGRpc3RhbmNlIHVudGlsbCB0aGUgbmV4dCBjaGVja1xuICAgICAgICAgICAgICAgIGlmIChhcmVhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWEucmFuZ2UgLT0gdGhpcy5kcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBmb3IgbmV3IGFyZWFzIG9yIHRob3NlIHRoYXQgc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICBpZiAoIWFyZWEucmFuZ2UgfHwgYXJlYS5yYW5nZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld19pbnNpZGUgPSBwb2ludF9pbl9wb2x5KHRoaXMucG9zaXRpb24sIGFyZWEuZGF0YS5jb29yZGluYXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWMgaGFzIGp1c3QgZW50ZXJlZCB0aGUgYXJlYTogLmluc2lkZSBpcyBzdGlsbCBmYWxzZSwgYnV0IHN0IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19pbnNpZGUgJiYgIWFyZWEuaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZXZlbnRzX3JlY29yZE5ldyhHQU1FX0VWRU5UUy5BSVJTUEFDRV9CVVNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEucmFuZ2UgPSB0aGlzLnNwZWVkICogMS44NSAvIDMuNiAqIDUwIC8gMTAwMDsgLy8gY2hlY2sgaW4gNTAgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlZWQgaXMga3RzLCByYW5nZSBpcyBrbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgcGxhbmUgZ290IGludG8gcmVzdHJpY3RlZCBhcmVhLCBkb24ndCBjaGVjayBpdCB0b28gb2Z0ZW5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNhbGN1bGF0ZSBtb3JlIG9mdGVuIHRoYW4gZXZlcnkgMTAgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5yYW5nZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCAqIDEuODUgLyAzNiAvIDEwMDAgKiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlX3RvX3BvbHkodGhpcy5wb3NpdGlvbiwgYXJlYS5kYXRhLmNvb3JkaW5hdGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcmVhLmluc2lkZSA9IG5ld19pbnNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByYWlzZSB3YXJuaW5nIGlmIGluIGF0IGxlYXN0IG9uZSByZXN0cmljdGVkIGFyZWFcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLnJlc3RyaWN0ZWQubGlzdCwgKGssIHYpID0+IHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nID0gd2FybmluZyB8fCB2Lmluc2lkZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGVycmFpbl9yYW5nZXMgJiYgIXRoaXMuaXNPbkdyb3VuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJyYWluID0gcHJvcC5haXJwb3J0LmN1cnJlbnQudGVycmFpbjtcbiAgICAgICAgICAgIGNvbnN0IHByZXZfbGV2ZWwgPSB0aGlzLnRlcnJhaW5fcmFuZ2VzW3RoaXMudGVycmFpbl9sZXZlbF07XG4gICAgICAgICAgICBjb25zdCBlbGUgPSBNYXRoLmNlaWwodGhpcy5hbHRpdHVkZSwgMTAwMCk7XG4gICAgICAgICAgICBsZXQgY3Vycl9yYW5nZXMgPSB0aGlzLnRlcnJhaW5fcmFuZ2VzW2VsZV07XG5cbiAgICAgICAgICAgIGlmIChlbGUgIT09IHRoaXMudGVycmFpbl9sZXZlbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGV2IGluIHByZXZfbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9sZXZlbFtsZXZdID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50ZXJyYWluX2xldmVsID0gZWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIGN1cnJfcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY3Vycl9yYW5nZXNbaWRdIC09IHRoaXMuZHM7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY3Vycl9yYW5nZXNbaWRdKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyX3Jhbmdlc1tpZF0gPCAwIHx8IGN1cnJfcmFuZ2VzW2lkXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYSA9IHRlcnJhaW5bZWxlXVtpZF07XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHBvaW50X3RvX21wb2x5KHRoaXMucG9zaXRpb24sIGFyZWEsIGlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHRpdHVkZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaGl0IHRlcnJhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1dhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIudWlfbG9nKGAke3RoaXMuZ2V0Q2FsbHNpZ24oKX0gY29sbGlkZWQgd2l0aCB0ZXJyYWluIGluIGNvbnRyb2xsZWQgZmxpZ2h0YCwgaXNXYXJuaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVlY2hfc2F5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnY2FsbHNpZ24nLCBjb250ZW50OiB0aGlzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnLCB3ZVxcJ3JlIGdvaW5nIGRvd24hJyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZXZlbnRzX3JlY29yZE5ldyhHQU1FX0VWRU5UUy5DT0xMSVNJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl9yYW5nZXNbaWRdID0gTWF0aC5tYXgoMC4yLCBzdGF0dXMuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nZXRDYWxsc2lnbigpLCAnaW4nLCBjdXJyX3Jhbmdlc1tpZF0sICdrbSBmcm9tJywgaWQsIGFyZWFbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2FybmluZyA9IHdhcm5pbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVN0cmlwXG4gICAgICovXG4gICAgdXBkYXRlU3RyaXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGZtcy5mb2xsb3dpbmdcbiAgICAgICAgdGhpcy5mbXMuZm9sbG93Q2hlY2soKTtcblxuICAgICAgICBjb25zdCB3cCA9IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludDtcbiAgICAgICAgLy8gUG9wdWxhdGUgc3RyaXAgZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdEhlYWRpbmdUZXh0ID0gaGVhZGluZ190b19zdHJpbmcod3AuaGVhZGluZyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBbHRpdHVkZVRleHQgPSBfZ2V0KHdwLCAnYWx0aXR1ZGUnLCAnLScpO1xuICAgICAgICBjb25zdCBkZWZhdWx0RGVzdGluYXRpb25UZXh0ID0gX2dldCh0aGlzLCAnZGVzdGluYXRpb24nLCB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5pY2FvKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNwZWVkVGV4dCA9IHdwLnNwZWVkO1xuXG4gICAgICAgIGxldCBoZWFkaW5nVGV4dDtcbiAgICAgICAgY29uc3QgYWx0aXR1ZGVUZXh0ID0gdGhpcy50YXhpX25leHQgPyAncmVhZHknIDogbnVsbDtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uVGV4dCA9IHRoaXMuZm1zLmdldEZvbGxvd2luZ1NJRFRleHQoKTtcbiAgICAgICAgY29uc3QgaGFzQWx0aXR1ZGUgPSBfaGFzKHdwLCAnYWx0aXR1ZGUnKTtcbiAgICAgICAgY29uc3QgaXNGb2xsb3dpbmdTSUQgPSBfaXNTdHJpbmcoZGVzdGluYXRpb25UZXh0KTtcbiAgICAgICAgY29uc3QgaXNGb2xsb3dpbmdTVEFSID0gX2lzU3RyaW5nKHRoaXMuZm1zLmZvbGxvd2luZy5zdGFyKTtcbiAgICAgICAgY29uc3QgeyBmaXhSZXN0cmljdGlvbnMgfSA9IHRoaXMuZm1zLmN1cnJlbnRXYXlwb2ludDtcblxuICAgICAgICB0aGlzLmFpcmNyYWZ0U3RyaXBWaWV3LnVwZGF0ZShkZWZhdWx0SGVhZGluZ1RleHQsIGRlZmF1bHRBbHRpdHVkZVRleHQsIGRlZmF1bHREZXN0aW5hdGlvblRleHQsIGN1cnJlbnRTcGVlZFRleHQpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEZMSUdIVF9NT0RFUy5BUFJPTjpcbiAgICAgICAgICAgICAgICB0aGlzLmFpcmNyYWZ0U3RyaXBWaWV3LnVwZGF0ZVZpZXdGb3JBcHJvbihkZXN0aW5hdGlvblRleHQsIGhhc0FsdGl0dWRlLCBpc0ZvbGxvd2luZ1NJRCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZMSUdIVF9NT0RFUy5UQVhJOlxuICAgICAgICAgICAgICAgIHRoaXMuYWlyY3JhZnRTdHJpcFZpZXcudXBkYXRlVmlld0ZvclRheGkoZGVzdGluYXRpb25UZXh0LCBoYXNBbHRpdHVkZSwgaXNGb2xsb3dpbmdTSUQsIGFsdGl0dWRlVGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZMSUdIVF9NT0RFUy5XQUlUSU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuYWlyY3JhZnRTdHJpcFZpZXcudXBkYXRlVmlld0ZvcldhaXRpbmcoZGVzdGluYXRpb25UZXh0LCBoYXNBbHRpdHVkZSwgaXNGb2xsb3dpbmdTSUQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGTElHSFRfTU9ERVMuVEFLRU9GRjpcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRha2luZyBvZmYuLi5cbiAgICAgICAgICAgICAgICB0aGlzLmFpcmNyYWZ0U3RyaXBWaWV3LnVwZGF0ZVZpZXdGb3JUYWtlb2ZmKGRlc3RpbmF0aW9uVGV4dCwgaXNGb2xsb3dpbmdTSUQpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZMSUdIVF9NT0RFUy5DUlVJU0U6XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpbiBub3JtYWwgZmxpZ2h0Li4uXG4gICAgICAgICAgICAgICAgaWYgKHdwLm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLkZJWCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW5nVGV4dCA9IHdwLmZpeFswXSA9PT0gJ18nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdbUk5BVl0nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdwLmZpeDtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25UZXh0ID0gdGhpcy5mbXMuZ2V0Rm9sbG93aW5nU1RBUlRleHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdwLm5hdm1vZGUgPT09IFdBWVBPSU5UX05BVl9NT0RFLkhPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ1RleHQgPSAnaG9sZGluZyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3cC5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5SV1kpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ1RleHQgPSAnaW50ZXJjZXB0JztcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25UZXh0ID0gdGhpcy5mbXMuZ2V0RGVzaW5hdGlvbkljYW9XaXRoUnVud2F5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5haXJjcmFmdFN0cmlwVmlldy51cGRhdGVWaWV3Rm9yQ3J1aXNlKHdwLm5hdm1vZGUsIGhlYWRpbmdUZXh0LCBkZXN0aW5hdGlvblRleHQsIGlzRm9sbG93aW5nU0lELCBpc0ZvbGxvd2luZ1NUQVIsIGZpeFJlc3RyaWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZMSUdIVF9NT0RFUy5MQU5ESU5HOlxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVGV4dCA9IHRoaXMuZm1zLmdldERlc2luYXRpb25JY2FvV2l0aFJ1bndheSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5haXJjcmFmdFN0cmlwVmlldy51cGRhdGVWaWV3Rm9yTGFuZGluZyhkZXN0aW5hdGlvblRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIEZMSUdIVF9NT0RFICR7dGhpcy5tb2RlfSBwYXNzZWQgdG8gLnVwZGF0ZVN0cmlwKClgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRJbnN0YW5jZU1vZGVsXG4gICAgICogQG1ldGhvZCB1cGRhdGVBdXRvXG4gICAgICovXG4gICAgdXBkYXRlQXV0bygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAocHJvcC5haXJjcmFmdC5hdXRvLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXV0bygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQaHlzaWNzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGFkZENvbmZsaWN0XG4gICAgICovXG4gICAgYWRkQ29uZmxpY3QoY29uZmxpY3QsIG90aGVyKSB7XG4gICAgICAgIHRoaXMuY29uZmxpY3RzW290aGVyLmdldENhbGxzaWduKCldID0gY29uZmxpY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEluc3RhbmNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGNoZWNrQ29uZmxpY3RcbiAgICAgKi9cbiAgICBjaGVja0NvbmZsaWN0KG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZsaWN0c1tvdGhlci5nZXRDYWxsc2lnbigpXSkge1xuICAgICAgICAgICAgdGhpcy5jb25mbGljdHNbb3RoZXIuZ2V0Q2FsbHNpZ24oKV0udXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgaGFzQWxlcnRzXG4gICAgICovXG4gICAgaGFzQWxlcnRzKCkge1xuICAgICAgICBjb25zdCBhID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuY29uZmxpY3RzKSB7XG4gICAgICAgICAgICBjID0gdGhpcy5jb25mbGljdHNbaV0uaGFzQWxlcnRzKCk7XG4gICAgICAgICAgICBhWzBdID0gKGFbMF0gfHwgY1swXSk7XG4gICAgICAgICAgICBhWzFdID0gKGFbMV0gfHwgY1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0SW5zdGFuY2VNb2RlbFxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29uZmxpY3RcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKi9cbiAgICByZW1vdmVDb25mbGljdChvdGhlcikge1xuICAgICAgICBkZWxldGUgdGhpcy5jb25mbGljdHNbb3RoZXIuZ2V0Q2FsbHNpZ24oKV07XG4gICAgfVxufVxuIiwiaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC9mb3JFYWNoJztcbmltcG9ydCBfZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IEFpcmNyYWZ0SW5zdGFuY2VNb2RlbCBmcm9tICcuL0FpcmNyYWZ0SW5zdGFuY2VNb2RlbCc7XG5cbi8vIFRPRE86IHRoaXMgY2xhc3MgY291bGQgdXNlIGEgYmV0dGVyIG5hbWUuIFdoYXQgZGlmZmVyZW50aWF0ZXMgdGhpcyBjbGFzcyBmcm9tIGBBaXJjcmFmdEluc3RhbmNlTW9kZWxgP1xuLyoqXG4gKiBEZWZpbml0aW9ucyBmb3IgY2hhcmFjdGVyaXN0aWNzIG9mIGEgcGFydGljdWxhciBhaXJjcmFmdCB0eXBlXG4gKlxuICogQGNsYXNzIEFpcmNyYWZ0TW9kZWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWlyY3JhZnRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eUxvYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gX2dldChvcHRpb25zLCAnbmFtZScsIG51bGwpO1xuICAgICAgICB0aGlzLmljYW8gPSBfZ2V0KG9wdGlvbnMsICdpY2FvJywgbnVsbCk7XG4gICAgICAgIHRoaXMuZW5naW5lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2VpbGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud2VpZ2h0Y2xhc3MgPSBfZ2V0KG9wdGlvbnMsICd3ZWlnaHRDbGFzcycsIG51bGwpO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gX2dldChvcHRpb25zLCAnY2F0ZWdvcnknLCBudWxsKTtcbiAgICAgICAgdGhpcy5fdXJsID0gJyc7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdBaXJjcmFmdCA9IFtdO1xuXG4gICAgICAgIHRoaXMucmF0ZSA9IHtcbiAgICAgICAgICAgIC8vIHJhZGlhbnMgcGVyIHNlY29uZFxuICAgICAgICAgICAgdHVybjogMCxcbiAgICAgICAgICAgIC8vIGZlZXQgcGVyIHNlY29uZFxuICAgICAgICAgICAgY2xpbWI6IDAsXG4gICAgICAgICAgICBkZXNjZW50OiAwLFxuICAgICAgICAgICAgLy8ga25vdHMgcGVyIHNlY29uZFxuICAgICAgICAgICAgYWNjZWxlcmF0ZTogMCxcbiAgICAgICAgICAgIGRlY2VsZXJhdGU6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJ1bndheSA9IHtcbiAgICAgICAgICAgIC8vIGttIG5lZWRlZCB0byB0YWtlb2ZmXG4gICAgICAgICAgICB0YWtlb2ZmOiAwLFxuICAgICAgICAgICAgbGFuZGluZzogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3BlZWQgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDAsXG4gICAgICAgICAgICBsYW5kaW5nOiAwLFxuICAgICAgICAgICAgY3J1aXNlOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYXJzZShvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZChvcHRpb25zLnVybCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2xhc3MgcHJvcGVydGllcyB3aXRoIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJ1biBvbmNlIG9uIGluc3RhbnRpYXRpb24gYW5kIGFnYWluIGBvbkxvYWRTdWNjZXNzYFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQG1ldGhvZCBwYXJzZVxuICAgICAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XG4gICAgICovXG4gICAgcGFyc2UoZGF0YSkge1xuICAgICAgICB0aGlzLmVuZ2luZXMgPSBfZ2V0KGRhdGEsICdlbmdpbmVzJywgdGhpcy5lbmdpbmVzKTtcbiAgICAgICAgdGhpcy5jZWlsaW5nID0gX2dldChkYXRhLCAnY2VpbGluZycsIHRoaXMuY2VpbGluZyk7XG4gICAgICAgIHRoaXMucnVud2F5ID0gX2dldChkYXRhLCAncnVud2F5JywgdGhpcy5ydW53YXkpO1xuICAgICAgICB0aGlzLnNwZWVkID0gX2dldChkYXRhLCAnc3BlZWQnLCB0aGlzLnNwZWVkKTtcbiAgICAgICAgdGhpcy5yYXRlID0gX2dldChkYXRhLCAncmF0ZScsIHRoaXMucmF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvYWQodXJsKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcblxuICAgICAgICB6bHNhLmF0Yy5sb2FkQXNzZXQoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaW1tZWRpYXRlOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHRoaXMub25Mb2FkU3VjY2VzcyhyZXNwb25zZSkpXG4gICAgICAgIC5mYWlsKCguLi5hcmdzKSA9PiB0aGlzLm9uTG9hZEVycm9yKC4uLmFyZ3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0TW9kZWxcbiAgICAgKiBAbWV0aG9kIG9uTG9hZFN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2Uge29iamVjdH1cbiAgICAgKi9cbiAgICBvbkxvYWRTdWNjZXNzID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHRoaXMucGFyc2UocmVzcG9uc2UpO1xuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVQZW5kaW5nQWlyY3JhZnQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQG1ldGhvZCBvbkxvYWRFcnJvclxuICAgICAqIEBwYXJhbSB0ZXh0U3RhdHVzIHtzdHJpbmd9XG4gICAgICovXG4gICAgb25Mb2FkRXJyb3IgPSAoeyB0ZXh0U3RhdHVzIH0pID0+IHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdBaXJjcmFmdCA9IFtdO1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBsb2FkIGFpcmNyYWZ0LyAke3RoaXMuaWNhb30gOiAke3RleHRTdGF0dXN9YCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBuZXcgYWlyY3JhZnQgb2YgdGhpcyBtb2RlbFxuICAgICAqXG4gICAgICogSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB0aGlzIG1vZGVsIG1heSBiZSBhc3luY2hyb25vdXNseSBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRNb2RlbFxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVBaXJjcmFmdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2VuZXJhdGVBaXJjcmFmdChvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IHByb3AgbmFtZXMgb2YgbG9hZGVkIGFuZCBsb2FkaW5nIGFyZSBjb25jZXJuaW5nLiB0aGVyZSBtYXkgYmUgc3RhdGUgbWFjaGluZSBtYWdpYyBoYXBwZW5pbmcgaGVyZVxuICAgICAgICAvLyB0aGF0IGNvdWxkIGxlYWQgdG8gaXNzdWVzXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQWlyY3JhZnQucHVzaChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eUxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgemxzYS5hdGMubG9hZEFzc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5fdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlMb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gc3Bhd24gYWlyY3JhZnQvICR7b3B0aW9ucy5pY2FvfSBhcyBsb2FkaW5nIGZhaWxlZGApO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVBaXJjcmFmdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgZ2VuZXJhdGVBaXJjcmFmdFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQG1ldGhvZCBfZ2VuZXJhdGVBaXJjcmFmdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZUFpcmNyYWZ0KG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0ID0gbmV3IEFpcmNyYWZ0SW5zdGFuY2VNb2RlbChvcHRpb25zKTtcblxuICAgICAgICBwcm9wLmFpcmNyYWZ0Lmxpc3QucHVzaChhaXJjcmFmdCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNwYXduaW5nICR7b3B0aW9ucy5jYXRlZ29yeX0gOiAke2FpcmNyYWZ0LmdldENhbGxzaWduKCl9YCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYWlyY3JhZnQgd2hpY2ggd2VyZSBxdWV1ZWQgd2hpbGUgdGhlIG1vZGVsIGxvYWRlZFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdE1vZGVsXG4gICAgICogQG1ldGhvZCBfZ2VuZXJhdGVQZW5kaW5nQWlyY3JhZnRcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVQZW5kaW5nQWlyY3JhZnQoKSB7XG4gICAgICAgIF9mb3JFYWNoKHRoaXMuX3BlbmRpbmdBaXJjcmFmdCwgKHBlbmRpbmdBaXJjcmFmdE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQWlyY3JhZnQocGVuZGluZ0FpcmNyYWZ0T3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdBaXJjcmFmdCA9IFtdO1xuICAgIH1cbn1cbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQge1xuICAgIEZMSUdIVF9DQVRFR09SWSxcbiAgICBGTElHSFRfTU9ERVMsXG4gICAgV0FZUE9JTlRfTkFWX01PREVcbn0gZnJvbSAnLi4vY29uc3RhbnRzL2FpcmNyYWZ0Q29uc3RhbnRzJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4uL2NvbnN0YW50cy9zZWxlY3RvcnMnO1xuXG4vKipcbiAqIHVuaXF1ZSBpZCBmb3IgZWFjaCBBaXJjcmFmdFN0cmlwVmlldyBpbnN0YW5jZVxuICpcbiAqIEBwcm9wZXJ0eSBJRFxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IElEID0gMDtcblxuLyoqXG4gKiBSb290IGh0bWwgZWxlbWVudFxuICpcbiAqIEBwcm9wZXJ0eSBBSVJDUkFGVF9TVFJJUF9URU1QTEFURVxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBBSVJDUkFGVF9TVFJJUF9URU1QTEFURSA9ICc8bGkgY2xhc3M9XCJzdHJpcFwiPjwvbGk+JztcblxuLyoqXG4gKiBIZWlnaHQgb2YgdGhlIEFpcmNyYWZ0U3RyaXAgRE9NIGVsZW1lbnQgaW4gcHguXG4gKlxuICogQHByb3BlcnR5IEFJUkNSQUZUX1NUUklQX0hFSUdIVFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBBSVJDUkFGVF9TVFJJUF9IRUlHSFQgPSA0NTtcblxuLyoqXG4gKiBAY2xhc3MgQWlyY3JhZnRTdHJpcFZpZXdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWlyY3JhZnRTdHJpcFZpZXcge1xuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gY2FsbHNpZ24ge3N0cmluZ30gIHRoaXMgcHJvcGVydHkgaXMgYSByZXN1bHQgb2YgYSBmdW5jdGlvbiBjYWxsIGFuZCBub3QgZGlyZWN0bHkgdGllZCB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBBaXJjcmFmdEluc3RhbmNlTW9kZWxgLCB0aHVzIGl0IGlzIGluY2x1ZGVkIGV4cGxpY2l0bHkgaW50ZWFkIG9mIG9idGFpbmluZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIGBBaXJjcmFmdEluc3RhbmNlTW9kZWxgXG4gICAgICogQHBhcmFtIGFpcmNyYWZ0SW5zdGFuY2VNb2RlbCB7QWlyY3JhZnRJbnN0YW5jZU1vZGVsfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbGxzaWduID0gJycsIGFpcmNyYWZ0SW5zdGFuY2VNb2RlbCkge1xuICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdG8gdXNlIGxvZGFzaCBfdW5pcXVlSWRcbiAgICAgICAgdGhpcy5faWQgPSBJRCsrO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRjYWxsc2lnbiA9IG51bGw7XG4gICAgICAgIHRoaXMuJGFpcmNyYWZ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4kaGVhZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuJGFsdGl0dWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLiRzcGVlZCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBBSVJDUkFGVF9TVFJJUF9IRUlHSFQ7XG4gICAgICAgIHRoaXMuY2FsbHNpZ24gPSBjYWxsc2lnbjtcbiAgICAgICAgdGhpcy5pY2FvID0gYWlyY3JhZnRJbnN0YW5jZU1vZGVsLm1vZGVsLmljYW87XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBhaXJjcmFmdEluc3RhbmNlTW9kZWwuZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMud2VpZ2h0Y2xhc3MgPSBhaXJjcmFmdEluc3RhbmNlTW9kZWwubW9kZWwud2VpZ2h0Y2xhc3M7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBhaXJjcmFmdEluc3RhbmNlTW9kZWwuY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMuZmxpZ2h0UGxhbiA9IGFpcmNyYWZ0SW5zdGFuY2VNb2RlbC5mbXMuZnAucm91dGUuam9pbignICcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnNldHVwSGFuZGxlcnMoYWlyY3JhZnRJbnN0YW5jZU1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAubGF5b3V0KClcbiAgICAgICAgICAgICAgICAgICAgLnJlZHJhdygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoQUlSQ1JBRlRfU1RSSVBfVEVNUExBVEUpO1xuICAgICAgICB0aGlzLiRhaXJjcmFmdCA9ICQodGhpcy5idWlsZFNwYW5Gb3JWaWV3SXRlbShTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BSVJDUkFGVCwgdGhpcy5idWlsZEljYW9XaXRoV2VpZ2h0Q2xhc3MoKSkpO1xuICAgICAgICB0aGlzLiRjYWxsc2lnbiA9ICQodGhpcy5idWlsZFNwYW5Gb3JWaWV3SXRlbShTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5DQUxMU0lHTiwgdGhpcy5jYWxsc2lnbikpO1xuICAgICAgICB0aGlzLiRoZWFkaW5nID0gJCh0aGlzLmJ1aWxkU3BhbkZvclZpZXdJdGVtKFNFTEVDVE9SUy5DTEFTU05BTUVTLkhFQURJTkcpKTtcbiAgICAgICAgdGhpcy4kYWx0aXR1ZGUgPSAkKHRoaXMuYnVpbGRTcGFuRm9yVmlld0l0ZW0oU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUxUSVRVREUpKTtcbiAgICAgICAgdGhpcy4kZGVzdGluYXRpb24gPSAkKHRoaXMuYnVpbGRTcGFuRm9yVmlld0l0ZW0oU0VMRUNUT1JTLkNMQVNTTkFNRVMuREVTVElOQVRJT04sIHRoaXMuZGVzdGluYXRpb24pKTtcbiAgICAgICAgdGhpcy4kc3BlZWQgPSAkKHRoaXMuYnVpbGRTcGFuRm9yVmlld0l0ZW0oU0VMRUNUT1JTLkNMQVNTTkFNRVMuU1BFRUQpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCBzZXR1cEhhbmRsZXJzXG4gICAgICovXG4gICAgc2V0dXBIYW5kbGVycyhhaXJjcmFmdEluc3RhbmNlTW9kZWwpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZGJsY2xpY2snLCBhaXJjcmFmdEluc3RhbmNlTW9kZWwsIHRoaXMub25Eb3VibGVDbGlja0hhbmRsZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAbWV0aG9kIGxheW91dFxuICAgICAqL1xuICAgIGxheW91dCgpIHtcbiAgICAgICAgLy8gVE9ETzogc29tZSBvZiB0aGUgc3RhdGljIEhUTUwgaGVyZSBjb3VsZCBiZSBtb3ZlZCB0byB0ZW1wbGF0ZSBjb25zdGFudHNcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kY2FsbHNpZ24pO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCh0aGlzLiRoZWFkaW5nKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kYWx0aXR1ZGUpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCh0aGlzLiRhaXJjcmFmdCk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXBwZW5kKHRoaXMuJGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kc3BlZWQpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMuZmluZENsYXNzbmFtZUZvckZsaWdodENhdGVvZ3J5KCkpO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNudCBhcHBlYXIgdG8gYmUgZG9pbmcgd2hhdCB0aGUgYmVsb3cgY29tbWVudCBzYXlzIGl0IHNob3VsZCBiZSBkb2luZ1xuICAgICAgICAvLyBzaG93IGZwIHJvdXRlIG9uIGhvdmVyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucHJvcCgndGl0bGUnLCB0aGlzLmZsaWdodFBsYW4pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAbWV0aG9kIHJlZHJhd1xuICAgICAqL1xuICAgIHJlZHJhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgZW5hYmxlXG4gICAgICovXG4gICAgZW5hYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCBkaXNhYmxlXG4gICAgICovXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2NsaWNrJywgdGhpcy5vbkNsaWNrSGFuZGxlcik7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdkYmxjbGljaycsIHRoaXMub25Eb3VibGVDbGlja0hhbmRsZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuJGNhbGxzaWduID0gbnVsbDtcbiAgICAgICAgdGhpcy4kYWlyY3JhZnQgPSBudWxsO1xuICAgICAgICB0aGlzLiRoZWFkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy4kYWx0aXR1ZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuJHNwZWVkID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxzaWduID0gJyc7XG4gICAgICAgIHRoaXMuaWNhbyA9ICcnO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gJyc7XG4gICAgICAgIHRoaXMud2VpZ2h0Y2xhc3MgPSAnJztcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9ICcnO1xuICAgICAgICB0aGlzLmZsaWdodFBsYW4gPSAnJztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzcGFuIHdpdGggYSBjbGFzc25hbWUgYW5kL29yIGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGluaXRpYWxpemluZyB0ZW1wbGF0ZXMuIFJlbW92ZXMgdGhlIG5lZWQgZm9yIGhhdmluZyBpbmRpdmlkdWFsIHRlbXBsYXRlIGNvbnN0YW50cyBmb3IgZWFjaCBsaW5lXG4gICAgICogd2hlbiB0aGUgb25seSBkaWZmZXJlbmNlIGlzIGEgY2xhc3NuYW1lIGFuZCBjb250ZW50LiBBbHNvIHByb3ZpZGVzIGEgd2F5IHRvIGNhY2hlIGFsbCB0aGUgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBzZWxlY3RvcnMgb24gaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGNvbnRlbnQge3N0cmluZ31cbiAgICAgKi9cbiAgICBidWlsZFNwYW5Gb3JWaWV3SXRlbShjbGFzc05hbWUsIGNvbnRlbnQgPSAnJykge1xuICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+JHtjb250ZW50fTwvc3Bhbj5gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAbWV0aG9kIGJ1aWxkSWNhb1dpdGhXZWlnaHRDbGFzc1xuICAgICAqIEByZXR1cm4gYWlyY3JhZnRJY2FvIHtzdHJpbmd9XG4gICAgICovXG4gICAgYnVpbGRJY2FvV2l0aFdlaWdodENsYXNzKCkge1xuICAgICAgICBsZXQgYWlyY3JhZnRJY2FvID0gdGhpcy5pY2FvO1xuXG4gICAgICAgIC8vIFRPRE86IGluZGV4T2YgaXMgZ29vZnkgaGVyZSwgdGhpcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgICAgICAvLyBCb3R0b20gTGluZSBEYXRhXG4gICAgICAgIGlmIChbJ0gnLCAnVSddLmluZGV4T2YodGhpcy53ZWlnaHRjbGFzcykgPiAtMSkge1xuICAgICAgICAgICAgYWlyY3JhZnRJY2FvID0gYEgvJHt0aGlzLmljYW99YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhaXJjcmFmdEljYW8udG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCBmaW5kQ2xhc3NuYW1lRm9yRmxpZ2h0Q2F0ZW9ncnlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZmluZENsYXNzbmFtZUZvckZsaWdodENhdGVvZ3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yeSA9PT0gRkxJR0hUX0NBVEVHT1JZLkRFUEFSVFVSRVxuICAgICAgICAgICAgPyBTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5ERVBBUlRVUkVcbiAgICAgICAgICAgIDogU0VMRUNUT1JTLkNMQVNTTkFNRVMuQVJSSVZBTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYXNjYWRlIG1ldGhvZCBmb3IganF1ZXJ5IGAuaGlkZSgpYFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgaGlkZVxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGhpZGUoZHVyYXRpb24gPSAwKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZShkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlKGhlYWRpbmdUZXh0LCBhbHRpdHVkZVRleHQsIGRlc3RpbmF0aW9uVGV4dCwgY3VycmVudFNwZWVkVGV4dCkge1xuICAgICAgICB0aGlzLnJlc2V0U3RyaXBTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBaXJjcmFmdFRlbGVtZXRyeVRleHQoaGVhZGluZ1RleHQsIGFsdGl0dWRlVGV4dCwgZGVzdGluYXRpb25UZXh0LCBjdXJyZW50U3BlZWRUZXh0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG9sZCBzdHlsaW5nXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCByZXNldFN0cmlwU3R5bGVzXG4gICAgICogQHBhcmFtIGhlYWRpbmdUZXh0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGFsdGl0dWRlVGV4dCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvblRleHQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gY3VycmVudFNwZWVkVGV4dCB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlc2V0U3RyaXBTdHlsZXMoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzbmFtZXNUb1JlbW92ZSA9ICdydW53YXkgaG9sZCB3YWl0aW5nIHRheGkgbG9va2luZ0dvb2QgYWxsU2V0JztcblxuICAgICAgICB0aGlzLiRoZWFkaW5nLnJlbW92ZUNsYXNzKGNsYXNzbmFtZXNUb1JlbW92ZSk7XG4gICAgICAgIHRoaXMuJGFsdGl0dWRlLnJlbW92ZUNsYXNzKGNsYXNzbmFtZXNUb1JlbW92ZSk7XG4gICAgICAgIHRoaXMuJGRlc3RpbmF0aW9uLnJlbW92ZUNsYXNzKGNsYXNzbmFtZXNUb1JlbW92ZSk7XG4gICAgICAgIHRoaXMuJHNwZWVkLnJlbW92ZUNsYXNzKGNsYXNzbmFtZXNUb1JlbW92ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlQWlyY3JhZnRUZWxlbWV0cnlUZXh0XG4gICAgICogQHBhcmFtIGhlYWRpbmdUZXh0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGFsdGl0dWRlVGV4dCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvblRleHQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gY3VycmVudFNwZWVkVGV4dCB7c3RyaW5nfVxuICAgICAqL1xuICAgIHVwZGF0ZUFpcmNyYWZ0VGVsZW1ldHJ5VGV4dChoZWFkaW5nVGV4dCwgYWx0aXR1ZGVUZXh0LCBkZXN0aW5hdGlvblRleHQsIGN1cnJlbnRTcGVlZFRleHQpIHtcbiAgICAgICAgdGhpcy4kaGVhZGluZy50ZXh0KGhlYWRpbmdUZXh0KTtcbiAgICAgICAgdGhpcy4kYWx0aXR1ZGUudGV4dChhbHRpdHVkZVRleHQpO1xuICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi50ZXh0KGRlc3RpbmF0aW9uVGV4dCk7XG4gICAgICAgIHRoaXMuJHNwZWVkLnRleHQoY3VycmVudFNwZWVkVGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlVmlld0ZvckFwcm9uXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uVGV4dCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBoYXNBbHRpdHVkZSB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0gaXNGb2xsb3dpbmdTSUQge2Jvb2xlYW59XG4gICAgICovXG4gICAgdXBkYXRlVmlld0ZvckFwcm9uKGRlc3RpbmF0aW9uVGV4dCwgaGFzQWx0aXR1ZGUsIGlzRm9sbG93aW5nU0lEKSB7XG4gICAgICAgIHRoaXMuJHNwZWVkLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlJVTldBWSk7XG4gICAgICAgIHRoaXMuJGhlYWRpbmcuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUlVOV0FZKTtcbiAgICAgICAgdGhpcy4kaGVhZGluZy50ZXh0KEZMSUdIVF9NT0RFUy5BUFJPTik7XG5cbiAgICAgICAgaWYgKGhhc0FsdGl0dWRlKSB7XG4gICAgICAgICAgICB0aGlzLiRhbHRpdHVkZS5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRm9sbG93aW5nU0lEKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhIGNsYXNzIG1ldGhvZCBvbiB0aGUgRk1TXG4gICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi50ZXh0KGRlc3RpbmF0aW9uVGV4dCk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlVmlld0ZvclRheGlcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25UZXh0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGhhc0FsdGl0dWRlIHtib29sZWFufVxuICAgICAqIEBwYXJhbSBpc0ZvbGxvd2luZ1NJRCB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0gYWx0aXR1ZGVUZXh0IHtzdHJpbmd9XG4gICAgICovXG4gICAgdXBkYXRlVmlld0ZvclRheGkoZGVzdGluYXRpb25UZXh0LCBoYXNBbHRpdHVkZSwgaXNGb2xsb3dpbmdTSUQsIGFsdGl0dWRlVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBhYnN0cmFjdCBGUk9NIEhFUkVcbiAgICAgICAgdGhpcy4kc3BlZWQuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUlVOV0FZKTtcbiAgICAgICAgdGhpcy4kaGVhZGluZy5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB0aGlzLiRoZWFkaW5nLnRleHQoRkxJR0hUX01PREVTLlRBWEkpO1xuXG4gICAgICAgIGlmIChoYXNBbHRpdHVkZSkge1xuICAgICAgICAgICAgdGhpcy4kYWx0aXR1ZGUuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUlVOV0FZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZvbGxvd2luZ1NJRCkge1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYSBjbGFzcyBtZXRob2Qgb24gdGhlIEZNU1xuICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24udGV4dChkZXN0aW5hdGlvblRleHQpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24uYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUlVOV0FZKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBhYnN0cmFjdCBUTyBIRVJFXG5cbiAgICAgICAgaWYgKGFsdGl0dWRlVGV4dCkge1xuICAgICAgICAgICAgdGhpcy4kYWx0aXR1ZGUudGV4dChhbHRpdHVkZVRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlVmlld0ZvcldhaXRpbmdcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25UZXh0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGhhc0FsdGl0dWRlIHtib29sZWFufVxuICAgICAqIEBwYXJhbSBpc0ZvbGxvd2luZ1NJRCB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3Rm9yV2FpdGluZyhkZXN0aW5hdGlvblRleHQsIGhhc0FsdGl0dWRlLCBpc0ZvbGxvd2luZ1NJRCkge1xuICAgICAgICB0aGlzLiRzcGVlZC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB0aGlzLiRoZWFkaW5nLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlJVTldBWSk7XG4gICAgICAgIHRoaXMuJGhlYWRpbmcudGV4dChGTElHSFRfTU9ERVMuV0FJVElORyk7XG5cbiAgICAgICAgaWYgKGhhc0FsdGl0dWRlKSB7XG4gICAgICAgICAgICB0aGlzLiRhbHRpdHVkZS5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRm9sbG93aW5nU0lEKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhIGNsYXNzIG1ldGhvZCBvbiB0aGUgRk1TXG4gICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi50ZXh0KGRlc3RpbmF0aW9uVGV4dCk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SVU5XQVkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2QgdXBkYXRlVGFrZU9mZlZpZXdcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25UZXh0IHtzdHJpbmd9XG4gICAgICovXG4gICAgdXBkYXRlVmlld0ZvclRha2VvZmYoZGVzdGluYXRpb25UZXh0LCBpc0ZvbGxvd2luZ1NJRCkge1xuICAgICAgICB0aGlzLiRoZWFkaW5nLnRleHQoRkxJR0hUX01PREVTLlRBS0VPRkYpO1xuXG4gICAgICAgIGlmIChpc0ZvbGxvd2luZ1NJRCkge1xuICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24udGV4dChkZXN0aW5hdGlvblRleHQpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24uYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuTE9PS0lOR19HT09EKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRTdHJpcFZpZXdcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVZpZXdGb3JMYW5kaW5nXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uVGV4dCB7c3RyaW5nfVxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdGb3JMYW5kaW5nKGRlc3RpbmF0aW9uVGV4dCkge1xuICAgICAgICBjb25zdCBPTl9HTElERVNMT1BFID0gJ0dTJztcbiAgICAgICAgY29uc3QgT05fSUxTID0gJ29uIElMUyc7XG5cbiAgICAgICAgdGhpcy4kaGVhZGluZy5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BTExfU0VUKTtcbiAgICAgICAgdGhpcy4kaGVhZGluZy50ZXh0KE9OX0lMUyk7XG4gICAgICAgIHRoaXMuJGFsdGl0dWRlLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkFMTF9TRVQpO1xuICAgICAgICB0aGlzLiRhbHRpdHVkZS50ZXh0KE9OX0dMSURFU0xPUEUpO1xuICAgICAgICB0aGlzLiRzcGVlZC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BTExfU0VUKTtcbiAgICAgICAgdGhpcy4kZGVzdGluYXRpb24uYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUxMX1NFVCk7XG4gICAgICAgIHRoaXMuJGRlc3RpbmF0aW9uLnRleHQoZGVzdGluYXRpb25UZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCB1cGRhdGVWaWV3Rm9yQ3J1aXNlXG4gICAgICogQHBhcmFtIG5hdk1vZGVcbiAgICAgKiBAcGFyYW0gaGVhZGluZ1RleHQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25UZXh0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGlzRm9sbG93aW5nU0lEIHtib29sZWFufVxuICAgICAqIEBwYXJhbSBpc0ZvbGxvd2luZ1NUQVIge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIGZpeFJlc3RyaWN0aW9ucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXdGb3JDcnVpc2UoXG4gICAgICAgIG5hdk1vZGUsXG4gICAgICAgIGhlYWRpbmdUZXh0ID0gJycsXG4gICAgICAgIGRlc3RpbmF0aW9uVGV4dCA9ICcnLFxuICAgICAgICBpc0ZvbGxvd2luZ1NJRCA9IGZhbHNlLFxuICAgICAgICBpc0ZvbGxvd2luZ1NUQVIgPSBmYWxzZSxcbiAgICAgICAgZml4UmVzdHJpY3Rpb25zID0ge31cbiAgICApIHtcbiAgICAgICAgc3dpdGNoIChuYXZNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFdBWVBPSU5UX05BVl9NT0RFLkZJWDpcbiAgICAgICAgICAgICAgICB0aGlzLiRoZWFkaW5nLnRleHQoaGVhZGluZ1RleHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRm9sbG93aW5nU0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGhlYWRpbmcuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUxMX1NFVCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGFsdGl0dWRlLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkFMTF9TRVQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BTExfU0VUKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3BlZWQuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUxMX1NFVCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRm9sbG93aW5nU1RBUikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRoZWFkaW5nLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkZPTExPV0lOR19TVEFSKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24udGV4dChkZXN0aW5hdGlvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRkZXN0aW5hdGlvbi5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5GT0xMT1dJTkdfU1RBUik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeFJlc3RyaWN0aW9ucy5hbHRpdHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kYWx0aXR1ZGUuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuRk9MTE9XSU5HX1NUQVIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeFJlc3RyaWN0aW9ucy5zcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3BlZWQuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuRk9MTE9XSU5HX1NUQVIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdBWVBPSU5UX05BVl9NT0RFLkhPTEQ6XG4gICAgICAgICAgICAgICAgdGhpcy4kaGVhZGluZy50ZXh0KGhlYWRpbmdUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRoZWFkaW5nLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkhPTEQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXQVlQT0lOVF9OQVZfTU9ERS5SV1k6XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdGluZyBJTFMgaW50ZXJjZXB0XG4gICAgICAgICAgICAgICAgdGhpcy4kaGVhZGluZy5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5MT09LSU5HX0dPT0QpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGhlYWRpbmcudGV4dChoZWFkaW5nVGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kYWx0aXR1ZGUuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuTE9PS0lOR19HT09EKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRzcGVlZC5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5MT09LSU5HX0dPT0QpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGRlc3RpbmF0aW9uLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkxPT0tJTkdfR09PRCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGVzdGluYXRpb24udGV4dChkZXN0aW5hdGlvblRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIgZm9yIGEgc2luZ2xlIGNsaWNrIG9uIGFuIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmNyYWZ0U3RyaXBWaWV3XG4gICAgICogQG1ldGhvZCBvbkNsaWNrSGFuZGxlclxuICAgICAqIEBwYXJhbSBldmVudCB7anF1ZXJ5IGV2ZW50fVxuICAgICAqL1xuICAgIG9uQ2xpY2tIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHdpbmRvdy5pbnB1dENvbnRyb2xsZXIuaW5wdXRfc2VsZWN0KHRoaXMuY2FsbHNpZ24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBoYW5kbGVyIGZvciBhIGRvdWJsZS1jbGljayBvbiBhbiBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdFN0cmlwVmlld1xuICAgICAqIEBtZXRob2Qgb25Eb3VibGVDbGlja0hhbmRsZXJcbiAgICAgKiBAcGFyYW0gIGV2ZW50IHtqcXVlcnkgZXZlbnR9XG4gICAgICovXG4gICAgb25Eb3VibGVDbGlja0hhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgcHJvcC5jYW52YXMucGFuWCA9IDAgLSByb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGV2ZW50LmRhdGEucG9zaXRpb25bMF0pKTtcbiAgICAgICAgcHJvcC5jYW52YXMucGFuWSA9IHJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoZXZlbnQuZGF0YS5wb3NpdGlvblsxXSkpO1xuICAgICAgICBwcm9wLmNhbnZhcy5kaXJ0eSA9IHRydWU7XG4gICAgfTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IF9maW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBfbGFzdCBmcm9tICdsb2Rhc2gvbGFzdCc7XG5pbXBvcnQgX21hcCBmcm9tICdsb2Rhc2gvbWFwJztcbmltcG9ydCBfaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBGaXhDb2xsZWN0aW9uIGZyb20gJy4uLy4uL2FpcnBvcnQvRml4L0ZpeENvbGxlY3Rpb24nO1xuaW1wb3J0IFdheXBvaW50IGZyb20gJy4vV2F5cG9pbnQnO1xuaW1wb3J0IExlZyBmcm9tICcuL0xlZyc7XG5pbXBvcnQgUm91dGVNb2RlbCBmcm9tICcuLi8uLi9haXJwb3J0L1JvdXRlL1JvdXRlTW9kZWwnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi9tYXRoL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBGUF9MRUdfVFlQRSxcbiAgICBGTElHSFRfQ0FURUdPUlksXG4gICAgV0FZUE9JTlRfTkFWX01PREVcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2FpcmNyYWZ0Q29uc3RhbnRzJztcbmltcG9ydCB7IExPRyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9sb2dMZXZlbCc7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgdGhlIExlZyBpbmRleCBpbiBgdGhpcy5jdXJyZW50YFxuICpcbiAqIEBwcm9wZXJ0eVxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBMRUcgPSAwO1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHRoZSBXYXlwb2ludCB3aXRoaW4gbGVnIGluZGV4IGluIGB0aGlzLmN1cnJlbnRgXG4gKlxuICogQHByb3BlcnR5XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFdBWVBPSU5UX1dJVEhJTl9MRUcgPSAxO1xuXG4vKipcbiAgKiBNYW5hZ2UgY3VycmVudCBhbmQgZnV0dXJlIGFpcmNyYWZ0IHdheXBvaW50c1xuICAqXG4gICogd2F5cG9pbnQgbmF2bW9kZXNcbiAgKiAtLS0tLS0tLS0tLS0tLS0tLVxuICAqIE1heSBiZSBvbmUgb2YgbnVsbCwgXCJmaXhcIiwgXCJoZWFkaW5nXCIsIFwiaG9sZFwiLCBcInJ3eVwiXG4gICpcbiAgKiAqIG51bGwgaXMgYXNzaWduZWQsIGlmIHRoZSBwbGFuZSBpcyBub3QgYWN0aXZlbHkgZm9sbG93aW5nIGFuXG4gICogICAgb2JqZWN0aXZlLiBUaGlzIGlzIG9ubHkgdGhlIGNhc2UsIGlmIGEgcGxhbmUgZW50ZXJzIHRoZSBhaXJzcGFjZVxuICAqICAgIG9yIGFuIGFjdGlvbiBoYXMgYmVlbiBhYm9ydGVkIGFuZCBubyBuZXcgY29tbWFuZCBpc3N1ZWRcbiAgKlxuICAqICogXCJmaXhcIiBpcyBhc3NpZ25lZCwgaWYgdGhlIHBsYW5lIGlzIGhlYWRpbmcgZm9yIGEgZml4LiBJbiB0aGlzXG4gICogICAgY2FzZSwgdGhlIGF0dHJpYnV0ZSByZXF1ZXN0LmZpeCBpcyB1c2VkIGZvciBuYXZpZ2F0aW9uXG4gICpcbiAgKiAqIFwiaGVhZGluZ1wiIGlzIGFzc2lnbmVkLCBpZiB0aGUgcGxhbmUgd2FzIGdpdmVuIGRpcmVjdGl2ZSB0byBmb2xsb3dcbiAgKiAgICB0aGUgY291cnNlIHNldCBvdXQgYnkgdGhlIGdpdmVuIGhlYWRpbmcuIEluIHRoaXMgY2FzZSwgdGhlXG4gICogICAgYXR0cmlidXRlcyByZXF1ZXN0LmhlYWRpbmcgYW5kIHJlcXVlc3QudHVybiBhcmUgdXNlZCBmb3JcbiAgKiAgICBuYXZpZ2F0aW9uXG4gICpcbiAgKiAqIFwiaG9sZFwiIGlzIGFzc2lnbmVkLCBpZiB0aGUgcGxhbmUgc2hvdWxkIGhvbGQgaXRzIHBvc2l0aW9uLiBBc1xuICAqICAgIHRoaXMgaXMgYXJjaGlldmVkIGJ5IGNvbnRpbnVvdXNseSB0dXJuaW5nLCByZXF1ZXN0LnR1cm4gaXMgdXNlZFxuICAqICAgIGluIHRoaXMgY2FzZVxuICAqXG4gICogKiBcInJ3eVwiIGlzIGFzc2lnbmVkLCBpZiB0aGUgcGxhbmUgaXMgaGVhZGluZyBmb3IgYSBydW53YXkuIFRoaXMgaXNcbiAgKiAgICBvbmx5IHRoZSBjYXNlLCBpZiB0aGUgcGxhbmUgd2FzIGlzc3VlZCB0aGUgY29tbWFuZCB0byBsYW5kLiBJblxuICAqICAgIHRoaXMgY2FzZSwgcmVxdWVzdC5ydW53YXkgaXMgdXNlZFxuICAqXG4gICogQGNsYXNzIEFpcmNyYWZ0RmxpZ2h0TWFuYWdlbWVudFN5c3RlbVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBaXJjcmFmdEZsaWdodE1hbmFnZW1lbnRTeXN0ZW0ge1xuICAgIC8qKlxuICAgICAqIEBmb3IgQWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgbWF5X2FpcmNyYWZ0c19laWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgb3B0aW9ucy5haXJjcmFmdC5laWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXlfYWlyY3JhZnRzX2VpZCA9IG9wdGlvbnMuYWlyY3JhZnQuZWlkO1xuXG4gICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhpcyByZWZlcmVuY2UgYW5kIGluc3RlYWQgc3VwcGx5IG1ldGhvZHMgdGhhdCB0aGUgYWlyY3JhZnQgY2FuIGNhbGwgdmlhIHRoZSBmbXNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBteV9haXJjcmFmdFxuICAgICAgICAgKiBAdHlwZSB7QWlyY3JhZkluc3RhbmNlTW9kZWx9XG4gICAgICAgICAqIEBkZWZhdWx0IG9wdGlvbnMuYWlyY3JhZnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXlfYWlyY3JhZnQgPSBvcHRpb25zLmFpcmNyYWZ0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgbGVnc1xuICAgICAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBpbmRpY2llcyBmb3IgTGVnIGFuZCBXYXlwb2ludCB3aXRoaW4gdGhhdCBMZWcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFtjdXJyZW50X0xlZywgY3VycmVudF9XYXlwb2ludF93aXRoaW5fdGhhdF9MZWddXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50XG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBbMCwgMF07XG5cbiAgICAgICAgLy8gVE9ETzogcG9zc2libGUgbW9kZWwgb2JqZWN0IGhlcmVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcFxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcCA9IHtcbiAgICAgICAgICAgIGFsdGl0dWRlOiBudWxsLFxuICAgICAgICAgICAgcm91dGU6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogcG9zc2libGUgbW9kZWwgb2JqZWN0IGhlcmVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmb2xsb3dpbmdcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9sbG93aW5nID0ge1xuICAgICAgICAgICAgc2lkOiBudWxsLCAgICAgICAgIC8vIFN0YW5kYXJkIEluc3RydW1lbnQgRGVwYXJ0dXJlIFByb2NlZHVyZVxuICAgICAgICAgICAgc3RhcjogbnVsbCwgICAgICAgIC8vIFN0YW5kYXJkIFRlcm1pbmFsIEFycml2YWwgUm91dGUgUHJvY2VkdXJlXG4gICAgICAgICAgICBpYXA6IG51bGwsICAgICAgICAgLy8gSW5zdHJ1bWVudCBBcHByb2FjaCBQcm9jZWR1cmUgKGxpa2UgSUxTLCBHUFMsIFJOQVYsIFZPUi1BLCBldGMpXG4gICAgICAgICAgICBhd3k6IG51bGwsICAgICAgICAgLy8gQWlyd2F5IChWLCBKLCBULCBRLCBldGMuKVxuICAgICAgICAgICAgdGZjOiBudWxsLCAgICAgICAgIC8vIFRyYWZmaWMgKGFub3RoZXIgYWlycGxhbmUpXG4gICAgICAgICAgICBhbnl0aGluZzogZmFsc2UgICAgLy8gVC9GIGZsYWcgZm9yIGlmIGFueXRoaW5nIGlzIGJlaW5nIFwiZm9sbG93ZWRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCBiZWxvbmcgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIFRPRE86IGVudW1lcmF0ZSB0aGUgbWFnaWMgbnVtYmVyc1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBhbHRpdHVkZVxuICAgICAgICB0aGlzLmZwLmFsdGl0dWRlID0gY2xhbXAoMTAwMCwgb3B0aW9ucy5tb2RlbC5jZWlsaW5nLCA2MDAwMCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWlyY3JhZnQuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5BUlJJVkFMKSB7XG4gICAgICAgICAgICB0aGlzLnByZXBlbmRMZWcoeyByb3V0ZTogJ1VOQVNTSUdORUQnIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWlyY3JhZnQuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcGVuZExlZyh7IHJvdXRlOiB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5pY2FvIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVfZnBfcm91dGUoKTtcbiAgICB9XG5cbiAgICAvKiogKioqKioqKioqKioqKioqKiogRk1TIEZMSUdIVFBMQU4gQ09OVFJPTCBGVU5DVElPTlMgKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIExlZyBhdCB0aGUgZnJvbnQgb2YgdGhlIGZsaWdodHBsYW5cbiAgICAgKi9cbiAgICBwcmVwZW5kTGVnKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuY3VycmVudFdheXBvaW50O1xuICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoZGF0YSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5sZWdzLnVuc2hpZnQobGVnVG9BZGQpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9mcF9yb3V0ZSgpO1xuXG4gICAgICAgIC8vIFRPRE86IHRoZXNlIGlmIGJsb2NrcyBhIHJlcGVhdGVkIGVsc2V3aGVyZSwgcGVyaGFwcyBjdXJyZW50V2F5cG9pbnQgY2FuIGhhbmRsZSB0aGlzIGxvZ2ljP1xuICAgICAgICAvLyBWZXJpZnkgYWx0aXR1ZGUgJiBzcGVlZCBub3QgbnVsbFxuICAgICAgICBjb25zdCBjdXJyID0gdGhpcy5jdXJyZW50V2F5cG9pbnQ7XG4gICAgICAgIGlmIChwcmV2ICYmICFjdXJyLmFsdGl0dWRlKSB7XG4gICAgICAgICAgICBjdXJyLmFsdGl0dWRlID0gcHJldi5hbHRpdHVkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2ICYmICFjdXJyLnNwZWVkKSB7XG4gICAgICAgICAgICBjdXJyLnNwZWVkID0gcHJldi5zcGVlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHdheXBvaW50IGF0IGN1cnJlbnQgcG9zaXRpb24gYW5kIGltbWVkaWF0ZWx5IGFjdGl2YXRlIGl0XG4gICAgICovXG4gICAgaW5zZXJ0V2F5cG9pbnRIZXJlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5jdXJyZW50V2F5cG9pbnQ7XG4gICAgICAgIGNvbnN0IHdheXBvaW50VG9BZGQgPSBuZXcgV2F5cG9pbnQoZGF0YSwgYWlycG9ydCk7XG5cbiAgICAgICAgLy8gVE9ETzogc3BsaXQgdGhpcyB1cCBpbnRvIHNtYWxsZXIgY2h1bmtzXG4gICAgICAgIHRoaXMuY3VycmVudExlZy53YXlwb2ludHMuc3BsaWNlKHRoaXMuY3VycmVudFtXQVlQT0lOVF9XSVRISU5fTEVHXSwgMCwgd2F5cG9pbnRUb0FkZCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2ZwX3JvdXRlKCk7XG5cbiAgICAgICAgLy8gVE9ETzogdGhlc2UgaWYgYmxvY2tzIGEgcmVwZWF0ZWQgZWxzZXdoZXJlLCBwZXJoYXBzIGN1cnJlbnRXYXlwb2ludCBjYW4gaGFuZGxlIHRoaXMgbG9naWM/XG4gICAgICAgIC8vIFZlcmlmeSBhbHRpdHVkZSAmIHNwZWVkIG5vdCBudWxsXG4gICAgICAgIGNvbnN0IGN1cnIgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuYWx0aXR1ZGUpIHtcbiAgICAgICAgICAgIGN1cnIuYWx0aXR1ZGUgPSBwcmV2LmFsdGl0dWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuc3BlZWQpIHtcbiAgICAgICAgICAgIGN1cnIuc3BlZWQgPSBwcmV2LnNwZWVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgTGVnIGF0IGEgcGFydGljdWxhciBwb3NpdGlvbiBpbiB0aGUgZmxpZ2h0cGxhblxuICAgICAqIE5vdGU6IGlmIG5vIHBvc2l0aW9uIHBhc3NlZCBpbiwgZGVmYXVsdHMgdG8gYWRkIHRvIHRoZSBlbmRcbiAgICAgKi9cbiAgICBpbnNlcnRMZWcoZGF0YSkge1xuICAgICAgICAvLyBUT0RPOiByZWFzc2lnaW5pbmcgZGF0YSBoZXJlIGlzIGRhbmdlcm91cy5cbiAgICAgICAgaWYgKGRhdGEuZmlyc3RJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLmZpcnN0SW5kZXggPSB0aGlzLmxlZ3MubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuY3VycmVudFdheXBvaW50O1xuICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoZGF0YSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5sZWdzLnNwbGljZShkYXRhLmZpcnN0SW5kZXgsIDAsIGxlZ1RvQWRkKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZV9mcF9yb3V0ZSgpO1xuXG4gICAgICAgIC8vIEFkanVzdCAnY3VycmVudCdcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFtMRUddID49IGRhdGEuZmlyc3RJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRoZXNlIGlmIGJsb2NrcyBhIHJlcGVhdGVkIGVsc2V3aGVyZSwgcGVyaGFwcyBjdXJyZW50V2F5cG9pbnQgY2FuIGhhbmRsZSB0aGlzIGxvZ2ljP1xuICAgICAgICAvLyBWZXJpZnkgYWx0aXR1ZGUgJiBzcGVlZCBub3QgbnVsbFxuICAgICAgICBjb25zdCBjdXJyID0gdGhpcy5jdXJyZW50V2F5cG9pbnQ7XG4gICAgICAgIGlmIChwcmV2ICYmICFjdXJyLmFsdGl0dWRlKSB7XG4gICAgICAgICAgICBjdXJyLmFsdGl0dWRlID0gcHJldi5hbHRpdHVkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2ICYmICFjdXJyLnNwZWVkKSB7XG4gICAgICAgICAgICBjdXJyLnNwZWVkID0gcHJldi5zcGVlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIExlZyBhdCBjdXJyZW50IHBvc2l0aW9uIGltbWVkaWF0ZWx5IGFjdGl2YXRlIGl0XG4gICAgICovXG4gICAgaW5zZXJ0TGVnSGVyZShkYXRhKSB7XG4gICAgICAgIC8vIGluZGV4IG9mIGN1cnJlbnQgbGVnXG4gICAgICAgIGRhdGEuZmlyc3RJbmRleCA9IHRoaXMuY3VycmVudFtMRUddO1xuICAgICAgICAvLyBwdXQgbmV3IExlZyBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgIHRoaXMuaW5zZXJ0TGVnKGRhdGEpO1xuICAgICAgICAvLyBzdGFydCBhdCBmaXJzdCB3cCBpbiB0aGlzIG5ldyBsZWdcbiAgICAgICAgdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgSW5zZXJ0IGEgTGVnIGF0IHRoZSBlbmQgb2YgdGhlIGZsaWdodHBsYW5cbiAgICAgKi9cbiAgICBhcHBlbmRMZWcoZGF0YSkge1xuICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoZGF0YSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5sZWdzLnB1c2gobGVnVG9BZGQpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9mcF9yb3V0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBJbnNlcnQgYSB3YXlwb2ludCBhZnRlciB0aGUgKmN1cnJlbnQqIHdheXBvaW50XG4gICAgICovXG4gICAgYXBwZW5kV2F5cG9pbnQoZGF0YSkge1xuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGNvbnN0IHdheXBvaW50VG9BZGQgPSBuZXcgV2F5cG9pbnQoZGF0YSwgYWlycG9ydCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TGVnLndheXBvaW50cy5zcGxpY2UodGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddICsgMSwgMCwgd2F5cG9pbnRUb0FkZCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2ZwX3JvdXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFN3aXRjaCB0byB0aGUgbmV4dCB3YXlwb2ludFxuICAgICAqL1xuICAgIG5leHRXYXlwb2ludCgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuY3VycmVudFdheXBvaW50O1xuICAgICAgICBjb25zdCBsZWcgPSB0aGlzLmN1cnJlbnRbTEVHXTtcbiAgICAgICAgY29uc3Qgd3AgPSB0aGlzLmN1cnJlbnRbV0FZUE9JTlRfV0lUSElOX0xFR10gKyAxO1xuXG4gICAgICAgIGlmICh3cCA8IHRoaXMubGVnc1tsZWddLndheXBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGxvb2sgdG8gbmV4dCB3YXlwb2ludCBpbiBjdXJyZW50IGxlZ1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddKys7XG4gICAgICAgIH0gZWxzZSBpZiAobGVnICsgMSA8IHRoaXMubGVncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGxvb2sgdG8gdGhlIG5leHQgbGVnXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRbTEVHXSsrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddID0gMDsgIC8vIGxvb2sgdG8gdGhlIGZpcnN0IHdheXBvaW50IG9mIHRoYXQgbGVnXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGVzZSBpZiBibG9ja3MgYSByZXBlYXRlZCBlbHNld2hlcmUsIHBlcmhhcHMgY3VycmVudFdheXBvaW50IGNhbiBoYW5kbGUgdGhpcyBsb2dpYz9cbiAgICAgICAgLy8gUmVwbGFjZSBudWxsIHZhbHVlcyB3aXRoIGN1cnJlbnQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGN1cnIgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuYWx0aXR1ZGUpIHtcbiAgICAgICAgICAgIGN1cnIuYWx0aXR1ZGUgPSBwcmV2LmFsdGl0dWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuc3BlZWQpIHtcbiAgICAgICAgICAgIGN1cnIuc3BlZWQgPSBwcmV2LnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJyLmhlYWRpbmcgJiYgY3Vyci5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HKSB7XG4gICAgICAgICAgICBjdXJyLmhlYWRpbmcgPSBwcmV2LmhlYWRpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU3dpdGNoIHRvIHRoZSBuZXh0IExlZ1xuICAgICAqL1xuICAgIG5leHRMZWcoKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcbiAgICAgICAgdGhpcy5jdXJyZW50W0xFR10rKztcbiAgICAgICAgdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddID0gMDtcblxuICAgICAgICAvLyBUT0RPOiB0aGVzZSBpZiBibG9ja3MgYSByZXBlYXRlZCBlbHNld2hlcmUsIHBlcmhhcHMgY3VycmVudFdheXBvaW50IGNhbiBoYW5kbGUgdGhpcyBsb2dpYz9cbiAgICAgICAgLy8gUmVwbGFjZSBudWxsIHZhbHVlcyB3aXRoIGN1cnJlbnQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGN1cnIgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuYWx0aXR1ZGUpIHtcbiAgICAgICAgICAgIGN1cnIuYWx0aXR1ZGUgPSBwcmV2LmFsdGl0dWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgIWN1cnIuc3BlZWQpIHtcbiAgICAgICAgICAgIGN1cnIuc3BlZWQgPSBwcmV2LnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJyLmhlYWRpbmcgJiYgY3Vyci5uYXZtb2RlID09PSBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HKSB7XG4gICAgICAgICAgICBjdXJyLmhlYWRpbmcgPSBwcmV2LmhlYWRpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTa2lwcyB0byB0aGUgZ2l2ZW4gd2F5cG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBmaXggdG8gc2tpcCB0b1xuICAgICAqL1xuICAgIHNraXBUb0ZpeChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcblxuICAgICAgICAvLyBUT0RPOiB0aGVzZSBuZXN0ZWQgZm9yIGxvb3BzIHNob3VsZCBiZSBzaW1wbGlmaWVkXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdGhpcy5sZWdzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHRoaXMubGVnc1tsXS53YXlwb2ludHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWdzW2xdLndheXBvaW50c1t3XS5maXggPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gW2wsIHddO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoZXNlIGlmIGJsb2NrcyBhIHJlcGVhdGVkIGVsc2V3aGVyZSwgcGVyaGFwcyBjdXJyZW50V2F5cG9pbnQgY2FuIGhhbmRsZSB0aGlzIGxvZ2ljP1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgYWx0aXR1ZGUgJiBzcGVlZCBub3QgbnVsbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gdGhpcy5jdXJyZW50V2F5cG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmICFjdXJyLmFsdGl0dWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyLmFsdGl0dWRlID0gcHJldi5hbHRpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmICFjdXJyLnNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyLnNwZWVkID0gcHJldi5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgYWxsIHdheXBvaW50c1xuICAgICAqL1xuICAgIHNldEFsbChkYXRhKSB7XG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMsIHdoYXQgaXMgYWN0dWFsbHkgaGFwcGVuaW5nIGhlcmU/XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubGVnc1tpXS53YXlwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ3NbaV0ud2F5cG9pbnRzW2pdW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGN1cnJlbnQgd2F5cG9pbnRcbiAgICAgKi9cbiAgICBzZXRDdXJyZW50KGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcywgd2hhdCBpcyBhY3R1YWxseSBoYXBwZW5pbmcgaGVyZT9cbiAgICAgICAgLy8gRklYTUU6IGl0IG1heSBiZSBlYXNpZXIgdG8gcmVwbGFjZSBjdXJyZW50IHdheXBvaW50IHdpdGggYSBuZXcgb25lP1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50V2F5cG9pbnRbaV0gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBmbXMuZnAucm91dGUgdG8gY29ycmVzcG9uZCB3aXRoIHRoZSBmbXMgTGVnc1xuICAgICAqL1xuICAgIHVwZGF0ZV9mcF9yb3V0ZSgpIHtcbiAgICAgICAgY29uc3QgZmxpZ2h0UGxhblJvdXRlID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZyA9IHRoaXMubGVnc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFsZWcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRTogcmVwbGFjZSB0aGUgc3RyaW5nIHNwbGl0dGluZyB3aXRoIHRoZSBgUm91dGVNb2RlbGAgY2xhc3MgbWV0aG9kc1xuICAgICAgICAgICAgc3dpdGNoIChsZWcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuU0lEOlxuICAgICAgICAgICAgICAgICAgICAvLyBkZXBhcnR1cmUgYWlycG9ydFxuICAgICAgICAgICAgICAgICAgICBmbGlnaHRQbGFuUm91dGUucHVzaChsZWcucm91dGUuZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAvLyAnc2lkbmFtZS5leGl0UG9pbnQnXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFBsYW5Sb3V0ZS5wdXNoKGAke2xlZy5yb3V0ZS5wcm9jZWR1cmV9LiR7bGVnLnJvdXRlLmV4aXR9YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGUF9MRUdfVFlQRS5TVEFSOlxuICAgICAgICAgICAgICAgICAgICAvLyAnZW50cnlQb2ludC5zdGFybmFtZS5leGl0UG9pbnQnXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFBsYW5Sb3V0ZS5wdXNoKGAke2xlZy5yb3V0ZS5lbnRyeX0uJHtsZWcucm91dGUucHJvY2VkdXJlfWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBhcnJpdmFsIGFpcnBvcnRcbiAgICAgICAgICAgICAgICAgICAgZmxpZ2h0UGxhblJvdXRlLnB1c2gobGVnLnJvdXRlLmV4aXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuSUFQOlxuICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGluY2x1ZGUgdGhlc2UgaW4gZmxpZ2h0cGxhbiAoYmVjYXVzZSB3b3VsZG4ndCBoYXBwZW4gaW4gcmVhbCBsaWZlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZQX0xFR19UWVBFLkFXWTpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGbGlnaHRQbGFuUm91dGUgPSBmbGlnaHRQbGFuUm91dGVbZmxpZ2h0UGxhblJvdXRlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0ZsaWdodFBsYW5Sb3V0ZSAhPT0gbGVnLnJvdXRlLnNwbGl0KCcuJylbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsaWdodFBsYW5Sb3V0ZS5wdXNoKGxlZy5yb3V0ZS5zcGxpdCgnLicpWzBdKTsgLy8gYWlyd2F5IGVudHJ5IGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpZ2h0UGxhblJvdXRlLnB1c2gobGVnLnJvdXRlLnNwbGl0KCcuJylbMV0pOyAvLyBhaXJ3YXkgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpZ2h0UGxhblJvdXRlLnB1c2gobGVnLnJvdXRlLnNwbGl0KCcuJylbMl0pOyAvLyBhaXJ3YXkgZXhpdCBmaXhcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuRklYOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBmaXhuYW1lXG4gICAgICAgICAgICAgICAgICAgIGZsaWdodFBsYW5Sb3V0ZS5wdXNoKGxlZy5yb3V0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGUF9MRUdfVFlQRS5NQU5VQUw6XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gaW5jbHVkZSB0aGVzZSBpbiBmbGlnaHRwbGFuIChiZWNhdXNlIHdvdWxkbid0IGhhcHBlbiBpbiByZWFsIGxpZmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBmaXJzdCBhbmQgcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICBpZiAoZmxpZ2h0UGxhblJvdXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZsaWdodFBsYW5Sb3V0ZS5wdXNoKHRoaXMubGVnc1swXS5yb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZwLnJvdXRlID0gZmxpZ2h0UGxhblJvdXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHZhcmlvdXMgdGFzay1iYXNlZCBmdW5jdGlvbnMgYW5kIHNldHMgJ2Ztcy5mb2xsb3dpbmcnIGZsYWdzXG4gICAgICovXG4gICAgZm9sbG93Q2hlY2soKSB7XG4gICAgICAgIGNvbnN0IGxlZyA9IHRoaXMuY3VycmVudExlZztcbiAgICAgICAgdGhpcy5mb2xsb3dpbmcuYW55dGhpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIHRPRE8gcmVwbGFjZSB0aGUgc3RyaW5nIHNwbGl0dGluZyB3aXRoIHRoZSBgUm91dGVNb2RlbGBcbiAgICAgICAgc3dpdGNoIChsZWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGUF9MRUdfVFlQRS5TSUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mb2xsb3dpbmcuc2lkID0gbGVnLnJvdXRlLnByb2NlZHVyZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuU1RBUjpcbiAgICAgICAgICAgICAgICB0aGlzLmZvbGxvd2luZy5zdGFyID0gbGVnLnJvdXRlLnByb2NlZHVyZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuSUFQOlxuICAgICAgICAgICAgICAgIC8vICoqKioqKipORUVEUyBUTyBCRSBGSU5JU0hFRCoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICAgIC8vIHRoaXMuZm9sbG93aW5nLmlhcCA9IDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RmYyc6XG4gICAgICAgICAgICAgICAgLy8gKipGVVRVUkUgRlVOQ1RJT05BTElUWSoqXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5mb2xsb3dpbmcuYW55dGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuZm9sbG93aW5nLnRmYyA9IC8vIEVJRCBvZiB0aGUgdHJhZmZpYyB3ZSdyZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuQVdZOlxuICAgICAgICAgICAgICAgIC8vICoqRlVUVVJFIEZVTkNUSU9OQUxJVFkqKlxuICAgICAgICAgICAgICAgIHRoaXMuZm9sbG93aW5nLmF3eSA9IGxlZy5yb3V0ZS5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmZvbGxvd0NsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBzb21ldGhpbmcgbW9yZSBhY2N1cmF0ZSBsaWtlIGByZXNldEZvbGxvd2luZ1R5cGVgXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFueSBjdXJyZW50IGZvbGxvd3MgYnkgdXBkYXRpbmcgdGhlICdmbXMuZm9sbG93aW5nJyBmbGFnc1xuICAgICAqL1xuICAgIGZvbGxvd0NsZWFyKCkge1xuICAgICAgICB0aGlzLmZvbGxvd2luZyA9IHtcbiAgICAgICAgICAgIHNpZDogbnVsbCxcbiAgICAgICAgICAgIHN0YXI6IG51bGwsXG4gICAgICAgICAgICBpYXA6IG51bGwsXG4gICAgICAgICAgICBhd3k6IG51bGwsXG4gICAgICAgICAgICB0ZmM6IG51bGwsXG4gICAgICAgICAgICBhbnl0aGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKb2luIGFuIGluc3RydW1lbnQgYXBwcm9hY2ggKGVnLiBJTFMvR1BTL1JOQVYvVk9SL0xBQVMvZXRjKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB0aGUgdHlwZSBvZiBhcHByb2FjaCAobGlrZSBcImlsc1wiKVxuICAgICAqIEBwYXJhbSB7UnVud2F5fSByd3kgLSB0aGUgUnVud2F5IG9iamVjdCB0aGUgYXBwcm9hY2ggZW5kcyBpbnRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhbnQgLSAob3B0aW9uYWwpIGZvciBzdHVmZiBsaWtlIFwiUk5BVi1aIDE3TFwiXG4gICAgICovXG4gICAgZm9sbG93QXBwcm9hY2godHlwZSwgcnd5LCB2YXJpYW50KSB7XG4gICAgICAvLyBOb3RlOiAndmFyaWFudCcgaXMgc2V0IHVwIHRvIHBhc3MgdG8gdGhpcyBmdW5jdGlvbiwgYnV0IGlzIG5vdCB1c2VkIGhlcmUgeWV0LlxuICAgICAgICBpZiAodHlwZSA9PT0gJ2lscycpIHtcbiAgICAgICAgICAgIHRoaXMubXlfYWlyY3JhZnQuY2FuY2VsRml4KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGxvb2tzIGxpa2UgYSBtb2RlbCBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudCh7XG4gICAgICAgICAgICAgICAgbmF2bW9kZTogJ3J3eScsXG4gICAgICAgICAgICAgICAgcnVud2F5OiByd3kudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB0dXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3NwZWVkOiB0aGlzLm15X2FpcmNyYWZ0LnNwZWVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgLy8gaWYtZWxzZSBhbGwgdGhlIG90aGVyIGFwcHJvYWNoIHR5cGVzIGhlcmUuLi5cbiAgICAgIC8vIElMUywgR1BTLCBSTkFWLCBWT1IsIE5EQiwgTEFBUy9XQUFTLCBNTFMsIGV0Yy4uLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIFNJRCBhcyB0aGUgZmlyc3QgTGVnIGluIHRoZSBmbXMncyBmbGlnaHRwbGFuXG4gICAgICovXG4gICAgZm9sbG93U0lEKHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gc2lkIGFzc2lnbmVkIGFmdGVyIHRha2luZyBvZmYgd2l0aG91dCBTSURcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZ3NbaV0ucm91dGUgPT09IGFpcnBvcnQuaWNhbykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbWFudWFsIGRlcGFydHVyZSBsZWdcbiAgICAgICAgICAgICAgICB0aGlzLmxlZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlZ3NbaV0udHlwZSA9PT0gRlBfTEVHX1RZUEUuU0lEKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIFNJRCBhbHJlYWR5IGFzc2lnbmVkXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgU0lEXG4gICAgICAgICAgICAgICAgdGhpcy5sZWdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IFNJRCBMZWdcbiAgICAgICAgdGhpcy5wcmVwZW5kTGVnKHtcbiAgICAgICAgICAgIHR5cGU6IEZQX0xFR19UWVBFLlNJRCxcbiAgICAgICAgICAgIHJvdXRlOiByb3V0ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldEFsbCh7XG4gICAgICAgICAgICBhbHRpdHVkZTogTWF0aC5tYXgoYWlycG9ydC5pbml0aWFsX2FsdCwgdGhpcy5teV9haXJjcmFmdC5hbHRpdHVkZSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgU1RBUiBhcyB0aGUgbGFzdCBMZWcgaW4gdGhlIGZtcydzIGZsaWdodHBsYW5cbiAgICAgKi9cbiAgICBmb2xsb3dTVEFSKHJvdXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWdzW2ldLnR5cGUgPT09IEZQX0xFR19UWVBFLlNUQVIpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgU1RBUiBhbHJlYWR5IGFzc2lnbmVkXG4gICAgICAgICAgICAgICAgdGhpcy5sZWdzLnNwbGljZShpLCAxKTsgIC8vIHJlbW92ZSB0aGUgb2xkIFNUQVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudCA9IFswLCAwXTtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgU1RBUiBMZWdcbiAgICAgICAgdGhpcy5hcHBlbmRMZWcoe1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICB0eXBlOiBGUF9MRUdfVFlQRS5TVEFSXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyB0byB0aGUgYFJvdXRlTW9kZWxgXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBzaW5nbGUtc3RyaW5nIHJvdXRlIGFuZCBjb252ZXJ0cyBpdCB0byBhIHNlZ21lbnRlZCByb3V0ZSB0aGUgZm1zIGNhbiB1bmRlcnN0YW5kXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbnB1dCBEYXRhIEZvcm1hdCA6IFwiS1NGTy5PRkZTSDkuU1hDLlY0NTguSVBMLkoyLkpDVC4uTExPLi5BQ1QuLktBQ1RcIlxuICAgICAqICAgICAgIFJldHVybiBEYXRhIEZvcm1hdDogW1wiS1NGTy5PRkZTSDkuU1hDXCIsIFwiU1hDLlY0NTguSVBMXCIsIFwiSVBMLkoyLkpDVFwiLCBcIkxMT1wiLCBcIkFDVFwiLCBcIktBQ1RcIl1cbiAgICAgKi9cbiAgICBmb3JtYXRSb3V0ZShkYXRhKSB7XG4gICAgICAgIC8vIGNvbnN0IHJvdXRlTW9kZWwgPSBuZXcgUm91dGVNb2RlbChkYXRhKTtcblxuICAgICAgICAvLyBGb3JtYXQgdGhlIHVzZXIncyBpbnB1dFxuICAgICAgICBsZXQgcm91dGUgPSBbXTtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCBmaXhPSyA9IChmaXhOYW1lKSA9PiBGaXhDb2xsZWN0aW9uLmZpbmRGaXhCeU5hbWUoZml4TmFtZSkgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGRhdGEuaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBpbnB1dCBjYW4ndCBjb250YWluIHNwYWNlc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgcmVhc3NpZ25lZCBhbmQgcmV0dXJuZWQgaW5zdGVhZCBvZiBvcGVyYXRpbmcgb24gdGhlIHBhc3NlZCBpbiBwYXJhbWF0ZXJcbiAgICAgICAgLy8gc3BsaXQgYXBhcnQgXCJkaXJlY3RcIiBwaWVjZXNcbiAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy4uJyk7XG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBibG9jayBuZWVkcyBzb21lIHdvcmsuIHRoZSBsb2dpYyBjb3VsZCBiZSBzaW1wbGlmaWVkLlxuICAgICAgICAvLyBkZWFsIHdpdGggbXVsdGlsaW5rcyAoZWcgJ0tTRk8uT0ZGU0g5LlNYQy5WNDU4LklQTCcpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGE7XG5cbiAgICAgICAgICAgIGlmIChkYXRhW2ldLnNwbGl0KCcuJykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXhPSyhkYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8ganVzdCBhIGZpeC9uYXZhaWRcbiAgICAgICAgICAgICAgICByb3V0ZS5wdXNoKGRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpcyBhIHByb2NlZHVyZSwgZWcgU0lELCBTVEFSLCBJQVAsIGFpcndheSwgZXRjLlxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLnNwbGl0KCcuJykubGVuZ3RoICUgMiAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2VyIGVpdGhlciBkaWRuJ3Qgc3BlY2lmeSBzdGFydCBwb2ludCBvciBlbmQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0ZWQgdG8gYW5vdGhlciBjbGFzcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgY29uc3QgcGllY2VzID0gZGF0YVtpXS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiB3aGF0IGRvZXMgJ2EnIG1lYW4/IGJldHRlciBuYW1pbmdcbiAgICAgICAgICAgICAgICBhID0gW2Ake3BpZWNlc1swXX0uJHtwaWVjZXNbMV19LiR7cGllY2VzWzJdfWBdO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvcCB1cCB0aGUgbXVsdGlsaW5rXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDM7IGogPCBkYXRhW2ldLnNwbGl0KCcuJykubGVuZ3RoOyBqICsgMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpeE9LKHBpZWNlc1swXSkgfHwgIWZpeE9LKHBpZWNlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIGludmFsaWQgam9pbi9leGl0IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhaXJwb3J0LnNpZENvbGxlY3Rpb24uaGFzUm91dGUocGllY2VzWzFdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5rZXlzKGFpcnBvcnQuYWlyd2F5cykuaW5kZXhPZihwaWVjZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkIHByb2NlZHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHBpZWNlc1tqIC0gMV0gKyAnLicgKyBwaWVjZXNbal0gKyBwaWVjZXNbaiArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHB1c2ggdGhlIHByb3Blcmx5IHJlZm9ybWF0dGVkIG11bHRpbGlua1xuICAgICAgICAgICAgcm91dGUgPSByb3V0ZS5jb25jYXQoYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byB1c2UgYFJvdXRlTW9kZWxgIGFuZCBwb3NzaWJseSBhIGBMZWdzQ29sbGVjdGlvbmAgY2xhc3NcbiAgICAvKipcbiAgICAgKiBUYWtlIGFuIGFycmF5IG9mIGxlZyByb3V0ZXMgYW5kIGJ1aWxkIHRoZSBsZWdzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSBmbXNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSByb3V0ZSAtIGFuIGFycmF5IG9mIHByb3Blcmx5IGZvcm1hdHRlZCByb3V0ZSBzdHJpbmdzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBFeGFtcGxlOiBbXCJLU0ZPLk9GRlNIOS5TWENcIiwgXCJTWEMuVjQ1OC5JUExcIixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSVBMLkoyLkpDVFwiLCBcIkxMT1wiLCBcIkFDVFwiLCBcIktBQ1RcIl1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZ1bGxSb3V0ZUNsZWFyYW5jZSAtIHNldCB0byB0cnVlIElGIHlvdSB3YW50IHRoZSBwcm92aWRlZCByb3V0ZSB0byBjb21wbGV0ZWx5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mICd0aGlzLmxlZ3MnXG4gICAgICovXG4gICAgY3VzdG9tUm91dGUocm91dGUsIGZ1bGxSb3V0ZUNsZWFyYW5jZSkge1xuICAgICAgICAvLyBzYXZlIHRoZSBjdXJyZW50IHdheXBvaW50XG4gICAgICAgIGNvbnN0IGN1cnIgPSB0aGlzLmN1cnJlbnRXYXlwb2ludDtcblxuICAgICAgICBjb25zdCBsZWdzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm91dGVTZWN0aW9ucyA9IHJvdXRlW2ldLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIC8vIGp1c3QgYSBmaXgvbmF2YWlkXG4gICAgICAgICAgICBpZiAocm91dGVTZWN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoeyB0eXBlOiBGUF9MRUdfVFlQRS5GSVgsIHJvdXRlOiByb3V0ZVtpXSB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIGxlZ3MucHVzaChsZWdUb0FkZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvdXRlU2VjdGlvbnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVNb2RlbCA9IG5ldyBSb3V0ZU1vZGVsKHJvdXRlW2ldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfaXNOaWwoY3VycmVudEFpcnBvcnQuc2lkQ29sbGVjdGlvbi5maW5kUm91dGVCeUljYW8ocm91dGVNb2RlbC5wcm9jZWR1cmUpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgU0lEIVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoeyB0eXBlOiBGUF9MRUdfVFlQRS5TSUQsIHJvdXRlOiByb3V0ZU1vZGVsLnJvdXRlQ29kZSB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWdzLnB1c2gobGVnVG9BZGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV9pc05pbChjdXJyZW50QWlycG9ydC5zdGFyQ29sbGVjdGlvbi5maW5kUm91dGVCeUljYW8ocm91dGVNb2RlbC5wcm9jZWR1cmUpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgU1RBUiFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVnVG9BZGQgPSBuZXcgTGVnKHsgdHlwZTogRlBfTEVHX1RZUEUuU1RBUiwgcm91dGU6IHJvdXRlTW9kZWwucm91dGVDb2RlIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxlZ3MucHVzaChsZWdUb0FkZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyh3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5haXJ3YXlzKS5pbmRleE9mKHJvdXRlTW9kZWwucHJvY2VkdXJlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYW4gYWlyd2F5IVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWdUb0FkZCA9IG5ldyBMZWcoeyB0eXBlOiBGUF9MRUdfVFlQRS5BV1ksIHJvdXRlOiByb3V0ZU1vZGVsLnJvdXRlQ29kZSB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWdzLnB1c2gobGVnVG9BZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBmb3JtYXR0ZWQgbGlrZSBcIkpBTlwiIG5vciBcIkpBTi5WMTguTUxVXCJcbiAgICAgICAgICAgICAgICBsb2coYFBhc3NlZCBpbnZhbGlkIHJvdXRlIHRvIGZtcy4gVW5hYmxlIHRvIGNyZWF0ZSBsZWcgZnJvbSBpbnB1dDogJHtyb3V0ZVtpXX1gLCBMT0cuV0FSTklORyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgaXRzIG93biBtZXRob2RcbiAgICAgICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBzaW1wbGlmaWVkLiB0aGVyZSBpcyBhIGxvdCBvZiBicmFuY2hpbmcgbG9naWMgaGVyZSB0aGF0IG1ha2VzIHRoaXMgYmxvY2sgdG91Z2ggdG8gZm9sbG93LlxuICAgICAgICAvLyBpbnNlcnQgdXNlcidzIHJvdXRlIHRvIHRoZSBsZWdzXG4gICAgICAgIGlmICghZnVsbFJvdXRlQ2xlYXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB1c2VyJ3Mgcm91dGUgaG9va3MgdXAgdG8gdGhlIGN1cnJlbnQgTGVncyBhbnl3aGVyZVxuICAgICAgICAgICAgY29uc3QgcGllY2VzID0gbGVnc1tsZWdzLmxlbmd0aCAtIDFdLnJvdXRlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCBsYXN0X2ZpeCA9IHBpZWNlc1twaWVjZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjb250aW51aXR5ID0gdGhpcy5pbmRleE9mV2F5cG9pbnQobGFzdF9maXgpO1xuXG4gICAgICAgICAgICAvLyB1c2VyIHJvdXRlIGNvbm5lY3RzIHdpdGggZXhpc3RpbmcgbGVnc1xuICAgICAgICAgICAgaWYgKGNvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbk1pZGRsZU9mTGVnID0gY29udGludWl0eS5sd1sxXSAhPT0gdGhpcy5sZWdzW2NvbnRpbnVpdHkubHdbMF1dLndheXBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ3NUb1JlbW92ZSA9IE1hdGgubWF4KDAsIGNvbnRpbnVpdHkubHdbMF0gLSBpbk1pZGRsZU9mTGVnIC0gdGhpcy5jdXJyZW50W0xFR10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluTWlkZGxlT2ZMZWcpIHsgLy8gY2hhbmdlIHRoZSBleGlzdGluZyBsZWcgQCBtZXJnZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHdheXBvaW50cyBiZWZvcmUgdGhlIG1lcmdlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVnc1tjb250aW51aXR5Lmx3WzBdXS53YXlwb2ludHMuc3BsaWNlKDAsIGNvbnRpbnVpdHkubHdbMV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5sZWdzW2NvbnRpbnVpdHkubHdbMF1dLnJvdXRlLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYSBoZWxwZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVnJ3Mgcm91dGUgdG8gcmVmbGVjdCB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVnc1tjb250aW51aXR5Lmx3WzBdXS5yb3V0ZSA9IGxhc3RfZml4ICsgJy4nICsgclsxXSArICcuJyArIHJbMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBsZWdzIGJlZm9yZSB0aGUgcG9pbnQgd2hlcmUgdGhlIHR3byByb3V0ZXMgam9pblxuICAgICAgICAgICAgICAgIHRoaXMubGVncy5zcGxpY2UuYXBwbHkodGhpcy5sZWdzLCBbTWF0aC5tYXgoMCwgY29udGludWl0eS5sd1swXSAtIGxlZ3NUb1JlbW92ZSksIGxlZ3NUb1JlbW92ZV0uY29uY2F0KGxlZ3MpKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIHRoZSBuZXdseSBpbnNlcnRlZCBMZWdcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRbTEVHXSA9IE1hdGgubWF4KDAsIGNvbnRpbnVpdHkubHdbMF0gLSBsZWdzVG9SZW1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFtXQVlQT0lOVF9XSVRISU5fTEVHXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIHJvdXRlIGNvbnRpbnVpdHkuLi4ganVzdCBhZGRpbmcgbGVnc1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbGVncyBhZnRlciB0aGUgYWN0aXZlIExlZ1xuICAgICAgICAgICAgICAgIHRoaXMubGVncy5zcGxpY2UuYXBwbHkodGhpcy5sZWdzLCBbdGhpcy5jdXJyZW50W0xFR10gKyAxLCAwXS5jb25jYXQobGVncykpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExlZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB1cCBhbmQgcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAvLyByZXBsYWNlIGFsbCBsZWdzIHdpdGggdGhlIGxlZ3Mgd2UndmUgYnVpbHQgaGVyZSBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aGlzLmxlZ3MgPSBsZWdzO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gWzAsIDBdOyAvLyBsb29rIHRvIGJlZ2lubmluZyBvZiByb3V0ZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVfZnBfcm91dGUoKTtcblxuICAgICAgICAvLyBNYWludGFpbiBvbGQgc3BlZWQgYW5kIGFsdGl0dWRlXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRXYXlwb2ludC5hbHRpdHVkZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQoeyBhbHRpdHVkZTogY3Vyci5hbHRpdHVkZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRXYXlwb2ludC5zcGVlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQoeyBzcGVlZDogY3Vyci5zcGVlZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaW1icyBhaXJjcmFmdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIFNJRCB0aGV5J3JlIGZvbGxvd2luZ1xuICAgICAqIEFkZHMgYWx0aXR1ZGVzIGFuZCBzcGVlZHMgdG8gZWFjaCB3YXlwb2ludCB0aGF0IGFyZSBhcyBoaWdoIGFzXG4gICAgICogcG9zc2libGUgd2l0aG91dCBleGNlZWRpbmcgYW55IHRoZSBmb2xsb3dpbmc6XG4gICAgICogICAgLSAoYWx0KSBhaXJzcGFjZSBjZWlsaW5nICgnY3RyX2NlaWxpbmcnKVxuICAgICAqICAgIC0gKGFsdCkgZmlsZWQgY3J1aXNlIGFsdGl0dWRlXG4gICAgICogICAgLSAoYWx0KSB3YXlwb2ludCdzIGFsdGl0dWRlIHJlc3RyaWNpdG9uXG4gICAgICogICAgLSAoc3BkKSAyNTBrdHMgd2hlbiB1bmRlciAxMGsgZnRcbiAgICAgKiAgICAtIChzcGQpIHdheXBvaW50J3Mgc3BlZWQgcmVzdHJpY3Rpb25cbiAgICAgKi9cbiAgICBjbGltYlZpYVNJRCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExlZy50eXBlICE9PSBGUF9MRUdfVFlQRS5TSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdwID0gdGhpcy5jdXJyZW50TGVnLndheXBvaW50cztcbiAgICAgICAgY29uc3QgY3J1aXNlX2FsdCA9IHRoaXMuZnAuYWx0aXR1ZGU7XG4gICAgICAgIGNvbnN0IGNydWlzZV9zcGQgPSB0aGlzLm15X2FpcmNyYWZ0Lm1vZGVsLnNwZWVkLmNydWlzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3YXlwb2ludCA9IHdwW2ldO1xuICAgICAgICAgICAgY29uc3QgeyBjdHJfY2VpbGluZyB9ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG5cbiAgICAgICAgICAgIHdheXBvaW50LnNldEFsdGl0dWRlKGN0cl9jZWlsaW5nLCBjcnVpc2VfYWx0KTtcbiAgICAgICAgICAgIHdheXBvaW50LnNldFNwZWVkKGNydWlzZV9zcGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzY2VuZHMgYWlyY3JhZnQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBTVEFSIHRoZXkncmUgZm9sbG93aW5nXG4gICAgICogQWRkcyBhbHRpdHVkZXMgYW5kIHNwZWVkcyB0byBlYWNoIHdheXBvaW50IGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgU1RBUlxuICAgICAqL1xuICAgIGRlc2NlbmRWaWFTVEFSKCkge1xuICAgICAgICBjb25zdCB3YXlwb2ludExpc3QgPSB0aGlzLmdldFN0YXJMZWdXYXlwb2ludHMoKTtcblxuICAgICAgICAvLyBUT0RPOiB3b3VsZCBhIHN0YXIgbGVnIGV2ZXIgbm90IGhhdmUgd2F5cG9pbnRzP1xuICAgICAgICBpZiAoIXdheXBvaW50TGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0X2FsdCA9IHRoaXMuY3VycmVudFdheXBvaW50LmFsdGl0dWRlIHx8IHRoaXMubXlfYWlyY3JhZnQuYWx0aXR1ZGU7XG4gICAgICAgIGxldCBzdGFydF9zcGQgPSB0aGlzLmN1cnJlbnRXYXlwb2ludC5zcGVlZCB8fCB0aGlzLm15X2FpcmNyYWZ0Lm1vZGVsLnNwZWVkLmNydWlzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdheXBvaW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnQgPSB3YXlwb2ludExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1dheXBvaW50ID0gd2F5cG9pbnRMaXN0W2kgLSAxXTtcblxuICAgICAgICAgICAgaWYgKGkgPj0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0X2FsdCA9IHByZXZpb3VzV2F5cG9pbnQuYWx0aXR1ZGU7XG4gICAgICAgICAgICAgICAgc3RhcnRfc3BkID0gcHJldmlvdXNXYXlwb2ludC5zcGVlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2F5cG9pbnQuc2V0QWx0aXR1ZGUobnVsbCwgc3RhcnRfYWx0KTtcbiAgICAgICAgICAgIHdheXBvaW50LnNldFNwZWVkKHN0YXJ0X3NwZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqIEZNUyBRVUVSWSBGVU5DVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB3YXlwb2ludCBvZiB0aGUgZ2l2ZW4gbmFtZSBleGlzdHNcbiAgICAgKi9cbiAgICBoYXNXYXlwb2ludChuYW1lKSB7XG4gICAgICAgIC8vIFRPRE86IGxvZGFzaCB3aWxsIHNpbXBsaWZ5IHRoaXMgbG9naWMgYmxvY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZWdzW2ldLndheXBvaW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZ3NbaV0ud2F5cG9pbnRzW2pdLmZpeCA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QncyBwb3NpdGlvbiBpbiBmbGlnaHRwbGFuIGFzIG9iamVjdCB3aXRoIDIgZm9ybWF0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpeCAtIG5hbWUgb2YgdGhlIGZpeCB0byBsb29rIGZvciBpbiB0aGUgZmxpZ2h0cGxhblxuICAgICAqIEByZXR1cm5zIHt3cDogXCJwb3NpdGlvbi1vZi1maXgtaW4td2F5cG9pbnQtbGlzdFwiLFxuICAgICAqICAgICAgICAgICBsdzogXCJwb3NpdGlvbi1vZi1maXgtaW4tbGVnLXdwLW1hdHJpeFwifVxuICAgICAqL1xuICAgIGluZGV4T2ZXYXlwb2ludChmaXgpIHtcbiAgICAgICAgbGV0IHdwID0gMDtcblxuICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHRoaXMubGVncy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCB0aGlzLmxlZ3NbbF0ud2F5cG9pbnRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVnc1tsXS53YXlwb2ludHNbd10uZml4ID09PSBmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBkbyB3cCBhbmQgbHcgc3RhbmQgZm9yP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3A6IHdwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbHc6IFtsLCB3XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50V2F5cG9pbnQncyBwb3NpdGlvbiBpbiBmbGlnaHRwbGFuIGFzIG9iamVjdCB3aXRoIDIgZm9ybWF0c1xuICAgICAqIEByZXR1cm5zIHt3cDogXCJwb3NpdGlvbi1vZi1maXgtaW4td2F5cG9pbnQtbGlzdFwiLFxuICAgICAqICAgICAgICAgICBsdzogXCJwb3NpdGlvbi1vZi1maXgtaW4tbGVnLXdwLW1hdHJpeFwifVxuICAgICAqL1xuICAgIGluZGV4T2ZDdXJyZW50V2F5cG9pbnQoKSB7XG4gICAgICAgIGxldCB3cCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jdXJyZW50W0xFR107IGkrKykge1xuICAgICAgICAgICAgLy8gYWRkIHdwJ3Mgb2YgY29tcGxldGVkIGxlZ3NcbiAgICAgICAgICAgIHdwICs9IHRoaXMubGVnc1tpXS53YXlwb2ludHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgd3AgKz0gdGhpcy5jdXJyZW50W1dBWVBPSU5UX1dJVEhJTl9MRUddO1xuXG4gICAgICAgIC8vIFRPRE86IHdoYXQgZG8gd3AgYW5kIGx3IHN0YW5kIGZvcj9cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdwOiB3cCxcbiAgICAgICAgICAgIGx3OiB0aGlzLmN1cnJlbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKiBGTVMgR0VUIEZVTkNUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBnZXQgY3VycmVudExlZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnc1t0aGlzLmN1cnJlbnRbTEVHXV07XG4gICAgfVxuXG4gICAgZ2V0IGN1cnJlbnRXYXlwb2ludCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVncy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRMZWcgPSB0aGlzLmN1cnJlbnRMZWc7XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMZWcud2F5cG9pbnRzW3RoaXMuY3VycmVudFtXQVlQT0lOVF9XSVRISU5fTEVHXV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBmaXhlcyBhbG9uZyB0aGUgZmxpZ2h0cGxhbiByb3V0ZVxuICAgICovXG4gICAgZml4ZXMoKSB7XG4gICAgICAgIHJldHVybiBfbWFwKHRoaXMud2F5cG9pbnRzKCksICh3KSA9PiB3LmZpeCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoaXMgZm1zJ3MgcGFyZW50IGFpcmNyYWZ0XG4gICAgICovXG4gICAgbXlfYWlyY3JhZnQoKSB7XG4gICAgICAgIC8vIFRPRE86IGlmIHdlIGFscmVhZHkgaGF2ZSBhIHJlZiB0byB0aGUgY3VycmVudCBhaXJjcmFmdCwgYHRoaXMubXlfYWlyY3JhZnRgLCB3aHkgYXJlIHdlIGdldHRpbmcgaXQgYWdhaW4gaGVyZT9cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5haXJjcmFmdENvbnRyb2xsZXIuYWlyY3JhZnRfZ2V0KHRoaXMubXlfYWlyY3JhZnRzX2VpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHdheXBvaW50IGF0IHRoZSBwcm92aWRlZCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQG1ldGhvZCB3YXlwb2ludFxuICAgICAqIEBwYXJhbSB7YXJyYXkgb3IgbnVtYmVyfSBwb3MgLSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCB3YXlwb2ludC4gTWF5IGJlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIGVpdGhlciBhcyBhbiBhcnJheSBzaG93aW5nIHRoZSBsZWcgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdheXBvaW50IHdpdGhpbiB0aGUgbGVnIChlZyBbbCx3XSksIG9yIGFzIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3YXlwb2ludCBpbiB0aGUgbGlzdCBvZiBhbGwgd2F5cG9pbnRzIChydW5uaW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F5cG9pbnRzKCkgd2lsbCByZXR1cm4gdGhlIGxpc3QpXG4gICAgICogQHJldHVybnMge1dheXBvaW50fSAtIHRoZSBXYXlwb2ludCBvYmplY3QgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAqL1xuICAgIHdheXBvaW50KHBvcykge1xuICAgICAgICAvLyBpbnB1dCBpcyBsaWtlIFtsZWcsIHdheXBvaW50V2l0aGluTGVnXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWdzW3Bvc1swXV0ud2F5cG9pbnRzW3Bvc1sxXV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGlucHV0IGlzIGEgcG9zaXRpb24gb2Ygd3AgaW4gbGlzdCBvZiBhbGwgd2F5cG9pbnRzXG4gICAgICAgICAgICBsZXQgbCA9IDA7XG5cbiAgICAgICAgICAgIC8vIGNvdW50IHVwIHRvIHBvcyB0byBsb2NhdGUgdGhlIHdheXBvaW50XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWdzW2xdLndheXBvaW50cy5sZW5ndGggPD0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyAtPSB0aGlzLmxlZ3NbbF0ud2F5cG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZ3NbbF0ud2F5cG9pbnRzW3Bvc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBsZWcgd2l0aCB0eXBlIGBzdGFyYCBhbmQgcmV0dXJuIHRoYXQgbGVnJ3Mgd2F5cG9pbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRTdFxuICAgICAqIEByZXR1cm4ge2FycmF5PFdheXBvaW50Pn1cbiAgICAgKi9cbiAgICBnZXRTdGFyTGVnV2F5cG9pbnRzKCkge1xuICAgICAgICBjb25zdCBzdGFyTGVnID0gX2ZpbmQodGhpcy5sZWdzLCB7IHR5cGU6IEZQX0xFR19UWVBFLlNUQVIgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXJMZWcud2F5cG9pbnRzIHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyBhbGwgd2F5cG9pbnRzIGluIGZtcywgaW4gb3JkZXJcbiAgICAqL1xuICAgIHdheXBvaW50cygpIHtcbiAgICAgICAgLy8gVE9ETzogbW92ZSB0byBfbWFwKCkgb3IgcmVmYWN0b3JcbiAgICAgICAgLy8gVE9ETzogdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMgd2l0aCBsb2Rhc2hcbiAgICAgICAgY29uc3Qgd2F5cG9pbnRMaXN0ID0gJC5tYXAodGhpcy5sZWdzLCAodikgPT4gdi53YXlwb2ludHMpO1xuXG4gICAgICAgIHJldHVybiB3YXlwb2ludExpc3Q7XG4gICAgfVxuXG4gICAgYXRMYXN0V2F5cG9pbnQoKSB7XG4gICAgICAgIC8vIFRPRE86IHNpbXBsaWZ5XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4T2ZDdXJyZW50V2F5cG9pbnQoKS53cCA9PT0gdGhpcy53YXlwb2ludHMoKS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgU0lEIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGZvbGxvd2VkLCByZXR1cm4gYSBzdHJpbmcgb2Y6IGBTSURfTkFNRS5MQVNUX0ZJWGBcbiAgICAgKlxuICAgICAqIGV4OlxuICAgICAqIC0gY3VycmVudCBTSUQgbmFtZSA9IE9GRlNIOVxuICAgICAqIC0gY3VycmVudCBTSUQgcm91dGUgPSBLU0ZPLk9GRlNIOS5TWENcbiAgICAgKlxuICAgICAqIEdpdmVuIHRoZSBhYm92ZSBjdXJyZW50IHZhbHVlcywgdGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm46XG4gICAgICogYE9GRlNIOS5TWENgXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmNyYWZ0RmxpZ2h0TWFuYWdlbWVudFN5c3RlbVxuICAgICAqIEBtZXRob2QgZ2V0Rm9sbG93aW5nU2lkZVRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRGb2xsb3dpbmdTSURUZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9sbG93aW5nLnNpZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb2xsb3dpbmcuc2lkfS4ke3RoaXMuY3VycmVudExlZy5yb3V0ZS5leGl0fWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJjcmFmdEZsaWdodE1hbmFnZW1lbnRTeXN0ZW1cbiAgICAgKiBAbWV0aG9kIGdldEZvbGxvd2luZ1NUQVJUZXh0XG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0Rm9sbG93aW5nU1RBUlRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb2xsb3dpbmcuc3Rhcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGljYW8gfSA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvbGxvd2luZy5zdGFyfS4ke2ljYW8udG9VcHBlckNhc2UoKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgdXNlZCBpbiB0aGUgYEFpcmNyYWZ0U3RyaXBWaWV3YCBmb3IgYSBsYW5kaW5nIGFpcmNyYWZ0LlxuICAgICAqXG4gICAgICogYEtTRk8gMjhMYFxuICAgICAqXG4gICAgICogQGZvciBBaXJjcmFmdEZsaWdodE1hbmFnZW1lbnRTeXN0ZW1cbiAgICAgKiBAbWV0aG9kIGdldERlc2luYXRpb25JY2FvV2l0aFJ1bndheVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXREZXNpbmF0aW9uSWNhb1dpdGhSdW53YXkoKSB7XG4gICAgICAgIHJldHVybiBgJHtfbGFzdCh0aGlzLmZwLnJvdXRlKX0gJHt0aGlzLmN1cnJlbnRXYXlwb2ludC5ydW53YXl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmNyYWZ0RmxpZ2h0TWFuYWdlbWVudFN5c3RlbVxuICAgICAqIEBtZXRob2QgYWx0aXR1ZGVGb3JDdXJyZW50V2F5cG9pbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBhbHRpdHVkZUZvckN1cnJlbnRXYXlwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFdheXBvaW50LmFsdGl0dWRlO1xuICAgIH1cbn1cbiIsImltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgV2F5cG9pbnQgZnJvbSAnLi9XYXlwb2ludCc7XG5pbXBvcnQgUm91dGVNb2RlbCBmcm9tICcuLi8uLi9haXJwb3J0L1JvdXRlL1JvdXRlTW9kZWwnO1xuaW1wb3J0IHsgRlBfTEVHX1RZUEUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvYWlyY3JhZnRDb25zdGFudHMnO1xuaW1wb3J0IHsgTE9HIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2xvZ0xldmVsJztcblxuLyoqXG4gICogVGhpcyBjbGFzcyBhY3RzIGFzIGEgY29sbGVjdGlvbiBvZiBXYXlwb2ludCBtb2RlbCBvYmplY3RzLlxuICAqXG4gICogQGNsYXNzIExlZ1xuICAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGVnIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmb3IgTGVnXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcm91dGU6ICAgICAgICAgICBcIktTRk8uT0ZGU0g5LlNYQ1wiLCBlaXRoZXIgYSBmaXgsIG9yIHdpdGggZm9ybWF0ICdzdGFydC5wcm9jZWR1cmUuZW5kJywgb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltSTkFWL0dQU11cIiBmb3IgY3VzdG9tIHBvc2l0aW9uc1xuICAgICAqICAgICAgICAgICAgICAgICB0eXBlOiBcInNpZFwiLCAgICAgY2FuIGJlICdzaWQnLCAnc3RhcicsICdpYXAnLCAnYXd5JywgJ2ZpeCdcbiAgICAgKiAgICAgICAgICAgICAgICAgZmlyc3RJbmRleDogMCAgICB0aGUgcG9zaXRpb24gKGluZGV4KSBpbiBmbXMubGVncyB0byBpbnNlcnQgdGhpcyBsZWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhID0ge30sIGZtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcm91dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1heSBiZSBhIHNpbmdsZSBmaXggb3IgYSByb3V0ZSBleHByZXNzZWQgaW4gZG90IG5vdGF0aW9uLiBleDpcbiAgICAgICAgICogLSBgS1NGTy5PRkZTSDkuU1hDYFxuICAgICAgICAgKiAtIGBGQUlUSGBcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHJvdXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvdXRlID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcblxuICAgICAgICAvLyBUT0RPOiBwb3NzaWJseSBpbXBsZW1lbnQgYXMgYSB3YXlwb2ludENvbGxlY3Rpb25cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBXYXlwb2ludCBpbnN0YW5jZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHdheXBvaW50c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndheXBvaW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMucGFyc2UoZGF0YSwgZm1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBpbnB1dCBkYXRhIGFuZCBhcHBseSB0byB0aGlzIGxlZ1xuICAgICAqXG4gICAgICogQGZvciBMZWdcbiAgICAgKiBAbWV0aG9kIHBhcnNlXG4gICAgICogQHBhcmFtIGRhdGEge29iamVjdH1cbiAgICAgKiBAcGFyYW0gZm1zIHtBaXJjcmFmdEZsaWdodE1hbmFnZW1lbnRTeXN0ZW19XG4gICAgICovXG4gICAgcGFyc2UoZGF0YSwgZm1zKSB7XG4gICAgICAgIC8vIFRPRE86IG1vdmUgcmFkYXIgdmVjdG9ycyB0byBjb25zdGFudHMgZmlsZVxuICAgICAgICB0aGlzLnJvdXRlID0gX2dldChkYXRhLCAncm91dGUnLCAnW3JhZGFyIHZlY3RvcnNdJyk7XG4gICAgICAgIHRoaXMudHlwZSA9IF9nZXQoZGF0YSwgJ3R5cGUnLCBGUF9MRUdfVFlQRS5NQU5VQUwpO1xuICAgICAgICB0aGlzLndheXBvaW50cyA9IF9nZXQoZGF0YSwgJ3dheXBvaW50cycsIFtdKTtcblxuICAgICAgICBpZiAodGhpcy53YXlwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlV2F5cG9pbnRzKGRhdGEsIGZtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIFdheXBvaW50IG9iamVjdHMgdG8gdGhpcyBMZWcgYmFzZWQgb24gdGhlIHJvdXRlIHR5cGVcbiAgICAgKlxuICAgICAqIEBmb3IgTGVnXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZVdheXBvaW50c1xuICAgICAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XG4gICAgICogQHBhcmFtIGZtcyB7QWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtfVxuICAgICAqL1xuICAgIGdlbmVyYXRlV2F5cG9pbnRzKGRhdGEsIGZtcykge1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZQX0xFR19UWVBFLlNJRDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGdyb3NzLiB3ZSBpbnN0YW50aWF0ZSByb3V0ZSB3aXRoIGEgc3RyaW5nIGFuZCBuZXcgbXV0YXRlIGl0IGhlcmUgdG8gYSBSb3V0ZU1vZGVsLlxuICAgICAgICAgICAgICAgIHRoaXMucm91dGUgPSBuZXcgUm91dGVNb2RlbChkYXRhLnJvdXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVdheXBvaW50c0ZvclNpZChkYXRhLCBmbXMpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZQX0xFR19UWVBFLlNUQVI6XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBncm9zcy4gd2UgaW5zdGFudGlhdGUgcm91dGUgd2l0aCBhIHN0cmluZyBhbmQgbmV3IG11dGF0ZSBpdCBoZXJlIHRvIGEgUm91dGVNb2RlbC5cbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlID0gbmV3IFJvdXRlTW9kZWwoZGF0YS5yb3V0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVXYXlwb2ludHNGb3JTdGFyKGRhdGEsIGZtcyk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuSUFQOlxuICAgICAgICAgICAgICAgIC8vIEZVVFVSRSBGVU5DVElPTkFMSVRZXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVXYXlwb2ludHNGb3JJYXAoZGF0YSwgYWlycG9ydCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRlBfTEVHX1RZUEUuQVdZOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgZ3Jvc3MuIHdlIGluc3RhbnRpYXRlIHJvdXRlIHdpdGggYSBzdHJpbmcgYW5kIG5ldyBtdXRhdGUgaXQgaGVyZSB0byBhIFJvdXRlTW9kZWwuXG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IG5ldyBSb3V0ZU1vZGVsKGRhdGEucm91dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlV2F5cG9pbnRzRm9yQWlyd2F5KGRhdGEsIGFpcnBvcnQpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZQX0xFR19UWVBFLkZJWDpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVdheXBvaW50Rm9yRml4KGFpcnBvcnQpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZQX0xFR19UWVBFLk1BTlVBTDpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hbnVhbFdheXBvaW50KGFpcnBvcnQpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlRW1wdHlXYXlwb2ludChhaXJwb3J0KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IFdheXBvaW50IHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFdheXBvaW50VG9MZWdcbiAgICAgKiBAcGFyYW0gd2F5cG9pbnRUb0FkZCB7V2F5cG9pbnR9XG4gICAgICovXG4gICAgYWRkV2F5cG9pbnRUb0xlZyh3YXlwb2ludFRvQWRkKSB7XG4gICAgICAgIGlmICghKHdheXBvaW50VG9BZGQgaW5zdGFuY2VvZiBXYXlwb2ludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyLCBleHBlY3RlIHdheXBvaW50VG9BZGQgdG8gYmUgYW4gaW5zdGFuY2VvZiB0aGUgV2F5cG9pbnQgY2xhc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2F5cG9pbnRzLnB1c2god2F5cG9pbnRUb0FkZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBMZWdcbiAgICAgKiBAbWV0aG9kIF9nZW5lcmF0ZVdheXBvaW50c0ZvclNpZFxuICAgICAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XG4gICAgICogQHBhcmFtIGZtcyB7QWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlV2F5cG9pbnRzRm9yU2lkKGRhdGEsIGZtcykge1xuICAgICAgICBpZiAoIWZtcykge1xuICAgICAgICAgICAgbG9nKCdBdHRlbXB0ZWQgdG8gZ2VuZXJhdGUgd2F5cG9pbnRzIGZvciBTSUQsIGJ1dCBjYW5ub3QgYmVjYXVzZSBmbXMgcmVmIG5vdCBwYXNzZWQhJywgTE9HLldBUk5JTkcpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZXNldFdheXBvaW50cygpO1xuXG4gICAgICAgIGNvbnN0IHJ3eSA9IGZtcy5teV9haXJjcmFmdC5yd3lfZGVwO1xuXG4gICAgICAgIGlmICghcnd5KSB7XG4gICAgICAgICAgICBjb25zdCBpc1dhcm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLnVpX2xvZyhcbiAgICAgICAgICAgICAgICBgJHtmbXMubXlfYWlyY3JhZnQuZ2V0Q2FsbHNpZ24oKX0gdW5hYmxlIHRvIGZseSBTSUQsIHdlIGhhdmVuJ3QgYmVlbiBhc3NpZ25lZCBhIGRlcGFydHVyZSBydW53YXkhYCxcbiAgICAgICAgICAgICAgICBpc1dhcm5pbmdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQodGhpcy5yb3V0ZS5lbnRyeSk7XG4gICAgICAgIGNvbnN0IHdheXBvaW50c0ZvclNpZCA9IGFpcnBvcnQuZmluZFdheXBvaW50TW9kZWxzRm9yU2lkKHRoaXMucm91dGUucHJvY2VkdXJlLCByd3ksIHRoaXMucm91dGUuZXhpdCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IvYWJzdHJhY3QgdGhpcyBib29sZWFuIGxvZ2ljXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcGxhY2Vob2xkZXIgbGVnIChpZiBwcmVzZW50KVxuICAgICAgICBpZiAoZm1zLm15X2FpcmNyYWZ0LmlzT25Hcm91bmQoKSAmJlxuICAgICAgICAgICAgZm1zLmxlZ3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgZm1zLmxlZ3NbMF0ucm91dGUgPT09IGFpcnBvcnQuaWNhbyAmJlxuICAgICAgICAgICAgcGFpcnMubGVuZ3RoID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIgbGVnLCB0byBiZSByZXBsYWNlZCBiZWxvdyB3aXRoIFNJRCBMZWdcbiAgICAgICAgICAgIGZtcy5sZWdzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F5cG9pbnRzRm9yU2lkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3YXlwb2ludFRvQWRkID0gd2F5cG9pbnRzRm9yU2lkW2ldLmdlbmVyYXRlRm1zV2F5cG9pbnQoYWlycG9ydCk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkV2F5cG9pbnRUb0xlZyh3YXlwb2ludFRvQWRkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy53YXlwb2ludHNbMF0uc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2F5cG9pbnRzWzBdLnNwZWVkID0gZm1zLm15X2FpcmNyYWZ0Lm1vZGVsLnNwZWVkLmNydWlzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTGVnXG4gICAgICogQG1ldGhvZCBfZ2VuZXJhdGVXYXlwb2ludHNGb3JTdGFyXG4gICAgICogQHBhcmFtIGRhdGEge29iamVjdH1cbiAgICAgKiBAcGFyYW0gZm1zIHtBaXJjcmFmdEZsaWdodE1hbmFnZW1lbnRTeXN0ZW19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVXYXlwb2ludHNGb3JTdGFyKGRhdGEsIGZtcykge1xuICAgICAgICBpZiAoIWZtcykge1xuICAgICAgICAgICAgbG9nKCdBdHRlbXB0ZWQgdG8gZ2VuZXJhdGUgd2F5cG9pbnRzIGZvciBTVEFSLCBidXQgY2Fubm90IGJlY2F1c2UgZm1zIHJlZiBub3QgcGFzc2VkIScsIExPRy5XQVJOSU5HKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVzZXRXYXlwb2ludHMoKTtcblxuICAgICAgICBjb25zdCByd3kgPSBmbXMubXlfYWlyY3JhZnQucnd5X2FycjtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCh0aGlzLnJvdXRlLmV4aXQpO1xuICAgICAgICBjb25zdCB3YXlwb2ludHNGb3JTdGFyID0gYWlycG9ydC5maW5kV2F5cG9pbnRNb2RlbHNGb3JTdGFyKHRoaXMucm91dGUucHJvY2VkdXJlLCB0aGlzLnJvdXRlLmVudHJ5LCByd3kpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F5cG9pbnRzRm9yU3Rhci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnRUb0FkZCA9IHdheXBvaW50c0ZvclN0YXJbaV0uZ2VuZXJhdGVGbXNXYXlwb2ludChhaXJwb3J0KTtcblxuICAgICAgICAgICAgdGhpcy5hZGRXYXlwb2ludFRvTGVnKHdheXBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLndheXBvaW50c1swXS5zcGVlZCkge1xuICAgICAgICAgICAgdGhpcy53YXlwb2ludHNbMF0uc3BlZWQgPSBmbXMubXlfYWlyY3JhZnQubW9kZWwuc3BlZWQuY3J1aXNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9UIElOIFVTRVxuICAgIF9nZW5lcmF0ZVdheXBvaW50c0ZvcklhcChkYXRhLCBhaXJwb3J0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOT1QgSU4gVVNFXG4gICAgLyoqXG4gICAgICogQGZvciBMZWdcbiAgICAgKiBAbWV0aG9kIF9nZW5lcmF0ZVdheXBvaW50c0ZvckFpcndheVxuICAgICAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XG4gICAgICogQHBhcmFtIGZtcyB7QWlyY3JhZnRGbGlnaHRNYW5hZ2VtZW50U3lzdGVtfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlV2F5cG9pbnRzRm9yQWlyd2F5KGRhdGEsIGFpcnBvcnQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnJvdXRlLnNwbGl0KCcuJylbMF07XG4gICAgICAgIGNvbnN0IGFpcndheSA9IHRoaXMucm91dGUuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5yb3V0ZS5zcGxpdCgnLicpWzJdO1xuICAgICAgICAvLyBWZXJpZnkgYWlyd2F5IGlzIHZhbGlkXG4gICAgICAgIGNvbnN0IGFwdCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgIGlmICghX2hhcyhhcHQsICdhaXJ3YXlzJykgfHwgIV9oYXMoYXB0LmFpcndheXMsICdhaXJ3YXknKSkge1xuICAgICAgICAgICAgbG9nKGBBaXJ3YXkgJHthaXJ3YXl9IG5vdCBkZWZpbmVkIGF0ICR7YXB0LmljYW99YCwgTE9HLldBUk5JTkcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHN0YXJ0L2VuZCBwb2ludHMgYXJlIGFsb25nIGFpcndheVxuICAgICAgICBjb25zdCBhd3kgPSBhcHQuYWlyd2F5c1thaXJ3YXldO1xuICAgICAgICBpZiAoIShhd3kuaW5kZXhPZihzdGFydCkgIT09IC0xICYmIGF3eS5pbmRleE9mKGVuZCkgIT09IC0xKSkge1xuICAgICAgICAgICAgbG9nKGBVbmFibGUgdG8gZm9sbG93ICR7YWlyd2F5fSBmcm9tICR7c3RhcnR9IHRvICR7ZW5kfWAsIExPRy5XQVJOSU5HKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFic3RyYWN0IHRoaXMgbG9naWNcbiAgICAgICAgLy8gQnVpbGQgbGlzdCBvZiBmaXhlcywgZGVwZW5kaW5nIG9uIGRpcmVjdGlvbiB0cmF2ZWxpbmcgYWxvbmcgYWlyd2F5XG4gICAgICAgIGNvbnN0IGZpeGVzID0gW107XG4gICAgICAgIGNvbnN0IHJlYWRGd2QgPSAoYXd5LmluZGV4T2YoZW5kKSA+IGF3eS5pbmRleE9mKHN0YXJ0KSk7XG5cbiAgICAgICAgaWYgKHJlYWRGd2QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGYgPSBhd3kuaW5kZXhPZihzdGFydCk7IGYgPD0gYXd5LmluZGV4T2YoZW5kKTsgZisrKSB7XG4gICAgICAgICAgICAgICAgZml4ZXMucHVzaChhd3lbZl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IGF3eS5pbmRleE9mKHN0YXJ0KTsgZiA+PSBhd3kuaW5kZXhPZihlbmQpOyBmLS0pIHtcbiAgICAgICAgICAgICAgICBmaXhlcy5wdXNoKGF3eVtmXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZXNldFdheXBvaW50cygpO1xuXG4gICAgICAgIF9mb3JFYWNoKGZpeGVzLCAoZml4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YXlwb2ludFRvQWRkID0gbmV3IFdheXBvaW50KHsgZml4IH0sIGFpcnBvcnQpO1xuXG4gICAgICAgICAgICB0aGlzLmFkZFdheXBvaW50VG9MZWcod2F5cG9pbnRUb0FkZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgTGVnXG4gICAgICogQG1ldGhvZCBfZ2VuZXJhdGVXYXlwb2ludEZvckZpeFxuICAgICAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0SW5zdGFuY2VNb2RlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZVdheXBvaW50Rm9yRml4KGFpcnBvcnQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRXYXlwb2ludHMoKTtcblxuICAgICAgICBjb25zdCB3YXlwb2ludFRvQWRkID0gbmV3IFdheXBvaW50KHsgZml4OiB0aGlzLnJvdXRlIH0sIGFpcnBvcnQpO1xuXG4gICAgICAgIHRoaXMuYWRkV2F5cG9pbnRUb0xlZyh3YXlwb2ludFRvQWRkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIExlZ1xuICAgICAqIEBtZXRob2QgX2dlbmVyYXRlTWFudWFsV2F5cG9pbnRcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVNYW51YWxXYXlwb2ludChhaXJwb3J0KSB7XG4gICAgICAgIGNvbnN0IHdheXBvaW50VG9BZGQgPSBuZXcgV2F5cG9pbnQoeyByb3V0ZTogdGhpcy5yb3V0ZSB9LCBhaXJwb3J0KTtcblxuICAgICAgICB0aGlzLmFkZFdheXBvaW50VG9MZWcod2F5cG9pbnRUb0FkZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBMZWdcbiAgICAgKiBAbWV0aG9kIF9nZW5lcmF0ZUVtcHR5V2F5cG9pbnRcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVFbXB0eVdheXBvaW50KGFpcnBvcnQpIHtcbiAgICAgICAgY29uc3Qgd2F5cG9pbnRUb0FkZCA9IG5ldyBXYXlwb2ludCh7IHJvdXRlOiAnJyB9LCBhaXJwb3J0KTtcblxuICAgICAgICB0aGlzLmFkZFdheXBvaW50VG9MZWcod2F5cG9pbnRUb0FkZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHdheXBvaW50IHByb3BlcnR5IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYSBzaW5nbGUgbWV0aG9kIHRoYXQgZW5jYXBzdWxhdGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IHRoYXRcbiAgICAgKiBjYW4gYmUgdXNlZCB0aHJvdWdob3V0IHRoZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBmb3IgTGVnXG4gICAgICogQG1ldGhvZCBfcmVzZXRXYXlwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFdheXBvaW50cygpIHtcbiAgICAgICAgdGhpcy53YXlwb2ludHMgPSBbXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGVhZCBmcm9tICdsb2Rhc2gvaGVhZCc7XG5pbXBvcnQgX2lzTmlsIGZyb20gJ2xvZGFzaC9pc05pbCc7XG5pbXBvcnQgRml4Q29sbGVjdGlvbiBmcm9tICcuLi8uLi9haXJwb3J0L0ZpeC9GaXhDb2xsZWN0aW9uJztcbmltcG9ydCB7IFdBWVBPSU5UX05BVl9NT0RFIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2FpcmNyYWZ0Q29uc3RhbnRzJztcblxuLyoqXG4gKiBTeW1ib2wgZGVub3RpbmcgYSBncmVhdGVyIHRoYW4gcmVzdHJpY3Rpb25cbiAqXG4gKiBAcHJvcGVydHkgQUJPVkVfU1lNQk9MXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IEFCT1ZFX1NZTUJPTCA9ICcrJztcblxuLyoqXG4gKiBTeW1ib2wgZGVub3RpbmcgYSBsZXNzIHRoYW4gcmVzdHJpY3Rpb25cbiAqXG4gKiBAcHJvcGVydHkgQUJPVkVfU1lNQk9MXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IEJFTE9XX1NZTUJPTCA9ICctJztcblxuLy8gVE9ETzogdGhlcmUgc2hvdWxkIGJlIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0aGlzXG4vKipcbiAqIE51bWJlciB0byB1c2VkIHRvIGNub3ZlcnQgYSBGTCBhbHRpdHVkZSB0byBhbiBhbHRpdHVkZSBpbiB0aG91c2FuZHNcbiAqXG4gKiBAcHJvcGVydHkgQUJPVkVfU1lNQk9MXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IEZMX1RPX1RIT1VTQU5EU19NVUxUSVBMSUVSID0gMTAwO1xuXG4vKipcbiAqIEVuZW11cmF0aW9uIGZvciBhbiBpbnZhbGlkIGluZGV4IG51bWJlci5cbiAqXG4gKiBAcHJvcGVydHkgSU5WQUxJRF9JTkRFWFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBJTlZBTElEX0lOREVYID0gLTE7XG5cbi8qKlxuICogRW51bWVyYXRpb24gZm9yIHRoZSByYWRpeCB2YWx1ZSBvZiBgcGFyc2VJbnRgXG4gKlxuICogQHByb2VwcnR5IERFQ0lNQUxfUkFESVhcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgREVDSU1BTF9SQURJWCA9IDEwO1xuXG4vKipcbiAgKiBCdWlsZCBhIHdheXBvaW50IG9iamVjdFxuICAqXG4gICogTm90ZSB0aGF0IC5wcmVwZW5kTGVnKCkgb3IgLmFwcGVuZExlZygpIG9yIC5pbnNlcnRMZWcoKVxuICAqIHNob3VsZCBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gYWRkIHdheXBvaW50cyB0byB0aGUgZm1zLCBiYXNlZCBvbiB3aGljaFxuICAqIHlvdSB3YW50LiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyBvbmx5IHRvIGJ1aWxkIHRoZSB3YXlwb2ludCBvYmplY3Q7IGl0IGlzXG4gICogcGxhY2VkIGJ5IG9uZSBvZiB0aGUgb3RoZXIgdGhyZWUgZnVuY3Rpb25zLlxuICAqXG4gICogQGNsYXNzIFdheXBvaW50XG4gICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXlwb2ludCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBXYXlwb2ludCB3aXRoIGVtcHR5IHZhbHVlcywgdGhlbiBjYWxsIHRoZSBwYXJzZXJcbiAgICAgKlxuICAgICAqIEBmb3IgV2F5cG9pbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhID0ge30sIGFpcnBvcnQpIHtcbiAgICAgICAgdGhpcy5hbHRpdHVkZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYXZtb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy50dXJuID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwZWRpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ob2xkID0ge1xuICAgICAgICAgICAgZGlyVHVybnM6IG51bGwsXG4gICAgICAgICAgICBmaXhOYW1lOiBudWxsLFxuICAgICAgICAgICAgZml4UG9zOiBudWxsLFxuICAgICAgICAgICAgaW5ib3VuZEhkOiBudWxsLFxuICAgICAgICAgICAgbGVnTGVuZ3RoOiBudWxsLFxuICAgICAgICAgICAgdGltZXI6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmZpeFJlc3RyaWN0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCxcbiAgICAgICAgICAgIHNwZDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucm91dGUgPSAnJztcblxuICAgICAgICB0aGlzLnBhcnNlKGRhdGEsIGFpcnBvcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGlucHV0IGRhdGEgYW5kIGFwcGx5IHRvIHRoaXMgd2F5cG9pbnRcbiAgICAgKlxuICAgICAqIEBmb3IgV2F5cG9pbnRcbiAgICAgKiBAbWV0aG9kIHBhcnNlXG4gICAgICogQHBhcmFtIGRhdGEge29iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZShkYXRhLCBhaXJwb3J0KSB7XG4gICAgICAgIC8vIFRPRE86IGlzIHRoaXMgdXNlZD9cbiAgICAgICAgdGhpcy5yb3V0ZSA9IF9nZXQoZGF0YSwgJ3JvdXRlJywgdGhpcy5yb3V0ZSk7XG4gICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBfZ2V0KGRhdGEsICdhbHRpdHVkZScsIHRoaXMuYWx0aXR1ZGUpO1xuICAgICAgICB0aGlzLm5hdm1vZGUgPSBfZ2V0KGRhdGEsICduYXZtb2RlJywgdGhpcy5uYXZtb2RlKTtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gX2dldChkYXRhLCAnaGVhZGluZycsIHRoaXMuaGVhZGluZyk7XG4gICAgICAgIHRoaXMudHVybiA9IF9nZXQoZGF0YSwgJ3R1cm4nLCB0aGlzLnR1cm4pO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gX2dldChkYXRhLCAnbG9jYXRpb24nLCB0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5leHBlZGl0ZSA9IF9nZXQoZGF0YSwgJ2V4cGVkaXRlJywgdGhpcy5leHBlZGl0ZSk7XG4gICAgICAgIHRoaXMuc3BlZWQgPSBfZ2V0KGRhdGEsICdzcGVlZCcsIHRoaXMuc3BlZWQpO1xuICAgICAgICB0aGlzLmhvbGQgPSBfZ2V0KGRhdGEsICdob2xkJywgdGhpcy5ob2xkKTtcblxuXG4gICAgICAgIC8vIFBvcHVsYXRlIFdheXBvaW50IHdpdGggZGF0YVxuICAgICAgICBpZiAoZGF0YS5maXgpIHtcbiAgICAgICAgICAgIHRoaXMubmF2bW9kZSA9IFdBWVBPSU5UX05BVl9NT0RFLkZJWDtcbiAgICAgICAgICAgIHRoaXMuZml4ID0gZGF0YS5maXg7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gRml4Q29sbGVjdGlvbi5nZXRGaXhQb3NpdGlvbkNvb3JkaW5hdGVzKGRhdGEuZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXh0cmFjdEZpeFJlc3RyaWN0aW9ucyhkYXRhKTtcbiAgICAgICAgdGhpcy5zZXRJbml0aWFsTmF2TW9kZShhaXJwb3J0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFdheXBvaW50XG4gICAgICogQG1ldGhvZCBleHRyYWN0Rml4UmVzdHJpY3Rpb25zXG4gICAgICogQHBhcmFtIGZpeFJlc3RyaWN0aW9ucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGV4dHJhY3RGaXhSZXN0cmljdGlvbnMoeyBmaXhSZXN0cmljdGlvbnMgfSkge1xuICAgICAgICBpZiAoX2lzTmlsKGZpeFJlc3RyaWN0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZml4UmVzdHJpY3Rpb25zID0gZml4UmVzdHJpY3Rpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzbid0IGEgbmF2bW9kZSBzZXQsIHNldCBvbmUgaGVyZVxuICAgICAqXG4gICAgICogRm9yIGFpcmNyYWZ0IHRoYXQgZG9uJ3QgeWV0IGhhdmUgcHJvcGVyIGd1aWRhbmNlIChlZzogU0lEL1NUQVIsIG9yIGRlcGFydGluZyBhaXJjcmFmdClcbiAgICAgKlxuICAgICAqIEBmb3IgV2F5cG9pbnRcbiAgICAgKiBAbWV0aG9kIHNldEluaXRpYWxOYXZNb2RlXG4gICAgICovXG4gICAgc2V0SW5pdGlhbE5hdk1vZGUoYWlycG9ydCkge1xuICAgICAgICBpZiAodGhpcy5uYXZtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdm1vZGUgPSBXQVlQT0lOVF9OQVZfTU9ERS5IRUFESU5HO1xuICAgICAgICBjb25zdCBmaXJzdFJvdXRlU2VnbWVudCA9IF9oZWFkKHRoaXMucm91dGUuc3BsaXQoJy4nKSk7XG5cbiAgICAgICAgaWYgKGZpcnN0Um91dGVTZWdtZW50ID09PSBhaXJwb3J0LmljYW8gJiYgdGhpcy5oZWFkaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhaW0gZGVwYXJ0dXJlIGFsb25nIHJ1bndheSBoZWFkaW5nXG4gICAgICAgICAgICBjb25zdCB7IGFuZ2xlIH0gPSBhaXJwb3J0LmdldFJ1bndheShhaXJwb3J0LnJ1bndheSk7XG5cbiAgICAgICAgICAgIHRoaXMuaGVhZGluZyA9IGFuZ2xlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Um91dGVTZWdtZW50ID09PSAnVU5BU1NJR05FRCcgJiYgdGhpcy5oZWFkaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogcmFkaWFsIGlzIG5vdCBkZWZpbmVkIG9yIHNldCBhbnl3aGVyZSBpbiB0aGlzIGNsYXNzLiB0aGlzIGJsb2NrIERPRVMgZ2V0IGhpdCBmb3JcbiAgICAgICAgICAgIC8vIGV2ZXJ5IGFycml2aW5nIGFpcmNyYWZ0XG5cbiAgICAgICAgICAgIC8vIGFpbSBhcnJpdmFsIEAgbWlkZGxlIG9mIGFpcnNwYWNlXG4gICAgICAgICAgICB0aGlzLmhlYWRpbmcgPSB0aGlzLnJhZGlhbCArIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW5hbWUgY2VudGVyQ2VpbGluZyBhbmQgbWFrZSB0aGlzIG1ldGhvZCBtb3JlIGZsZXhpYmxlXG4gICAgLy8gVE9ETzogdXNlIGEgZGVmYXVsdCBjb25zdGFudCBmb3IgY3J1aXNlQWx0aXR1ZGVcbiAgICAvKipcbiAgICAgKiBAZm9yIFdheXBvaW50XG4gICAgICogQG1ldGhvZCBzZXRBbHRpdHVkZVxuICAgICAqIEBwYXJhbSBjZW50ZXJDZWlsaW5nIHtudW1iZXJ9ICBjZWlsaW5nIG9mIHRoZSBhaXJzcGFjZSBpbiBmZWV0XG4gICAgICogQHBhcmFtIGNydWlzZUFsdGl0dWRlIHtudW1iZXJ9IGNydWlzZUFsdGl0dWRlIG9mIHRoZSBjdXJyZW50IGFpcmNyYWZ0XG4gICAgICovXG4gICAgc2V0QWx0aXR1ZGUoY2VudGVyQ2VpbGluZyA9IG51bGwsIGNydWlzZUFsdGl0dWRlKSB7XG4gICAgICAgIGNvbnN0IHsgYWx0OiBhbHRpdHVkZVJlc3RyaWN0aW9uIH0gPSB0aGlzLmZpeFJlc3RyaWN0aW9ucztcblxuICAgICAgICBpZiAoIWFsdGl0dWRlUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWx0aXR1ZGUgPSAhX2lzTmlsKGNlbnRlckNlaWxpbmcpXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1pbihjZW50ZXJDZWlsaW5nLCBjcnVpc2VBbHRpdHVkZSlcbiAgICAgICAgICAgICAgICA6IGNydWlzZUFsdGl0dWRlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGVyZSBoYXMgdG8gYmUgYW4gZWFzaWVyIHdheSB0byBkbyB0aGlzIGxvZ2ljLlxuICAgICAgICBpZiAoYWx0aXR1ZGVSZXN0cmljdGlvbi5pbmRleE9mKEFCT1ZFX1NZTUJPTCkgIT09IElOVkFMSURfSU5ERVgpIHtcbiAgICAgICAgICAgIC8vIGF0LW9yLWFib3ZlIGFsdGl0dWRlUmVzdHJpY3Rpb24gcmVzdHJpY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IG1pbkFsdCA9IHBhcnNlSW50KGFsdGl0dWRlUmVzdHJpY3Rpb24ucmVwbGFjZShBQk9WRV9TWU1CT0wsICcnKSwgREVDSU1BTF9SQURJWCk7XG4gICAgICAgICAgICBjb25zdCBtaW5pbXVtQWx0aXR1ZGVXaXRob3V0U3ltYm9sID0gbWluQWx0ICogRkxfVE9fVEhPVVNBTkRTX01VTFRJUExJRVI7XG5cbiAgICAgICAgICAgIC8vIG5vdCBhIGZhbiBvZiB0aGlzIHRlcm5hcnksIGJ1dCBJIGRvbid0IHRoaW5rIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byBkbyBpdFxuICAgICAgICAgICAgdGhpcy5hbHRpdHVkZSA9IG1pbmltdW1BbHRpdHVkZVdpdGhvdXRTeW1ib2wgPiBjcnVpc2VBbHRpdHVkZVxuICAgICAgICAgICAgICAgID8gbWluaW11bUFsdGl0dWRlV2l0aG91dFN5bWJvbFxuICAgICAgICAgICAgICAgIDogY3J1aXNlQWx0aXR1ZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoYWx0aXR1ZGVSZXN0cmljdGlvbi5pbmRleE9mKEJFTE9XX1NZTUJPTCkgIT09IElOVkFMSURfSU5ERVgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heEFsdCA9IHBhcnNlSW50KGFsdGl0dWRlUmVzdHJpY3Rpb24ucmVwbGFjZShCRUxPV19TWU1CT0wsICcnKSwgREVDSU1BTF9SQURJWCk7XG4gICAgICAgICAgICBjb25zdCBtYXhpbXVtQWx0aXR1ZGVXaXRob3V0U3ltYm9sID0gbWF4QWx0ICogRkxfVE9fVEhPVVNBTkRTX01VTFRJUExJRVI7XG5cbiAgICAgICAgICAgIC8vIGNsaW1iIGFzIGhpZ2ggYXMgcmVzdHJpY3Rpb25zIHBlcm1pdFxuICAgICAgICAgICAgdGhpcy5hbHRpdHVkZSA9IE1hdGgubWluKG1heGltdW1BbHRpdHVkZVdpdGhvdXRTeW1ib2wsIGNydWlzZUFsdGl0dWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAvLyBjcm9zcyBBVCB0aGlzIGFsdGl0dWRlUmVzdHJpY3Rpb25cbiAgICAgICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBwYXJzZUludChhbHRpdHVkZVJlc3RyaWN0aW9uLCBERUNJTUFMX1JBRElYKSAqIEZMX1RPX1RIT1VTQU5EU19NVUxUSVBMSUVSO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBXYXlwb2ludFxuICAgICAqIEBtZXRob2Qgc2V0U3BlZWRcbiAgICAgKiBAcGFyYW0gY3J1aXNlU3BlZWQge251bWJlcn0gIGNydWlzZVNwZWVkIG9mIHRoZSBjdXJyZW50IGFpcmNyYWZ0XG4gICAgICovXG4gICAgc2V0U3BlZWQoY3J1aXNlU3BlZWQpIHtcbiAgICAgICAgY29uc3QgeyBzcGQ6IHNwZWVkUmVzdHJpY3Rpb24gfSA9IHRoaXMuZml4UmVzdHJpY3Rpb25zO1xuXG4gICAgICAgIGlmICghc3BlZWRSZXN0cmljdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGNydWlzZVNwZWVkO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGVyZSBoYXMgdG8gYmUgYW4gZWFzaWVyIHdheSB0byBkbyB0aGlzIGxvZ2ljLlxuICAgICAgICBpZiAoc3BlZWRSZXN0cmljdGlvbi5pbmRleE9mKEFCT1ZFX1NZTUJPTCkgIT09IElOVkFMSURfSU5ERVgpIHtcbiAgICAgICAgICAgIC8vIGF0LW9yLWFib3ZlIHNwZWVkIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBjb25zdCBtaW5TcGQgPSBwYXJzZUludChzcGVlZFJlc3RyaWN0aW9uLnJlcGxhY2UoQUJPVkVfU1lNQk9MLCAnJyksIERFQ0lNQUxfUkFESVgpO1xuXG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gbWluU3BkID4gY3J1aXNlU3BlZWRcbiAgICAgICAgICAgICAgICA/IG1pblNwZFxuICAgICAgICAgICAgICAgIDogY3J1aXNlU3BlZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc3BlZWRSZXN0cmljdGlvbi5pbmRleE9mKEJFTE9XX1NZTUJPTCkgIT09IElOVkFMSURfSU5ERVgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heFNwZCA9IHBhcnNlSW50KHNwZWVkUmVzdHJpY3Rpb24ucmVwbGFjZShCRUxPV19TWU1CT0wsICcnKSwgREVDSU1BTF9SQURJWCk7XG5cbiAgICAgICAgICAgIC8vIGdvIGFzIGZhc3QgYXMgcmVzdHJpY3Rpb25zIHBlcm1pdFxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IE1hdGgubWluKG1heFNwZCwgY3J1aXNlU3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIC8vIGNyb3NzIEFUIHRoaXMgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBwYXJzZUludChzcGVlZFJlc3RyaWN0aW9uLCBERUNJTUFMX1JBRElYKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IEFpcmxpbmUgZnJvbSAnLi9BaXJsaW5lTW9kZWwnO1xuXG4vLyBUZW1wb3JhcnkgY29uc3QgZGVjbGFyYXRpb24gaGVyZSB0byBhdHRhY2ggdG8gdGhlIHdpbmRvdyBBTkQgdXNlIGFzIGludGVybmFsIHByb3BlcnR5XG5jb25zdCBhaXJsaW5lID0ge307XG5cbi8qKlxuICogQGNsYXNzIEFpcmxpbmVDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpcmxpbmVDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5haXJsaW5lID0gYWlybGluZTtcbiAgICAgICAgdGhpcy5haXJsaW5lLmFpcmxpbmVzID0ge307XG4gICAgICAgIHByb3AuYWlybGluZSA9IGFpcmxpbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJsaW5lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYWlybGluZV9nZXRcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqIHJldHVybiB7QWlybGluZU1vZGVsfG51bGx9XG4gICAgICovXG4gICAgYWlybGluZV9nZXQoaWNhbykge1xuICAgICAgICBpY2FvID0gaWNhby50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghX2hhcyh0aGlzLmFpcmxpbmUuYWlybGluZXMsIGljYW8pKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFpcmxpbmUoaWNhbyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5haXJsaW5lLmFpcmxpbmVzW2ljYW9dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgYWlybGluZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFkZEFpcmxpbmVcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFkZEFpcmxpbmUoaWNhbykge1xuICAgICAgICBjb25zdCBhaXJsaW5lVG9BZGQgPSBuZXcgQWlybGluZShcbiAgICAgICAgICAgIGljYW8sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXJsOiBgYXNzZXRzL2FpcmxpbmVzLyR7aWNhb30uanNvbmBcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmFpcmxpbmUuYWlybGluZXNbaWNhb10gPSBhaXJsaW5lVG9BZGQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IF9nZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgX2hhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgeyBjaG9vc2UsIGNob29zZV93ZWlnaHQgfSBmcm9tICcuLi91dGlsaXRpZXMvZ2VuZXJhbFV0aWxpdGllcyc7XG5cbi8qKlxuICogQW4gYWlyY3JjcmFmdCBvcGVyYXRpbmcgYWdlbmN5XG4gKlxuICogQGNsYXNzIEFpcmxpbmVNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBaXJsaW5lTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXcgYWlybGluZVxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGZvciBBaXJsaW5lTW9kZWxcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWNhbywgb3B0aW9ucykge1xuICAgICAgICAvLyBJQ0FPIGFpcmxpbmUgZGVzaWduYXRpb25cbiAgICAgICAgdGhpcy5pY2FvID0gaWNhbztcbiAgICAgICAgLy8gQWdlbmN5IG5hbWVcbiAgICAgICAgdGhpcy5uYW1lID0gX2dldChvcHRpb25zLCAnbmFtZScsICdEZWZhdWx0IGFpcmxpbmUnKTtcbiAgICAgICAgLy8gUmFkaW8gY2FsbHNpZ25cbiAgICAgICAgdGhpcy5jYWxsc2lnbiA9ICdEZWZhdWx0JztcbiAgICAgICAgLy8gUGFyYW1ldGVycyBmb3IgZmxpZ2h0IG51bWJlciBnZW5lcmF0aW9uXG4gICAgICAgIHRoaXMuZmxpZ2h0TnVtYmVyR2VuZXJhdGlvbiA9IHtcbiAgICAgICAgICAgIC8vIEhvdyBtYW55IGNoYXJhY3RlcnMgaW4gdGhlIGZsaWdodCBudW1iZXJcbiAgICAgICAgICAgIGxlbmd0aDogMyxcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBhbHBoYTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBOYW1lZCB3ZWlnaHRlZCBzZXRzIG9mIGFpcmNyYWZ0XG4gICAgICAgIHRoaXMuZmxlZXRzID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogW11cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByaW9yaXR5TG9hZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWlyY3JhZnQgPSBbXTtcblxuICAgICAgICB0aGlzLnBhcnNlKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKG9wdGlvbnMudXJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb2JqZWN0IGZyb20gZGF0YVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdHdpY2UgYXQgbWluaW11bTsgb25jZSBvbiBpbnN0YW50aWF0aW9uIGFuZCBhZ2FpbiBvbmNlXG4gICAgICogYG9uTG9hZFN1Y2Nlc3NgLiBNb3N0IG9mIHRoZSBwcm9wZXJ0aWVzIGJlbG93IHdpbGwgb25seSBiZSBhdmFpbGFibGUgYG9uTG9hZFN1Y2Nlc3NgXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgcGFyc2VcbiAgICAgKiBAcGFyYW0gZGF0YSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pY2FvID0gX2dldChkYXRhLCAnaWNhbycsIHRoaXMuaWNhbyk7XG5cbiAgICAgICAgaWYgKGRhdGEuY2FsbHNpZ24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbHNpZ24gPSBkYXRhLmNhbGxzaWduLm5hbWU7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNhbGxzaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpZ2h0TnVtYmVyR2VuZXJhdGlvbi5sZW5ndGggPSBkYXRhLmNhbGxzaWduLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mbGlnaHROdW1iZXJHZW5lcmF0aW9uLmFscGhhID0gX2hhcyhkYXRhLCAnY2FsbHNpZ24uYWxwaGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmZsZWV0cykge1xuICAgICAgICAgICAgdGhpcy5mbGVldHMgPSBkYXRhLmZsZWV0cztcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmFpcmNyYWZ0KSB7XG4gICAgICAgICAgICB0aGlzLmZsZWV0cy5kZWZhdWx0ID0gZGF0YS5haXJjcmFmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9mb3JFYWNoKHRoaXMuZmxlZXRzLCAoZmxlZXQpID0+IHtcbiAgICAgICAgICAgIF9mb3JFYWNoKGZsZWV0LCAoYWlyY3JhZnRJbkZsZWV0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgTkFNRV9JTkRFWCA9IDA7XG4gICAgICAgICAgICAgICAgYWlyY3JhZnRJbkZsZWV0W05BTUVfSU5ERVhdID0gYWlyY3JhZnRJbkZsZWV0W05BTUVfSU5ERVhdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgZGF0YSBmb3IgdGhpcyBhaXJsaW5lXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2FkKHVybCkge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG5cbiAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB6bHNhLmF0Yy5sb2FkQXNzZXQoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBpbW1lZGlhdGU6IHRoaXMucHJpb3JpdHlMb2FkXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4gdGhpcy5vbkxvYWRTdWNjZXNzKHJlc3BvbnNlKSlcbiAgICAgICAgLmZhaWwoKC4uLmFyZ3MpID0+IHRoaXMub25Mb2FkRXJyb3IoLi4uYXJncykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlybGluZU1vZGVsXG4gICAgICogQG1ldGhvZCBvbkxvYWRTdWNjZXNzXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIHtvYmplY3R9XG4gICAgICovXG4gICAgb25Mb2FkU3VjY2VzcyhyZXNwb25zZSkge1xuICAgICAgICB0aGlzLnBhcnNlKHJlc3BvbnNlKTtcblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMudmFsaWRhdGVGbGVldHMoKTtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVQZW5kaW5nQWlyY3JhZnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2Qgb25Mb2FkRXJyb3JcbiAgICAgKiBAcGFyYW0gdGV4dFN0YXR1cyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG9uTG9hZEVycm9yKHsgdGV4dFN0YXR1cyB9KSB7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWlyY3JhZnQgPSBbXTtcblxuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gbG9hZCBhaXJsaW5lLyR7dGhpcy5pY2FvfTogJHt0ZXh0U3RhdHVzfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJhbmRvbSBJQ0FPIGFpcmNyYWZ0IGRlc2lnbmF0b3IgZnJvbSB0aGUgZ2l2ZW4gZmxlZXRcbiAgICAgKlxuICAgICAqIElmIG5vIGZsZWV0IGlzIHNwZWNpZmllZCB0aGUgZGVmYXVsdCBmbGVldCBpcyB1c2VkXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgY2hvb3NlQWlyY3JhZnRcbiAgICAgKiBAcGFyYW0gZmxlZXRcbiAgICAgKiBAcmV0dXJuXG4gICAgICovXG4gICAgY2hvb3NlQWlyY3JhZnQoZmxlZXQpIHtcbiAgICAgICAgaWYgKCFmbGVldCkge1xuICAgICAgICAgICAgZmxlZXQgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBhIHRyeS9jYXRjaD9cbiAgICAgICAgLy8gVE9ETzogdGhpcyB0cnkvY2F0Y2ggYmxvY2sgY291bGQgYmUgaW1wcm92ZWQuIGl0cyBoYXJkIHRvIHRlbGwgd2hhdCBoaXMgYmxvY2sgaXMgYWN0dWFsbHkgZG9pbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY2hvb3NlX3dlaWdodCh0aGlzLmZsZWV0c1tmbGVldC50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVW5hYmxlIHRvIGZpbmQgZmxlZXQgJHtmbGVldH0gZm9yIGFpcmxpbmUgJHt0aGlzLmljYW99YCk7XG5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFpcmNyYWZ0XG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVBaXJjcmFmdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICogQHJldHVyblxuICAgICAqL1xuICAgIGdlbmVyYXRlQWlyY3JhZnQob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0FpcmNyYWZ0LnB1c2gob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJpb3JpdHlMb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHpsc2EuYXRjLmxvYWRBc3NldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5TG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIHNwYXduIGFpcmNyYWZ0IGZvciBhaXJsaW5lLyAke3RoaXMuaWNhb30gYXMgbG9hZGluZyBmYWlsZWRgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlQWlyY3JhZnQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhlIGxvZ2ljIGhlcmUgY2FuIGJlIHNpbXBsaWZpZWQuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZmxpZ2h0IG51bWJlci9pZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVGbGlnaHROdW1iZXJcbiAgICAgKiBAcmV0dXJuIGZsaWdodE51bWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdlbmVyYXRlRmxpZ2h0TnVtYmVyKCkge1xuICAgICAgICBsZXQgZmxpZ2h0TnVtYmVyID0gJyc7XG4gICAgICAgIGxldCBsaXN0ID0gJzAxMjM0NTY3ODknO1xuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1iZXIgb3RoZXIgdGhhbiB6ZXJvXG4gICAgICAgIGZsaWdodE51bWJlciArPSBjaG9vc2UobGlzdC5zdWJzdHIoMSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmZsaWdodE51bWJlckdlbmVyYXRpb24uYWxwaGEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdoeSBgdGhpcy5mbGlnaHROdW1iZXJHZW5lcmF0aW9uLmxlbmd0aCAtIDNgPyAgZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXIuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmxpZ2h0TnVtYmVyR2VuZXJhdGlvbi5sZW5ndGggLSAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbGlnaHROdW1iZXIgKz0gY2hvb3NlKGxpc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbGlnaHROdW1iZXIgKz0gY2hvb3NlKGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmZsaWdodE51bWJlckdlbmVyYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbGlnaHROdW1iZXIgKz0gY2hvb3NlKGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBmbGlnaHROdW1iZXIgYWxyZWFkeSBleGlzdHMsIHJlcGVhdCB0aGUgcHJvY2VzcyBvZiBnZW5lcmF0aW5nIGEgbmV3IGZsaWdodE51bWJlclxuICAgICAgICBpZiAod2luZG93LmFpcmNyYWZ0Q29udHJvbGxlci5pc0NhbGxzaWduSW5MaXN0KGZsaWdodE51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRmxpZ2h0TnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxpZ2h0TnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBhbGwgZmxlZXRzIGZvciB2YWxpZCBhaXJjcmFmdCBpZGVudGlmaWVycyBhbmQgbG9nIGVycm9yc1xuICAgICAqXG4gICAgICogQGZvciBBaXJsaW5lTW9kZWxcbiAgICAgKiBAbWV0aG9kIHZhbGlkYXRlRmxlZXRzXG4gICAgICovXG4gICAgdmFsaWRhdGVGbGVldHMoKSB7XG4gICAgICAgIF9mb3JFYWNoKHRoaXMuZmxlZXRzLCAoZmxlZXQpID0+IHtcbiAgICAgICAgICAgIF9mb3JFYWNoKGZsZWV0LCAoZmxlZXRBaXJjcmFmdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IE5BTUVfSU5ERVggPSAwO1xuICAgICAgICAgICAgICAgIC8vIFByZWxvYWQgdGhlIGFpcmNyYWZ0IG1vZGVsXG4gICAgICAgICAgICAgICAgd2luZG93LmFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdF9tb2RlbF9nZXQoZmxlZXRBaXJjcmFmdFtOQU1FX0lOREVYXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsZWV0QWlyY3JhZnRbMV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWlybGluZSAke3RoaXMuaWNhby50b1VwcGVyQ2FzZSgpfSB1c2VzIG5vbiBudW1lcmljIHdlaWdodCBmb3IgYWlyY3JhZnQgJHtmbGVldEFpcmNyYWZ0W05BTUVfSU5ERVhdfSwgZXhwZWN0IGVycm9yc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhaXJjcmFmdCB3aGljaCB3ZXJlIHF1ZXVlZCB3aGlsZSB0aGUgbW9kZWwgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcmxpbmVNb2RlbFxuICAgICAqIEBtZXRob2QgX2dlbmVyYXRlUGVuZGluZ0FpcmNyYWZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVQZW5kaW5nQWlyY3JhZnQoKSB7XG4gICAgICAgIF9mb3JFYWNoKHRoaXMuX3BlbmRpbmdBaXJjcmFmdCwgKGFpcmNyYWZ0T3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVBaXJjcmFmdChhaXJjcmFmdE9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nQWlyY3JhZnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlybGluZU1vZGVsXG4gICAgICogQG1ldGhvZCBfZ2VuZXJhdGVBaXJjcmFmdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgX2dlbmVyYXRlQWlyY3JhZnQob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuY2FsbHNpZ24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbHNpZ24gPSB0aGlzLmdlbmVyYXRlRmxpZ2h0TnVtYmVyKCk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5haXJjcmFmdENvbnRyb2xsZXIuYWRkQ2FsbHNpZ25Ub0xpc3Qob3B0aW9ucy5jYWxsc2lnbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuaWNhbykge1xuICAgICAgICAgICAgb3B0aW9ucy5pY2FvID0gdGhpcy5jaG9vc2VBaXJjcmFmdChvcHRpb25zLmZsZWV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gd2luZG93LmFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdF9tb2RlbF9nZXQob3B0aW9ucy5pY2FvLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbC5nZW5lcmF0ZUFpcmNyYWZ0KG9wdGlvbnMpO1xuICAgIH1cbn1cbiIsImltcG9ydCBfaXNBcnJheSBmcm9tICdsb2Rhc2gvaXNBcnJheSc7XG5pbXBvcnQgeyBjaG9vc2Vfd2VpZ2h0IH0gZnJvbSAnLi4vdXRpbGl0aWVzL2dlbmVyYWxVdGlsaXRpZXMnO1xuXG4vLyBUT0RPOiB0aGlzIGZpbGUgbmVlZHMgdG8gYmUgcmVuYW1lZCB0byBzb21ldGhpbmcgbW9yZSBnZW5lcmFsaXplZC5cblxuLyoqXG4gKiBTeW1vYmwgdGhhdCBwb3NzaWJseSBzZXBlcmF0ZXMgYW5kIGFpcmxpbmUgbmFtZSBmcm9tIGl0cyBmbGVldCBjbGFzc2lmaWNhdGlvblxuICpcbiAqIEBwcm9wZXJ0eSBOQU1FX0ZMRUVUX1NFUEVSQVRPUlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBOQU1FX0ZMRUVUX1NFUEVSQVRPUiA9ICcvJztcblxuLyoqXG4gKiBAcHJvcGVydHkgSU5WQUxJRF9JTkRFWFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBJTlZBTElEX0lOREVYID0gLTE7XG5cbi8qKlxuICogRW5lbWVyYXRpb24gb2YgYW4gaW5kZXggdmFsdWUgb2YgYDBgXG4gKlxuICogQHByb3BlcnR5IEZJUlNUX0lOREVYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IEZJUlNUX0lOREVYID0gMDtcblxuLyoqXG4gKiBFbmVtZXJhdGlvbiBvZiBhbiBpbmRleCB2YWx1ZSBvZiBgMWBcbiAqXG4gKiBAcHJvcGVydHkgU0VDT05EX0lOREVYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFNFQ09ORF9JTkRFWCA9IDE7XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgc2VsZWN0ZWQgYWlybGluZSBuYW1lLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHRoZSBgTkFNRV9GTEVFVF9TRVBFUkFUT1JgLCBhbmRcbiAqIHJldHVybnMgdGhlIGBhaXJsaW5lTmFtZUFuZEZsZWV0YCBvYmplY3Qgd2l0aCB1cGRhdGVkIHByb3BlcnR5IHZhbHVlcy5cbiAqXG4gKiBAZnVuY3Rpb24gX2V4dHJhY3ROYW1lQW5kRmxlZXRGcm9tQ3VycmVudEFpcmxpbmVcbiAqIEBwYXJhbSBzZWxlY3RlZEFpcmxpbmUge3N0cmluZ31cbiAqIEBwYXJhbSBhaXJsaW5lTmFtZUFuZEZsZWV0IHtvYmplY3R9XG4gKiBAcmV0dXJuIGFpcmxpbmVOYW1lQW5kRmxlZXQge29iamVjdH1cbiAqL1xuY29uc3QgX2V4dHJhY3ROYW1lQW5kRmxlZXRGcm9tQ3VycmVudEFpcmxpbmUgPSAoc2VsZWN0ZWRBaXJsaW5lLCBhaXJsaW5lTmFtZUFuZEZsZWV0KSA9PiB7XG4gICAgYWlybGluZU5hbWVBbmRGbGVldC5uYW1lID0gc2VsZWN0ZWRBaXJsaW5lO1xuXG4gICAgaWYgKHNlbGVjdGVkQWlybGluZS5pbmRleE9mKE5BTUVfRkxFRVRfU0VQRVJBVE9SKSA+IElOVkFMSURfSU5ERVgpIHtcbiAgICAgICAgY29uc3QgbmFtZUFuZEZsZWV0ID0gc2VsZWN0ZWRBaXJsaW5lLnNwbGl0KE5BTUVfRkxFRVRfU0VQRVJBVE9SKTtcblxuICAgICAgICBhaXJsaW5lTmFtZUFuZEZsZWV0Lm5hbWUgPSBuYW1lQW5kRmxlZXRbRklSU1RfSU5ERVhdO1xuICAgICAgICBhaXJsaW5lTmFtZUFuZEZsZWV0LmZsZWV0ID0gbmFtZUFuZEZsZWV0W1NFQ09ORF9JTkRFWF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFpcmxpbmVOYW1lQW5kRmxlZXQ7XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYW4gYWlybGluZSwgYXMgZGVmaW5lZCBpbiBhbiBhaXJwb3J0IGpzb24gZmlsZSBmcm9tIHRoZSBgZGVwYXJ0dXJlc2AgYW5kIGBhcnJpdmFsc2Agc2VjdGlvbnMsXG4gKiBhbmQgcmV0dXJucyBhIGNvbnNpc3RlbnQgb2JqZWN0IGNvbnRhaW5pbmcgYW4gYWlybGluZSBuYW1lIGFuZCBmbGVldCBjbGFzc2lmaWNhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGFpcmxpbmVOYW1lQW5kRmxlZXRIZWxwZXJcbiAqIEBwYXJhbSBhaXJsaW5lIHtzdHJpbmd9XG4gKiBAcmV0dXJuIGFpcmxpbmVOYW1lQW5kRmxlZXQge29iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFpcmxpbmVOYW1lQW5kRmxlZXRIZWxwZXIgPSAoYWlybGluZSkgPT4ge1xuICAgIGlmICghX2lzQXJyYXkoYWlybGluZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXIuIEV4cGVjdGVkIGFpcmxpbmUgdG8gYmUgYW4gYXJyYXkgYnV0IGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2YgYWlybGluZX1gKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGNvdWxkIGJlIGEgbW9kZWwgb2JqZWN0LCBidXQgdGhlIHZhbHVlcyB1c2VkIGhlcmUgYXJlIHRlbXBvcmFyeSBzbyB3ZSBqdXN0IHVzZSBhIGNvbnN0YW50XG4gICAgLy8gYW5kIHVwZGF0ZSBpdHMga2V5IHZhbHVlcyBhcyBuZWVkZWQuXG4gICAgY29uc3QgYWlybGluZU5hbWVBbmRGbGVldCA9IHtcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIGZsZWV0OiAnJ1xuICAgIH07XG5cbiAgICBpZiAoYWlybGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFpcmxpbmVOYW1lQW5kRmxlZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRyYWN0TmFtZUFuZEZsZWV0RnJvbUN1cnJlbnRBaXJsaW5lKGFpcmxpbmVbRklSU1RfSU5ERVhdLCBhaXJsaW5lTmFtZUFuZEZsZWV0KTtcbn07XG5cbi8qKlxuICogQWNjZXB0cyBhIGxpc3Qgb2YgYWlybGluZXMsIGFzIGRlZmluZWQgaW4gYW4gYWlycG9ydCBqc29uIGZpbGUgZnJvbSB0aGUgYGRlcGFydHVyZXNgIGFuZCBgYXJyaXZhbHNgIHNlY3Rpb25zLFxuICogYW5kIHJldHVybnMgYSBjb25zaXN0ZW50IG9iamVjdCBjb250YWluaW5nIGFuIGFpcmxpbmUgbmFtZSBhbmQgZmxlZXQgY2xhc3NpZmljYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uIHJhbmRvbUFpcmxpbmVTZWxlY3Rpb25IZWxwZXJcbiAqIEBwYXJhbSBhaXJsaW5lTGlzdCB7YXJyYXl9XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCByYW5kb21BaXJsaW5lU2VsZWN0aW9uSGVscGVyID0gKGFpcmxpbmVMaXN0KSA9PiB7XG4gICAgLy8gVE9ETzogYSBsYXJnZSBwb3J0aW9uIG9mIHRoaXMgZnVuY3Rpb24gaXMgZHVwbGljYXRlZCBhYm92ZSwgcmVmYWN0b3JcbiAgICBpZiAoIV9pc0FycmF5KGFpcmxpbmVMaXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHBhcmFtZXRlci4gRXhwZWN0ZWQgYWlybGluZUxpc3QgdG8gYmUgYW4gYXJyYXkgYnV0IGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2YgYWlybGluZUxpc3R9YCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBjb3VsZCBiZSBhIG1vZGVsIG9iamVjdCwgYnV0IHRoZSB2YWx1ZXMgdXNlZCBoZXJlIGFyZSB0ZW1wb3Jhcnkgc28gd2UganVzdCB1c2UgYSBjb25zdGFudFxuICAgIC8vIGFuZCB1cGRhdGUgaXRzIGtleSB2YWx1ZXMgYXMgbmVlZGVkLlxuICAgIGNvbnN0IGFpcmxpbmVOYW1lQW5kRmxlZXQgPSB7XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICBmbGVldDogJydcbiAgICB9O1xuXG4gICAgaWYgKGFpcmxpbmVMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYWlybGluZU5hbWVBbmRGbGVldDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RlZEFpcmxpbmUgPSBjaG9vc2Vfd2VpZ2h0KGFpcmxpbmVMaXN0KTtcblxuICAgIHJldHVybiBfZXh0cmFjdE5hbWVBbmRGbGVldEZyb21DdXJyZW50QWlybGluZShzZWxlY3RlZEFpcmxpbmUsIGFpcmxpbmVOYW1lQW5kRmxlZXQpO1xufTtcbiIsImltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9sb3dlckNhc2UgZnJvbSAnbG9kYXNoL2xvd2VyQ2FzZSc7XG5pbXBvcnQgQWlybGluZUNvbnRyb2xsZXIgZnJvbSAnLi4vYWlybGluZS9BaXJsaW5lQ29udHJvbGxlcic7XG5pbXBvcnQgQWlyY3JhZnRDb250cm9sbGVyIGZyb20gJy4uL2FpcmNyYWZ0L0FpcmNyYWZ0Q29udHJvbGxlcic7XG5pbXBvcnQgQWlycG9ydCBmcm9tICcuL0FpcnBvcnRNb2RlbCc7XG5pbXBvcnQgeyBTVE9SQUdFX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cy9zdG9yYWdlS2V5cyc7XG5cbi8vIFRlbXBvcmFyeSBjb25zdCBkZWNsYXJhdGlvbiBoZXJlIHRvIGF0dGFjaCB0byB0aGUgd2luZG93IEFORCB1c2UgYXMgaW50ZXJuYWwgcHJvcGVydHlcbmNvbnN0IGFpcnBvcnQgPSB7fTtcblxuLyoqXG4gKiBAcHJvcGVydHkgREVGQVVMVF9BSVJQT1JUX0lDQU9cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgREVGQVVMVF9BSVJQT1JUX0lDQU8gPSAna3Nmbyc7XG5cbi8qKlxuICogQGNsYXNzIEFpcnBvcnRDb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpcnBvcnRDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWlycG9ydExvYWRMaXN0IHthcnJheTxvYmplY3Q+fSAgTGlzdCBvZiBhaXJwb3J0cyB0byBsb2FkXG4gICAgICogQHBhcmFtIHVwZGF0ZVJ1biB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWlycG9ydExvYWRMaXN0LCB1cGRhdGVSdW4pIHtcbiAgICAgICAgdGhpcy51cGRhdGVSdW4gPSB1cGRhdGVSdW47XG4gICAgICAgIHRoaXMuYWlycG9ydCA9IGFpcnBvcnQ7XG4gICAgICAgIHRoaXMuYWlycG9ydC5haXJwb3J0cyA9IHt9O1xuICAgICAgICB0aGlzLmFpcnBvcnQuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWlybGluZUNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFpcmNyYWZ0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FpcnBvcnRMaXN0VG9Mb2FkID0gYWlycG9ydExvYWRMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QuIFNob3VsZCBydW4gb25seSBvbmNlIG9uIEFwcCBpbml0aWFsaWF6YXRpb25cbiAgICAgKlxuICAgICAqIEBmb3IgQWlycG9ydENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGluaXRfcHJlXG4gICAgICovXG4gICAgaW5pdF9wcmUoKSB7XG4gICAgICAgIHByb3AuYWlycG9ydCA9IGFpcnBvcnQ7XG5cbiAgICAgICAgdGhpcy5haXJsaW5lQ29udHJvbGxlciA9IG5ldyBBaXJsaW5lQ29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmFpcmNyYWZ0Q29udHJvbGxlciA9IG5ldyBBaXJjcmFmdENvbnRyb2xsZXIoKTtcblxuICAgICAgICB3aW5kb3cuYWlybGluZUNvbnRyb2xsZXIgPSB0aGlzLmFpcmxpbmVDb250cm9sbGVyO1xuICAgICAgICB3aW5kb3cuYWlyY3JhZnRDb250cm9sbGVyID0gdGhpcy5haXJjcmFmdENvbnRyb2xsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIG1ldGhvZC4gU2hvdWxkIHJ1biBvbmx5IG9uY2Ugb24gQXBwIGluaXRpYWxpYXphdGlvblxuICAgICAqXG4gICAgICogTG9hZCBlYWNoIGFpcnBvcnQgaW4gdGhlIGBhaXJwb3J0TG9hZExpc3RgXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcnBvcnRDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9haXJwb3J0TGlzdFRvTG9hZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWlycG9ydCA9IHRoaXMuX2FpcnBvcnRMaXN0VG9Mb2FkW2ldO1xuXG4gICAgICAgICAgICB0aGlzLmFpcnBvcnRfbG9hZChhaXJwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QgY2FsbGVkIGZyb20gYEFwcGAuXG4gICAgICpcbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBmYXNjYWRlIGZvciB0aGUgYGFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdF91cGRhdGVgIG1ldGhvZCxcbiAgICAgKiB3aGVyZSBhaXJjcmFmdCBkYXRhIGlzIHJlY2FsY3VsYXRlZCBiZWZvcmUgcmUtcmVuZGVyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlY2FsY3VsYXRlXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGUoKSB7XG4gICAgICAgIHRoaXMuYWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0X3VwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QuIFNob3VsZCBydW4gb25seSBvbmNlIG9uIEFwcCBpbml0aWFsaWF6YXRpb25cbiAgICAgKlxuICAgICAqIEBmb3IgQWlycG9ydENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHJlYWR5XG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGxldCBhaXJwb3J0TmFtZSA9IERFRkFVTFRfQUlSUE9SVF9JQ0FPO1xuXG4gICAgICAgIGlmIChfaGFzKGxvY2FsU3RvcmFnZSwgU1RPUkFHRV9LRVkuQVRDX0xBU1RfQUlSUE9SVCkgfHxcbiAgICAgICAgICAgIF9oYXModGhpcy5haXJwb3J0LmFpcnBvcnRzLCBfbG93ZXJDYXNlKGxvY2FsU3RvcmFnZVtTVE9SQUdFX0tFWS5BVENfTEFTVF9BSVJQT1JUXSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgYWlycG9ydE5hbWUgPSBfbG93ZXJDYXNlKGxvY2FsU3RvcmFnZVtTVE9SQUdFX0tFWS5BVENfTEFTVF9BSVJQT1JUXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFpcnBvcnRfc2V0KGFpcnBvcnROYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gYWlycG9ydF9sb2FkXG4gICAgICogQHBhcmFtIGljYW8ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gbGV2ZWwge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4gYWlycG9ydCB7QWlydHBvcnRJbnN0YW5jZX1cbiAgICAgKi9cbiAgICBhaXJwb3J0X2xvYWQoeyBpY2FvLCBsZXZlbCwgbmFtZSB9KSB7XG4gICAgICAgIGljYW8gPSBpY2FvLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQWlycG9ydCgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpY2FvfTogYWxyZWFkeSBsb2FkZWRgKTtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgQWlycG9ydCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoaXMudXBkYXRlUnVuKClcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IG5ldyBBaXJwb3J0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGljYW8sXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUnVuXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5haXJwb3J0X2FkZChhaXJwb3J0KTtcblxuICAgICAgICByZXR1cm4gYWlycG9ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gYWlycG9ydF9hZGRcbiAgICAgKiBAcGFyYW0gYWlycG9ydFxuICAgICAqL1xuICAgIGFpcnBvcnRfYWRkKGFpcnBvcnQpIHtcbiAgICAgICAgdGhpcy5haXJwb3J0LmFpcnBvcnRzW2FpcnBvcnQuaWNhb10gPSBhaXJwb3J0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydENvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGFpcnBvcnRfc2V0XG4gICAgICovXG4gICAgYWlycG9ydF9zZXQoaWNhbykge1xuICAgICAgICBpZiAodGhpcy5oYXNTdG9yZWRJY2FvKGljYW8pKSB7XG4gICAgICAgICAgICBpY2FvID0gbG9jYWxTdG9yYWdlW1NUT1JBR0VfS0VZLkFUQ19MQVNUX0FJUlBPUlRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWNhbyA9IGljYW8udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoIXRoaXMuYWlycG9ydC5haXJwb3J0c1tpY2FvXSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7aWNhb306IG5vIHN1Y2ggYWlycG9ydGApO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5haXJwb3J0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWlycG9ydC5jdXJyZW50LnVuc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdF9yZW1vdmVfYWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0QWlycG9ydE1vZGVsID0gdGhpcy5haXJwb3J0LmFpcnBvcnRzW2ljYW9dO1xuICAgICAgICBuZXh0QWlycG9ydE1vZGVsLnNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gYWlycG9ydF9nZXRcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBhaXJwb3J0X2dldChpY2FvKSB7XG4gICAgICAgIGlmICghaWNhbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWlycG9ydC5jdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWlycG9ydC5haXJwb3J0c1tpY2FvLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaGFzU3RvcmVkSWNhb1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU3RvcmVkSWNhbyhpY2FvKSB7XG4gICAgICAgIHJldHVybiAhaWNhbyAmJiBfaGFzKGxvY2FsU3RvcmFnZSwgU1RPUkFHRV9LRVkuQVRDX0xBU1RfQUlSUE9SVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBoYXNBaXJwb3J0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBaXJwb3J0KGljYW8pIHtcbiAgICAgICAgcmV0dXJuIF9oYXModGhpcy5haXJwb3J0LmFpcnBvcnRzLCBpY2FvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gYWlyY3JhZnQgZnJvbSB0aGUgcXVldWUgb2YgYW55IHJ1bndheShzKSBhdCB0aGUgQWlycG9ydE1vZGVsXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFpcmNyYWZ0RnJvbUFsbFJ1bndheVF1ZXVlc1xuICAgICAqIEBwYXJhbSAge2FpcmNyYWZ0fSBhaXJjcmFmdCBUaGUgYWlyY3JhZnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlQWlyY3JhZnRGcm9tQWxsUnVud2F5UXVldWVzKGFpcmNyYWZ0KSB7XG4gICAgICAgIGNvbnN0IHJ1bndheVByaW1hcnlFbmRJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHJ1bndheVNlY29uZGFyeUVuZEluZGV4ID0gMTtcbiAgICAgICAgY29uc3QgcnVud2F5cyA9IHRoaXMuYWlycG9ydF9nZXQoKS5ydW53YXlzO1xuICAgICAgICBmb3IgKGxldCBydW53YXlQYWlyID0gMDsgcnVud2F5UGFpciA8IHJ1bndheXMubGVuZ3RoOyBydW53YXlQYWlyKyspIHtcbiAgICAgICAgICAgIHJ1bndheXNbcnVud2F5UGFpcl1bcnVud2F5UHJpbWFyeUVuZEluZGV4XS5yZW1vdmVRdWV1ZShhaXJjcmFmdCwgdHJ1ZSk7XG4gICAgICAgICAgICBydW53YXlzW3J1bndheVBhaXJdW3J1bndheVNlY29uZGFyeUVuZEluZGV4XS5yZW1vdmVRdWV1ZShhaXJjcmFmdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgZnVuYy1uYW1lcywgY2FtZWxjYXNlLCBuby11bmRlZiwgbWF4LWxlbiwgb2JqZWN0LXNob3J0aGFuZCAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9oZWFkIGZyb20gJ2xvZGFzaC9oZWFkJztcbmltcG9ydCBfbWFwIGZyb20gJ2xvZGFzaC9tYXAnO1xuaW1wb3J0IF9pc0VtcHR5IGZyb20gJ2xvZGFzaC9pc0VtcHR5JztcbmltcG9ydCBfaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBBaXJzcGFjZU1vZGVsIGZyb20gJy4vQWlyc3BhY2VNb2RlbCc7XG5pbXBvcnQgUG9zaXRpb25Nb2RlbCBmcm9tICcuLi9iYXNlL1Bvc2l0aW9uTW9kZWwnO1xuaW1wb3J0IFJ1bndheU1vZGVsIGZyb20gJy4vUnVud2F5TW9kZWwnO1xuaW1wb3J0IEZpeENvbGxlY3Rpb24gZnJvbSAnLi9GaXgvRml4Q29sbGVjdGlvbic7XG5pbXBvcnQgU3RhbmRhcmRSb3V0ZUNvbGxlY3Rpb24gZnJvbSAnLi9TdGFuZGFyZFJvdXRlL1N0YW5kYXJkUm91dGVDb2xsZWN0aW9uJztcbmltcG9ydCB7IGFycml2YWxGYWN0b3J5IH0gZnJvbSAnLi9BcnJpdmFsL2Fycml2YWxGYWN0b3J5JztcbmltcG9ydCB7IGRlcGFydHVyZUZhY3RvcnkgfSBmcm9tICcuL0RlcGFydHVyZS9kZXBhcnR1cmVGYWN0b3J5JztcbmltcG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMsIHBhcnNlRWxldmF0aW9uIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IHJvdW5kLCBhYnMsIHNpbiwgZXh0cmFwb2xhdGVfcmFuZ2VfY2xhbXAgfSBmcm9tICcuLi9tYXRoL2NvcmUnO1xuaW1wb3J0IHsgYW5nbGVfb2Zmc2V0IH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsgZ2V0T2Zmc2V0IH0gZnJvbSAnLi4vbWF0aC9mbGlnaHRNYXRoJztcbmltcG9ydCB7IHZsZW4sIHZzdWIsIHZhZGQsIHZzY2FsZSwgcmF5c0ludGVyc2VjdCB9IGZyb20gJy4uL21hdGgvdmVjdG9yJztcbmltcG9ydCB7IExPRyB9IGZyb20gJy4uL2NvbnN0YW50cy9sb2dMZXZlbCc7XG5pbXBvcnQgeyBTRUxFQ1RPUlMgfSBmcm9tICcuLi9jb25zdGFudHMvc2VsZWN0b3JzJztcbmltcG9ydCB7IFNUT1JBR0VfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzL3N0b3JhZ2VLZXlzJztcblxuLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBzaG91bGQgcmVhbGx5IGxpdmUgaW4gYSBkaWZmZXJlbnQgZmlsZSBhbmQgaGF2ZSB0ZXN0cy5cbi8vIHdoYXQgZG9lcyByYSBzdGFuZCBmb3I/IHJ1bndheSBhbmdsZT8gd2hhdCBhYm91dCBuPyBuZWVkIGJldHRlciBuYW1lcyBoZXJlLlxuLyoqXG4gKiBAZnVuY3Rpb24gcmFcbiAqIEBwYXJhbSBuIHtudW1lcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgcmEgPSAobikgPT4ge1xuICAgIGNvbnN0IGRldmlhdGlvbiA9IGRlZ3JlZXNUb1JhZGlhbnMoMTApO1xuXG4gICAgcmV0dXJuIG4gKyBleHRyYXBvbGF0ZV9yYW5nZV9jbGFtcCgwLCBNYXRoLnJhbmRvbSgpLCAxLCAtZGV2aWF0aW9uLCBkZXZpYXRpb24pO1xufTtcblxuY29uc3QgREVGQVVMVF9DVFJfUkFESVVTX05NID0gODA7XG5jb25zdCBERUZBVUxUX0NUUl9DRUlMSU5HX0ZUID0gMTAwMDA7XG5jb25zdCBERUZBVUxUX0lOSVRJQUxfQUxUSVRVREVfRlQgPSA1MDAwO1xuY29uc3QgREVBRlVMVF9SUl9SQURJVVNfTk0gPSA1O1xuXG4vKipcbiAqXG4gKlxuICogQGNsYXNzIEFpcnBvcnRNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBaXJwb3J0TW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICogQHBhcmFtIHVwZGF0ZVJ1biB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCB1cGRhdGVSdW4pIHtcbiAgICAgICAgdGhpcy51cGRhdGVSdW4gPSB1cGRhdGVSdW47XG4gICAgICAgIC8vIEZJWE1FOiBBbGwgcHJvcGVydGllcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgaGVyZSwgZXZlbiBpZiB0aGV5IHdvbnQgaGF2ZSB2YWx1ZXMgeWV0LlxuICAgICAgICAvLyB0aGVyZSBpcyBhIGxvdCBvZiBsb2dpYyBiZWxvdyB0aGF0IGNhbiBiZSBlbGltaW5pbmF0ZWQgYnkgc2ltcGx5IGluc3RhbnRpYXRpbmcgdmFsdWVzIGhlcmUuXG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmljYW8gPSBudWxsO1xuICAgICAgICB0aGlzLnJhZGlvID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bndheXMgPSBbXTtcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIHRvIGBydW53YXlOYW1lYFxuICAgICAgICB0aGlzLnJ1bndheSA9IG51bGw7XG4gICAgICAgIC8vIHRoaXMgcHJvcGVydHkgaXMga2VwdCBmb3IgZWFjaCBhaXJwb3J0IHRvIGFsbG93IGZvciByZS1oeWRyYXRpb24gb2YgdGhlIGBGaXhDb2xsZWN0aW9uYCBvbiBhaXJwb3J0IGNoYW5nZVxuICAgICAgICB0aGlzLmZpeGVzID0ge307XG4gICAgICAgIHRoaXMuc2lkQ29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhckNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm1hcHMgPSB7fTtcbiAgICAgICAgdGhpcy5haXJ3YXlzID0ge307XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZF9hcmVhcyA9IFtdO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgcnd5OiB7fVxuICAgICAgICB9O1xuICAgICAgICAvLyBhcnJheSBvZiBhcmVhcyB1bmRlciB0aGlzIHNlY3RvcidzIGNvbnRyb2wuIElmIG51bGwsIGRyYXdzIGNpcmNsZSB3aXRoIGRpYW1ldGVyIG9mICdjdHJfcmFkaXVzJ1xuICAgICAgICB0aGlzLmFpcnNwYWNlID0gbnVsbDtcbiAgICAgICAgLy8gYXJlYSBvdXRsaW5pbmcgdGhlIG91dGVybW9zdCBsYXRlcmFsIGFpcnNwYWNlIGJvdW5kYXJ5LiBDb21lcyBmcm9tIHRoaXMuYWlyc3BhY2VbMF1cbiAgICAgICAgdGhpcy5wZXJpbWV0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgID0ge1xuICAgICAgICAgICAgcnVud2F5OiBudWxsLFxuICAgICAgICAgICAgZGVwYXJ0dXJlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVwYXJ0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmFycml2YWxzID0gW107XG5cbiAgICAgICAgdGhpcy53aW5kICA9IHtcbiAgICAgICAgICAgIHNwZWVkOiAxMCxcbiAgICAgICAgICAgIGFuZ2xlOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jdHJfcmFkaXVzID0gODA7XG4gICAgICAgIHRoaXMuY3RyX2NlaWxpbmcgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5pbml0aWFsX2FsdCA9IDUwMDA7XG4gICAgICAgIHRoaXMucnJfcmFkaXVzX25tID0gMDtcbiAgICAgICAgdGhpcy5ycl9jZW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMucGFyc2Uob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHJlYWxfZml4ZXNcbiAgICAgKiBAcmV0dXJuIHthcnJheTxGaXhNb2RlbD59XG4gICAgICovXG4gICAgZ2V0IHJlYWxfZml4ZXMoKSB7XG4gICAgICAgIHJldHVybiBGaXhDb2xsZWN0aW9uLmZpbmRSZWFsRml4ZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWxldmF0aW9uXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBlbGV2YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmVsZXZhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbWFnbmV0aWNfbm9ydGhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IG1hZ25ldGljX25vcnRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5tYWduZXRpY05vcnRoSW5SYWRpYW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBwYXJzZVxuICAgICAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XG4gICAgICovXG4gICAgcGFyc2UoZGF0YSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBfZ2V0KGRhdGEsICduYW1lJywgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5pY2FvID0gX2dldChkYXRhLCAnaWNhbycsIHRoaXMuaWNhbykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IF9nZXQoZGF0YSwgJ2xldmVsJywgdGhpcy5sZXZlbCk7XG5cbiAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBgcG9zaXRpb25gIGRvZXNudCBleGlzdCBpbiBkYXRhLiBvbiBhcHAgaW5pdGlhbGlhemF0aW9uLCB3ZSBsb29wIHRocm91Z2ggZXZlcnkgYWlycG9ydFxuICAgICAgICAvLyBpbiB0aGUgYGFpcnBvcnRMb2FkTGlzdGAgYW5kIGluc3RhbnRpYXRlIGEgbW9kZWwgZm9yIGVhY2ggYnV0IHdvbnQgaGF2ZSB0aGUgZnVsbCBkYXRhIHNldCB1bnRpbCB0aGVcbiAgICAgICAgLy8gYWlycG9ydCBqc29uIGZpbGUgaXMgbG9hZGVkLlxuICAgICAgICBpZiAoIWRhdGEucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFBvc2l0aW9uKGRhdGEucG9zaXRpb24sIGRhdGEubWFnbmV0aWNfbm9ydGgpO1xuXG4gICAgICAgIHRoaXMucmFkaW8gPSBfZ2V0KGRhdGEsICdyYWRpbycsIHRoaXMucmFkaW8pO1xuICAgICAgICB0aGlzLmhhc190ZXJyYWluID0gX2dldChkYXRhLCAnaGFzX3RlcnJhaW4nLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYWlyd2F5cyA9IF9nZXQoZGF0YSwgJ2FpcndheXMnLCB7fSk7XG4gICAgICAgIHRoaXMuY3RyX3JhZGl1cyA9IF9nZXQoZGF0YSwgJ2N0cl9yYWRpdXMnLCBERUZBVUxUX0NUUl9SQURJVVNfTk0pO1xuICAgICAgICB0aGlzLmN0cl9jZWlsaW5nID0gX2dldChkYXRhLCAnY3RyX2NlaWxpbmcnLCBERUZBVUxUX0NUUl9DRUlMSU5HX0ZUKTtcbiAgICAgICAgdGhpcy5pbml0aWFsX2FsdCA9IF9nZXQoZGF0YSwgJ2luaXRpYWxfYWx0JywgREVGQVVMVF9JTklUSUFMX0FMVElUVURFX0ZUKTtcbiAgICAgICAgdGhpcy5ycl9yYWRpdXNfbm0gPSBfZ2V0KGRhdGEsICdycl9yYWRpdXNfbm0nKTtcbiAgICAgICAgdGhpcy5ycl9jZW50ZXIgPSBfZ2V0KGRhdGEsICdycl9jZW50ZXInKTtcblxuICAgICAgICB0aGlzLmZpeGVzID0gX2dldChkYXRhLCAnZml4ZXMnLCB7fSk7XG4gICAgICAgIEZpeENvbGxlY3Rpb24uYWRkSXRlbXModGhpcy5maXhlcywgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5zaWRDb2xsZWN0aW9uID0gbmV3IFN0YW5kYXJkUm91dGVDb2xsZWN0aW9uKGRhdGEuc2lkcyk7XG4gICAgICAgIHRoaXMuc3RhckNvbGxlY3Rpb24gPSBuZXcgU3RhbmRhcmRSb3V0ZUNvbGxlY3Rpb24oZGF0YS5zdGFycyk7XG5cbiAgICAgICAgdGhpcy5sb2FkVGVycmFpbigpO1xuICAgICAgICB0aGlzLmJ1aWxkQWlycG9ydEFpcnNwYWNlKGRhdGEuYWlyc3BhY2UpO1xuICAgICAgICB0aGlzLmJ1aWxkQWlycG9ydFJ1bndheXMoZGF0YS5ydW53YXlzKTtcbiAgICAgICAgdGhpcy5idWlsZEFpcnBvcnRNYXBzKGRhdGEubWFwcyk7XG4gICAgICAgIHRoaXMuYnVpbGRSZXN0cmljdGVkQXJlYXMoZGF0YS5yZXN0cmljdGVkKTtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50V2luZChkYXRhLndpbmQpO1xuICAgICAgICB0aGlzLmJ1aWxkQWlycG9ydERlcGFydHVyZXMoZGF0YS5kZXBhcnR1cmVzKTtcbiAgICAgICAgdGhpcy5idWlsZEFycml2YWxzKGRhdGEuYXJyaXZhbHMpO1xuICAgICAgICB0aGlzLmJ1aWxkUnVud2F5TWV0YURhdGEoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2Qgc2V0Q3VycmVudFBvc2l0aW9uXG4gICAgICogQHBhcmFtIGN1cnJlbnRQb3NpdGlvbiB7YXJyYXl9XG4gICAgICovXG4gICAgc2V0Q3VycmVudFBvc2l0aW9uKGN1cnJlbnRQb3NpdGlvbiwgbWFnbmV0aWNOb3J0aCkge1xuICAgICAgICBpZiAoIWN1cnJlbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBQb3NpdGlvbk1vZGVsKGN1cnJlbnRQb3NpdGlvbiwgbnVsbCwgbWFnbmV0aWNOb3J0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIDNkIHBvbHlnb25hbCBhaXJzcGFjZVxuICAgICAqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIGJ1aWxkQWlycG9ydEFpcnNwYWNlXG4gICAgICogQHBhcmFtIGFpcnNwYWNlXG4gICAgICovXG4gICAgYnVpbGRBaXJwb3J0QWlyc3BhY2UoYWlyc3BhY2UpIHtcbiAgICAgICAgaWYgKCFhaXJzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIGVhY2ggYXJlYVxuICAgICAgICB0aGlzLmFpcnNwYWNlID0gX21hcChhaXJzcGFjZSwgKGFpcnNwYWNlU2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBaXJzcGFjZU1vZGVsKFxuICAgICAgICAgICAgICAgIGFpcnNwYWNlU2VjdGlvbixcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRoaXMubWFnbmV0aWNfbm9ydGhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFpcnNwYWNlIHBlcmltZXRlciAoYXNzdW1lZCB0byBiZSBmaXJzdCBlbnRyeSBpbiBkYXRhLmFpcnNwYWNlKVxuICAgICAgICB0aGlzLnBlcmltZXRlciA9IF9oZWFkKHRoaXMuYWlyc3BhY2UpO1xuXG4gICAgICAgIC8vIGNoYW5nZSBjdHJfcmFkaXVzIHRvIHBvaW50IGFsb25nIHBlcmltZXRlciB0aGF0J3MgZmFydGhlc3QgZnJvbSBycl9jZW50ZXJcbiAgICAgICAgLy8gY29uc3QgcG9zID0gbmV3IFBvc2l0aW9uTW9kZWwodGhpcy5wZXJpbWV0ZXIucG9seVswXS5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgdGhpcy5tYWduZXRpY19ub3J0aCk7XG5cbiAgICAgICAgdGhpcy5jdHJfcmFkaXVzID0gTWF0aC5tYXgoLi4uX21hcChcbiAgICAgICAgICAgIHRoaXMucGVyaW1ldGVyLnBvbHksICh2KSA9PiB2bGVuKFxuICAgICAgICAgICAgICAgIHZzdWIoXG4gICAgICAgICAgICAgICAgICAgIHYucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIFBvc2l0aW9uTW9kZWwuY2FsY3VsYXRlUG9zaXRpb24odGhpcy5ycl9jZW50ZXIsIHRoaXMucG9zaXRpb24sIHRoaXMubWFnbmV0aWNfbm9ydGgpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgYnVpbGRBaXJwb3J0UnVud2F5c1xuICAgICAqIEBwYXJhbSBydW53YXlzIHthcnJheX1cbiAgICAgKi9cbiAgICBidWlsZEFpcnBvcnRSdW53YXlzKHJ1bndheXMpIHtcbiAgICAgICAgaWYgKCFydW53YXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfZm9yRWFjaChydW53YXlzLCAocnVud2F5KSA9PiB7XG4gICAgICAgICAgICBydW53YXkucmVmZXJlbmNlX3Bvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHJ1bndheS5tYWduZXRpY19ub3J0aCA9IHRoaXMubWFnbmV0aWNfbm9ydGg7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgZG8gdGhlIDAgYW5kIDEgbWVhbj8gbWFnaWMgbnVtYmVycyBzaG91bGQgYmUgZW51bWVyYXRlZFxuXG4gICAgICAgICAgICB0aGlzLnJ1bndheXMucHVzaChbXG4gICAgICAgICAgICAgICAgbmV3IFJ1bndheU1vZGVsKHJ1bndheSwgMCwgdGhpcyksXG4gICAgICAgICAgICAgICAgbmV3IFJ1bndheU1vZGVsKHJ1bndheSwgMSwgdGhpcylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgYnVpbGRBaXJwb3J0TWFwc1xuICAgICAqIEBwYXJhbSBtYXBzIHtvYmplY3R9XG4gICAgICovXG4gICAgYnVpbGRBaXJwb3J0TWFwcyhtYXBzKSB7XG4gICAgICAgIGlmICghbWFwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX2ZvckVhY2gobWFwcywgKG1hcCwga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hcHNba2V5XSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBtYXA7XG5cbiAgICAgICAgICAgIF9mb3JFYWNoKGxpbmVzLCAobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gUG9zaXRpb25Nb2RlbC5jYWxjdWxhdGVQb3NpdGlvbihbbGluZVswXSwgbGluZVsxXV0sIHRoaXMucG9zaXRpb24sIHRoaXMubWFnbmV0aWNfbm9ydGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFBvc2l0aW9uTW9kZWwuY2FsY3VsYXRlUG9zaXRpb24oW2xpbmVbMl0sIGxpbmVbM11dLCB0aGlzLnBvc2l0aW9uLCB0aGlzLm1hZ25ldGljX25vcnRoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubWFwc1trZXldLnB1c2goW3N0YXJ0WzBdLCBzdGFydFsxXSwgZW5kWzBdLCBlbmRbMV1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgYnVpbGRSZXN0cmljdGVkQXJlYXNcbiAgICAgKiBAcGFyYW0gcmVzdHJpY3RlZEFyZWFzXG4gICAgICovXG4gICAgYnVpbGRSZXN0cmljdGVkQXJlYXMocmVzdHJpY3RlZEFyZWFzKSB7XG4gICAgICAgIGlmICghcmVzdHJpY3RlZEFyZWFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfZm9yRWFjaChyZXN0cmljdGVkQXJlYXMsIChhcmVhKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGlzIGBvYmpgIGdvaW5nIHRvIGJlPyBuZWVkIGJldHRlciBuYW1lLlxuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICBpZiAoYXJlYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqLm5hbWUgPSBhcmVhLm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5oZWlnaHQgPSBwYXJzZUVsZXZhdGlvbihhcmVhLmhlaWdodCk7XG4gICAgICAgICAgICBvYmouY29vcmRpbmF0ZXMgPSAkLm1hcChhcmVhLmNvb3JkaW5hdGVzLCAodikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbKFBvc2l0aW9uTW9kZWwuY2FsY3VsYXRlUG9zaXRpb24odiwgdGhpcy5wb3NpdGlvbiwgdGhpcy5tYWduZXRpY19ub3J0aCkpXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHJpZ2h0PyBtYXggYW5kIG1pbiBhcmUgZ2V0dGluZyBzZXQgdG8gdGhlIHNhbWUgdmFsdWU/XG4gICAgICAgICAgICAvLyBjb25zdCBjb29yZHMgPSBvYmouY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBsZXQgY29vcmRzX21heCA9IG9iai5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgIGxldCBjb29yZHNfbWluID0gb2JqLmNvb3JkaW5hdGVzWzBdO1xuXG4gICAgICAgICAgICBfZm9yRWFjaChvYmouY29vcmRpbmF0ZXMsICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29vcmRzX21heCA9IFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgodlswXSwgY29vcmRzX21heFswXSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHZbMV0sIGNvb3Jkc19tYXhbMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjb29yZHNfbWluID0gW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbih2WzBdLCBjb29yZHNfbWluWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4odlsxXSwgY29vcmRzX21pblsxXSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9iai5jZW50ZXIgPSB2c2NhbGUodmFkZChjb29yZHNfbWF4LCBjb29yZHNfbWluKSwgMC41KTtcblxuICAgICAgICAgICAgdGhpcy5yZXN0cmljdGVkX2FyZWFzLnB1c2gob2JqKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUN1cnJlbnRXaW5kXG4gICAgICogQHBhcmFtIGN1cnJlbnRXaW5kXG4gICAgICovXG4gICAgdXBkYXRlQ3VycmVudFdpbmQoY3VycmVudFdpbmQpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50V2luZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53aW5kLnNwZWVkID0gY3VycmVudFdpbmQuc3BlZWQ7XG4gICAgICAgIHRoaXMud2luZC5hbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnMoY3VycmVudFdpbmQuYW5nbGUpO1xuICAgIH1cblxuICAgIGJ1aWxkQWlycG9ydERlcGFydHVyZXMoZGVwYXJ0dXJlcykge1xuICAgICAgICBpZiAoIWRlcGFydHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVwYXJ0dXJlcyA9IGRlcGFydHVyZUZhY3RvcnkodGhpcywgZGVwYXJ0dXJlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIGJ1aWxkQXJyaXZhbHNcbiAgICAgKiBAcGFyYW0gYXJyaXZhbHMge2FycmF5fVxuICAgICAqL1xuICAgIGJ1aWxkQXJyaXZhbHMoYXJyaXZhbHMpIHtcbiAgICAgICAgaWYgKCFhcnJpdmFscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJpdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFfaGFzKGFycml2YWxzW2ldLCAndHlwZScpKSB7XG4gICAgICAgICAgICAgICAgbG9nKGAke3RoaXMuaWNhb30gYXJyaXZhbCBzdHJlYW0gIyR7aX0gbm90IGdpdmVuIHR5cGUhYCwgTE9HLldBUk5JTkcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycml2YWxzLnB1c2goYXJyaXZhbEZhY3RvcnkodGhpcywgYXJyaXZhbHNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBidWlsZFJ1bndheU1ldGFEYXRhXG4gICAgICovXG4gICAgYnVpbGRSdW53YXlNZXRhRGF0YSgpIHtcbiAgICAgICAgLy8gVE9ETzogdHJhbnNsYXRlIHRoZXNlIHRvIF9mb3JFYWNoKClcbiAgICAgICAgZm9yIChjb25zdCByd3kxIGluIHRoaXMucnVud2F5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCByd3kxZW5kIGluIHRoaXMucnVud2F5c1tyd3kxXSkge1xuICAgICAgICAgICAgICAgIC8vIHNldHVwIHByaW1hcnkgcnVud2F5IG9iamVjdFxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucnd5W3RoaXMucnVud2F5c1tyd3kxXVtyd3kxZW5kXS5uYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByd3kyIGluIHRoaXMucnVud2F5cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnd5MSA9PT0gcnd5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJ3eTJlbmQgaW4gdGhpcy5ydW53YXlzW3J3eTJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBzZWNvbmRhcnkgcnVud2F5IHN1Ym9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcjEgPSB0aGlzLnJ1bndheXNbcnd5MV1bcnd5MWVuZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByMiA9IHRoaXMucnVud2F5c1tyd3kyXVtyd3kyZW5kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGdldE9mZnNldChyMSwgcjIucG9zaXRpb24sIHIxLmFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucnd5W3IxLm5hbWVdW3IyLm5hbWVdID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoaXMgcnVud2F5IHBhaXIncyByZWxhdGlvbnNoaXAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yd3lbcjEubmFtZV1bcjIubmFtZV0ubGF0ZXJhbF9kaXN0ID0gYWJzKG9mZnNldFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJ3eVtyMS5uYW1lXVtyMi5uYW1lXS5zdHJhaWdodF9kaXN0ID0gYWJzKG9mZnNldFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJ3eVtyMS5uYW1lXVtyMi5uYW1lXS5jb252ZXJnaW5nID0gcmF5c0ludGVyc2VjdChyMS5wb3NpdGlvbiwgcjEuYW5nbGUsIHIyLnBvc2l0aW9uLCByMi5hbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJ3eVtyMS5uYW1lXVtyMi5uYW1lXS5wYXJhbGxlbCA9IChhYnMoYW5nbGVfb2Zmc2V0KHIxLmFuZ2xlLCByMi5hbmdsZSkpIDwgZGVncmVlc1RvUmFkaWFucygxMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqL1xuICAgIHNldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsU3RvcmFnZVtTVE9SQUdFX0tFWS5BVENfTEFTVF9BSVJQT1JUXSA9IHRoaXMuaWNhbztcbiAgICAgICAgcHJvcC5haXJwb3J0LmN1cnJlbnQgPSB0aGlzO1xuXG4gICAgICAgIHByb3AuY2FudmFzLmRyYXdfbGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5UT0dHTEVfTEFCRUxTKS50b2dnbGUoIV9pc0VtcHR5KHRoaXMubWFwcykpO1xuICAgICAgICAkKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLlRPR0dMRV9SRVNUUklDVEVEX0FSRUFTKS50b2dnbGUoKHRoaXMucmVzdHJpY3RlZF9hcmVhcyB8fCBbXSkubGVuZ3RoID4gMCk7XG4gICAgICAgICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuVE9HR0xFX1NJRFMpLnRvZ2dsZSghX2lzTmlsKHRoaXMuc2lkQ29sbGVjdGlvbikpO1xuXG4gICAgICAgIHByb3AuY2FudmFzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5UT0dHTEVfVEVSUkFJTikudG9nZ2xlKCFfaXNFbXB0eSh0aGlzLnRlcnJhaW4pKTtcblxuICAgICAgICB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV9yZXNldF9zY29yZV9hbmRfZXZlbnRzKCk7XG5cbiAgICAgICAgdGhpcy5zdGFydCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBwYXJzZSBtZXRob2QgaXMgcnVuLCB0aGlzIG1ldGhvZCBhbHNvIHJ1bnMuIGhvd2V2ZXIsIHdoZW4gYW4gYWlycG9ydCBpcyBiZWluZyByZS1sb2FkZWQsXG4gICAgICAgIC8vIG9ubHkgdGhpcyBtZXRob2QgcnVucy4gdGhpcyBkb2VzbnQgYmVsb25nIGhlcmUgYnV0IG5lZWRzIHRvIGJlIGhlcmUgc28gdGhlIGZpeGVzIGdldCBwb3B1bGF0ZWQgY29ycmVjdGx5LlxuICAgICAgICAvLyBGSVhNRTogbWFrZSBGaXhDb2xsZWN0aW9uIGEgaW5zdGFuY2UgY2xhc3MgYWluc3RlYWQgb2YgYSBzdGF0aWMgY2xhc3NcbiAgICAgICAgRml4Q29sbGVjdGlvbi5hZGRJdGVtcyh0aGlzLmZpeGVzLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVJ1bndheSgpO1xuICAgICAgICB0aGlzLmFkZEFpcmNyYWZ0KCk7XG4gICAgICAgIHRoaXMudXBkYXRlUnVuKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCB1bnNldFxuICAgICAqL1xuICAgIHVuc2V0KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJyaXZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYXJyaXZhbHNbaV0uc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXBhcnR1cmVzLnN0b3AoKTtcblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0LnJ1bndheSkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfY2xlYXJfdGltZW91dCh0aGlzLnRpbWVvdXQucnVud2F5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBhZGRBaXJjcmFmdFxuICAgICAqL1xuICAgIGFkZEFpcmNyYWZ0KCkge1xuICAgICAgICBpZiAodGhpcy5kZXBhcnR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGFydHVyZXMuc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFycml2YWxzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJyaXZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycml2YWxzW2ldLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgZ2V0V2luZFxuICAgICAqIEByZXR1cm4gd2luZCB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFdpbmQoKSB7XG4gICAgICAgIC8vIFRPRE86IHRoZXJlIGFyZSBhIGxvdCBvZiBtYWdpYyBudW1iZXJzIGhlcmUuIFdoYXQgYXJlIHRoZXkgZm9yIGFuZCB3aGF0IGRvIHRoZXkgbWVhbj8gVGhlc2Ugc2hvdWxkIGJlIGVudW1lcmF0ZWQuXG4gICAgICAgIGNvbnN0IHdpbmQgPSBjbG9uZSh0aGlzLndpbmQpO1xuICAgICAgICBsZXQgcyA9IDE7XG4gICAgICAgIGNvbnN0IGFuZ2xlX2ZhY3RvciA9IHNpbigocyArIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKSkgKiAwLjUpICsgc2luKChzICsgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZSgpKSAqIDIpO1xuICAgICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyB2YXIgZ2V0dGluZyByZWFzc2lnbmVkIHRvIGEgbWFnaWMgbnVtYmVyP1xuICAgICAgICBzID0gMTAwO1xuICAgICAgICBjb25zdCBzcGVlZF9mYWN0b3IgPSBzaW4oKHMgKyB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkpICogMC41KSArIHNpbigocyArIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKSkgKiAyKTtcbiAgICAgICAgd2luZC5hbmdsZSArPSBleHRyYXBvbGF0ZV9yYW5nZV9jbGFtcCgtMSwgYW5nbGVfZmFjdG9yLCAxLCBkZWdyZWVzVG9SYWRpYW5zKC00KSwgZGVncmVlc1RvUmFkaWFucyg0KSk7XG4gICAgICAgIHdpbmQuc3BlZWQgKj0gZXh0cmFwb2xhdGVfcmFuZ2VfY2xhbXAoLTEsIHNwZWVkX2ZhY3RvciwgMSwgMC45LCAxLjA1KTtcblxuICAgICAgICByZXR1cm4gd2luZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgdXBkYXRlUnVud2F5XG4gICAgICovXG4gICAgdXBkYXRlUnVud2F5KGxlbmd0aCA9IDApIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBtZXRob2QgY29udGFpbnMgc29tZSBhbWJpZ3VvdXMgbmFtZXMuIG5lZWQgYmV0dGVyIG5hbWVzLlxuICAgICAgICBjb25zdCB3aW5kID0gdGhpcy5nZXRXaW5kKCk7XG4gICAgICAgIGNvbnN0IGhlYWR3aW5kID0ge307XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bndheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bndheSA9IHRoaXMucnVud2F5c1tpXTtcbiAgICAgICAgICAgIGhlYWR3aW5kW3J1bndheVswXS5uYW1lXSA9IE1hdGguY29zKHJ1bndheVswXS5hbmdsZSAtIHJhKHdpbmQuYW5nbGUpKSAqIHdpbmQuc3BlZWQ7XG4gICAgICAgICAgICBoZWFkd2luZFtydW53YXlbMV0ubmFtZV0gPSBNYXRoLmNvcyhydW53YXlbMV0uYW5nbGUgLSByYSh3aW5kLmFuZ2xlKSkgKiB3aW5kLnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJlc3RfcnVud2F5ID0gJyc7XG4gICAgICAgIGxldCBiZXN0X3J1bndheV9oZWFkd2luZCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChjb25zdCBydW53YXkgaW4gaGVhZHdpbmQpIHtcbiAgICAgICAgICAgIGlmIChoZWFkd2luZFtydW53YXldID4gYmVzdF9ydW53YXlfaGVhZHdpbmQgJiYgdGhpcy5nZXRSdW53YXkocnVud2F5KS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBiZXN0X3J1bndheSA9IHJ1bndheTtcbiAgICAgICAgICAgICAgICBiZXN0X3J1bndheV9oZWFkd2luZCA9IGhlYWR3aW5kW3J1bndheV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bndheSA9IGJlc3RfcnVud2F5O1xuICAgICAgICB0aGlzLnRpbWVvdXQucnVud2F5ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZW91dCh0aGlzLnVwZGF0ZVJ1bndheSwgTWF0aC5yYW5kb20oKSAqIDMwLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2Qgc2VsZWN0UnVud2F5XG4gICAgICovXG4gICAgc2VsZWN0UnVud2F5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW53YXk7XG4gICAgfVxuXG4gICAgcGFyc2VUZXJyYWluKGRhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogcmVhc3NpZ25tZW50IG9mIHRoaXMgdG8gYXB0IGlzIG5vdCBuZWVkZWQgaGVyZS4gY2hhbmdlIGFwdCB0byB0aGlzLlxuICAgICAgICAvLyB0ZXJyYWluIG11c3QgYmUgaW4gZ2VvanNvbiBmb3JtYXRcbiAgICAgICAgY29uc3QgYXB0ID0gdGhpcztcbiAgICAgICAgYXB0LnRlcnJhaW4gPSB7fTtcblxuICAgICAgICBfZm9yRWFjaChkYXRhLmZlYXR1cmVzLCAoZikgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgZiA9IGRhdGEuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICAvLyBtID0+IGZ0LCByb3VuZGVkIHRvIDFLIChidXQgbm90IGRpdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBlbGUgPSByb3VuZChmLnByb3BlcnRpZXMuZWxldmF0aW9uIC8gMC4zMDQ4LCAxMDAwKTtcblxuICAgICAgICAgICAgaWYgKCFhcHQudGVycmFpbltlbGVdKSB7XG4gICAgICAgICAgICAgICAgYXB0LnRlcnJhaW5bZWxlXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXVsdGlwb2x5ID0gZi5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBlbnVtZXJhdGlvblxuICAgICAgICAgICAgaWYgKGYuZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlwb2x5ID0gW1ttdWx0aXBvbHldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogYWRkIGVudW1lcmF0aW9uXG4gICAgICAgICAgICBpZiAoZi5nZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICBtdWx0aXBvbHkgPSBbbXVsdGlwb2x5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJC5lYWNoKG11bHRpcG9seSwgKGksIHBvbHkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBtdWx0aXBvbHkgY29udGFpbnMgc2V2ZXJhbCBwb2x5c1xuICAgICAgICAgICAgICAgIC8vIGVhY2ggcG9seSBoYXMgMXN0IG91dGVyIHJpbmcgYW5kIG90aGVyIHJpbmdzIGFyZSBob2xlc1xuICAgICAgICAgICAgICAgIGFwdC50ZXJyYWluW2VsZV0ucHVzaCgkLm1hcChwb2x5LCAobGluZV9zdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICQubWFwKGxpbmVfc3RyaW5nLCAocHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdC5yZXZlcnNlKCk7ICAgLy8gYFBvc2l0aW9uTW9kZWxgIHJlcXVpcmVzIFtsYXQsbG9uXSBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IG5ldyBQb3NpdGlvbk1vZGVsKHB0LCBhcHQucG9zaXRpb24sIGFwdC5tYWduZXRpY19ub3J0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Bvcy5wb3NpdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgbG9hZFRlcnJhaW5cbiAgICAgKi9cbiAgICBsb2FkVGVycmFpbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc190ZXJyYWluKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGVyZSBpcyBhIGxvdCBvZiBiaW5kaW5nIGhlcmUsIHVzZSA9PiBmdW5jdGlvbnMgYW5kIHRoaXMgcHJvYmFibHkgd29udCBiZSBhbiBpc3N1ZS5cbiAgICAgICAgemxzYS5hdGMubG9hZEFzc2V0KHtcbiAgICAgICAgICAgIHVybDogYGFzc2V0cy9haXJwb3J0cy90ZXJyYWluLyR7dGhpcy5pY2FvLnRvTG93ZXJDYXNlKCl9Lmdlb2pzb25gLFxuICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0byBvblN1Y2Nlc3MgYW5kIG9uRXJyb3IgaGFuZGxlciBhYnN0cmFjdGlvbnNcbiAgICAgICAgLmRvbmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbG9nKCdQYXJzaW5nIHRlcnJhaW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGVycmFpbihkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2coZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldCgpO1xuICAgICAgICB9KVxuICAgICAgICAuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gbG9hZCBhaXJwb3J0L3RlcnJhaW4vJHt0aGlzLmljYW99OiAke3RleHRTdGF0dXN9YCk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5haXJwb3J0LmN1cnJlbnQuc2V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVJ1bihmYWxzZSk7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgemxzYS5hdGMubG9hZEFzc2V0KHtcbiAgICAgICAgICAgIHVybDogYGFzc2V0cy9haXJwb3J0cy8ke3RoaXMuaWNhby50b0xvd2VyQ2FzZSgpfS5qc29uYCxcbiAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHRoaXMub25Mb2FkQWlycG9ydFN1Y2Nlc3MocmVzcG9uc2UpKVxuICAgICAgICAuZmFpbCgoLi4uYXJncykgPT4gdGhpcy5vbkxvYWRBaXJwb3J0RXJyb3IoLi4uYXJncykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25Mb2FkQWlycG9ydFN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2Uge29iamVjdH1cbiAgICAgKi9cbiAgICBvbkxvYWRBaXJwb3J0U3VjY2VzcyA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICB0aGlzLnBhcnNlKHJlc3BvbnNlKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNfdGVycmFpbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAbWV0aG9kIG9uTG9hZEFpcnBvcnRFcnJvclxuICAgICAqIEBwYXJhbSB0ZXh0U3RhdHVzIHtzdHJpbmd9XG4gICAgICovXG4gICAgb25Mb2FkQWlycG9ydEVycm9yID0gKHsgdGV4dFN0YXR1cyB9KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBsb2FkIGFpcnBvcnQvJHt0aGlzLmljYW99OiAke3RleHRTdGF0dXN9YCk7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWlycG9ydC5jdXJyZW50LnNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBnZXRSZXN0cmljdGVkQXJlYXNcbiAgICAgKiBAcmV0dXJuIHthcnJheXxudWxsfVxuICAgICAqL1xuICAgIGdldFJlc3RyaWN0ZWRBcmVhcygpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQodGhpcywgJ3Jlc3RyaWN0ZWRfYXJlYXMnLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGEgRml4TW9kZWxcbiAgICAgKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBnZXRGaXhQb3NpdGlvblxuICAgICAqIEBwYXJhbSBmaXhOYW1lIHtzdHJpbmd9XG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgZ2V0Rml4UG9zaXRpb24oZml4TmFtZSkge1xuICAgICAgICAvLyBUT0RPOiBpZiBwb3NzaWJsZSwgcmVwbGFjZSB3aXRoIEZveENvbGxlY3Rpb24uZ2V0Rml4UG9zaXRpb25Db29yZGluYXRlc1xuICAgICAgICBjb25zdCBmaXhNb2RlbCA9IEZpeENvbGxlY3Rpb24uZmluZEZpeEJ5TmFtZShmaXhOYW1lKTtcblxuICAgICAgICByZXR1cm4gZml4TW9kZWwucG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBaXJwb3J0TW9kZWxcbiAgICAgKiBAcGFyYW0gaWQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZXhpdCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBydW53YXkge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnZXRTSUQoaWQsIGV4aXQsIHJ1bndheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRDb2xsZWN0aW9uLmZpbmRGaXhlc0ZvclNpZEJ5UnVud2F5QW5kRXhpdChpZCwgZXhpdCwgcnVud2F5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBmaW5kV2F5cG9pbnRNb2RlbHNGb3JTaWRcbiAgICAgKiBAcGFyYW0gaWQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZW50cnkge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gcnVud2F5IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGlzUHJlU3Bhd24ge2Jvb2xlYW59IGZsYWcgdXNlZCB0byBkZXRlcm1pbmUgaWYgZGlzdGFuY2VzIGJldHdlZW4gd2F5cG9pbnRzIHNob3VsZCBiZSBjYWxjdWxhdGVkXG4gICAgICogQHJldHVybiB7YXJyYXk8U3RhbmRhcmRXYXlwb2ludE1vZGVsPn1cbiAgICAgKi9cbiAgICBmaW5kV2F5cG9pbnRNb2RlbHNGb3JTaWQoaWQsIGVudHJ5LCBydW53YXksIGlzUHJlU3Bhd24gPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRDb2xsZWN0aW9uLmZpbmRGaXhNb2RlbHNGb3JSb3V0ZUJ5RW50cnlBbmRFeGl0KGlkLCBlbnRyeSwgcnVud2F5LCBpc1ByZVNwYXduKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnBvcnRNb2RlbFxuICAgICAqIEBtZXRob2QgZ2V0U0lERXhpdFBvaW50XG4gICAgICogQHBhcmFtIGljYW8ge3N0cmluZ30gIE5hbWUgb2YgU0lEXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgTmFtZSBvZiBFeGl0IGZpeCBpbiBTSURcbiAgICAgKi9cbiAgICBnZXRTSURFeGl0UG9pbnQoaWNhbykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRDb2xsZWN0aW9uLmZpbmRSYW5kb21FeGl0UG9pbnRGb3JTSURJY2FvKGljYW8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBbV2F5cG9pbnQsIGZpeFJlc3RyaWN0aW9uc10gZm9yIGEgZ2l2ZW4gU1RBUlxuICAgICAqXG4gICAgICogTm90ZTogUGFzc2luZyBhIHZhbHVlIGZvciAncnd5JyB3aWxsIGhlbHAgdGhlIGZtcyBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gICAgICogICAgICAgZGlmZmVyZW50IGJyYW5jaGVzIG9mIGEgU1RBUiwgd2hlbiBpdCBzcGxpdHMgaW50byBkaWZmZXJlbnQgcGF0aHNcbiAgICAgKiAgICAgICBmb3IgbGFuZGluZyBvbiBkaWZmZXJlbnQgcnVud2F5cyAoZWcgJ0hBV0taNCwgbGFuZGluZyBzb3V0aCcgdnNcbiAgICAgKiAgICAgICAnSEFXS1o0LCBsYW5kaW5nIG5vcnRoJykuIE5vdCBzdHJpY3RseSByZXF1aXJlZCwgYnV0IG5vdCBwYXNzaW5nXG4gICAgICogICAgICAgaXQgd2lsbCBjYXVzZSBhbiBpbmNvbXBsZXRlIHJvdXRlIGluIG1hbnkgY2FzZXMgKGRlcGVuZHMgb24gdGhlXG4gICAgICogICAgICAgZGVzaWduIG9mIHRoZSBhY3R1YWwgU1RBUiBpbiB0aGUgYWlycG9ydCdzIGpzb24gZmlsZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWRlbnRpZmllciBmb3IgdGhlIFNUQVIgKGVnICdMRU5EWTYnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeSAtIHRoZSBlbnRyeVBvaW50IGZyb20gd2hpY2ggdG8gam9pbiB0aGUgU1RBUlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByd3kgLSAob3B0aW9uYWwpIHRoZSBwbGFubmVkIGFycml2YWwgcnVud2F5XG4gICAgICogQHJldHVybiB7YXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRTVEFSKGlkLCBlbnRyeSwgcnd5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJDb2xsZWN0aW9uLmZpbmRGaXhlc0ZvclN0YXJCeUVudHJ5QW5kUnVud2F5KGlkLCBlbnRyeSwgcnd5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBmb3IgQWlycG9ydE1vZGVsXG4gICAgICogQG1ldGhvZCBmaW5kV2F5cG9pbnRNb2RlbHNGb3JTdGFyXG4gICAgICogQHBhcmFtIGlkIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGVudHJ5IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHJ1bndheSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBpc1ByZVNwYXduIHtib29sZWFufSBmbGFnIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGRpc3RhbmNlcyBiZXR3ZWVuIHdheXBvaW50cyBzaG91bGQgYmUgY2FsY3VsYXRlZFxuICAgICAqIEByZXR1cm4ge2FycmF5PFN0YW5kYXJkV2F5cG9pbnRNb2RlbD59XG4gICAgICovXG4gICAgZmluZFdheXBvaW50TW9kZWxzRm9yU3RhcihpZCwgZW50cnksIHJ1bndheSwgaXNQcmVTcGF3biA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJDb2xsZWN0aW9uLmZpbmRGaXhNb2RlbHNGb3JSb3V0ZUJ5RW50cnlBbmRFeGl0KGlkLCBlbnRyeSwgcnVud2F5LCBpc1ByZVNwYXduKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0UnVud2F5KG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bndheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bndheXNbaV1bMF0ubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVud2F5c1tpXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bndheXNbaV1bMV0ubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVud2F5c1tpXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsImltcG9ydCBfaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgX2lzTnVtYmVyIGZyb20gJ2xvZGFzaC9pc051bWJlcic7XG5pbXBvcnQgX21hcCBmcm9tICdsb2Rhc2gvbWFwJztcbmltcG9ydCBCYXNlTW9kZWwgZnJvbSAnLi4vYmFzZS9CYXNlTW9kZWwnO1xuaW1wb3J0IFBvc2l0aW9uTW9kZWwgZnJvbSAnLi4vYmFzZS9Qb3NpdGlvbk1vZGVsJztcbmltcG9ydCB7IGNvbnZlcnRUb1Rob3VzYW5kcyB9IGZyb20gJy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5cbi8qKlxuICogQW4gZW5jbG9zZWQgcmVnaW9uIGRlZmluZWQgYnkgYSBzZXJpZXMgb2YgUG9zaXRpb24gb2JqZWN0cyBhbmQgYW4gYWx0aXR1ZGUgcmFuZ2VcbiAqXG4gKiBAY2xhc3MgQWlyc3BhY2VNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBaXJzcGFjZU1vZGVsIGV4dGVuZHMgQmFzZU1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnNwYWNlTW9kZWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWlyc3BhY2Uge29iamVjdH1cbiAgICAgKiBAcGFyYW0gYWlycG9ydFBvc2l0aW9uIHtQb3NpdGlvbk1vZGVsfVxuICAgICAqIEBwYXJhbSBtYWduZXRpY05vcnRoIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWlyc3BhY2UsIGFpcnBvcnRQb3NpdGlvbiwgbWFnbmV0aWNOb3J0aCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmICghYWlyc3BhY2UgfHwgIWFpcnBvcnRQb3NpdGlvbiB8fCAhX2lzTnVtYmVyKG1hZ25ldGljTm9ydGgpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIsIGV4cGVjdGVkIGFpcnNwYWNlLCBhaXJwb3J0UG9zaXRpb24gYW5kIG1hZ25ldGljTm9ydGggdG8gYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgbGF0L2xvbmcgY29vcmRpbmF0ZXMgdGhhdCBvdXRsaW5lIHRoZSBzaGFwZSBvZiB0aGUgYXJlYVxuICAgICAgICAgKlxuICAgICAgICAgKiBETyBOT1QgcmVwZWF0IHRoZSBvcmlnaW4gdG8gJ2Nsb3NlJyB0aGUgc2hhcGUsIHRoaXMgaGFwcGVucyBwcm9ncmFtYXRpY2FsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHBvbHlcbiAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsdGl0dWRlIGF0IGJvdHRvbSBvZiBhcmVhLCBpbiBodW5kcmVkcyBvZiBmZWV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmbG9vclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG9vciA9IC0xO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbHRpdHVkZSBvZiB0b3Agb2YgYXJlYSwgaW4gaHVuZHJlZHMgb2YgZmVldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgY2VpbGluZ1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWlsaW5nID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZBQSBhaXJzcGFjZSBjbGFzc2lmaWNhdGlvbiAoQSxCLEMsRCxFLEcpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhaXJzcGFjZV9jbGFzc1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5haXJzcGFjZV9jbGFzcyA9ICcnO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KGFpcnNwYWNlLCBhaXJwb3J0UG9zaXRpb24sIG1hZ25ldGljTm9ydGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIG1vZGVsXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcnNwYWNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIF9pbml0XG4gICAgICogQHBhcmFtIGFpcnNwYWNlIHthcnJheX1cbiAgICAgKiBAcGFyYW0gYWlycG9ydFBvc2l0aW9uIHtQb3NpdGlvbk1vZGVsfVxuICAgICAqIEBwYXJhbSBtYWduZXRpY05vcnRoIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdChhaXJzcGFjZSwgYWlycG9ydFBvc2l0aW9uLCBtYWduZXRpY05vcnRoKSB7XG4gICAgICAgIHRoaXMuZmxvb3IgPSBjb252ZXJ0VG9UaG91c2FuZHMoYWlyc3BhY2UuZmxvb3IpO1xuICAgICAgICB0aGlzLmNlaWxpbmcgPSBjb252ZXJ0VG9UaG91c2FuZHMoYWlyc3BhY2UuY2VpbGluZyk7XG4gICAgICAgIHRoaXMuYWlyc3BhY2VfY2xhc3MgPSBhaXJzcGFjZS5haXJzcGFjZV9jbGFzcztcbiAgICAgICAgdGhpcy5wb2x5ID0gdGhpcy5fYnVpbGRQb2x5UG9zaXRpb25Nb2RlbHMoYWlyc3BhY2UucG9seSwgYWlycG9ydFBvc2l0aW9uLCBtYWduZXRpY05vcnRoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFpcnNwYWNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucG9seSA9IFtdO1xuICAgICAgICB0aGlzLmZsb29yID0gLTE7XG4gICAgICAgIHRoaXMuY2VpbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmFpcnNwYWNlX2NsYXNzID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUG9zaXRpb25Nb2RlbCBmb3IgZWFjaCBwb2x5IGxpc3RlZCBpbiBgYWlyc3BhY2UucG9seWAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGFzdCBlbnRyeSBpcyB0aGUgc2FtZSBhcyB0aGUgZmlyc3QsIHJlbW92ZSBpdCBiZWNhdXNlIHRoZSBwYXRoIHdpbGwgYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAZm9yIEFpcnNwYWNlTW9kZWxcbiAgICAgKiBAbWV0aG9kIF9idWlsZFBvbHlQb3NpdGlvbk1vZGVsc1xuICAgICAqIEBwYXJhbSBwb2x5TGlzdCB7YXJyYXl9XG4gICAgICogQHBhcmFtIGFpcnBvcnRQb3NpdGlvbiB7UG9zaXRpb25Nb2RlbH1cbiAgICAgKiBAcGFyYW0gbWFnbmV0aWNOb3J0aCB7bnVtYmVyfVxuICAgICAqIEByZXR1cm4gcG9seVBvc2l0aW9uTW9kZWxzIHthcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9idWlsZFBvbHlQb3NpdGlvbk1vZGVscyhwb2x5TGlzdCwgYWlycG9ydFBvc2l0aW9uLCBtYWduZXRpY05vcnRoKSB7XG4gICAgICAgIGNvbnN0IHBvbHlQb3NpdGlvbk1vZGVscyA9IF9tYXAocG9seUxpc3QsIChwb2x5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uTW9kZWwocG9seSwgYWlycG9ydFBvc2l0aW9uLCBtYWduZXRpY05vcnRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHBvbHlQb3NpdGlvbk1vZGVscy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGlmIChfaXNFcXVhbChwb2x5UG9zaXRpb25Nb2RlbHNbZmlyc3RJbmRleF0ucG9zaXRpb24sIHBvbHlQb3NpdGlvbk1vZGVsc1tsYXN0SW5kZXhdLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgLy8gc2hhcGUgc2hvdWxkbid0IGZ1bGx5IGNsb3NlOyB3aWxsIGRyYXcgd2l0aCAnY2MuY2xvc2VwYXRoKCknIHNvIHdlIHJlbW92ZSB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICBwb2x5UG9zaXRpb25Nb2RlbHMucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seVBvc2l0aW9uTW9kZWxzO1xuICAgIH1cbn1cbiIsImltcG9ydCBfZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgX3JhbmRvbSBmcm9tICdsb2Rhc2gvcmFuZG9tJztcbmltcG9ydCBGaXhDb2xsZWN0aW9uIGZyb20gJy4uL0ZpeC9GaXhDb2xsZWN0aW9uJztcbmltcG9ydCBSb3V0ZU1vZGVsIGZyb20gJy4uL1JvdXRlL1JvdXRlTW9kZWwnO1xuaW1wb3J0IFBvc2l0aW9uTW9kZWwgZnJvbSAnLi4vLi4vYmFzZS9Qb3NpdGlvbk1vZGVsJztcbmltcG9ydCB7XG4gICAgYWlybGluZU5hbWVBbmRGbGVldEhlbHBlcixcbiAgICByYW5kb21BaXJsaW5lU2VsZWN0aW9uSGVscGVyXG59IGZyb20gJy4uLy4uL2FpcmxpbmUvcmFuZG9tQWlybGluZVNlbGVjdGlvbkhlbHBlcic7XG5pbXBvcnQgeyBubSwgZGVncmVlc1RvUmFkaWFucyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5pbXBvcnQgeyByb3VuZCwgc2luLCBjb3MgfSBmcm9tICcuLi8uLi9tYXRoL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBiZWFyaW5nLFxuICAgIGZpeFJhZGlhbERpc3QsXG4gICAgaXNXaXRoaW5BaXJzcGFjZSxcbiAgICBjYWxjdWxhdGVEaXN0YW5jZVRvQm91bmRhcnksXG4gICAgYmVhcmluZ1RvUG9pbnRcbn0gZnJvbSAnLi4vLi4vbWF0aC9mbGlnaHRNYXRoJztcbmltcG9ydCB7IEZMSUdIVF9DQVRFR09SWSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9haXJjcmFmdENvbnN0YW50cyc7XG5pbXBvcnQgeyBBSVJQT1JUX0NPTlNUQU5UUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9haXJwb3J0Q29uc3RhbnRzJztcbmltcG9ydCB7IFRJTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2xvYmFsQ29uc3RhbnRzJztcbmltcG9ydCB7IExPRyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9sb2dMZXZlbCc7XG5cbi8qKlxuICogQHByb3BlcnR5IElOVEVSVkFMX0RFTEFZX0lOX01TXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IElOVEVSVkFMX0RFTEFZX0lOX01TID0gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTO1xuXG4vLyBUT0RPOiB0aGlzIHNob3VsZG4ndCBsaXZlIGhlcmUuIHBlcmhhcHMgbW92ZSB0byBgRml4Q29sbGVjdGlvbmAgYXMgYW4gZXhwb3J0ZWQgZnVuY3Rpb24/XG4vKipcbiAqIEVuY2Fwc3VsYXRpb24gb2YgYSBgRml4Q29sbGVjdGlvbmAgbWV0aG9kLlxuICpcbiAqIFRoaXMgYWxsb3dzIGZvciBjZW50cmFsaXphdGlvbiBvZiB0aGlzIGxvZ2ljLCB3aGlsZSBhdm9pZGluZyB0aGUgbmVlZCBmb3JcbiAqIGFub3RoZXIgY2xhc3MgbWV0aG9kLlxuICpcbiAqIEBtZXRob2QgZ2V0Rml4UG9zdGlpb25cbiAqIEBwYXJhbSBmaXhOYW1lIHtzdHJpbmd9XG4gKiBAcmV0dXJuIGZpeC5wb3NpdGlvbiB7YXJyYXl9XG4gKi9cbmNvbnN0IGdldEZpeFBvc2l0aW9uID0gKGZpeE5hbWUpID0+IHtcbiAgICBjb25zdCBmaXggPSBGaXhDb2xsZWN0aW9uLmZpbmRGaXhCeU5hbWUoZml4TmFtZSk7XG5cbiAgICByZXR1cm4gZml4LnBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhcnJpdmFscyBhdCByYW5kb20sIGF2ZXJhZ2luZyB0aGUgc3BlY2lmaWVkIGFycml2YWwgcmF0ZVxuICpcbiAqIEBjbGFzcyBBcnJpdmFsQmFzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcnJpdmFsQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGZvciBBcnJpdmFsQmFzZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0SW5zdGFuY2VNb2RlbH1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFpcnBvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRklYTUU6IHRoaXMgY3JlYXRlcyBhIGNpcmN1bGFyIHJlZmVyZW5jZSBhbmQgc2hvdWxkIGJlIHJlZmFjdG9yZWRcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFpcnBvcnQgdGhhdCBhcnJpdmFscyBiZWxvbmcgdG9cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGFpcnBvcnRcbiAgICAgICAgICogQHR5cGUge0FpcnBvcnRJbnN0YW5jZU1vZGVsfVxuICAgICAgICAgKiBAZGVmYXVsdCBhaXJwb3J0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFpcnBvcnQgPSBhaXJwb3J0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGFpcmxpbmVzIHdpdGggd2VpZ2h0IGZvciBlYWNoXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhaXJsaW5lc1xuICAgICAgICAgKiBAdHlwZSB7YXJyYXlbXX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWlybGluZXMgPSBbXTtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIG5lZWRzIGEgYmV0dGVyIG5hbWUuIHRoaXMgaXMgYWN0dWFsbHkgZml4ZXMgZm9yIGEgcm91dGVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiBmaXhlcyB0byB0cmF2ZXJzZSAoZWcuIGZvciBTVEFScykgYXMgZGVmaW5lZCBpbiB0aGUgYWlycG9ydCBqc29uIGZpbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNwYXduIG9jY3VycyBhdCBmaXJzdCBmaXggbGlzdGVkLlxuICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGdldHMgc2VudCB0byBhbiBgQWlycG9ydEluc3RhbmNlTW9kZWxgIGFuZCBiZWNvbWVzIHRoYXQgYWlyY3JhZnQnc1xuICAgICAgICAgKiB3YXlwb2ludCBsaXN0IGluIHRoZSBmbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmaXhlc1xuICAgICAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpeGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcmVwcmVzZW50YXRpb24gb2YgYSBgU3RhbmRhcmRSb3V0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBSb3V0ZU1vZGVsYCBvYmplY3QgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZGVhbGluZyB3aXRoIGEgcm91dGUgc3RyaW5nLlxuICAgICAgICAgKiBFeHBlY3RzIHN0cmluZyB0byBiZSBpbiB0aGUgc2hhcGUgb2Y6XG4gICAgICAgICAqIC0gYE9SSUdJTl9GSVhOQU1FLlJPVVRFX05BTUUuREVTVElOQVRJT05fRklYTkFNRWBcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGFjdGl2ZVJvdXRlTW9kZWxcbiAgICAgICAgICogQHR5cGUge1JvdXRlTW9kZWx9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlUm91dGVNb2RlbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsdGl0dWRlIGluIGZlZXQgb3IgbWluL21heCByYW5nZSBvZiBhbHRpdHVkZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQWx0aXR1ZGUgbWF5IGJlIHBhc3NlZCBpbiBhcyBlaXRoZXIgYW4gYXJyYXkgb2YgYWx0aXR1ZGVzIFttaW4sIG1heF0sIG9yIGFzIGEgc2luZ2xlIG51bWJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGFsdGl0dWRlXG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW0FJUlBPUlRfQ09OU1RBTlRTLkRFRkFVTFRfU1BBV05fQUxUSVRVREVfTUlOLCBBSVJQT1JUX0NPTlNUQU5UUy5ERUZBVUxUX1NQQVdOX0FMVElUVURFX01BWF1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBbQUlSUE9SVF9DT05TVEFOVFMuREVGQVVMVF9TUEFXTl9BTFRJVFVERV9NSU4sIEFJUlBPUlRfQ09OU1RBTlRTLkRFRkFVTFRfU1BBV05fQUxUSVRVREVfTUFYXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbCBoZWFkaW5nIG9mIGEgc3Bhd25lZCBhaXJjcmFmdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgaGVhZGluZ1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRpbmcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWFyaW5nIGZyb20gYWlyc3BhY2UgY2VudGVyIHRvIHNwYXduIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBTaG91bGRuJ3QgYmUgdXNlZCB3aXRoIGZpeGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSByYWRpYWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpYWwgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnYW1lIHRpbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGN5Y2xlU3RhcnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jeWNsZVN0YXJ0ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3VyZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG9mZnNldFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDMwIG1pbnV0ZSBjeWNsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgcGVyaW9kXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDE4MDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVyaW9kID0gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gMjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbCBzcGVlZCBpbiBrbm90cyBvZiBzcGF3bmVkIGFpcmNyYWZ0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgc3BlZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgQUlSUE9SVF9DT05TVEFOVFMuREVGQVVMVF9TUEFXTl9BSVJDUkFGVF9TUEVFRF9LVFNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3BlZWQgPSBBSVJQT1JUX0NPTlNUQU5UUy5ERUZBVUxUX1NQQVdOX0FJUkNSQUZUX1NQRUVEX0tUUztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyaXZhbCByYXRlIGFsb25nIHRoaXMgc3RyZWFtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOdW1iZXIgcmVwcmVzZW50cyBhaXJjcmFmdCBwZXIgaG91ciAoYWNwaClcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGZyZXF1ZW5jeVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0aW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhcnNlKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYXJyaXZhbCBzdHJlYW1cbiAgICAgKlxuICAgICAqIEBmb3IgQXJyaXZhbEJhc2VcbiAgICAgKiBAbWV0aG9kIHBhcnNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBhcnNlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5haXJsaW5lcyA9IF9nZXQob3B0aW9ucywgJ2FpcmxpbmVzJywgdGhpcy5haXJsaW5lcyk7XG4gICAgICAgIHRoaXMuYWx0aXR1ZGUgPSBfZ2V0KG9wdGlvbnMsICdhbHRpdHVkZScsIHRoaXMuYWx0aXR1ZGUpO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IF9nZXQob3B0aW9ucywgJ2ZyZXF1ZW5jeScsIHRoaXMuZnJlcXVlbmN5KTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IF9nZXQob3B0aW9ucywgJ3NwZWVkJywgdGhpcy5zcGVlZCk7XG5cbiAgICAgICAgLy8gTWFrZSBjb3JyZWN0aW9ucyB0byBkYXRhXG4gICAgICAgIGlmIChvcHRpb25zLnJhZGlhbCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpYWwgPSBkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMucmFkaWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGluZyA9IGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5oZWFkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsdGl0dWRlIG1heSBiZSBwYXNzZWQgaW4gYXMgZWl0aGVyIGFuIGFycmF5IG9mIGFsdGl0dWRlcyBbbWluLCBtYXhdLCBvciBhcyBhIHNpbmdsZSBudW1iZXIuXG4gICAgICAgIC8vIGhlcmUgd2UgY2hlY2sgZm9yIHRoZSBzaW5nbGUgbnVtYmVyIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIFttaW4sIG1heF0gZm9ybWF0LlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYWx0aXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmFsdGl0dWRlID0gW3RoaXMuYWx0aXR1ZGUsIHRoaXMuYWx0aXR1ZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUm91dGVNb2RlbCA9IG5ldyBSb3V0ZU1vZGVsKG9wdGlvbnMucm91dGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZml4ZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbWF5IG5vdCBiZSBuZWVkZWQgYXQgYWxsLiB3ZSBjb3VsZCBqdXN0IHVzZSBgX2dldCgpYCBpbnN0ZWFkLlxuICAgICAgICAgICAgLy8gYHRoaXMuZml4ZXNgIGV2ZW50dWFsbHkgbWFrZXMgaXRzIHdheSB0byB0aGUgYEFpcmNyYWZ0SW5zdGFuY2VNb2RlbC5mbXNgIHZpYVxuICAgICAgICAgICAgLy8gYEFpcmNyYWZ0SW5zdGFuY2VNb2RlbC5zZXRBcnJpdmFsV2F5cG9pbnRzKClgLiB0aGF0IG1ldGhvZCBzaW1wbHkgYnVpbGRzIGFub3RoZXIgb2JqZWN0IGFuZFxuICAgICAgICAgICAgLy8gcHVsbHMgZWFjaCBpdGVtIGZyb20gdGhpcyBhcnJheS4gY3JlYXRpbmcgYW4gb2JqZWN0IGhlcmUgaXMgZG9lc24ndCBhcHBlYXIgdG8gc2VydmUgYW55IHJlYWwgcHVycG9zZS5cbiAgICAgICAgICAgIHRoaXMuZml4ZXMgPSBfbWFwKG9wdGlvbnMuZml4ZXMsIChmaXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmaXg6IGZpeFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlbG9hZEFpcmxpbmVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9vcCB0aHJvdWdoIGVhY2ggYWlybGluZSBwcm92aWRlZCBmcm9tIGFuIGFpcnBvcnQganNvbiBhbmQgZW5zdXJlIGl0IGhhZCBiZWVuIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBmb3IgQXJyaXZhbEJhc2VcbiAgICAgKiBAbWV0aG9kIHByZWxvYWRBaXJsaW5lc1xuICAgICAqL1xuICAgIHByZWxvYWRBaXJsaW5lcygpIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyByZWFsbHkgZG9lc24ndCBiZWxvbmcgaGVyZSBhbmQgc2hvdWxkIGJlIG1vdmVkXG4gICAgICAgIC8vIFByZS1sb2FkIHRoZSBhaXJsaW5lc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWlybGluZXMubGVudGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWlybGluZSA9IHRoaXMuYWlybGluZXNbaV07XG4gICAgICAgICAgICAvLyByZWFzc2lnbnMgYGFpcmxpbmUubmFtZWAgdG8gYGFpcmxpbmVOYW1lYCBmb3IgcmVhZGFiaWxpdHlcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogYWlybGluZU5hbWUgfSA9IGFpcmxpbmVOYW1lQW5kRmxlZXRIZWxwZXIoYWlybGluZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5haXJsaW5lQ29udHJvbGxlci5haXJsaW5lX2dldChhaXJsaW5lTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZmlsbCBTVEFSIHJvdXRlcyB3aXRoIGFycml2YWxzIGNsb3NlciB0aGFuIHRoZSBzcGF3biBwb2ludC5cbiAgICAgKlxuICAgICAqIFNob3VsZCBiZSBydW4gb25seSBvbmNlIG9uIGFpcnBvcnQgbG9hZC5cbiAgICAgKlxuICAgICAqIEFpcmNyYWZ0IHNwYXduIGF0IHRoZSBmaXJzdCBwb2ludCBkZWZpbmVkIGluIHRoZSBgYXJyaXZhbHNgIGVudHJ5IG9mIHRoZSBhaXJwb3J0IGpzb24gZmlsZS5cbiAgICAgKiBXaGVuIHRoYXQgc3Bhd24gcG9pbnQgaXMgdmVyeSBmYXIgZnJvbSB0aGUgYWlyc3BhY2UgYm91bmRhcnksIGl0IG9idmlvdXNseSB0YWtlcyBxdWl0ZSBhXG4gICAgICogd2hpbGUgZm9yIHRoZW0gdG8gcmVhY2ggdGhlIGFpcnNwYWNlLiBUaGlzIGZ1bmN0aW9uIHNwYXducyAoYWxsIGF0IG9uY2UpIGFycml2YWxzIGFsb25nXG4gICAgICogdGhlIHJvdXRlLCBiZXR3ZWVuIHRoZSBzcGF3biBwb2ludCBhbmQgdGhlIGFpcnNwYWNlIGJvdW5kYXJ5LCBpbiBvcmRlciB0b1xuICAgICAqIGVuc3VyZSB0aGUgcGxheWVyIGlzIG5vdCBrZXB0IHdhaXRpbmcgZm9yIHRoZWlyIGZpcnN0IGFycml2YWwgYWlyY3JhZnQuXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxCYXNlXG4gICAgICogQG1ldGhvZCBwcmVTcGF3blxuICAgICAqL1xuICAgIHByZVNwYXduKCkge1xuICAgICAgICAvLyBmaW5kIGxhc3QgZml4IGFsb25nIFNUQVIgdGhhdCBpcyBvdXRzaWRlIG9mIGFpcnNwYWNlLCBpZTogbmV4dCBmaXggaXMgd2l0aGluIGFpcnNwYWNlXG4gICAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY2xvc2VzdCBmaXggb3V0c2lkZSBhaXJzcGFjZSBhbmQgYWlyc3BhY2UgYm9yZGVyIGluIG5tXG4gICAgICAgIGxldCBleHRyYSA9IDA7XG4gICAgICAgIGxldCB0b3RhbERpc3RhbmNlID0gMDtcbiAgICAgICAgY29uc3QgaXNQcmVTcGF3biA9IHRydWU7XG4gICAgICAgIGNvbnN0IHdheXBvaW50TW9kZWxMaXN0ID0gdGhpcy5haXJwb3J0LmZpbmRXYXlwb2ludE1vZGVsc0ZvclN0YXIoXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJvdXRlTW9kZWwucHJvY2VkdXJlLFxuICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3V0ZU1vZGVsLmVudHJ5LFxuICAgICAgICAgICAgdGhpcy5haXJwb3J0LnJ1bndheSxcbiAgICAgICAgICAgIGlzUHJlU3Bhd25cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdheXBvaW50TW9kZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3YXlwb2ludCA9IHdheXBvaW50TW9kZWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnRQb3NpdGlvbiA9IHdheXBvaW50LnBvc2l0aW9uO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzV2F5cG9pbnQgPSB3YXlwb2ludDtcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1Bvc2l0aW9uID0gd2F5cG9pbnQucG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzV2F5cG9pbnQgPSB3YXlwb2ludE1vZGVsTGlzdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHByZXZpb3VzV2F5cG9pbnQucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1dpdGhpbkFpcnNwYWNlKHRoaXMuYWlycG9ydCwgd2F5cG9pbnRQb3NpdGlvbikgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICBleHRyYSA9IG5tKGNhbGN1bGF0ZURpc3RhbmNlVG9Cb3VuZGFyeSh0aGlzLmFpcnBvcnQsIHByZXZpb3VzUG9zaXRpb24pKTtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IHdheXBvaW50LmRpc3RhbmNlRnJvbVByZXZpb3VzV2F5cG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRTogaW5jbHVpbmcgdGhpcyBjYXVzZXMgYWlyY3JhZnQgdG8gc3Bhd24gd2l0aGluIGFpcnNwYWNlLiBzb21ldGhpbmcgZ29vZnkgaXMgZ29pbmcgb24gaGVyZS5cbiAgICAgICAgLy8gdG90YWxEaXN0YW5jZSArPSBleHRyYTtcblxuICAgICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggYXJyaXZpbmcgYWlyY3JhZnQsIGluIG5tXG4gICAgICAgIGNvbnN0IGVudHJhaWxEaXN0YW5jZSA9IHRoaXMuc3BlZWQgLyB0aGlzLmZyZXF1ZW5jeTtcbiAgICAgICAgY29uc3Qgc3Bhd25PZmZzZXRzID0gdGhpcy5hc3NlbWJsZVNwYXduT2Zmc2V0cyhlbnRyYWlsRGlzdGFuY2UsIHRvdGFsRGlzdGFuY2UpO1xuICAgICAgICBjb25zdCBzcGF3blBvc2l0aW9ucyA9IHRoaXMuY2FsY3VsYXRlU3Bhd25Qb3NpdGlvbnMod2F5cG9pbnRNb2RlbExpc3QsIHNwYXduT2Zmc2V0cyk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVBaXJjcmFmdEF0U3Bhd25Qb3NpdGlvbnMoc3Bhd25Qb3NpdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXJyaXZhbEJhc2VcbiAgICAgKiBAbWV0aG9kIGFzc2VtYmxlU3Bhd25PZmZzZXRzXG4gICAgICogQHBhcmFtIGVudHJhaWxEaXN0YW5jZSB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB0b3RhbERpc3RhbmNlIHtudW1iZXJ9XG4gICAgICogQHJldHVybiBzcGF3bk9mZnNldHMge2FycmF5fVxuICAgICAqL1xuICAgIGFzc2VtYmxlU3Bhd25PZmZzZXRzKGVudHJhaWxEaXN0YW5jZSwgdG90YWxEaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBzcGF3bk9mZnNldHMgPSBbXTtcblxuICAgICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHN1Y2Nlc3NpdmUgYXJyaXZhbHMgaW4gbm1cbiAgICAgICAgZm9yIChsZXQgaSA9IGVudHJhaWxEaXN0YW5jZTsgaSA8IHRvdGFsRGlzdGFuY2U7IGkgKz0gZW50cmFpbERpc3RhbmNlKSB7XG4gICAgICAgICAgICBzcGF3bk9mZnNldHMucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGF3bk9mZnNldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBBcnJpdmFsQmFzZVxuICAgICAqIEBtZXRob2QgY2FsY3VsYXRlU3Bhd25Qb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0gd2F5cG9pbnRNb2RlbExpc3Qge2FycmF5PFN0YW5kYXJkV2F5cG9pbnRNb2RlbD59XG4gICAgICogQHBhcmFtIHNwYXduT2Zmc2V0cyB7YXJyYXl9XG4gICAgICogQHJldHVybiBzcGF3blBvc2l0aW9ucyB7YXJyYXl9XG4gICAgICovXG4gICAgY2FsY3VsYXRlU3Bhd25Qb3NpdGlvbnMod2F5cG9pbnRNb2RlbExpc3QsIHNwYXduT2Zmc2V0cykge1xuICAgICAgICBjb25zdCBzcGF3blBvc2l0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIGZvciBlYWNoIG5ldyBhaXJjcmFmdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXduT2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYXduT2Zmc2V0ID0gc3Bhd25PZmZzZXRzW2ldO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBmaXggYWhlYWRcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgd2F5cG9pbnRNb2RlbExpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXlwb2ludCA9IHdheXBvaW50TW9kZWxMaXN0W2pdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNwYXduT2Zmc2V0ID4gd2F5cG9pbnQuZGlzdGFuY2VGcm9tUHJldmlvdXNXYXlwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwb2ludCBiZXlvbmQgbmV4dCBmaXggc3VidHJhY3QgZGlzdGFuY2UgZnJvbSBzcGF3bk9mZnNldCBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25PZmZzZXQgLT0gd2F5cG9pbnQuZGlzdGFuY2VGcm9tUHJldmlvdXNXYXlwb2ludDtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwb2ludCBiZWZvcmUgbmV4dCBmaXhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEZpeCA9IHdheXBvaW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpeCA9IHdheXBvaW50TW9kZWxMaXN0W2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IGJlYXJpbmdUb1BvaW50KHByZXZpb3VzRml4Lmdwc1hZLCBuZXh0Rml4Lmdwc1hZKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25Qb2ludCA9IGZpeFJhZGlhbERpc3QocHJldmlvdXNGaXguZ3BzLCBoZWFkaW5nLCBzcGF3bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBuZXcgUG9zaXRpb25Nb2RlbChzcGF3blBvaW50LCB0aGlzLmFpcnBvcnQucG9zaXRpb24sIHRoaXMuYWlycG9ydC5tYWduZXRpY19ub3J0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBsb29rcyBsaWtlIGl0IHNob3VsZCBiZSBhIG1vZGVsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBzcGF3blBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHNwYXduUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Rml4OiBuZXh0Rml4Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwYXduUG9zaXRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGBzcGF3blBvc2l0aW9uc2AsIGNyZWF0ZSBuZXcgYWlyY3JhZnQgZm9yIGVhY2ggYHNwYXduUG9zaXRpb25gXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxCYXNlXG4gICAgICogQG1ldGhvZCBjcmVhdGVBaXJjcmFmdEF0U3Bhd25Qb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0gc3Bhd25Qb3NpdGlvbnMge2FycmF5fVxuICAgICAqL1xuICAgIGNyZWF0ZUFpcmNyYWZ0QXRTcGF3blBvc2l0aW9ucyhzcGF3blBvc2l0aW9ucykge1xuICAgICAgICAvLyBTcGF3biBhaXJjcmFmdCBhbG9uZyB0aGUgcm91dGUsIGFoZWFkIG9mIHRoZSBzdGFuZGFyZCBzcGF3biBwb2ludFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXduUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRpbmcsIHBvcywgbmV4dEZpeCB9ID0gc3Bhd25Qb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCB7IGljYW8gfSA9IHRoaXMuYWlycG9ydDtcbiAgICAgICAgICAgIGNvbnN0IGFpcmxpbmUgPSByYW5kb21BaXJsaW5lU2VsZWN0aW9uSGVscGVyKHRoaXMuYWlybGluZXMpO1xuICAgICAgICAgICAgY29uc3QgYWlyY3JhZnRUb0FkZCA9IHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogRkxJR0hUX0NBVEVHT1JZLkFSUklWQUwsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IGljYW8sXG4gICAgICAgICAgICAgICAgYWlybGluZTogYWlybGluZS5uYW1lLFxuICAgICAgICAgICAgICAgIGZsZWV0OiBhaXJsaW5lLmZsZWV0LFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBldmVudHVhbGx5IGxvb2sgdXAgYWx0aXR1ZGUgcmVzdHJpY3Rpb25zIGFuZCB0cnkgdG8gc3Bhd24gaW4gYW4gYXBwcm9wcmlhdGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICB0aGlzIGNhbiBiZSBkb25lIHdpdGggdGhlIGB3YXlwb2ludE1vZGVsTGlzdGAgYW5kIGBTdGFuZGFyZFdheXBvaW50TW9kZWxgIG9iamVjdHMsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgaW4gY29uanVudGlvbiB3aXRoIHRoZSBgUm91dGVNb2RlbGAuXG4gICAgICAgICAgICAgICAgYWx0aXR1ZGU6IDEwMDAwLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgYSBfZ2V0KCkgaW5zdGVhZCBvZiBhbiB8fCBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgaGVhZGluZzogaGVhZGluZyB8fCB0aGlzLmhlYWRpbmcsXG4gICAgICAgICAgICAgICAgd2F5cG9pbnRzOiB0aGlzLmZpeGVzLFxuICAgICAgICAgICAgICAgIHJvdXRlOiBfZ2V0KHRoaXMsICdhY3RpdmVSb3V0ZU1vZGVsLnJvdXRlQ29kZScsICcnKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHNwZWVkOiB0aGlzLnNwZWVkLFxuICAgICAgICAgICAgICAgIG5leHRGaXg6IG5leHRGaXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdpbmRvdy5haXJjcmFmdENvbnRyb2xsZXIuYWlyY3JhZnRfbmV3KGFpcmNyYWZ0VG9BZGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGlzIGFycml2YWwgc3RyZWFtXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxCYXNlXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfY2xlYXJfdGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhpcyBhcnJpdmFsIHN0cmVhbVxuICAgICAqXG4gICAgICogQGZvciBBcnJpdmFsQmFzZVxuICAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gVE9ETzogd2hhdCBkbyB0aGVzZSBudW1iZXJzIG1lYW4/IGVudW1lcmF0ZSB0aGUgbWFnaWMgbnVtYmVycy5cbiAgICAgICAgY29uc3QgZGVsYXkgPSBfcmFuZG9tKDAsIFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIHRoaXMuZnJlcXVlbmN5KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZW91dCh0aGlzLnNwYXduQWlyY3JhZnQsIGRlbGF5LCB0aGlzLCBbdHJ1ZSwgdHJ1ZV0pO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVJvdXRlTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJlU3Bhd24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgbWV0aG9kIHNob3VsZCBhY2NlcHQgZXhwbGljaXQgYXJndW1lbnRzXG4gICAgLyoqXG4gICAgICogU3Bhd24gYSBuZXcgYWlyY3JhZnRcbiAgICAgKlxuICAgICAqIEBmb3IgQXJyaXZhbEJhc2VcbiAgICAgKiBAbWV0aG9kIHNwYXduQWlyY3JhZnRcbiAgICAgKi9cbiAgICBzcGF3bkFpcmNyYWZ0KGFyZ3MpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICBsZXQgaGVhZGluZztcbiAgICAgICAgbGV0IGRpc3RhbmNlO1xuICAgICAgICAvLyBhcmdzID0gW2Jvb2xlYW4sIGJvb2xlYW5dXG4gICAgICAgIGNvbnN0IGFsdGl0dWRlID0gcm91bmQoX3JhbmRvbSh0aGlzLmFsdGl0dWRlWzBdLCB0aGlzLmFsdGl0dWRlWzFdKSAvIDEwMDApICogMTAwMDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICEod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZSgpIC0gdGhpcy5haXJwb3J0LnN0YXJ0IDwgMik7XG4gICAgICAgIGNvbnN0IGFpcmxpbmUgPSByYW5kb21BaXJsaW5lU2VsZWN0aW9uSGVscGVyKHRoaXMuYWlybGluZXMpO1xuICAgICAgICAvLyBXaGF0IGlzIHRoaXMgbmV4dCB2YXJpYWJsZSBmb3IsIHdoeSBpcyBpdCBoZXJlIGFuZCBjYW4gaXQgYmUgcmVtb3ZlZD9cbiAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgY29uc3Qgc3RhcnRfZmxhZyA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IHRpbWVvdXRfZmxhZyA9IGFyZ3NbMV0gfHwgZmFsc2U7XG5cbiAgICAgICAgLy8gc3Bhd24gYXQgZmlyc3QgZml4XG4gICAgICAgIGlmICh0aGlzLmZpeGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBoZWFkaW5nIHRvIG5leHQgZml4XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGdldEZpeFBvc2l0aW9uKHRoaXMuZml4ZXNbMF0uZml4KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IGdldEZpeFBvc2l0aW9uKHRoaXMuZml4ZXNbMV0uZml4KTtcbiAgICAgICAgICAgIGhlYWRpbmcgPSBiZWFyaW5nVG9Qb2ludChwb3NpdGlvbiwgbmV4dFBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZVJvdXRlTW9kZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUHJlU3Bhd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHdheXBvaW50TW9kZWxMaXN0ID0gdGhpcy5haXJwb3J0LmZpbmRXYXlwb2ludE1vZGVsc0ZvclN0YXIoXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSb3V0ZU1vZGVsLnByb2NlZHVyZSxcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJvdXRlTW9kZWwuZW50cnksXG4gICAgICAgICAgICAgICAgdGhpcy5haXJwb3J0LnJ1bndheSxcbiAgICAgICAgICAgICAgICBpc1ByZVNwYXduXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBncmFiIHBvc2l0aW9uIG9mIGZpcnN0IGZpeFxuICAgICAgICAgICAgcG9zaXRpb24gPSB3YXlwb2ludE1vZGVsTGlzdFswXS5wb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBoZWFkaW5nIGZyb20gZmlyc3Qgd2F5cG9pbnQgdG8gc2Vjb25kIHdheXBvaW50XG4gICAgICAgICAgICBoZWFkaW5nID0gYmVhcmluZ1RvUG9pbnQocG9zaXRpb24sIHdheXBvaW50TW9kZWxMaXN0WzFdLnBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNwYXduIG91dHNpZGUgdGhlIGFpcnNwYWNlIGFsb25nICd0aGlzLnJhZGlhbCdcbiAgICAgICAgICAgIGRpc3RhbmNlID0gMiAqIHRoaXMuYWlycG9ydC5jdHJfcmFkaXVzO1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgcmVhbGx5IHVzZSBgUG9zaXRpb25Nb2RlbGBcbiAgICAgICAgICAgIHBvc2l0aW9uID0gW1xuICAgICAgICAgICAgICAgIHNpbih0aGlzLnJhZGlhbCkgKiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBjb3ModGhpcy5yYWRpYWwpICogZGlzdGFuY2VcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBoZWFkaW5nID0gdGhpcy5oZWFkaW5nIHx8IHRoaXMucmFkaWFsICsgTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFpcmNyYWZ0VG9BZGQgPSB7XG4gICAgICAgICAgICBhbHRpdHVkZSxcbiAgICAgICAgICAgIGhlYWRpbmcsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXRlZ29yeTogRkxJR0hUX0NBVEVHT1JZLkFSUklWQUwsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogdGhpcy5haXJwb3J0LmljYW8sXG4gICAgICAgICAgICBhaXJsaW5lOiBhaXJsaW5lLm5hbWUsXG4gICAgICAgICAgICBmbGVldDogYWlybGluZS5mbGVldCxcbiAgICAgICAgICAgIHdheXBvaW50czogdGhpcy5maXhlcyxcbiAgICAgICAgICAgIHJvdXRlOiBfZ2V0KHRoaXMsICdhY3RpdmVSb3V0ZU1vZGVsLnJvdXRlQ29kZScsICcnKSxcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIHVzZSBhIGBQb3NpdGlvbk1vZGVsYCBpbnN0ZWFkIG9mIGp1c3QgdXNpbmcgaXQgdG8gZ2V0IGEgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCB0YWtlIGEgbG90IG9mIHJlZmFjdG9yaW5nLCB0aG91Z2gsIGFzIGFpcmNyYWZ0LnBvc2l0aW9uIGlzIHVzZWQgYWxsIG92ZXIgdGhlIGFwcC5cbiAgICAgICAgICAgIHNwZWVkOiB0aGlzLnNwZWVkXG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmFpcmNyYWZ0Q29udHJvbGxlci5haXJjcmFmdF9uZXcoYWlyY3JhZnRUb0FkZCk7XG5cbiAgICAgICAgaWYgKHRpbWVvdXRfZmxhZykge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZW91dChcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXduQWlyY3JhZnQsXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0SW50ZXJ2YWwoKSxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIFtudWxsLCB0cnVlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBkZWxheSB1bnRpbCBuZXh0IHNwYXduXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxCYXNlXG4gICAgICogQG1ldGhvZCBuZXh0SW50ZXJ2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbmV4dEludGVydmFsKCkge1xuICAgICAgICBjb25zdCBtaW5faW50ZXJ2YWwgPSBBSVJQT1JUX0NPTlNUQU5UUy5NSU5fRU5UUkFJTF9ESVNUQU5DRV9OTSAqIChJTlRFUlZBTF9ERUxBWV9JTl9NUyAvIHRoaXMuc3BlZWQpO1xuICAgICAgICBsZXQgdGd0X2ludGVydmFsID0gSU5URVJWQUxfREVMQVlfSU5fTVMgLyB0aGlzLmZyZXF1ZW5jeTtcblxuICAgICAgICBpZiAodGd0X2ludGVydmFsIDwgbWluX2ludGVydmFsKSB7XG4gICAgICAgICAgICB0Z3RfaW50ZXJ2YWwgPSBtaW5faW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIGxvZyhgUmVxdWVzdGVkIGFycml2YWwgcmF0ZSBvZiAke3RoaXMuZnJlcXVlbmN5fSBhY3BoIG92ZXJyaWRkZW4gdG8gYCArXG4gICAgICAgICAgICAgICAgYG1haW50YWluIG1pbmltdW0gb2YgJHtBSVJQT1JUX0NPTlNUQU5UUy5NSU5fRU5UUkFJTF9ESVNUQU5DRV9OTX0gbWlsZXMgZW50cmFpbCBvbiBhcnJpdmFsIHN0cmVhbSBgICtcbiAgICAgICAgICAgICAgICBgZm9sbG93aW5nIHJvdXRlICR7dGhpcy5hY3RpdmVSb3V0ZU1vZGVsLnJvdXRlQ29kZX1gLCBMT0cuSU5GTyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhfaW50ZXJ2YWwgPSB0Z3RfaW50ZXJ2YWwgKyAodGd0X2ludGVydmFsIC0gbWluX2ludGVydmFsKTtcblxuICAgICAgICByZXR1cm4gX3JhbmRvbShtaW5faW50ZXJ2YWwsIG1heF9pbnRlcnZhbCk7XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tbWl4ZWQtb3BlcmF0b3JzLCBmdW5jLW5hbWVzLCBvYmplY3Qtc2hvcnRoYW5kICovXG5pbXBvcnQgX3JhbmRvbSBmcm9tICdsb2Rhc2gvcmFuZG9tJztcbmltcG9ydCBBcnJpdmFsQmFzZSBmcm9tICcuL0Fycml2YWxCYXNlJztcbmltcG9ydCB7IGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IFRJTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2xvYmFsQ29uc3RhbnRzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhcnJpdmFscyBpbiBjeWNsaWMgcGF0dGVyblxuICogQXJyaXZhbCByYXRlIHZhcmllcyBhcyBwaWN0dXJlZCBiZWxvdy4gUmF0ZSBhdCB3aGljaCB0aGUgYXJyaXZhbCByYXRlXG4gKiBpbmNyZWFzZXMgb3IgZGVjcmVhc2VzIHJlbWFpbnMgY29uc3RhbnQgdGhyb3VnaG91dCB0aGUgY3ljbGUuXG5cbiAqIHwtLS1vLS0tLS0tLS0tLS0tLS0tby0tLS0tLS0tLS0tLS0tLW8tLS0tLS0tLS0tLS0tLS1vLS0tLS0tLS0tLS18IDwgLSAtIC0gLSAtIC0gbWF4IGFycml2YWwgcmF0ZVxuICogfCBvICAgbyAgICAgICAgICAgbyAgIG8gICAgICAgICAgIG8gICBvICAgICAgICAgICBvICAgbyAgICAgICAgIHwgICArdmFyaWF0aW9uXG4gKiBvLS0tLS0tLW8tLS0tLS0tby0tLS0tLS1vLS0tLS0tLW8tLS0tLS0tby0tLS0tLS1vLS0tLS0tLW8tLS0tLS0tbyA8IC0gLSAtIC0gLSAtIGF2ZyBhcnJpdmFsIHJhdGVcbiAqIHwgICAgICAgICBvICAgbyB8ICAgICAgICAgbyAgIG8gICAgICAgICAgIG8gICBvICAgICAgICAgICBvICAgbyB8ICAgLXZhcmlhdGlvblxuICogfC0tLS0tLS0tLS0tby0tLXwtLS0tLS0tLS0tLW8tLS0tLS0tLS0tLS0tLS1vLS0tLS0tLS0tLS0tLS0tby0tLXwgPCAtIC0gLSAtIC0gLSBtaW4gYXJyaXZhbCByYXRlXG4gKiB8PC0tLXBlcmlvZC0tLS0+fCAgICAgICAgICAgfDwtLS1wZXJpb2QtLS0tPnxcbiAqXG4gKiBAY2xhc3MgQXJyaXZhbEN5Y2xpY1xuICogQGV4dGVuZHMgQXJyaXZhbEJhc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJyaXZhbEN5Y2xpYyBleHRlbmRzIEFycml2YWxCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEFycml2YWxDeWNsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhaXJwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFpcnBvcnQsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbW91bnQgdG8gZGV2aWF0ZSBmcm9tIHRoZSBwcmVzY3JpYmVkIGZyZXF1ZW5jeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgdmFyaWF0aW9uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFyaWF0aW9uID0gMDtcblxuICAgICAgICB0aGlzLnBhcnNlKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFycml2YWwgU3RyZWFtIFNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHBlcmlvZCAtIChvcHRpb25hbCkgbGVuZ3RoIG9mIGEgY3ljbGUsIGluIG1pbnV0ZXNcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCAtIChvcHRpb25hbCkgbWludXRlcyB0byBzaGlmdCBzdGFydGluZyBwb3NpdGlvbiBpbiBjeWNsZVxuICAgICAqL1xuICAgIHBhcnNlKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIucGFyc2Uob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzKG9wdGlvbnMub2Zmc2V0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGVyaW9kKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzKG9wdGlvbnMucGVyaW9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnZhcmlhdGlvbikge1xuICAgICAgICAgICAgdGhpcy52YXJpYXRpb24gPSBvcHRpb25zLnZhcmlhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmN5Y2xlU3RhcnQgPSB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS50aW1lIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gX3JhbmRvbSgwLCBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyB0aGlzLmZyZXF1ZW5jeSk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWVvdXQodGhpcy5zcGF3bkFpcmNyYWZ0LCBkZWxheSwgdGhpcywgW3RydWUsIHRydWVdKTtcbiAgICB9XG5cbiAgICBuZXh0SW50ZXJ2YWwoKSB7XG4gICAgICAgIC8vIFRPRE86IHdoYXQgZG8gYWxsIHRoZXNlIG1hZ2ljIG51bWJlcnMgbWVhbj8gZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJzLlxuICAgICAgICBjb25zdCB0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUudGltZSAtIHRoaXMuY3ljbGVTdGFydDtcbiAgICAgICAgY29uc3QgZG9uZSA9IHQgLyAodGhpcy5wZXJpb2QgLyA0KTsgLy8gcHJvZ3Jlc3MgaW4gY3VycmVudCBxdWFydGVyLXBlcmlvZFxuXG4gICAgICAgIGlmIChkb25lID49IDQpIHtcbiAgICAgICAgICAgIHRoaXMuY3ljbGVTdGFydCArPSB0aGlzLnBlcmlvZDtcblxuICAgICAgICAgICAgcmV0dXJuIFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvICh0aGlzLmZyZXF1ZW5jeSArIChkb25lIC0gNCkgKiB0aGlzLnZhcmlhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZSA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gKHRoaXMuZnJlcXVlbmN5ICsgZG9uZSAqIHRoaXMudmFyaWF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb25lIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyAodGhpcy5mcmVxdWVuY3kgKyAoMiAqICh0aGlzLnBlcmlvZCAtIDIgKiB0KSAvIHRoaXMucGVyaW9kKSAqIHRoaXMudmFyaWF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb25lIDw9IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyAodGhpcy5mcmVxdWVuY3kgLSAoZG9uZSAtIDIpICogdGhpcy52YXJpYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbmUgPCA0KSB7XG4gICAgICAgICAgICByZXR1cm4gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gKHRoaXMuZnJlcXVlbmN5IC0gKDQgKiAodGhpcy5wZXJpb2QgLSB0KSAvIHRoaXMucGVyaW9kKSAqIHRoaXMudmFyaWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLW1peGVkLW9wZXJhdG9ycywgZnVuYy1uYW1lcywgb2JqZWN0LXNob3J0aGFuZCAqL1xuaW1wb3J0IF9yYW5kb20gZnJvbSAnbG9kYXNoL3JhbmRvbSc7XG5pbXBvcnQgQXJyaXZhbEJhc2UgZnJvbSAnLi9BcnJpdmFsQmFzZSc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uLy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyBjb252ZXJ0TWludXRlc1RvU2Vjb25kcyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5pbXBvcnQgeyBUSU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dsb2JhbENvbnN0YW50cyc7XG5pbXBvcnQgeyBMT0cgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvbG9nTGV2ZWwnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFycml2YWxzIGluIGEgcmVwZWF0aW5nIHN1cmdlXG4gKlxuICogQXJyaXZhbCByYXRlIGdvZXMgZnJvbSB2ZXJ5IGxvdyBhbmQgc3RlZXBseSBpbmNyZWFzZXMgdG8gYSBzdXN0YWluZWQgYXJyaXZhbCBzdXJnZSBvZiBkZW5zZWx5IHBhY2tlZCBhaXJjcmFmdC5cbiAqXG4gKiBFeGFtcGxlIGFpcnBvcnQ6IGBFRERUIC0gQmVybGluIFRlZ2VsIEFpcnBvcnRgXG4gKlxuICogbyBvIG8gbyBvIG8gbyBvIG8gbyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gbyBvIG8gbyBvIG8gbyBvIG8gby0tLS0tKyA8IC0gLSAtIG1heCBhcnJpdmFsIHJhdGUgKCp0aGlzLmZhY3RvcilcbiAqIG8gICAgICAgICAgICAgICAgIG8gICAgICAgICAgICAgICAgICAgICAgIG8gICAgICAgICAgICAgICAgIG8gICAgIHxcbiAqIG8gICAgICAgICAgICAgICAgIG8gICAgICAgICAgICAgICAgICAgICAgIG8gICAgICAgICAgICAgICAgIG8gICAgIHwgICB4KHRoaXMuZmFjdG9yKVxuICogbyAgICAgICAgICAgICAgICAgbyAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgICAgICAgICAgbyAgICAgfFxuICogbyAtIC0gLSAtIC0gLSAtIC0gbyBvIG8gbyBvIG8gbyBvIG8gbyBvIG8gbyAtIC0gLSAtIC0gLSAtIC0gbyBvIG8tKyA8IC0gLSAtIG1pbiBhcnJpdmFsIHJhdGUgKG4pXG4gKiB8PC0tLSB1cCB0aW1lIC0tLT58PC0tLS0tIGRvd24gdGltZSAtLS0tLT58PC0tLSB1cCB0aW1lIC0tLT58XG4gKlxuICogQGNsYXNzIEFycml2YWxTdXJnZVxuICogQGV4dGVuZHMgQXJyaXZhbEJhc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJyaXZhbFN1cmdlIGV4dGVuZHMgQXJyaXZhbEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBmb3IgQXJyaXZhbEJhc2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhaXJwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFpcnBvcnQsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaWxlcyBlbnRyYWlsIGR1cmluZyB0aGUgc3VyZ2UgW2Zhc3Qsc2xvd11cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGVudHJhaWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW50cmFpbCA9IFs1LjUsIDEwXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGVkXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aW1lIGxlbmd0aCBvZiBzdXJnZSwgaW4gbWludXRlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgdXB0aW1lXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXB0aW1lID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJyaXZhbCByYXRlIHdoZW4gXCJpbiB0aGUgc3VyZ2VcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgYWNwaF91cFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjcGhfdXAgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJpdmFsIHJhdGUgd2hlbiBub3QgXCJpbiB0aGUgc3VyZ2VcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgYWNwaF9kblxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjcGhfZG4gPSAwO1xuXG4gICAgICAgIHRoaXMucGFyc2Uob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2hhcGVUaGVTdXJnZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFycml2YWwgU3RyZWFtIFNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxTdXJnZVxuICAgICAqIEBtZXRob2QgcGFyc2VcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHBlcmlvZCAtIE9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgbGVuZ3RoIG9mIGEgY3ljbGUgaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IC0gT3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjZW50ZXIgb2YgdGhlIHdhdmUgaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGVudHJhaWwgLSAyLWVsZW1lbnQgYXJyYXkgd2l0aCBbZmFzdCxzbG93XSBubSBiZXR3ZWVuIGVhY2hcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZSBhcnJpdmFsLiBOb3RlIHRoYXQgdGhlIGVudHJhaWwgZGlzdGFuY2Ugb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxhcmdlciBnYXAgKFwic2xvd1wiKSB3aWxsIGJlIGFkanVzdGVkIHNsaWdodGx5IGluXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyIHRvIG1haW50YWluIHRoZSByZXF1ZXN0ZWQgZnJlcXVlbmN5LiBUaGlzIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBseSBkdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBjYW4ndCBkaXZpZGUgcGVyZmVjdGx5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFjcm9zcyBlYWNoIHBlcmlvZCwgc28gd2Ugc3F1aXNoIHRoZSBnYXAgYSB0aW55IGJpdCB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwIHVzIGhpdCB0aGUgbWFyayBvbiB0aGUgYWlyY3JhZnQtcGVyLWhvdXIgcmF0ZS5cbiAgICAgKi9cbiAgICBwYXJzZShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLnBhcnNlKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBjb252ZXJ0TWludXRlc1RvU2Vjb25kcyhvcHRpb25zLm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wZXJpb2QpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gY29udmVydE1pbnV0ZXNUb1NlY29uZHMob3B0aW9ucy5wZXJpb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW50cmFpbCkge1xuICAgICAgICAgICAgdGhpcy5lbnRyYWlsID0gb3B0aW9ucy5lbnRyYWlsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgdGltZSBzcGVudCBhdCBlbGV2YXRlZCBhbmQgc2xvdyBzcGF3biByYXRlc1xuICAgICAqXG4gICAgICogQGZvciBBcnJpdmFsU3VyZ2VcbiAgICAgKiBAbWV0aG9kIHNoYXBlVGhlU3VyZ2VcbiAgICAgKi9cbiAgICBzaGFwZVRoZVN1cmdlKCkge1xuICAgICAgICB0aGlzLmFjcGhfdXAgPSB0aGlzLnNwZWVkIC8gdGhpcy5lbnRyYWlsWzBdO1xuICAgICAgICB0aGlzLmFjcGhfZG4gPSB0aGlzLnNwZWVkIC8gdGhpcy5lbnRyYWlsWzFdOyAgLy8gdG8gaGVscCB0aGUgdXB0aW1lIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgdGhpcy51cHRpbWUgPSAodGhpcy5wZXJpb2QgKiB0aGlzLmZyZXF1ZW5jeSAtIHRoaXMucGVyaW9kICogdGhpcy5hY3BoX2RuKSAvICh0aGlzLmFjcGhfdXAgLSB0aGlzLmFjcGhfZG4pO1xuICAgICAgICB0aGlzLnVwdGltZSAtPSB0aGlzLnVwdGltZSAlIChUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyB0aGlzLmFjcGhfdXApO1xuICAgICAgICAvLyBGSVhNRTogVGhpcyB3b3VsZCBiZXR0ZXIgYmVsb25nIGluIGEgaGVscGVyIG1ldGhvZCBhbmQgc2hvdWxkIGJlIHNpbXBsaWZpZWRcbiAgICAgICAgLy8gYWRqdXN0IHRvIG1haW50YWluIGNvcnJlY3QgYWNwaCByYXRlXG4gICAgICAgIHRoaXMuYWNwaF9kbiA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSAqIHRoaXMucGVyaW9kIC8gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC0gTWF0aC5yb3VuZCh0aGlzLmFjcGhfdXAgKiB0aGlzLnVwdGltZSAvIFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUykpICogVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gKHRoaXMucGVyaW9kIC0gdGhpcy51cHRpbWUpO1xuXG4gICAgICAgIC8vIFRPRE86IGFic3RyYWN0IHRoaXMgaWYvZWxzZSBibG9ja1xuICAgICAgICAvLyBWZXJpZnkgd2UgY2FuIGNvbXBseSB3aXRoIHRoZSByZXF1ZXN0ZWQgYXJyaXZhbCByYXRlIGJhc2VkIG9uIGVudHJhaWwgc3BhY2luZ1xuICAgICAgICBpZiAodGhpcy5mcmVxdWVuY3kgPiB0aGlzLmFjcGhfdXApIHtcbiAgICAgICAgICAgIGxvZyhgJHt0aGlzLmFpcnBvcnQuaWNhb306IFRPTyBNQU5ZIEFSUklWQUxTIElOIFNVUkdFISBSZXF1ZXN0ZWQ6IGAgK1xuICAgICAgICAgICAgICAgIGAke3RoaXMuZnJlcXVlbmN5fSBhY3BoIHwgQWNjZXB0YWJsZSBSYW5nZSBmb3IgcmVxdWVzdGVkIGVudHJhaWwgZGlzdGFuY2U6IGAgK1xuICAgICAgICAgICAgICAgIGAke01hdGguY2VpbCh0aGlzLmFjcGhfZG4pfSBhY3BoIC0gJHtNYXRoLmZsb29yKHRoaXMuYWNwaF91cCl9IGFjcGhgLCBMT0cuV0FSTklORyk7XG5cbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5hY3BoX3VwO1xuICAgICAgICAgICAgdGhpcy5hY3BoX2RuID0gdGhpcy5hY3BoX3VwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlcXVlbmN5IDwgdGhpcy5hY3BoX2RuKSB7XG4gICAgICAgICAgICBsb2coYCR7dGhpcy5haXJwb3J0LmljYW99OiBUT08gRkVXIEFSUklWQUxTIElOIFNVUkdFISBSZXF1ZXN0ZWQ6IGAgK1xuICAgICAgICAgICAgICAgIGAke3RoaXMuZnJlcXVlbmN5fSBhY3BoIHwgQWNjZXB0YWJsZSBSYW5nZSBmb3IgcmVxdWVzdGVkIGVudHJhaWwgZGlzdGFuY2U6IGAgK1xuICAgICAgICAgICAgICAgIGAke01hdGguY2VpbCh0aGlzLmFjcGhfZG4pfSBhY3BoIC0gJHtNYXRoLmZsb29yKHRoaXMuYWNwaF91cCl9IGFjcGhgLCBMT0cuV0FSTklORyk7XG5cbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5hY3BoX2RuO1xuICAgICAgICAgICAgdGhpcy5hY3BoX3VwID0gdGhpcy5hY3BoX2RuO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFycml2YWxTdXJnZVxuICAgICAqIEBtZXRob2QgbmV4dEludGVydmFsXG4gICAgICogQHJldHVybiBpbnRlcnZhbF91cCB7bnVtYmVyfVxuICAgICAqL1xuICAgIG5leHRJbnRlcnZhbCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLnRpbWUgLSB0aGlzLmN5Y2xlU3RhcnQ7XG4gICAgICAgIGNvbnN0IGRvbmUgPSB0IC8gdGhpcy5wZXJpb2Q7IC8vIHByb2dyZXNzIGluIHBlcmlvZFxuICAgICAgICBjb25zdCBpbnRlcnZhbF91cCA9IFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIHRoaXMuYWNwaF91cDtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxfZG4gPSBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyB0aGlzLmFjcGhfZG47XG4gICAgICAgIC8vIHJlZHVjZWQgc3Bhd24gcmF0ZVxuICAgICAgICBjb25zdCB0aW1lbGVmdCA9IHRoaXMucGVyaW9kIC0gdDtcblxuICAgICAgICBpZiAoZG9uZSA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmN5Y2xlU3RhcnQgKz0gdGhpcy5wZXJpb2Q7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbF91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsZXZhdGVkIHNwYXduIHJhdGVcbiAgICAgICAgaWYgKHQgPD0gdGhpcy51cHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbF91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lbGVmdCA+IGludGVydmFsX2RuICsgaW50ZXJ2YWxfdXApIHtcbiAgICAgICAgICAgIC8vIHBsZW50eSBvZiB0aW1lIHVudGlsIG5ldyBwZXJpb2RcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbF9kbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lbGVmdCA+IGludGVydmFsX2RuKSB7XG4gICAgICAgICAgICAvLyBuZXh0IHBsYW5lIHdpbGwgZGVsYXkgdGhlIGZpcnN0IGFycml2YWwgb2YgdGhlIG5leHQgcGVyaW9kXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxfZG4gLSAodCArIGludGVydmFsX2RuICsgaW50ZXJ2YWxfdXAgLSB0aGlzLnBlcmlvZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IHBsYW5lIGlzIGZpcnN0IG9mIGVsZXZhdGVkIHNwYXduIHJhdGVcbiAgICAgICAgdGhpcy5jeWNsZVN0YXJ0ICs9IHRoaXMucGVyaW9kO1xuXG4gICAgICAgIHJldHVybiBpbnRlcnZhbF91cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFycml2YWxTdXJnZVxuICAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBfcmFuZG9tKDAsIFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIHRoaXMuZnJlcXVlbmN5KTtcbiAgICAgICAgdGhpcy5jeWNsZVN0YXJ0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUudGltZSAtIHRoaXMub2Zmc2V0ICsgZGVsYXk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWVvdXQodGhpcy5zcGF3bkFpcmNyYWZ0LCBkZWxheSwgdGhpcywgW3RydWUsIHRydWVdKTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UsIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1taXhlZC1vcGVyYXRvcnMsIGZ1bmMtbmFtZXMsIG9iamVjdC1zaG9ydGhhbmQgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgX3JhbmRvbSBmcm9tICdsb2Rhc2gvcmFuZG9tJztcbmltcG9ydCBBcnJpdmFsQmFzZSBmcm9tICcuL0Fycml2YWxCYXNlJztcbmltcG9ydCB7IHNpbiB9IGZyb20gJy4uLy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyB0YXUgfSBmcm9tICcuLi8uLi9tYXRoL2NpcmNsZSc7XG5pbXBvcnQgeyBjb252ZXJ0TWludXRlc1RvU2Vjb25kcyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5pbXBvcnQgeyBUSU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dsb2JhbENvbnN0YW50cyc7XG5pbXBvcnQgeyBMT0cgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvbG9nTGV2ZWwnO1xuXG4vKiogR2VuZXJhdGUgYXJyaXZhbHMgaW4gYSByZXBlYXRpbmcgd2F2ZVxuICAqIEFycml2YWwgcmF0ZSB2YXJpZXMgYXMgcGljdHVyZWQgYmVsb3cuIEFycml2YWwgcmF0ZSB3aWxsIGluY3JlYXNlXG4gICogYW5kIGRlY3JlYXNlIGZhc3RlciB3aGVuIGNoYW5naW5nIGJldHdlZW4gdGhlIGxvd2VyL2hpZ2hlciByYXRlcy5cbiAgKlxuICAqIC0tLS0tLS0tLS0tLW8tby1vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tby1vIDwgLSAtIC0gLSAtIG1heCBhcnJpdmFsIHJhdGVcbiAgKiAgICAgICAgbyAgICAgICAgICAgICBvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBvICAgICAgfCAgICAgICBeXG4gICogICAgbyAgICAgICAgICAgICAgICAgICAgIG8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvICAgICAgICAgIHwgICt2YXJpYXRpb25cbiAgKiAgbyAgICAgICAgICAgICAgICAgICAgICAgICBvICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxvICAgICAgICAgICAgfCAgICAgICB2XG4gICogby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1vLS0tLS0tLS0tLS0tLSsgPCAtIC0gLSAtIC0gYXZnIGFycml2YWwgcmF0ZVxuICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgICAgICAgICAgICAgICAgICBvfCAgICAgICAgICAgICB8ICAgICAgIF5cbiAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgICAgICAgICAgICAgIG8gIHwgICAgICAgICAgICAgfCAgLXZhcmlhdGlvblxuICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgICAgICBvICAgICAgfCAgICAgICAgICAgICB8ICAgICAgIHZcbiAgKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tby1vLW8tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKyA8IC0gLSAtIC0gLSBtaW4gYXJyaXZhbCByYXRlXG4gICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICogfDwgIC0gIC0gIC0gIC0gIC0gIC0gIC0gIC0gcGVyaW9kIC0gIC0gIC0gIC0gIC0gIC0gIC0gID58XG4gICpcbiAgKiBAY2xhc3MgQXJyaXZhbFdhdmVcbiAgKiBAZXh0ZW5kcyBBcnJpdmFsQmFzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcnJpdmFsV2F2ZSBleHRlbmRzIEFycml2YWxCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEFycml2YWxXYXZlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGFpcnBvcnQge0FpcnBvcnRJbnN0YW5jZU1vZGVsfVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWlycG9ydCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihhaXJwb3J0LCBvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW1vdW50IHRvIGRldmlhdGUgZnJvbSB0aGUgcHJlc2NyaWJlZCBmcmVxdWVuY3lcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnkgdmFyaWF0aW9uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFyaWF0aW9uID0gMDtcblxuICAgICAgICB0aGlzLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNsYW1wU3Bhd25SYXRlKDUuNSk7IC8vIG1pbmltdW0gb2YgNS41bm0gZW50cmFpbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFycml2YWwgU3RyZWFtIFNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAZm9yIEFycml2YWxXYXZlXG4gICAgICogQG1ldGhvZCBwYXJzZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gcGVyaW9kIC0gKG9wdGlvbmFsKSBsZW5ndGggb2YgYSBjeWNsZSwgaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IC0gKG9wdGlvbmFsKSBtaW51dGVzIHRvIHNoaWZ0IHN0YXJ0aW5nIHBvc2l0aW9uIGluIGN5Y2xlXG4gICAgICovXG4gICAgcGFyc2Uob3B0aW9ucykge1xuICAgICAgICBzdXBlci5wYXJzZShvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gY29udmVydE1pbnV0ZXNUb1NlY29uZHMob3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGVyaW9kKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzKG9wdGlvbnMucGVyaW9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnZhcmlhdGlvbikge1xuICAgICAgICAgICAgdGhpcy52YXJpYXRpb24gPSBvcHRpb25zLnZhcmlhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIHNwYXduIHJhdGUgd2lsbCBiZSBhdCBsZWFzdCB0aGUgcmVxdWlyZWQgZW50cmFpbCBkaXN0YW5jZVxuICAgICAqXG4gICAgICogQGZvciBBcnJpdmFsV2F2ZVxuICAgICAqIEBtZXRob2QgY2xhbXBTcGF3blJhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW50cmFpbF9kaXN0IC0gbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHN1Y2Nlc3NpdmUgYXJyaXZhbHMsIGluIG5tXG4gICAgICovXG4gICAgY2xhbXBTcGF3blJhdGUoZW50cmFpbF9kaXN0KSB7XG4gICAgICAgIGNvbnN0IGVudHJhaWxfaW50ZXJ2YWwgPSBlbnRyYWlsX2Rpc3QgKiAoVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gdGhpcy5zcGVlZCk7XG4gICAgICAgIGNvbnN0IG1pbl9pbnRlcnZhbCA9IFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvICh0aGlzLmZyZXF1ZW5jeSArIHRoaXMudmFyaWF0aW9uKTtcblxuICAgICAgICAvLyBUT0RPOiByZXR1cm4gZWFybHkgaGVyZSB0byBhdm9pZCB0aGlzIHdyYXBwaW5nIGlmXG4gICAgICAgIGlmIChtaW5faW50ZXJ2YWwgPCBlbnRyYWlsX2ludGVydmFsKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZW50cmFpbF9pbnRlcnZhbCAtIG1pbl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgLy8gY2FuIHJlZHVjZSB2YXJpYXRpb24gdG8gYWNoaWV2ZSBhY2NlcHRhYmxlIHNwYXduIHJhdGVcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IChUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyB0aGlzLnZhcmlhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsb2coJ1JlcXVlc3RlZCBhcnJpdmFsIHJhdGUgdmFyaWF0aW9uIG9mICsvLScgKyB0aGlzLnZhcmlhdGlvbiArICcgYWNwaCByZWR1Y2VkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWFpbnRhaW4gbWluaW11bSBvZiAnICsgZW50cmFpbF9kaXN0ICsgJyBtaWxlcyBlbnRyYWlsIG9uIGFycml2YWwgc3RyZWFtIGZvbGxvd2luZyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JvdXRlICcgKyAkLm1hcCh0aGlzLmZpeGVzLCAodikgPT4gdi5maXgpLmpvaW4oJy0nKSwgTE9HLldBUk5JTkcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYXRpb24gPSB0aGlzLnZhcmlhdGlvbiAtIFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIGRpZmY7IC8vIHJlZHVjZSB0aGUgdmFyaWF0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVkdWNlIGZyZXF1ZW5jeSB0byBhY2hpZXZlIGFjY2VwdGFibGUgc3Bhd24gcmF0ZVxuICAgICAgICAgICAgICAgIGxvZygnUmVxdWVzdGVkIGFycml2YWwgcmF0ZSBvZiAnICsgdGhpcy5mcmVxdWVuY3kgKyAnIGFjcGggb3ZlcnJpZGRlbiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21haW50YWluIG1pbmltdW0gb2YgJyArIGVudHJhaWxfZGlzdCArICcgbWlsZXMgZW50cmFpbCBvbiBhcnJpdmFsIHN0cmVhbSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbGxvd2luZyByb3V0ZSAnICsgJC5tYXAodGhpcy5maXhlcywgKHYpID0+IHYuZml4KS5qb2luKCctJyksIExPRy5XQVJOSU5HKTtcblxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3Bhd24gYXQgY29uc3RhbnQgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgLy8gcmVkdWNlIHRoZSBmcmVxdWVuY3lcbiAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIGVudHJhaWxfaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEFycml2YWxXYXZlXG4gICAgICogQG1ldGhvZCBuZXh0SW50ZXJ2YWxcbiAgICAgKiByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBuZXh0SW50ZXJ2YWwoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS50aW1lIC0gdGhpcy5jeWNsZVN0YXJ0O1xuICAgICAgICBjb25zdCBkb25lID0gdCAvIHRoaXMucGVyaW9kOyAvLyBwcm9ncmVzcyBpbiBwZXJpb2RcblxuICAgICAgICBpZiAoZG9uZSA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmN5Y2xlU3RhcnQgKz0gdGhpcy5wZXJpb2Q7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByYXRlID0gdGhpcy5mcmVxdWVuY3kgKyB0aGlzLnZhcmlhdGlvbiAqIHNpbihkb25lICogdGF1KCkpO1xuXG4gICAgICAgIHJldHVybiBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyByYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQXJyaXZhbFdhdmVcbiAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gX3JhbmRvbSgwLCBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgLyB0aGlzLmZyZXF1ZW5jeSk7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBvbiBgd2luZG93LnByb3BgIHVwZGF0ZSByZWZlcmVuY2VcbiAgICAgICAgdGhpcy5jeWNsZVN0YXJ0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUudGltZSAtIHRoaXMub2Zmc2V0ICsgZGVsYXk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWVvdXQodGhpcy5zcGF3bkFpcmNyYWZ0LCBkZWxheSwgdGhpcywgW3RydWUsIHRydWVdKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQXJyaXZhbEJhc2UgZnJvbSAnLi9BcnJpdmFsQmFzZSc7XG5pbXBvcnQgQXJyaXZhbEN5Y2xpYyBmcm9tICcuL0Fycml2YWxDeWNsaWMnO1xuaW1wb3J0IEFycml2YWxXYXZlIGZyb20gJy4vQXJyaXZhbFdhdmUnO1xuaW1wb3J0IEFycml2YWxTdXJnZSBmcm9tICcuL0Fycml2YWxTdXJnZSc7XG5pbXBvcnQgeyBMT0cgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvbG9nTGV2ZWwnO1xuXG4vKipcbiAqIENhbGxzIGNvbnN0cnVjdG9yIG9mIHRoZSBhcHByb3ByaWF0ZSBhcnJpdmFsIHR5cGVcbiAqXG4gKiBAZnVuY3Rpb24gQXJyaXZhbEZhY3RvcnlcbiAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0TW9kZWx9XG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JlamN0fVxuICogQHJldHVybiB7Y29uc3RydWN0b3J9XG4gKi9cbmV4cG9ydCBjb25zdCBhcnJpdmFsRmFjdG9yeSA9IChhaXJwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJycpIHtcbiAgICAgICAgbG9nKGAke2FpcnBvcnQuaWNhb30gYXJyaXZhbCBzdHJlYW0gbm90IGdpdmVuIHR5cGUhYCwgTE9HLldBUk5JTkcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgICBjYXNlICdyYW5kb20nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJpdmFsQmFzZShhaXJwb3J0LCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSAnY3ljbGljJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyaXZhbEN5Y2xpYyhhaXJwb3J0LCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycml2YWxXYXZlKGFpcnBvcnQsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlICdzdXJnZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycml2YWxTdXJnZShhaXJwb3J0LCBvcHRpb25zKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZyhgJHthaXJwb3J0LmljYW99IHVzaW5nIHVuc3VwcG9ydGVkIGFycml2YWwgdHlwZSBcIiR7b3B0aW9ucy50eXBlfVwiYCwgTE9HLldBUk5JTkcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiIsImltcG9ydCBfZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IF9yYW5kb20gZnJvbSAnbG9kYXNoL3JhbmRvbSc7XG5pbXBvcnQgUm91dGVNb2RlbCBmcm9tICcuLi9Sb3V0ZS9Sb3V0ZU1vZGVsJztcbmltcG9ydCB7XG4gICAgYWlybGluZU5hbWVBbmRGbGVldEhlbHBlcixcbiAgICByYW5kb21BaXJsaW5lU2VsZWN0aW9uSGVscGVyXG59IGZyb20gJy4uLy4uL2FpcmxpbmUvcmFuZG9tQWlybGluZVNlbGVjdGlvbkhlbHBlcic7XG5pbXBvcnQgeyBjaG9vc2UgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvZ2VuZXJhbFV0aWxpdGllcyc7XG5pbXBvcnQgeyBGTElHSFRfQ0FURUdPUlkgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvYWlyY3JhZnRDb25zdGFudHMnO1xuaW1wb3J0IHsgVElNRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9nbG9iYWxDb25zdGFudHMnO1xuXG4vKipcbiAqIEdlbmVyYXRlIGRlcGFydHVyZXMgYXQgcmFuZG9tLCBhdmVyYWdpbmcgdGhlIHNwZWNpZmllZCBzcGF3biByYXRlXG4gKlxuICogQGNsYXNzIERlcGFydHVyZUJhc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVwYXJ0dXJlQmFzZSB7XG4gICAgLyoqXG4gICAgICogQGZvciBEZXBhcnR1cmVCYXNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGFpcnBvcnQge0FpcnBvcnRJbnN0YW5jZU1vZGVsfVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWlycG9ydCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBhaXJsaW5lcyB3aXRoIHdlaWdodCBmb3IgZWFjaFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgYWlybGluZXNcbiAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5haXJsaW5lcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgYWlycG9ydFxuICAgICAgICAgKiBAdHlwZSB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFpcnBvcnQgPSBhaXJwb3J0O1xuXG4gICAgICAgIC8vIFRPRE86IGFyZSB3ZSBpbml0aWFsaXppbmcgYW4gYXJyYXkgd2l0aCBhIHZhbHVlIGhlcmU/XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIFNJRHMgb3IgZGVwYXJ0dXJlIGZpeCBuYW1lc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgZGVzdGluYXRpb25zXG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgWzBdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9ucyA9IFswXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3Bhd24gcmF0ZSwgaW4gYWlyY3JhZnQgcGVyIGhvdXIgKGFjcGgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmVxdWVuY3lcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgdGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhY3RpdmVSb3V0ZU1vZGVsXG4gICAgICAgICAqIEB0eXBlIHtSb3V0ZU1vZGVsfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVJvdXRlTW9kZWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFyc2Uob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVwYXJ0dXJlIFN0cmVhbSBTZXR0aW5nc1xuICAgICAqXG4gICAgICogQGZvciBEZXBhcnR1cmVCYXNlXG4gICAgICogQG1ldGhvZCBwYXJzZVxuICAgICAqL1xuICAgIHBhcnNlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5haXJsaW5lcyA9IF9nZXQob3B0aW9ucywgJ2FpcmxpbmVzJywgdGhpcy5haXJsaW5lcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25zID0gX2dldChvcHRpb25zLCAnZGVzdGluYXRpb25zJywgdGhpcy5kZXN0aW5hdGlvbnMpO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IF9nZXQob3B0aW9ucywgJ2ZyZXF1ZW5jeScsIHRoaXMuZnJlcXVlbmN5KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWlybGluZXMubGVudGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWlybGluZSA9IHRoaXMuYWlybGluZXNbaV07XG4gICAgICAgICAgICAvLyByZWFzc2lnbnMgYGFpcmxpbmUubmFtZWAgdG8gYGFpcmxpbmVOYW1lYCBmb3IgcmVhZGFiaWxpdHlcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogYWlybGluZU5hbWUgfSA9IGFpcmxpbmVOYW1lQW5kRmxlZXRIZWxwZXIoYWlybGluZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5haXJsaW5lQ29udHJvbGxlci5haXJsaW5lX2dldChhaXJsaW5lTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoaXMgZGVwYXJ0dXJlIHN0cmVhbVxuICAgICAqXG4gICAgICogQGZvciBEZXBhcnR1cmVCYXNlXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfY2xlYXJfdGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhpcyBkZXBhcnR1cmUgc3RyZWFtXG4gICAgICpcbiAgICAgKiBAZm9yIERlcGFydHVyZUJhc2VcbiAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbVNwYXduQ291bnQgPSBNYXRoLmZsb29yKF9yYW5kb20oMiwgNS45OSkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHJhbmRvbVNwYXduQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgLy8gc3Bhd24gMi01IGRlcGFydHVyZXMgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgdGhpcy5zcGF3bkFpcmNyYWZ0KGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhdGVTcGF3bmluZ0xvb3AoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIERlcGFydHVyZUJhc2VcbiAgICAgKiBAbWV0aG9kIGluaXRpYXRlU3Bhd25pbmdMb29wXG4gICAgICovXG4gICAgaW5pdGlhdGVTcGF3bmluZ0xvb3AoKSB7XG4gICAgICAgIGNvbnN0IG1pbkZyZXF1ZW5jeSA9IHRoaXMuZnJlcXVlbmN5ICogMC41O1xuICAgICAgICBjb25zdCBtYXhGcmVxdWVuY3kgPSB0aGlzLmZyZXF1ZW5jeSAqIDEuNTtcbiAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyRm9yVGltZW91dCA9IF9yYW5kb20obWluRnJlcXVlbmN5LCBtYXhGcmVxdWVuY3kpO1xuXG4gICAgICAgIC8vIHN0YXJ0IHNwYXduaW5nIGxvb3BcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZW91dCh0aGlzLnNwYXduQWlyY3JhZnQsIHJhbmRvbU51bWJlckZvclRpbWVvdXQsIHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwYXduIGEgbmV3IGFpcmNyYWZ0XG4gICAgICpcbiAgICAgKiBAZm9yIERlcGFydHVyZUJhc2VcbiAgICAgKiBAbWV0aG9kIHNwYXduQWlyY3JhZnRcbiAgICAgKi9cbiAgICBzcGF3bkFpcmNyYWZ0KHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICh3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkgLSB0aGlzLnN0YXJ0ID49IDIpO1xuICAgICAgICBjb25zdCBhaXJsaW5lID0gcmFuZG9tQWlybGluZVNlbGVjdGlvbkhlbHBlcih0aGlzLmFpcmxpbmVzKTtcbiAgICAgICAgY29uc3QgYWlyY3JhZnRUb0FkZCA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBhaXJsaW5lOiBhaXJsaW5lLm5hbWUsXG4gICAgICAgICAgICBmbGVldDogYWlybGluZS5mbGVldCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBGTElHSFRfQ0FURUdPUlkuREVQQVJUVVJFLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IGNob29zZSh0aGlzLmRlc3RpbmF0aW9ucylcbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3cuYWlyY3JhZnRDb250cm9sbGVyLmFpcmNyYWZ0X25ldyhhaXJjcmFmdFRvQWRkKTtcblxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfdGltZW91dChcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXduQWlyY3JhZnQsXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0SW50ZXJ2YWwoKSxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgZGVsYXkgdW50aWwgbmV4dCBzcGF3blxuICAgICAqXG4gICAgICogQGZvciBEZXBhcnR1cmVCYXNlXG4gICAgICogQG1ldGhvZCBuZXh0SW50ZXJ2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbmV4dEludGVydmFsKCkge1xuICAgICAgICAvLyBmYXN0ZXN0IHBvc3NpYmxlIGJldHdlZW4gYmFjay10by1iYWNrIGRlcGFydHVyZXMsIGluIHNlY29uZHNcbiAgICAgICAgY29uc3QgbWluX2ludGVydmFsID0gNTtcbiAgICAgICAgY29uc3QgdGd0X2ludGVydmFsID0gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gdGhpcy5mcmVxdWVuY3k7XG4gICAgICAgIGNvbnN0IG1heF9pbnRlcnZhbCA9IHRndF9pbnRlcnZhbCArICh0Z3RfaW50ZXJ2YWwgLSBtaW5faW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiBfcmFuZG9tKG1pbl9pbnRlcnZhbCwgbWF4X2ludGVydmFsKTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tbWl4ZWQtb3BlcmF0b3JzLCBmdW5jLW5hbWVzLCBvYmplY3Qtc2hvcnRoYW5kICovXG5pbXBvcnQgRGVwYXJ0dXJlQmFzZSBmcm9tICcuL0RlcGFydHVyZUJhc2UnO1xuaW1wb3J0IHsgc2luIH0gZnJvbSAnLi4vLi4vbWF0aC9jb3JlJztcbmltcG9ydCB7IHRhdSB9IGZyb20gJy4uLy4uL21hdGgvY2lyY2xlJztcbmltcG9ydCB7IGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IFRJTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZ2xvYmFsQ29uc3RhbnRzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBkZXBhcnR1cmVzIGluIGN5Y2xpYyBwYXR0ZXJuXG4gKlxuICogQGNsYXNzIERlcGFydHVyZUN5Y2xpY1xuICogQGV4dGVuZHMgRGVwYXJ0dXJlQmFzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXBhcnR1cmVDeWNsaWMgZXh0ZW5kcyBEZXBhcnR1cmVCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIERlcGFydHVyZUJhc2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhaXJwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFpcnBvcnQsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZW5ndGggb2YgYSBjeWNsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgcGVyaW9kXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFRJTUUuT05FX0hPVVJfSU5fU0VDT05EU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZXJpb2QgPSBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IGF0IHRoZSBwZWFrXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGVuIHRoZSBjeWNsZSBwZWFrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgb2Zmc2V0XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IC05MDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gLTkwMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IF9hbXBsaXR1ZGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FtcGxpdHVkZSA9IFRJTUUuT05FX0hPVVJfSU5fU0VDT05EUyAvIHRoaXMuZnJlcXVlbmN5IC8gMjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IF9hdmVyYWdlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hdmVyYWdlID0gVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gdGhpcy5mcmVxdWVuY3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBEZXBhcnR1cmVDeWNsaWNcbiAgICAgKiBAbWV0aG9kIHBhcnNlXG4gICAgICovXG4gICAgcGFyc2Uob3B0aW9ucykge1xuICAgICAgICBzdXBlci5wYXJzZShvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5wZXJpb2QpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gY29udmVydE1pbnV0ZXNUb1NlY29uZHMob3B0aW9ucy5wZXJpb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlcnNcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gLXRoaXMucGVyaW9kIC8gNCArIGNvbnZlcnRNaW51dGVzVG9TZWNvbmRzKG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgRGVwYXJ0dXJlQ3ljbGljXG4gICAgICogQG1ldGhvZCBuZXh0SW50ZXJ2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbmV4dEludGVydmFsKCkge1xuICAgICAgICBjb25zdCBnYW1lVGltZVdpdGhPZmZzZXQgPSB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgY29uc3Qgc2luT2Zmc2V0T3ZlclBlcmlvZCA9IHNpbih0YXUoKSAqIChnYW1lVGltZVdpdGhPZmZzZXQgLyB0aGlzLnBlcmlvZCkpO1xuICAgICAgICBjb25zdCBhbXBsaXR1ZGVUaW1lc1Npbk9mZnNldE92ZXJQZXJpb2QgPSB0aGlzLl9hbXBsaXR1ZGUgKiBzaW5PZmZzZXRPdmVyUGVyaW9kO1xuXG4gICAgICAgIHJldHVybiAoYW1wbGl0dWRlVGltZXNTaW5PZmZzZXRPdmVyUGVyaW9kICsgdGhpcy5fYXZlcmFnZSkgLyB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZS5mcmVxdWVuY3k7XG4gICAgfVxufVxuIiwiaW1wb3J0IERlcGFydHVyZUN5Y2xpYyBmcm9tICcuL0RlcGFydHVyZUN5Y2xpYyc7XG5pbXBvcnQgeyBUSU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2dsb2JhbENvbnN0YW50cyc7XG5cbi8qKlxuICogR2VuZXJhdGUgZGVwYXJ0dXJlcyBpbiBhIHJlcGVhdGluZyB3YXZlXG4gKlxuICogQGNsYXNzIERlcGFydHVyZVdhdmVcbiAqIEBleHRlbmRzIERlcGFydHVyZUN5Y2xpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXBhcnR1cmVXYXZlIGV4dGVuZHMgRGVwYXJ0dXJlQ3ljbGljIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIERlcGFydHVyZUN5Y2xpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0SW5zdGFuY2VNb2RlbH1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFpcnBvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoYWlycG9ydCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGNvbW1lbnRpbmcgb2YgdGhlIG1hZ2ljIG51bWJlcnMgaW4gdGhpcyBmaWxlLiBlbnVtZXJhdGUgdGhlIG1hZ2ljIG51bWJlcnMuXG4gICAgICAgIC8vIFRpbWUgYmV0d2VlbiBhaXJjcmFmdCBpbiB0aGUgd2F2ZVxuICAgICAgICB0aGlzLl9zZXBhcmF0aW9uID0gMTA7XG5cbiAgICAgICAgLy8gQWlyY3JhZnQgcGVyIHdhdmVcbiAgICAgICAgdGhpcy5fY291bnQgPSBNYXRoLmZsb29yKHRoaXMuX2F2ZXJhZ2UgLyBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFMgKiB0aGlzLnBlcmlvZCk7XG5cbiAgICAgICAgaWYgKCh0aGlzLnBlcmlvZCAvIHRoaXMuX3NlcGFyYXRpb24pIDwgdGhpcy5fY291bnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWR1Y2luZyBhdmVyYWdlIGRlcGFydHVyZSBmcmVxdWVuY3kgZnJvbSAke3RoaXMuX2F2ZXJhZ2V9L2hvdXIgdG8gbWFpbnRhaW4gbWluaW11bSBpbnRlcnZhbGApO1xuXG4gICAgICAgICAgICB0aGlzLl9jb3VudCA9IE1hdGguZmxvb3IoVElNRS5PTkVfSE9VUl9JTl9TRUNPTkRTIC8gdGhpcy5fc2VwYXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2YgYSB3YXZlIGluIHNlY29uZHNcbiAgICAgICAgdGhpcy5fd2F2ZUxlbmd0aCA9IHRoaXMuX3NlcGFyYXRpb24gKiB0aGlzLl9jb3VudCAtIDE7XG5cbiAgICAgICAgLy8gT2Zmc2V0IHRvIGhhdmUgY2VudGVyIG9mIHdhdmUgYXQgMCB0aW1lXG4gICAgICAgIHRoaXMuX29mZnNldCA9ICh0aGlzLl93YXZlTGVuZ3RoIC0gdGhpcy5fc2VwYXJhdGlvbikgLyAyICsgdGhpcy5vZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBEZXBhcnR1cmVDeWNsaWNcbiAgICAgKiBAbWV0aG9kIG5leHRJbnRlcnZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBuZXh0SW50ZXJ2YWwoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lX3RpbWUoKSArIHRoaXMuX29mZnNldCkgJSB0aGlzLnBlcmlvZDtcblxuICAgICAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5fd2F2ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyaW9kIC0gcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2VwYXJhdGlvbiAvIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLmZyZXF1ZW5jeTtcbiAgICB9XG59XG4iLCJpbXBvcnQgRGVwYXJ0dXJlQmFzZSBmcm9tICcuL0RlcGFydHVyZUJhc2UnO1xuaW1wb3J0IERlcGFydHVyZUN5Y2xpYyBmcm9tICcuL0RlcGFydHVyZUN5Y2xpYyc7XG5pbXBvcnQgRGVwYXJ0dXJlV2F2ZSBmcm9tICcuL0RlcGFydHVyZVdhdmUnO1xuaW1wb3J0IHsgTE9HIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2xvZ0xldmVsJztcblxuLyoqXG4gKiBDYWxscyBjb25zdHJ1Y3RvciBvZiB0aGUgYXBwcm9wcmlhdGUgYXJyaXZhbCB0eXBlXG4gKlxuICogQGZ1bmN0aW9uIERlcGFydHVyZUZhY3RvcnlcbiAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0TW9kZWx9XG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICogQHJldHVybiB7Y29uc3RydWN0b3J9XG4gKi9cbmV4cG9ydCBjb25zdCBkZXBhcnR1cmVGYWN0b3J5ID0gKGFpcnBvcnQsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnJykge1xuICAgICAgICByZXR1cm4gbG9nKGAke2FpcnBvcnQuaWNhb30gZGVwYXJ0dXJlIHN0cmVhbSBub3QgZ2l2ZW4gdHlwZSFgLCBMT0cuV0FSTklORyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncmFuZG9tJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVwYXJ0dXJlQmFzZShhaXJwb3J0LCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSAnY3ljbGljJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVwYXJ0dXJlQ3ljbGljKGFpcnBvcnQsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlICd3YXZlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVwYXJ0dXJlV2F2ZShhaXJwb3J0LCBvcHRpb25zKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZyhgJHthaXJwb3J0LmljYW99IHVzaW5nIHVuc3VwcG9ydGVkIGRlcGFydHVyZSB0eXBlIFwiJHtvcHRpb25zLnR5cGV9XCJgLCBMT0cuV0FSTklORyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuIiwiaW1wb3J0IF9jb21wYWN0IGZyb20gJ2xvZGFzaC9jb21wYWN0JztcbmltcG9ydCBfZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgbW9kZWxTb3VyY2VGYWN0b3J5IGZyb20gJy4uLy4uL2Jhc2UvTW9kZWxTb3VyY2UvTW9kZWxTb3VyY2VGYWN0b3J5JztcbmltcG9ydCBCYXNlQ29sbGVjdGlvbiBmcm9tICcuLi8uLi9iYXNlL0Jhc2VDb2xsZWN0aW9uJztcbmltcG9ydCBGaXhNb2RlbCBmcm9tICcuL0ZpeE1vZGVsJztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBgRml4TW9kZWxgcyBkZWZpbmVkIGluIGFuIGFpcnBvcnQganNvbiBmaWxlLlxuICpcbiAqIFRoaXMgaXMgYnVpbHQgYXMgYSBzdGF0aWMgY2xhc3MsIHNvIHRoZXJlIGlzIG9ubHkgZXZlciBvbmNlIGluc3RhbmNlLlxuICogV2UgdXNlIGEgc3RhdGljIGNsYXNzIGhlcmUgYmVjYXVzZSB0aGUgbWV0aG9kcyBjb250YWluZWQgaGVyZWluIGFyZSBuZWVkZWQgYnkgc2V2ZXJhbFxuICogZGlmZmVyZW50IGNsYXNzZXMuIFRoaXMgcHJvdmlkZXMgYSBzaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciBhbGwgdGhlIGBGaXhNb2RlbGBzXG4gKiBiZWxvbmdpbmcgdG8gYW4gQWlycG9ydC5cbiAqXG4gKiBAY2xhc3MgRml4Q29sbGVjdGlvblxuICogQGV4dGVuZHMgQmFzZUNvbGxlY3Rpb25cbiAqL1xuY2xhc3MgRml4Q29sbGVjdGlvbiBleHRlbmRzIEJhc2VDb2xsZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgbWV0aG9kLiBTaG91bGQgYmUgcnVuIG9ubHkgb25jZSBvbiBpbnN0YW50aWF0aW9uLlxuICAgICAqXG4gICAgICogQGZvciBGaXhDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBhZGRJdGVtc1xuICAgICAqIEBwYXJhbSBmaXhMaXN0IHtvYmplY3R9XG4gICAgICogQHBhcmFtIGFpcnBvcnRQb3NpdGlvbiB7UG9zaXRpb25Nb2RlbH1cbiAgICAgKi9cbiAgICBhZGRJdGVtcyhmaXhMaXN0LCBhaXJwb3J0UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyB5b3UgbWFkZSBpdCBoZXJlIGJlY2F1c2UgYW4gYWlycG9ydCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIC8vIGluIGBBaXJwb3J0TW9kZWwucGFyc2UoKWAgdGhpcyBtZXRob2QgaXMgY2FsbGVkIHdpdGggdGhlIGZpeCBkYXRhIGZvciB0aGUgbmV3IGFpcnBvcnQuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgIC8vIG9yIG5lZWQgdG8ga2VlcCB0aGUgZml4ZXMgZnJvbSBhIHByZXZpb3VzIGFpcnBvcnQgc28gaWYgYF9pdGVtc2AgaGFzIGEgbGVuZ3RoLCB3ZSBuZWVkIHRvIHJlc2V0IHRoYXRcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IGJlZm9yZSB3ZSBiZWdpbiB0byBhZGQgZml4ZXMgZm9yIHRoZSBuZXcgYWlycG9ydC5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1aWxkRml4TW9kZWxzRnJvbUxpc3QoZml4TGlzdCwgYWlycG9ydFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIHJlbW92ZUl0ZW1zXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbXMoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Rml4TW9kZWxzKCk7XG5cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBgRml4TW9kZWxgIHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGFkZEZpeFRvQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBmaXhUb0FkZCB7Rml4TW9kZWx9XG4gICAgICovXG4gICAgYWRkRml4VG9Db2xsZWN0aW9uKGZpeFRvQWRkKSB7XG4gICAgICAgIGlmICghKGZpeFRvQWRkIGluc3RhbmNlb2YgRml4TW9kZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBmaXhUb0FkZCB0byBiZSBhbiBpbnN0YW5jZSBvZiBGaXhNb2RlbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChmaXhUb0FkZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGBGaXhNb2RlbGAgYnkgYG5hbWVgIGlmIGl0IGV4aXN0cyB3aXRoaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGZpbmRGaXhCeU5hbWVcbiAgICAgKiBAcGFyYW0gZml4TmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge0ZpeE1vZGVsfG51bGx9XG4gICAgICovXG4gICAgZmluZEZpeEJ5TmFtZShmaXhOYW1lKSB7XG4gICAgICAgIGNvbnN0IGZpeE1vZGVsID0gX2ZpbmQodGhpcy5faXRlbXMsIHsgbmFtZTogZml4TmFtZS50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gICAgICAgIC8vIGlmIGEgZml4IGlzIG5vdCBmb3VuZCwgX2ZpbmQoKSByZXR1cm5zIGB1bmRlZmluZWRgIHNvIHdlIHNwZWNpZmljYWxseSByZXR1cm4gbnVsbCBoZXJlIGlmIGEgZml4IGlzIG5vdCBmb3VuZFxuICAgICAgICByZXR1cm4gZml4TW9kZWwgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGdldEZpeFBvc2l0aW9uQ29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gZml4TmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge2FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0Rml4UG9zaXRpb25Db29yZGluYXRlcyhmaXhOYW1lKSB7XG4gICAgICAgIGNvbnN0IGZpeE1vZGVsID0gdGhpcy5maW5kRml4QnlOYW1lKGZpeE5hbWUpO1xuXG4gICAgICAgIGlmICghZml4TW9kZWwpIHtcbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaXhNb2RlbC5wb3NpdGlvblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBsaXN0IG9mIGFsbCBgRml4TW9kZWxgcyB3aXRoaW4gdGhlIGNvbGxlY3Rpb24gdGhhdCBoYXZlIGEgbmFtZSB0aGF0IGRvZXMgbm90IHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZS5cbiAgICAgKlxuICAgICAqIEBmb3IgRml4Q29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZmluZFJlYWxGaXhlc1xuICAgICAqIEByZXR1cm4ge2FycmF5PEZpeE1vZGVsPn1cbiAgICAgKi9cbiAgICBmaW5kUmVhbEZpeGVzKCkge1xuICAgICAgICBjb25zdCByZWFsRml4TGlzdCA9IF9tYXAodGhpcy5faXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5uYW1lLmluZGV4T2YoJ18nKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2NvbXBhY3QocmVhbEZpeExpc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvb3AgdGhyb3VnaCBlYWNoIGZpeCBwcm92aWRlZCBpbiB0aGUgZml4IGxpc3QsIGNyZWF0ZSBhIG5ldyBgRml4TW9kZWxgIGluc3RhbmNlLCB0aGVuIHNlbmQgaXQgb2ZmXG4gICAgICogdG8gYmUgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIF9idWlsZEZpeE1vZGVsc0Zyb21MaXN0XG4gICAgICogQHBhcmFtIGZpeExpc3Qge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9idWlsZEZpeE1vZGVsc0Zyb21MaXN0KGZpeExpc3QsIGFpcnBvcnRQb3NpdGlvbikge1xuICAgICAgICBfZm9yRWFjaChmaXhMaXN0LCAoZml4Q29vcmRpbmF0ZXMsIGZpeE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpeE1vZGVsID0gbW9kZWxTb3VyY2VGYWN0b3J5LmdldE1vZGVsU291cmNlRm9yVHlwZSgnRml4TW9kZWwnLCBmaXhOYW1lLCBmaXhDb29yZGluYXRlcywgYWlycG9ydFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRGaXhUb0NvbGxlY3Rpb24oZml4TW9kZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEZpeENvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIF9yZXNldEZpeE1vZGVsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0Rml4TW9kZWxzKCkge1xuICAgICAgICBfZm9yRWFjaCh0aGlzLl9pdGVtcywgKGZpeE1vZGVsKSA9PiB7XG4gICAgICAgICAgICBmaXhNb2RlbC5yZXNldCgpO1xuICAgICAgICAgICAgbW9kZWxTb3VyY2VGYWN0b3J5LnJldHVybk1vZGVsVG9Qb29sKGZpeE1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgRml4Q29sbGVjdGlvbigpO1xuIiwiaW1wb3J0IF9jbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4uLy4uL2Jhc2UvQmFzZU1vZGVsJztcbmltcG9ydCBQb3NpdGlvbk1vZGVsIGZyb20gJy4uLy4uL2Jhc2UvUG9zaXRpb25Nb2RlbCc7XG5cbi8qKlxuICogRGVmaW5lcyBhIG5hdmlnYXRpb25hbCBgRml4TW9kZWxgXG4gKlxuICogQSBgRml4TW9kZWxgIGNhbiBiZSB1c2VkIGFzIHBhcnQgb2YgYSBgU3RhbmRhcmRSb3V0ZWAgb3IgYXMgYSBuYXZpYWd0aW9uYWwgYWlkLlxuICogTm90IGFsbCBgRml4TW9kZWxgcyBhcmUgYSBwYXJ0IG9mIGEgYFN0YW5kYXJkUm91dGVgLlxuICpcbiAqIEBjbGFzcyBGaXhNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQGZvciBGaXhNb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBmaXhOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGZpeENvb3JkaW5hdGUge2FycmF5fVxuICAgICAqIEBwYXJhbSBhaXJwb3J0UG9zaXRpb24ge1Bvc2l0aW9uTW9kZWx9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZml4TmFtZSwgZml4Q29vcmRpbmF0ZSwgYWlycG9ydFBvc2l0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhlIEZpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvb3JkaW5hdGVzIG9mIHRoZSBmaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9maXhQb3NpdGlvblxuICAgICAgICAgKiBAdHlwZSB7UG9zaXRpb25Nb2RlbH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZml4UG9zaXRpb24gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaW5pdChmaXhOYW1lLCBmaXhDb29yZGluYXRlLCBhaXJwb3J0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcG9zaXRpb24gZGF0YSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpeFBvc2l0aW9uLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QuIFNob3VsZCBiZSBydW4gb25seSBvbmNlIG9uIGluc3RhbnRpYXRpb24uXG4gICAgICpcbiAgICAgKiBAZm9yIEZpeE1vZGVsXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICogQHBhcmFtIGZpeE5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZml4Q29vcmRpbmF0ZSB7YXJyYXl9XG4gICAgICogQHBhcmFtIGFpcnBvcnRQb3NpdGlvbiB7UG9zaXRpb25Nb2RlbH1cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgaW5pdChmaXhOYW1lLCBmaXhDb29yZGluYXRlLCBhaXJwb3J0UG9zaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgYSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBlYXJseT9cbiAgICAgICAgaWYgKCFmaXhOYW1lIHx8ICFmaXhDb29yZGluYXRlIHx8ICFhaXJwb3J0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZSA9IGZpeE5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdGhpcy5fZml4UG9zaXRpb24gPSBuZXcgUG9zaXRpb25Nb2RlbChmaXhDb29yZGluYXRlLCBhaXJwb3J0UG9zaXRpb24sIGFpcnBvcnRQb3NpdGlvbi5tYWduZXRpY05vcnRoSW5SYWRpYW5zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNldCB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZvciBGaXhNb2RlbFxuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9maXhQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIGFuIGluc3RhbmNlJ3MgYF9maXhQb3NpdGlvbmAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHRoaXMgaXMgYSBfY2xvbmVfIGFuZCBub3QgYSBjb3B5LiBPbmNlIGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhpcyBpbnN0YW5jZSB3aWxsXG4gICAgICogbm90IGJlIHJlZmxlY3RlZCBpbiB0aGUgY2xvbmUuIFRoaXMgY3JlYXRlcyBhbiBlbnRpcmVseSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBfZml4UG9zaXRpb25gIHByb3BlcnR5LFxuICAgICAqIGFuZCBhZnRlciBjcmVhdGlvbiBpcyBjb21wbGV0ZWx5IGluZGVwZW5kYW50IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgd2l0aCBgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWxgIG9iamVjdHMgdG8gb2J0YWluIHRoZSBwb3NpdGlvbiBvZiBhIGZpeC4gVGhpcyBtZXRob2RcbiAgICAgKiBwcm92aWRlcyBlYXN5IGFjY2VzcyB0byB0aGUgYFBvc2l0aW9uTW9kZWxgIHRoYXQgYWxyZWFkeSBleGlzdHMgaGVyZS5cbiAgICAgKlxuICAgICAqIEBmb3IgRml4TW9kZWxcbiAgICAgKiBAcmV0dXJuIHtQb3NpdGlvbk1vZGVsfSAgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBgX2ZpeFBvc2l0aW9uYCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGNsb25lUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2xvbmVEZWVwKHRoaXMuX2ZpeFBvc2l0aW9uKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4uLy4uL2Jhc2UvQmFzZU1vZGVsJztcblxuLyoqXG4gKiBTeW1ib2wgdGhhdCBkaXZpZGVzIGVhY2ggcm91dGUgc2VnbWVudFxuICpcbiAqIEBwcm9wZXJ0eSBTRUdNRU5UX1NFUEFSQVRJT05fU1lNQk9MXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFNFR01FTlRfU0VQQVJBVElPTl9TWU1CT0wgPSAnLic7XG5cbi8qKlxuICogQSByb3V0ZSBpcyBhc3N1bWVkIHRvIGhhdmUsIGF0IG1vc3QsIHRocmVlIHBhcnRzLlxuICpcbiAqIEBwcm9wZXJ0eSBNQVhJTVVNX1JPVVRFX1NFR01FTlRfTEVOR1RIXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IE1BWElNVU1fUk9VVEVfU0VHTUVOVF9MRU5HVEggPSAzO1xuXG4vLyBUT0RPOiB0aGlzIGNsYXNzIG5lZWRzIGEgYmV0dGVyIG5hbWVcbi8qKlxuICogQGNsYXNzIFJvdXRlTW9kZWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgLyoqXG4gICAgICogZXhhbXBsZSBgcm91dGVDb2RlYFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogJ0JFVEhMLkdSTlBBMS5LTEFTJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogLy8gVE9ETzogc2hvdWxkIGJlIGFibGUgdG8gc3VwcG9ydCBpbnB1dCBvZjpcbiAgICAgKiAtIEtTRk8uT0ZGU0g5LlNYQy5WNDU4LklQTC5KMi5KQ1QuLkxMTy4uQUNULi5LQUNUXG4gICAgICogd2hpY2ggY2FuIGJlIHJldHVybmVkIGFzOlxuICAgICAqIC0gWydLU0ZPLk9GRlNIOS5TWEMnLCAnU1hDLlY0NTguSVBMJywgJ0lQTC5KMi5KQ1QnLCAnTExPJywgJ0FDVCcsICdLQUNUJ11cbiAgICAgKlxuICAgICAqIEBmb3IgUm91dGVNb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSByb3V0ZUNvZGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZUNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJvdXRlQ29kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJvdXRlQ29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgZGF0YSB0eXBlIHBhc3NlZCB0byBSb3V0ZU1vZGVsLiBFeHBlY3RlZCBhIHN0cmluZyBidXQgcmVjZWl2ZWQgJHtyb3V0ZUNvZGV9YCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZFJvdXRlQ29kZShyb3V0ZUNvZGUpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByb3V0ZUNvZGUgcGFzc2VkIHRvIFJvdXRlTW9kZWwuIEV4cGVjdGVkIGEgcm91dGVDb2RlIG9mIHRoZSBzaGFwZSBPUklHSU4uQkFTRS5ERVNUSU5BVElPTiBidXQgaW5zdGVhZCByZWNlaXZlZCAke3JvdXRlQ29kZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgZW50cnlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW50cnkgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHByb2NlZHVyZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZWR1cmUgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGV4aXRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhpdCA9ICcnO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KHJvdXRlQ29kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW5nbGUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgZW50aXJlIHJvdXRlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcm91dGVDb2RlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCByb3V0ZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmVudHJ5fS4ke3RoaXMucHJvY2VkdXJlfS4ke3RoaXMuZXhpdH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QuIFNob3VsZCBiZSBydW4gb25seSBvbmNlIG9uIGluc3RhbnRpYXRpb25cbiAgICAgKlxuICAgICAqIEBmb3IgUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcGFyYW0gcm91dGVDb2RlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdChyb3V0ZUNvZGUpIHtcbiAgICAgICAgY29uc3QgeyBlbnRyeSwgYmFzZSwgZXhpdCB9ID0gdGhpcy5fZXh0cmFjdFNlZ21lbnROYW1lc0Zyb21Sb3V0ZUNvZGUocm91dGVDb2RlKTtcblxuICAgICAgICB0aGlzLmVudHJ5ID0gZW50cnkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdGhpcy5wcm9jZWR1cmUgPSBiYXNlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuZXhpdCA9IGV4aXQudG9VcHBlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNldCB0aGlzIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZm9yIFJvdXRlTW9kZWxcbiAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZW50cnkgPSAnJztcbiAgICAgICAgdGhpcy5wcm9jZWR1cmUgPSAnJztcbiAgICAgICAgdGhpcy5leGl0ID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfZXh0cmFjdFNlZ21lbnROYW1lc0Zyb21Sb3V0ZUNvZGVcbiAgICAgKiBAcGFyYW0gcm91dGVDb2RlIHtzdHJpbmd9XG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dHJhY3RTZWdtZW50TmFtZXNGcm9tUm91dGVDb2RlKHJvdXRlQ29kZSkge1xuICAgICAgICBjb25zdCByb3V0ZVNlZ21lbnRzID0gcm91dGVDb2RlLnNwbGl0KFNFR01FTlRfU0VQQVJBVElPTl9TWU1CT0wpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnRyeTogcm91dGVTZWdtZW50c1swXSxcbiAgICAgICAgICAgIGJhc2U6IHJvdXRlU2VnbWVudHNbMV0sXG4gICAgICAgICAgICBleGl0OiByb3V0ZVNlZ21lbnRzWzJdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoYXQgYSByb3V0ZUNvZGUgaGFzIGV4YWN0bHkgMyBzZWdtZW50c1xuICAgICAqXG4gICAgICogQGZvciBSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfaXNWYWxpZFJvdXRlQ29kZVxuICAgICAqIEBwYXJhbSByb3V0ZUNvZGUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzVmFsaWRSb3V0ZUNvZGUocm91dGVDb2RlKSB7XG4gICAgICAgIHJldHVybiByb3V0ZUNvZGUuc3BsaXQoU0VHTUVOVF9TRVBBUkFUSU9OX1NZTUJPTCkubGVuZ3RoID09PSBNQVhJTVVNX1JPVVRFX1NFR01FTlRfTEVOR1RIO1xuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlTW9kZWwgZnJvbSAnLi4vYmFzZS9CYXNlTW9kZWwnO1xuaW1wb3J0IFBvc2l0aW9uTW9kZWwgZnJvbSAnLi4vYmFzZS9Qb3NpdGlvbk1vZGVsJztcbmltcG9ydCB7IGFicywgdGFuIH0gZnJvbSAnLi4vbWF0aC9jb3JlJztcbmltcG9ydCB7IHJhZGlhbnNfbm9ybWFsaXplIH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsga20sIGRlZ3JlZXNUb1JhZGlhbnMgfSBmcm9tICcuLi91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMnO1xuaW1wb3J0IHsgdmxlbiwgdnJhZGlhbCwgdnN1YiwgdmFkZCwgdnNjYWxlIH0gZnJvbSAnLi4vbWF0aC92ZWN0b3InO1xuXG4vKipcbiAqIEBjbGFzcyBSdW53YXlNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW53YXlNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQGZvciBSdW53YXlNb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9XG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqIEBwYXJhbSBhaXJwb3J0IHtBaXJwb3J0TW9kZWx9XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBlbmQsIGFpcnBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBvcHRpb25zLmFpcnBvcnQgPSBhaXJwb3J0O1xuICAgICAgICB0aGlzLmFpcnBvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGV2YXRpb24gPSAwO1xuICAgICAgICB0aGlzLmRlbGF5ID0gMjtcbiAgICAgICAgdGhpcy5ncHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbHMgPSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGRvIHRoZXNlIG51bWJlcnMgbWVhbj8gZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJzXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbG9jX21heERpc3Q6IGttKDI1KSxcbiAgICAgICAgICAgIGdzX21heEhlaWdodDogOTk5OSxcbiAgICAgICAgICAgIGdzX2dyYWRpZW50OiBkZWdyZWVzVG9SYWRpYW5zKDMpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGFiZWxQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBudWxsO1xuICAgICAgICB0aGlzLm1pZGZpZWxkID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW107XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zZXBGcm9tQWRqYWNlbnQgPSBrbSgzKTtcblxuICAgICAgICB0aGlzLnBhcnNlKG9wdGlvbnMsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBSdW53YXlNb2RlbFxuICAgICAqIEBtZXRob2QgcGFyc2VcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBlbmRcbiAgICAgKi9cbiAgICBwYXJzZShkYXRhLCBlbmQpIHtcbiAgICAgICAgdGhpcy5haXJwb3J0ID0gZGF0YS5haXJwb3J0O1xuXG4gICAgICAgIGlmIChkYXRhLmRlbGF5KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGF0YS5kZWxheVtlbmRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzU2lkZSA9IG5ldyBQb3NpdGlvbk1vZGVsKGRhdGEuZW5kW2VuZF0sIGRhdGEucmVmZXJlbmNlX3Bvc2l0aW9uLCBkYXRhLm1hZ25ldGljX25vcnRoKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiByZXNzaWdubWVudCBvZiBhbiBhcmd1bWVudCB3aXRoIGFuIGlubGluZSB0ZXJuYXJ5PyB0aGlzIGxpbmUgbmVlZHMgc29tZSB3b3JrLlxuICAgICAgICAgICAgY29uc3QgZmFyU2lkZSA9IG5ldyBQb3NpdGlvbk1vZGVsKGRhdGEuZW5kWyhlbmQgPT09IDApID8gMSA6IDBdLCBkYXRhLnJlZmVyZW5jZV9wb3NpdGlvbiwgZGF0YS5tYWduZXRpY19ub3J0aCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IGBncHNgIGFuZCBgZWxldmF0aW9uYCBhcmUgYXZhaWxhYmxlIGZyb20gdGhlIGBQb3NpdGlvbk1vZGVsYCBhbmQgc2hvdWxkIGJlIHB1bGxlZCBmcm9tIHRoZXJlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHNldHRpbmcgZGlyZWN0IHByb3BlcnRpZXMuIElmIGRpcmVjdCBwcm9wZXJ0aWVzIGFyZSBuZWVkZWQsIHVzZSBnZXR0ZXJzIGlzbnRlYWQuXG4gICAgICAgICAgICAvLyBHUFMgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5ncHMgPSBbdGhpc1NpZGUubGF0aXR1ZGUsIHRoaXNTaWRlLmxvbmdpdHVkZV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzU2lkZS5lbGV2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxldmF0aW9uID0gdGhpc1NpZGUuZWxldmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMuZWxldmF0aW9uID09PSAwKSAmJiAodGhpcy5haXJwb3J0LmVsZXZhdGlvbiAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZXZhdGlvbiA9IHRoaXMuYWlycG9ydC5lbGV2YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbGF0aXZlIHBvc2l0aW9uLCBiYXNlZCBvbiBjZW50ZXIgb2YgbWFwXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpc1NpZGUucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHZsZW4odnN1YihmYXJTaWRlLnBvc2l0aW9uLCB0aGlzU2lkZS5wb3NpdGlvbikpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBpcyB0aGUgMC41IGZvcj8gZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJcbiAgICAgICAgICAgIHRoaXMubWlkZmllbGQgPSB2c2NhbGUodmFkZCh0aGlzU2lkZS5wb3NpdGlvbiwgZmFyU2lkZS5wb3NpdGlvbiksIDAuNSk7XG4gICAgICAgICAgICB0aGlzLmFuZ2xlID0gcmFkaWFuc19ub3JtYWxpemUodnJhZGlhbCh2c3ViKGZhclNpZGUucG9zaXRpb24sIHRoaXNTaWRlLnBvc2l0aW9uKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuaWxzKSB7XG4gICAgICAgICAgICB0aGlzLmlscy5lbmFibGVkID0gZGF0YS5pbHNbZW5kXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmlsc19kaXN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbHMubG9jX21heERpc3QgPSBrbShkYXRhLmlsc19kaXN0YW5jZVtlbmRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmlsc19nc19tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaWxzLmdzX21heEhlaWdodCA9IGRhdGEuaWxzX2dzX21heEhlaWdodFtlbmRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZ2xpZGVzbG9wZSkge1xuICAgICAgICAgICAgdGhpcy5pbHMuZ3NfZ3JhZGllbnQgPSBkZWdyZWVzVG9SYWRpYW5zKGRhdGEuZ2xpZGVzbG9wZVtlbmRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLm5hbWVfb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsUG9zID0gZGF0YS5uYW1lX29mZnNldFtlbmRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lW2VuZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5zZXBGcm9tQWRqYWNlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VwRnJvbUFkamFjZW50ID0ga20oZGF0YS5zZXBGcm9tQWRqYWNlbnRbZW5kXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQGZvciBSdW53YXlNb2RlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBhZGRRdWV1ZShhaXJjcmFmdCkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goYWlyY3JhZnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZm9yIFJ1bndheU1vZGVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHJlbW92ZVF1ZXVlKGFpcmNyYWZ0LCBmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZVswXSA9PT0gYWlyY3JhZnQgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUuc2hpZnQoYWlyY3JhZnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVbMF0ubW92ZUZvcndhcmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBmb3IgUnVud2F5TW9kZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgaW5RdWV1ZShhaXJjcmFmdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5pbmRleE9mKGFpcmNyYWZ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQGZvciBSdW53YXlNb2RlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICB0YXhpRGVsYXkoKSB7XG4gICAgICAgIC8vIFRPRE86IHdoYXQgZG9lcyAzIG1lYW4/IGVudW1lcmF0ZSB0aGUgbWFnaWMgbnVtYmVycy5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRlbGF5ICsgTWF0aC5yYW5kb20oKSkgKiAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZm9yIFJ1bndheU1vZGVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGdldEdsaWRlc2xvcGVBbHRpdHVkZShkaXN0YW5jZSwgLyogb3B0aW9uYWwgKi8gZ3NfZ3JhZGllbnQpIHtcbiAgICAgICAgaWYgKCFnc19ncmFkaWVudCkge1xuICAgICAgICAgICAgZ3NfZ3JhZGllbnQgPSB0aGlzLmlscy5nc19ncmFkaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCByaXNlID0gdGFuKGFicyhnc19ncmFkaWVudCkpO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgbG9naWMgY291bGQgYmUgYWJzdHJhY3RlZCB0byBhIGhlbHBlci5cbiAgICAgICAgLy8gVE9ETzogd2hhdCBkb2VzIDMyODAgbWVhbj8gZW51bWVyYXRlIHRoZSBtYWdpYyBudW1iZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxldmF0aW9uICsgKHJpc2UgKiBkaXN0YW5jZSAqIDMyODApO1xuICAgIH1cbn1cbiIsImltcG9ydCBfZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJ2xvZGFzaC9pc0FycmF5JztcbmltcG9ydCBfaXNPYmplY3QgZnJvbSAnbG9kYXNoL2lzT2JqZWN0JztcbmltcG9ydCBfbWFwIGZyb20gJ2xvZGFzaC9tYXAnO1xuaW1wb3J0IEJhc2VDb2xsZWN0aW9uIGZyb20gJy4uLy4uL2Jhc2UvQmFzZUNvbGxlY3Rpb24nO1xuaW1wb3J0IFJvdXRlU2VnbWVudE1vZGVsIGZyb20gJy4vUm91dGVTZWdtZW50TW9kZWwnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBgUm91dGVTZWdtZW50YHMuXG4gKlxuICogUHJvdmlkZSBhIHdheSB0byBkZWFsIHdpdGggdGhlIHZhcmlvdXMgcGFydHMgb2YgYSBgU3RhbmRhcmRQcm9jZWR1cmVSb3V0ZWAgYXMgZGVmaW5lZCBpbiBlYWNoXG4gKiBhaXJwb3J0IGpzb24gZmlsZS5cbiAqXG4gKiBFYWNoIFNJRCBpcyBicm9rZW4gdXAgaW50byB0aHJlZSByb3V0ZSBzZWdtZW50czpcbiAqIC0gYHJ3eWAgKG9wdGlvbmFsKVxuICogLSBgYm9keWBcbiAqIC0gYGV4aXRQb2ludHNgIChvcHRpb25hbClcbiAqXG4gKiBFYWNoIFNUQVIgaXMgYnJva2VuIHVwIGludG8gdGhyZWUgcm91dGUgc2VnbWVudHM6XG4gKiAtIGBlbnRyeVBvaW50c2AgKG9wdGlvbmFsKVxuICogLSBgYm9keWBcbiAqIC0gYHJ3eWAgKG9wdGlvbmFsKVxuICpcbiAqIFRoaXMgY29sbGVjdGlvbiBpcyBtZWFudCB0byBjb250YWluIHRoZSB3YXlwb2ludHMgZm9yIGEgc2luZ2xlIHJvdXRlIHNlZ21lbnQgYW5kIGNhbiBiZVxuICogdXNlZCB0byByZXNhb24gYWJvdXQgdGhlIHJvdXRlIGFzIGEgc2luZ2xlIHVuaXQuXG4gKlxuICogQGNsYXNzIFJvdXRlU2VnbWVudENvbGxlY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVTZWdtZW50Q29sbGVjdGlvbiBleHRlbmRzIEJhc2VDb2xsZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcm91dGVTZWdtZW50cyB7b2JqZWN0fVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3RydWN0b3Iocm91dGVTZWdtZW50cykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygcm91dGVTZWdtZW50cyA9PT0gJ3VuZGVmaW5lZCcgfHwgIV9pc09iamVjdChyb3V0ZVNlZ21lbnRzKSB8fCBfaXNBcnJheShyb3V0ZVNlZ21lbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgcm91dGVTZWdtZW50cyB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2Ygcm91dGVTZWdtZW50c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoZSBSb3V0ZVNlZ21lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KHJvdXRlU2VnbWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYWNjZXNzIHRvIHRoZSBjb250ZW50cyBvZiBgX2l0ZW1zYFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGl0ZW1zXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIG1ldGhvZC4gU2hvdWxkIGJlIHJ1biBvbmx5IG9uY2Ugb24gaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgUm91dGVTZWdtZW50Q29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcGFyYW0gcm91dGVTZWdtZW50cyB7b2JqZWN0fVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0KHJvdXRlU2VnbWVudHMpIHtcbiAgICAgICAgX2ZvckVhY2gocm91dGVTZWdtZW50cywgKHJvdXRlV2F5cG9pbnRzLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlU2VnbWVudE1vZGVsID0gbmV3IFJvdXRlU2VnbWVudE1vZGVsKGtleSwgcm91dGVXYXlwb2ludHMpO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRTZWdtZW50VG9Db2xsZWN0aW9uKHJvdXRlU2VnbWVudE1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2lkID0gJyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBgUm91dGVTZWdtZW50TW9kZWxgIHdpdGhpbiB0aGUgY29sbGVjdGlvbiBieSBpdHMgbmFtZVxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBmaW5kU2VnbWVudEJ5TmFtZVxuICAgICAqIEBwYXJhbSBzZWdtZW50TmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge1NlZ21lbnRNb2RlbH1cbiAgICAgKi9cbiAgICBmaW5kU2VnbWVudEJ5TmFtZShzZWdtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gX2ZpbmQodGhpcy5faXRlbXMsIHsgbmFtZTogc2VnbWVudE5hbWUudG9VcHBlckNhc2UoKSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgbGlzdCBvZiB3YXlwb2ludHMgZm9yIGEgZ2l2ZW4gYHNlZ21lbnROYW1lYFxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBmaW5kV2F5cG9pbnRzRm9yU2VnbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gc2VnbWVudE5hbWUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBmaW5kV2F5cG9pbnRzRm9yU2VnbWVudE5hbWUoc2VnbWVudE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuZmluZFNlZ21lbnRCeU5hbWUoc2VnbWVudE5hbWUpO1xuXG4gICAgICAgIHJldHVybiBzZWdtZW50LmZpbmRXYXlwb2ludHNGb3JTZWdtZW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiBmaXhOYW1lcyBmb3IgYWxsIG9mIHRoZSBgUm91dGVTZWdtZW50TW9kZWxgcyBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBnYXRoZXJGaXhOYW1lc0ZvckNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnYXRoZXJGaXhOYW1lc0ZvckNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbWFwKHRoaXMuX2l0ZW1zLCAoaXRlbSkgPT4gaXRlbS5uYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgc2VnbWVudCB0byB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBfYWRkU2VnbWVudFRvQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzZWdtZW50IHtTZWdtZW50TW9kZWx9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFNlZ21lbnRUb0NvbGxlY3Rpb24oc2VnbWVudCkge1xuICAgICAgICBpZiAoIShzZWdtZW50IGluc3RhbmNlb2YgUm91dGVTZWdtZW50TW9kZWwpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc2VnbWVudCB0byBiZSBhbiBpbnN0YW5jZSBvZiBSb3V0ZVNlZ21lbnRNb2RlbCwgaW5zdGVhZCByZWNlaXZlZCAke3NlZ21lbnR9LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChzZWdtZW50KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCJpbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSAnbG9kYXNoL2lzQXJyYXknO1xuaW1wb3J0IEJhc2VNb2RlbCBmcm9tICcuLi8uLi9iYXNlL0Jhc2VNb2RlbCc7XG5pbXBvcnQgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWwgZnJvbSAnLi9TdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBkZWFsaW5nIHdpdGggYSBsaXN0IG9mIGBTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbGBzIHRoYXQgbWFrZSB1cCBhIGdpdmVuIHJvdXRlIHNlZ21lbnQuXG4gKlxuICogQGNsYXNzIFJvdXRlU2VnbWVudE1vZGVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlU2VnbWVudE1vZGVsIGV4dGVuZHMgQmFzZU1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBzZWdtZW50V2F5cG9pbnRzIHNob3VsZCBjb21lIGluIGEgc2ltaWxhciBzaGFwZSB0bzpcbiAgICAgKiAtIFtcIl9OQVBTRTA2OFwiLCBcIk5BUFNFXCIsIFtcIlJJT09TXCIsIFwiQTEzMCtcIl0sIFwiQ09NUFNcIl1cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9ICBJY2FvIG9mIHBhcnRpY3VsYXIgd2F5cG9pbnRcbiAgICAgKiBAcGFyYW0gc2VnbWVudFdheXBvaW50cyB7YXJyYXl9ICBhIG1peGVkIGFycmF5IG9mIHN0cmluZ3Mgb3IgYXJyYXlzIG9mIHN0cmluZ3NcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNlZ21lbnRXYXlwb2ludHMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoZSBSb3V0ZVNlZ21lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWxgcyB0aGF0IG1ha2UgdXAgdGhlIFJvdXRlU2VnbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2l0ZW1zXG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQobmFtZSwgc2VnbWVudFdheXBvaW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGl0ZW1zXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgcHJvcGVydHkgdG8gZ2V0IGF0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiBgX2l0ZW1zYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIG1ldGhvZC4gU2hvdWxkIGJlIHJ1biBvbmx5IG9uY2Ugb24gaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgUm91dGVTZWdtZW50TW9kZWxcbiAgICAgKiBAbWV0aG9kIF9pbml0XG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2VnbWVudFdheXBvaW50cyB7YXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdChuYW1lLCBzZWdtZW50V2F5cG9pbnRzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5KHNlZ21lbnRXYXlwb2ludHMpKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVXYXlwb2ludE1vZGVsc0Zyb21MaXN0KHNlZ21lbnRXYXlwb2ludHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVzdCB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRNb2RlbFxuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiBmaXhlcyBmb3IgdGhlIFJvdXRlU2VnbWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gYSBub3JtYWxpemVkIGxpc3Qgb2YgZml4ZXMsIGV4OlxuICAgICAqIC0gW0ZJWE5BTUUsIG51bGxdXG4gICAgICogLSBbRklYTkFNRSwgUkVTVFJJQ1RJT05TXVxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRNb2RlbFxuICAgICAqIEBtZXRob2QgZmluZFdheXBvaW50c0ZvclNlZ21lbnRcbiAgICAgKiBAcmV0dXJuIGZpeExpc3Qge2FycmF5fVxuICAgICAqL1xuICAgIGZpbmRXYXlwb2ludHNGb3JTZWdtZW50KCkge1xuICAgICAgICBjb25zdCBmaXhMaXN0ID0gX21hcCh0aGlzLl9pdGVtcywgKHdheXBvaW50KSA9PiB3YXlwb2ludC5maXgpO1xuXG4gICAgICAgIHJldHVybiBmaXhMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgUm91dGVTZWdtZW50TW9kZWxcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVXYXlwb2ludE1vZGVsc0Zyb21MaXN0XG4gICAgICogQHBhcmFtIHNlZ21lbnRXYXlwb2ludHMge2FycmF5fVxuICAgICAqIEByZXR1cm4gd2F5cG9pbnRNb2RlbExpc3Qge2FycmF5fVxuICAgICAqL1xuICAgIF9jcmVhdGVXYXlwb2ludE1vZGVsc0Zyb21MaXN0KHNlZ21lbnRXYXlwb2ludHMpIHtcbiAgICAgICAgX2ZvckVhY2goc2VnbWVudFdheXBvaW50cywgKGZpeEFuZFJlc3RyaWN0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2F5cG9pbnRNb2RlbCA9IG5ldyBTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbChmaXhBbmRSZXN0cmljdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBjYWxjdWxhdGUgZGlzdGFuY2UgaGVyZVxuXG4gICAgICAgICAgICB0aGlzLl9hZGRXYXlwb2ludFRvQ29sbGVjdGlvbih3YXlwb2ludE1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IG1vZGVsIHRvIHRoZSBjb2xsZWN0aW9uIGFuZCB1cGRhdGUgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQGZvciBSb3V0ZVNlZ21lbnRNb2RlbFxuICAgICAqIEBtZXRob2QgX2FkZFdheXBvaW50VG9Db2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHdheXBvaW50IHtTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRXYXlwb2ludFRvQ29sbGVjdGlvbih3YXlwb2ludCkge1xuICAgICAgICBpZiAoISh3YXlwb2ludCBpbnN0YW5jZW9mIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgd2F5cG9pbnQgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWwsIGluc3RlYWQgcmVjZWl2ZWQgJHt3YXlwb2ludH0uYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKHdheXBvaW50KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgX2ZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC9mb3JFYWNoJztcbmltcG9ydCBfaXNFbXB0eSBmcm9tICdsb2Rhc2gvaXNFbXB0eSc7XG5pbXBvcnQgX2lzTmlsIGZyb20gJ2xvZGFzaC9pc05pbCc7XG5pbXBvcnQgX21hcCBmcm9tICdsb2Rhc2gvbWFwJztcbmltcG9ydCBfcmFuZG9tIGZyb20gJ2xvZGFzaC9yYW5kb20nO1xuaW1wb3J0IEJhc2VDb2xsZWN0aW9uIGZyb20gJy4uLy4uL2Jhc2UvQmFzZUNvbGxlY3Rpb24nO1xuaW1wb3J0IFN0YW5kYXJkUm91dGVNb2RlbCBmcm9tICcuL1N0YW5kYXJkUm91dGVNb2RlbCc7XG5cbi8qKlxuICogQWNjZXB0IGBzaWRzYCBvciBgc3RhcnNgIGRhdGEgZnJvbSBhbiBhaXJwb3J0IGpzb24gZmlsZSBhbmQgY3JlYXRlIGEgY29sbGVjdGlvbiBvZiBtb2RlbCBvYmplY3RzLlxuICpcbiAqIFByb3ZpZGVzIGFuZCBpbnRlcmZhY2UgdG8gcmVhc29uIGFib3V0IGEgYFN0YW5kYXJkUm91dGVgLCBkZWZpbmVkIGFzIGVpdGhlciBhIFNJRCBvciBTVEFSLlxuICogQ3JlYXRlcyBhIGBTdGFuZGFyZFJvdXRlTW9kZWxgIGZvciBlYWNoIHJvdXRlIGRlZmluZWQgaW4gdGhlIFN0YW5kYXJkUm91dGUuXG4gKlxuICogQGNsYXNzIFN0YW5kYXJkUm91dGVDb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YW5kYXJkUm91dGVDb2xsZWN0aW9uIGV4dGVuZHMgQmFzZUNvbGxlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBzdGFuZGFyZFJvdXRlRW51bSB7b2JqZWN0fVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3RydWN0b3Ioc3RhbmRhcmRSb3V0ZUVudW0pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHN0YW5kYXJkUm91dGVFbnVtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoc3RhbmRhcmRSb3V0ZUVudW0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlZmFjdG9yIGludG8gYSByZXVzYWJsZSBjbGFzcyB0aGF0IGNhbiBiZSBmZWQgYW4gYGl0ZW1gIGFuZCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBgQ2FudmFzQ29udHJvbGxlcmBcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gaWRlbnRpZmllciBhbmQgYSBsaXN0IG9mIGZpeGVzIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKlxuICAgICAqIFB1bGxlZCBkaXJlY3RseSBmcm9tIGFuIGFpcnBvcnQganNvbiBgZHJhd2AgZGVmaW5pdGlvbiBwZXIgcm91dGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZHJhd1xuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBkcmF3KCkge1xuICAgICAgICByZXR1cm4gX21hcCh0aGlzLl9pdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZEZvckNhbnZhcyA9IHt9O1xuICAgICAgICAgICAgc2lkRm9yQ2FudmFzLmlkZW50aWZpZXIgPSBpdGVtLmljYW87XG5cbiAgICAgICAgICAgIGlmICghX2lzRW1wdHkoaXRlbS5kcmF3KSkge1xuICAgICAgICAgICAgICAgIHNpZEZvckNhbnZhcy5kcmF3ID0gaXRlbS5kcmF3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2lkRm9yQ2FudmFzO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgbWV0aG9kLiBTaG91bGQgYmUgcnVuIG9ubHkgb25jZSBvbiBpbnN0YW50aWF0aW9uLlxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgX2luaXRcbiAgICAgKiBAcGFyYW0gc3RhbmRhcmRSb3V0ZUVudW0ge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0KHN0YW5kYXJkUm91dGVFbnVtKSB7XG4gICAgICAgIHRoaXMuX2FkZFJvdXRlTGlzdFRvQ29sbGVjdGlvbihzdGFuZGFyZFJvdXRlRW51bSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdXBkYXRlIGltcGxlbWVudGF0aW9ucyB0byBhY2NlcHQgdGhlIEZpeE1vZGVsIGluc3RlYWQgb2YgYW4gYXJyYXlcbiAgICAvKipcbiAgICAgKiBGaW5kIGEgbGlzdCBvZiBmaXhlcyBmb3IgYSByb3V0ZSwgZ2l2ZW4gYW4gYGljYW9gLCBgZXhpdEZpeE5hbWVgIGFuZCBgcnVud2F5TmFtZWAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZ2V0U0lEXG4gICAgICogQHBhcmFtIGljYW8ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZXhpdEZpeE5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gcnVud2F5TmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGZpbmRGaXhlc0ZvclNpZEJ5UnVud2F5QW5kRXhpdChpY2FvLCBleGl0Rml4TmFtZSwgcnVud2F5TmFtZSkge1xuICAgICAgICBpZiAoIWljYW8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpZCA9IHRoaXMuZmluZFJvdXRlQnlJY2FvKGljYW8pO1xuXG4gICAgICAgIHJldHVybiBzaWQuZmluZEZpeGVzQW5kUmVzdHJpY3Rpb25zRm9yUnVud2F5QW5kRXhpdChydW53YXlOYW1lLCBleGl0Rml4TmFtZSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdXBkYXRlIGltcGxlbWVudGF0aW9ucyB0byBhY2NlcHQgdGhlIEZpeE1vZGVsIGluc3RlYWQgb2YgYW4gYXJyYXlcbiAgICAvKipcbiAgICAgKiBGaW5kIGEgbGlzdCBvZiBmaXhlcyBmb3IgYSByb3V0ZSwgZ2l2ZW4gYW4gYGljYW9gLCBgZW50cnlGaXhOYW1lYCBhbmQgYHJ1bndheU5hbWVgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gZ2F0aGVyIGFsbCB0aGUgZml4ZXMgZm9yIGEgZ2l2ZSBTVEFSIHJvdXRlLlxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZ2V0U0lEXG4gICAgICogQHBhcmFtIGljYW8ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZW50cnlGaXhOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHJ1bndheU5hbWUge3N0cmluZ30gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGZpbmRGaXhlc0ZvclN0YXJCeUVudHJ5QW5kUnVud2F5KGljYW8sIGVudHJ5Rml4TmFtZSwgcnVud2F5TmFtZSkge1xuICAgICAgICBpZiAoIWljYW8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXIgPSB0aGlzLmZpbmRSb3V0ZUJ5SWNhbyhpY2FvKTtcblxuICAgICAgICByZXR1cm4gc3Rhci5maW5kRml4ZXNBbmRSZXN0cmljdGlvbnNGb3JFbnRyeUFuZFJ1bndheShlbnRyeUZpeE5hbWUsIHJ1bndheU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBsaXN0IG9mIGBTdGFuZGFyZFdheXBvaW50TW9kZWxgcyBmb3IgYSBzcGVjaWZpYyByb3V0ZVxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZmluZEZpeE1vZGVsc0ZvclJvdXRlQnlFbnRyeUFuZEV4aXRcbiAgICAgKiBAcGFyYW0gaWNhbyB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBlbnRyeSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBleGl0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGlzUHJlU3Bhd24ge2Jvb2xlYW59IGZsYWcgdXNlZCB0byBkZXRlcm1pbmUgaWYgZGlzdGFuY2VzIGJldHdlZW4gd2F5cG9pbnRzIHNob3VsZCBiZSBjYWxjdWxhdGVkXG4gICAgICogQHJldHVybiB7U3RhbmRhcmRSb3V0ZU1vZGVsfVxuICAgICAqL1xuICAgIGZpbmRGaXhNb2RlbHNGb3JSb3V0ZUJ5RW50cnlBbmRFeGl0KGljYW8sIGVudHJ5LCBleGl0LCBpc1ByZVNwYXduKSB7XG4gICAgICAgIGlmICghaWNhbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLmZpbmRSb3V0ZUJ5SWNhbyhpY2FvKTtcblxuICAgICAgICByZXR1cm4gcm91dGUuZmluZFN0YW5kYXJkV2F5cG9pbnRNb2RlbHNGb3JFbnRyeUFuZEV4aXQoZW50cnksIGV4aXQsIGlzUHJlU3Bhd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSByYW5kb20gbmFtZSBvZiBhbiBgZXhpdFBvaW50YCBzZWdtZW50IHRoYXQgZXhpc3RzIHdpdGhpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZUNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGZpbmRSYW5kb21FeGl0UG9pbnRGb3JTSURJY2FvXG4gICAgICogQHBhcmFtIGljYW8ge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZmluZFJhbmRvbUV4aXRQb2ludEZvclNJREljYW8oaWNhbykge1xuICAgICAgICBjb25zdCBzaWQgPSB0aGlzLmZpbmRSb3V0ZUJ5SWNhbyhpY2FvKTtcblxuICAgICAgICAvLyBpZiBzaWQgZG9lc250IGhhdmUgYW55IGV4aXQgcG9pbnRzIGl0IGVuZHMgYXQgZml4IGZvciB3aGljaCB0aGUgU0lEIGlzIG5hbWVkXG4gICAgICAgIGlmICghc2lkLmhhc0V4aXRQb2ludHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZC5pY2FvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaGFzIGV4aXRQb2ludHMsIHJldHVybiBhIHJhbmRvbWx5IHNlbGVjdGVkIG9uZSBmcm9tIGEgbGlzdCBvZiBleGl0Rml4TmFtZXNcbiAgICAgICAgY29uc3QgZXhpdFBvaW50SWNhb3MgPSBzaWQuZ2F0aGVyRXhpdFBvaW50TmFtZXMoKTtcbiAgICAgICAgY29uc3QgbWF4SW5kZXggPSBleGl0UG9pbnRJY2Fvcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IF9yYW5kb20oMCwgbWF4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiBleGl0UG9pbnRJY2Fvc1tyYW5kb21JbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGBTdGFuZGFyZFJvdXRlTW9kZWxgIHdpdGhpbiB0aGUgY29sbGVjdGlvbiBnaXZlbiBhbiBgaWNhb2BcbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZUNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGZpbmRSb3V0ZUJ5SWNhb1xuICAgICAqIEBwYXJhbSBpY2FvIHtzdHJpbmd9XG4gICAgICogQHJldHVybiB7U3RhbmRhcmRSb3V0ZU1vZGVsfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmaW5kUm91dGVCeUljYW8oaWNhbykge1xuICAgICAgICByZXR1cm4gX2ZpbmQodGhpcy5faXRlbXMsIHsgaWNhbzogaWNhby50b1VwcGVyQ2FzZSgpIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZUNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGhhc1JvdXRlXG4gICAgICogQHBhcmFtIHJvdXRlTmFtZSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUm91dGUocm91dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiAhX2lzTmlsKHRoaXMuZmluZFJvdXRlQnlJY2FvKHJvdXRlTmFtZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3Qgb2Ygc2lkcyB0byB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgX2FkZFJvdXRlTGlzdFRvQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSByb3V0ZUxpc3Qge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRSb3V0ZUxpc3RUb0NvbGxlY3Rpb24ocm91dGVMaXN0KSB7XG4gICAgICAgIF9mb3JFYWNoKHJvdXRlTGlzdCwgKHJvdXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3V0ZU1vZGVsID0gbmV3IFN0YW5kYXJkUm91dGVNb2RlbChyb3V0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZFNpZFRvQ29sbGVjdGlvbihyb3V0ZU1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgYFN0YW5kYXJkUm91dGVNb2RlbGAgdG8gdGhlIGNvbGxlY3Rpb24gYW5kIHVwZGF0ZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVDb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZCBfYWRkU2lkVG9Db2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHJvdXRlTW9kZWwge1N0YW5kYXJkUm91dGVNb2RlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRTaWRUb0NvbGxlY3Rpb24ocm91dGVNb2RlbCkge1xuICAgICAgICBpZiAoIShyb3V0ZU1vZGVsIGluc3RhbmNlb2YgU3RhbmRhcmRSb3V0ZU1vZGVsKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHJvdXRlTW9kZWwgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgU3RhbmRhcmRSb3V0ZU1vZGVsLCBpbnN0ZWFkIHJlY2VpdmVkICR7cm91dGVNb2RlbH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2l0ZW1zLnB1c2gocm91dGVNb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IF9jb21wYWN0IGZyb20gJ2xvZGFzaC9jb21wYWN0JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJ2xvZGFzaC9pc0FycmF5JztcbmltcG9ydCBfaXNFbXB0eSBmcm9tICdsb2Rhc2gvaXNFbXB0eSc7XG5pbXBvcnQgX2lzTmlsIGZyb20gJ2xvZGFzaC9pc05pbCc7XG5pbXBvcnQgX2lzT2JqZWN0IGZyb20gJ2xvZGFzaC9pc09iamVjdCc7XG5pbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4uLy4uL2Jhc2UvQmFzZU1vZGVsJztcbmltcG9ydCBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uIGZyb20gJy4vUm91dGVTZWdtZW50Q29sbGVjdGlvbic7XG5pbXBvcnQgUm91dGVTZWdtZW50TW9kZWwgZnJvbSAnLi9Sb3V0ZVNlZ21lbnRNb2RlbCc7XG5pbXBvcnQgeyBkaXN0YW5jZTJkIH0gZnJvbSAnLi4vLi4vbWF0aC9kaXN0YW5jZSc7XG5pbXBvcnQgeyBubSB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5cbi8qKlxuICogQWNjZXB0cyBhIHNpbmdsZSByb3V0ZSBiZWxvbmdpbmcgdG8gYSBTSUQgb3IgU1RBUiBhbmQgcHJvdmlkZXMgbWV0aG9kcyB0byByZWFzb24gYWJvdXQgaXRzIGNvbnRlbnRzLlxuICpcbiAqIEBjbGFzcyBTdGFuZGFyZFJvdXRlTW9kZWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhbmRhcmRSb3V0ZU1vZGVsIGV4dGVuZHMgQmFzZU1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RzIGFuIG9iamVjdCBpbiB0aGUgZm9ybSBvZiAodGFrZW4gZnJvbSBga2xhcy5zaWRzLlNIRUFEOWApOlxuICAgICAqXG4gICAgICogIHtcbiAgICAgKiAgICAnaWNhbyc6ICdTSEVBRDknLFxuICAgICAqICAgICduYW1lJzogJ1NoZWFkIE5pbmUnLFxuICAgICAqICAgICdyd3knOiB7XG4gICAgICogICAgICAnMDFMJzogW1snQkVTU1knLCAnUzIzMCddLCBbJ01ERE9HJywgJ0E5MCddLCBbJ1RBUlJLJywgJ0ExMTAnXV0sXG4gICAgICogICAgICAnMDFSJzogW1snQkVTU1knLCAnUzIzMCddLCBbJ01ERE9HJywgJ0E5MCddLCBbJ1RBUlJLJywgJ0ExMTAnXV0sXG4gICAgICogICAgICAnMDdMJzogWydXQVNURScsIFsnQkFLUlInLCAnQTcwJ10sIFsnTUlORVknLCAnQTgwKyddLCAnSElUTUUnXSxcbiAgICAgKiAgICAgICcwN1InOiBbJ0pFU0pJJywgWydCQUtSUicsICdBNzAnXSwgWydNSU5FWScsICdBODArJ10sICdISVRNRSddLFxuICAgICAqICAgICAgJzE5TCc6IFsnRklYSVgnLCBbJ1JPUFBSJywgJ0E3MCddLCBbJ01ERE9HJywgJ0E5MCddLCBbJ1RBUlJLJywgJ0ExMTAnXV0sXG4gICAgICogICAgICAnMTlSJzogWydKQUtFUicsIFsnUk9QUFInLCAnQTcwJ10sIFsnTURET0cnLCAnQTkwJ10sIFsnVEFSUksnLCAnQTExMCddXSxcbiAgICAgKiAgICAgICcyNUwnOiBbJ1BJUk1EJywgWydST1BQUicsICdBNzAnXSwgWydNRERPRycsICdBOTAnXSwgWydUQVJSSycsICdBMTEwJ11dLFxuICAgICAqICAgICAgJzI1Uic6IFsnUkJFTEwnLCBbJ1JPUFBSJywgJ0E3MCddLCBbJ01ERE9HJywgJ0E5MCddLCBbJ1RBUlJLJywgJ0ExMTAnXV1cbiAgICAgKiAgICB9LFxuICAgICAqICAgICdib2R5JzogW1snU0hFQUQnLCAnQTE0MCsnXV0sXG4gICAgICogICAgJ2V4aXRQb2ludHMnOiB7XG4gICAgICogICAgICAnS0VOTk8nOiBbWydEQklHRScsICdBMjEwKyddLCBbJ0JJS0tSJywgJ0EyMTArJ10sICdLRU5OTyddLFxuICAgICAqICAgICAgJ09BTCc6IFtbJ0RCSUdFJywgJ0EyMTArJ10sIFsnQklLS1InLCAnQTIxMCsnXSwgJ0tFTk5PJywgJ09BTCddXG4gICAgICogICAgfSxcbiAgICAgKiAgICAnZHJhdyc6IFtcbiAgICAgKiAgICAgIFsnQkVTU1knLCAnTURET0cnXSxcbiAgICAgKiAgICAgIFsnUk9QUFInLCAnTURET0cnLCAnVEFSUksnLCAnU0hFQUQnXSxcbiAgICAgKiAgICAgIFsnSElUTUUnLCAnU0hFQUQnLCAnREJJR0UnLCAnQklLS1InLCAnS0VOTk8qJ10sXG4gICAgICogICAgICBbJ0tFTk5PJywgJ09BTConXVxuICAgICAqICAgIF1cbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogLSBgcnd5YCBiZWNvbWVzIHRoZSBgX3J1bndheUNvbGxlY3Rpb25gLiBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGEgcm91dGUgZGVmaW5pdGlvblxuICAgICAqIC0gYGJvZHlgIGJlY29tZXMgdGhlIGBfYm9keVNlZ21lbnRNb2RlbGAuIG1heSBub3QgYmUgaW5jbHVkZWQgaW4gYSByb3V0ZSBkZWZpbml0aW9uXG4gICAgICogLSBgZXhpdFBvaW50c2AgYmVjb21lcyB0aGUgIGBfZXhpdENvbGxlY3Rpb25gLiB3aWxsIG9ubHkgYmUgcHJlc2VudCBvbiBTSUQgcm91dGVzXG4gICAgICogLSBgZW50cnlQb2ludHNgIChub3Qgc2hvd24gYWJvdmUpIGJlY29tZXMgdGhlIGBfZW50cnlDb2xsZWN0aW9uYC4gd2lsbCBvbmx5IGJlIHByZXNlbnQgb24gU1RBUiByb3V0ZXNcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBzdGFuZGFyZFJvdXRlIHtvYmplY3R9XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGFuZGFyZFJvdXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgaWYgKCFfaXNPYmplY3Qoc3RhbmRhcmRSb3V0ZSkgfHwgX2lzQXJyYXkoc3RhbmRhcmRSb3V0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0YW5kYXJkUm91dGUgdG8gYmUgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIHN0YW5kYXJkUm91dGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGUgZml4XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogU0lEIGljb2EgaWRlbnRpZmllclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgaWNhb1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pY2FvID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgZml4ZXMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd25cbiAgICAgICAgICpcbiAgICAgICAgICogUHVsbGVkIHN0cmFpZ2h0IGZyb20gdGhlIGpzb24gZmlsZS5cbiAgICAgICAgICogQ3VycmVudGx5IHVudXNlZCBhbmQgaXMgb25seSBhIHBsYWNlIHRvIHB1dCB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGRyYXdcbiAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgYHJ3eWAgc2VnbWVudHMgYW5kIGZpeGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIFB1bGxlZCBzdHJhaWdodCBmcm9tIHRoZSBqc29uIGZpbGUuXG4gICAgICAgICAqIEN1cnJlbnRseSB1bnVzZWQgYW5kIGlzIG9ubHkgYSBwbGFjZSB0byBwdXQgdGhlIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSByd3lcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucnd5ID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBib2R5XG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9keSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGBleGl0UG9pbnRzYCBzZWdtZW50cyBhbmQgZml4ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogUHVsbGVkIHN0cmFpZ2h0IGZyb20gdGhlIGpzb24gZmlsZS5cbiAgICAgICAgICogQ3VycmVudGx5IHVudXNlZCBhbmQgaXMgb25seSBhIHBsYWNlIHRvIHB1dCB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IGV4aXRQb2ludHNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhpdFBvaW50cyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgUm91dGVTZWdtZW50TW9kZWxgIGZvciB0aGUgZml4ZXMgYmVsb25naW5nIHRvIHRoZSBgYm9keWAgc2VnbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2JvZHlTZWdtZW50TW9kZWxcbiAgICAgICAgICogQHR5cGUge1JvdXRlU2VnbWVudE1vZGVsfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib2R5U2VnbWVudE1vZGVsID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBgZXhpdFBvaW50c2Agcm91dGUgc2VnbWVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBzaG91bGQgb25seSBiZSBkZWZpbmVkIGZvciBTSURzIGFuZCBudWxsIGZvciBTVEFSIHJvdXRlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2V4aXRDb2xsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtSb3V0ZVNlZ21lbnRDb2xsZWN0aW9ufVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9leGl0Q29sbGVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgdGhlIGBlbnRyeVBvaW50c2Agcm91dGUgc2VnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgc2hvdWxkIG9ubHkgYmUgZGVmaW5lZCBmb3IgU1RBUnMgYW5kIG51bGwgZm9yIFNJRCByb3V0ZXNcbiAgICAgICAgICogQHR5cGUge1JvdXRlU2VnbWVudENvbGxlY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VudHJ5Q29sbGVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoc3RhbmRhcmRSb3V0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIG1ldGhvZC4gU2hvdWxkIGJlIHJ1biBvbmx5IG9uY2Ugb24gaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBwYXJhbSBzdGFuZGFyZFJvdXRlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdChzdGFuZGFyZFJvdXRlKSB7XG4gICAgICAgIHRoaXMuaWNhbyA9IHN0YW5kYXJkUm91dGUuaWNhbztcbiAgICAgICAgdGhpcy5uYW1lID0gc3RhbmRhcmRSb3V0ZS5uYW1lO1xuICAgICAgICB0aGlzLmRyYXcgPSBzdGFuZGFyZFJvdXRlLmRyYXc7XG4gICAgICAgIHRoaXMucnd5ID0gc3RhbmRhcmRSb3V0ZS5yd3k7XG4gICAgICAgIHRoaXMuYm9keSA9IHN0YW5kYXJkUm91dGUuYm9keTtcbiAgICAgICAgdGhpcy5leGl0UG9pbnRzID0gX2dldChzdGFuZGFyZFJvdXRlLCAnZXhpdFBvaW50cycsIHt9KTtcbiAgICAgICAgdGhpcy5lbnRyeVBvaW50cyA9IF9nZXQoc3RhbmRhcmRSb3V0ZSwgJ2VudHJ5UG9pbnRzJywge30pO1xuICAgICAgICB0aGlzLl9ib2R5U2VnbWVudE1vZGVsID0gdGhpcy5fYnVpbGRTZWdtZW50TW9kZWwoc3RhbmRhcmRSb3V0ZS5ib2R5KTtcblxuICAgICAgICB0aGlzLl9idWlsZEVudHJ5QW5kRXhpdENvbGxlY3Rpb25zKHN0YW5kYXJkUm91dGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlc2V0IHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pY2FvID0gJyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLnJ3eSA9IFtdO1xuICAgICAgICB0aGlzLmJvZHkgPSBbXTtcbiAgICAgICAgdGhpcy5leGl0UG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZHJhdyA9IFtdO1xuICAgICAgICB0aGlzLl9ib2R5U2VnbWVudE1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXhpdENvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9lbnRyeUNvbGxlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdhdGhlciB0aGUgZml4ZXMgZnJvbSBhbGwgdGhlIHJvdXRlIHNlZ21lbnRzLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiAyZCBhcnJheSBpbiB0aGUgc2hhcGUgb2ZcbiAgICAgKiAtIFtbRklYTkFNRSwgRklYX1JFU1RSSUNUSU9OU10sIFtGSVhOQU1FLCBGSVhfUkVTVFJJQ1RJT05TXV1cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBmaW5kRml4ZXNBbmRSZXN0cmljdGlvbnNGb3JSdW53YXlBbmRFeGl0XG4gICAgICogQHBhcmFtIHJ1bndheU5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZXhpdEZpeE5hbWUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBmaW5kRml4ZXNBbmRSZXN0cmljdGlvbnNGb3JSdW53YXlBbmRFeGl0KHJ1bndheU5hbWUsIGV4aXRGaXhOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kRml4TGlzdEZvclNpZEJ5UnVud2F5QW5kRXhpdChydW53YXlOYW1lLCBleGl0Rml4TmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2F0aGVyIHRoZSBmaXhlcyBmcm9tIGFsbCB0aGUgcm91dGUgc2VnbWVudHMuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgZmluZEZpeGVzQW5kUmVzdHJpY3Rpb25zRm9yRW50cnlBbmRSdW53YXlcbiAgICAgKiBAcGFyYW0gZW50cnlGaXhOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHJ1bndheU5hbWUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBmaW5kRml4ZXNBbmRSZXN0cmljdGlvbnNGb3JFbnRyeUFuZFJ1bndheShlbnRyeUZpeE5hbWUsIHJ1bndheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXhMaXN0Rm9yU3RhckJ5RW50cnlBbmRSdW53YXkoZW50cnlGaXhOYW1lLCBydW53YXlOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0IGFsbCB0aGUgYFN0YW5kYXJkV2F5cG9pbnRNb2RlbGAgb2JqZWN0cyBmb3IgYSBnaXZlbiByb3V0ZS5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBmaW5kU3RhbmRhcmRXYXlwb2ludE1vZGVsc0ZvckVudHJ5QW5kRXhpdFxuICAgICAqIEBwYXJhbSBlbnRyeSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBleGl0IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGlzUHJlU3Bhd24ge2Jvb2xlYW59IGZsYWcgdXNlZCB0byBkZXRlcm1pbmUgaWYgZGlzdGFuY2VzIGJldHdlZW4gd2F5cG9pbnRzIHNob3VsZCBiZSBjYWxjdWxhdGVkXG4gICAgICogQHJldHVybiB3YXlwb2ludExpc3Qge2FycmF5PFN0YW5kYXJkV2F5cG9pbnRNb2RlbD59XG4gICAgICovXG4gICAgZmluZFN0YW5kYXJkV2F5cG9pbnRNb2RlbHNGb3JFbnRyeUFuZEV4aXQoZW50cnksIGV4aXQsIGlzUHJlU3Bhd24pIHtcbiAgICAgICAgY29uc3Qgd2F5cG9pbnRMaXN0ID0gdGhpcy5fZmluZFN0YW5kYXJkV2F5cG9pbnRNb2RlbHNGb3JSb3V0ZShlbnRyeSwgZXhpdCk7XG5cbiAgICAgICAgaWYgKGlzUHJlU3Bhd24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdheXBvaW50c1dpdGhQcmV2aW91c1dheXBvaW50RGF0YSh3YXlwb2ludExpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdheXBvaW50TGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0d28gYFN0YW5kYXJkV2F5cG9pbnRNb2RlbGAgb2JqZWN0cywgY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBpbiBgbm1gIGJldHdlZW4gdGhlbVxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGNhbGN1bGF0ZURpc3RhbmNlQmV0d2VlbldheXBvaW50c1xuICAgICAqIEBwYXJhbSB3YXlwb2ludCB7U3RhbmRhcmRXYXlwb2ludE1vZGVsfVxuICAgICAqIEBwYXJhbSBwcmV2aW91c1dheXBvaW50IHtTdGFuZGFyZFdheXBvaW50TW9kZWx9XG4gICAgICogQHJldHVybiBkaXN0YW5jZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZURpc3RhbmNlQmV0d2VlbldheXBvaW50cyh3YXlwb2ludCwgcHJldmlvdXNXYXlwb2ludCkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlMmQocHJldmlvdXNXYXlwb2ludCwgd2F5cG9pbnQpO1xuXG4gICAgICAgIHJldHVybiBubShkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaXhuYW1lcyBmb3IgdGhlIGBfZXhpdENvbGxlY3Rpb25gXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgZ2F0aGVyRXhpdFBvaW50TmFtZXNcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnYXRoZXJFeGl0UG9pbnROYW1lcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V4aXRQb2ludHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXRDb2xsZWN0aW9uLmdhdGhlckZpeE5hbWVzRm9yQ29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGBfZXhpdENvbGxlY3Rpb25gIGhhdmUgYW55IGV4aXRQb2ludHM/XG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgaGFzRXhpdFBvaW50c1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRXhpdFBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXRDb2xsZWN0aW9uICE9PSBudWxsICYmIHRoaXMuX2V4aXRDb2xsZWN0aW9uLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYGZpeE5hbWVgIGlzIHByZXNlbnQgaW4gdGhlIGBfZW50cnlDb2xsZWN0aW9uYCBvciBgX2V4aXRDb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGZvciBpdGVtcyB3aXRoaW4gdGhlIGBfYm9keVNlZ21lbnRNb2RlbGAuIEluIHRoZSBmdXR1cmVcbiAgICAgKiB0aGlzIG1ldGhvZCBtYXkgbmVlZCB0byBiZSBleHRlbmRlZCB0byB3b3JrIHdpdGggYF9ib2R5U2VnbWVudE1vZGVsYCBpdGVtcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlTW9kZWxcbiAgICAgKiBAbWV0aG9kIGhhc0ZpeE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0ZpeE5hbWUoZml4TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW50cnlDb2xsZWN0aW9uICYmICFfaXNOaWwodGhpcy5fZW50cnlDb2xsZWN0aW9uLmZpbmRTZWdtZW50QnlOYW1lKGZpeE5hbWUpKSB8fFxuICAgICAgICAgICAgdGhpcy5fZXhpdENvbGxlY3Rpb24gJiYgIV9pc05pbCh0aGlzLl9leGl0Q29sbGVjdGlvbi5maW5kU2VnbWVudEJ5TmFtZShmaXhOYW1lKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgYSBuZXcgUm91dGVTZWdtZW50TW9kZWwgZm9yIGEgc2VnbWVudEZpeExpc3RcbiAgICAgKlxuICAgICAqIGBib2R5YCBzZWdtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5LCBzbyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgY29sbGVjdGlvbiBsaWtlIHdpdGggYHJ3eWAgYW5kXG4gICAgICogYGV4aXRQb2ludHNgLCBoZXJlIHdlIGp1c3QgY3JlYXRlIGEgbW9kZWwuICBUaGlzIHByb3ZpZGVzIHRoZSBzYW1lIG1ldGhvZHMgdGhlIGNvbGxlY3Rpb25zIHVzZSwgb25seVxuICAgICAqIHdpdGhvdXQgdGhlIGNvbGxlY3Rpb24gbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX2J1aWxkU2VnbWVudE1vZGVsXG4gICAgICogQHBhcmFtIHNlZ21lbnRGaXhMaXN0IHthcnJheX1cbiAgICAgKiBAcmV0dXJuIHNlZ21lbnRNb2RlbCB7U2VnbWVudE1vZGVsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2J1aWxkU2VnbWVudE1vZGVsKHNlZ21lbnRGaXhMaXN0KSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNb2RlbCA9IG5ldyBSb3V0ZVNlZ21lbnRNb2RlbCgnYm9keScsIHNlZ21lbnRGaXhMaXN0KTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudE1vZGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgY29sbGVjdGlvbiBvZiBgUm91dGVTZWdtZW50TW9kZWxgcyBmcm9tIGEgc2VnbWVudC5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfYnVpbGRTZWdtZW50Q29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzZWdtZW50IHtvYmplY3R9XG4gICAgICogQHJldHVybiBzZWdtZW50Q29sbGVjdGlvbiB7U2VnbWVudENvbGxlY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRTZWdtZW50Q29sbGVjdGlvbihzZWdtZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgX2lzRW1wdHkoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VnbWVudENvbGxlY3Rpb24gPSBuZXcgUm91dGVTZWdtZW50Q29sbGVjdGlvbihzZWdtZW50KTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudENvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBgc3RhbmRhcmRSb3V0ZWAgaXMgYSBzaWQgb3IgYSBzdGFyIGFuZCBidWlsZCB0aGUgZW50cnkvZXhpdCBjb2xsZWN0aW9uc1xuICAgICAqIHdpdGggdGhlIGNvcnJlY3QgZGF0YS5cbiAgICAgKlxuICAgICAqIFNUQVJTIHdpbGwgaGF2ZSBgZW50cnlQb2ludHNgIGRlZmluZWQgc28gYHJ3eWAgYmVjb21lcyB0aGUgYF9leGl0Q29sbGVjdGlvbmBcbiAgICAgKiBTSURTIHdpbGwgaGF2ZSBgZXhpdFBvaW50c2AgZGVmaW5lZCBzbyBgcnd5YCBiZWNvbWVzIHRoZSBgX2VudHJ5Q29sbGVjdGlvbmBcbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfYnVpbGRFbnRyeUFuZEV4aXRDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSBzdGFuZGFyZFJvdXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRFbnRyeUFuZEV4aXRDb2xsZWN0aW9ucyhzdGFuZGFyZFJvdXRlKSB7XG4gICAgICAgIGlmIChfaGFzKHN0YW5kYXJkUm91dGUsICdlbnRyeVBvaW50cycpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnRyeUNvbGxlY3Rpb24gPSB0aGlzLl9idWlsZFNlZ21lbnRDb2xsZWN0aW9uKHN0YW5kYXJkUm91dGUuZW50cnlQb2ludHMpO1xuICAgICAgICAgICAgdGhpcy5fZXhpdENvbGxlY3Rpb24gPSB0aGlzLl9idWlsZFNlZ21lbnRDb2xsZWN0aW9uKHN0YW5kYXJkUm91dGUucnd5KTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzKHN0YW5kYXJkUm91dGUsICdleGl0UG9pbnRzJykpIHtcbiAgICAgICAgICAgIHRoaXMuX2VudHJ5Q29sbGVjdGlvbiA9IHRoaXMuX2J1aWxkU2VnbWVudENvbGxlY3Rpb24oc3RhbmRhcmRSb3V0ZS5yd3kpO1xuICAgICAgICAgICAgdGhpcy5fZXhpdENvbGxlY3Rpb24gPSB0aGlzLl9idWlsZFNlZ21lbnRDb2xsZWN0aW9uKHN0YW5kYXJkUm91dGUuZXhpdFBvaW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhcyhzdGFuZGFyZFJvdXRlLCAncnd5JykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSAnJHt0aGlzLmljYW99JyBwcm9jZWR1cmUgZG9lcyBub3QgY29udGFpbiBleGl0UG9pbnRzIG9yIGVudHJ5UG9pbnRzLiBgICtcbiAgICAgICAgICAgICAgICBgSWYgdGhpcyBpcyBhIFNJRCwgYXQgbGVhc3Qgb25lIGV4aXRQb2ludCBtdXN0IGJlIGRlZmluZWQuIElmIHRoaXMgaXMgYSBTVEFSLCBhdCBsZWFzdCBgICtcbiAgICAgICAgICAgICAgICBgb25lIGVudHJ5UG9pbnQgbXVzdCBiZSBkZWZpbmVkLmApO1xuXG4gICAgICAgICAgICB0aGlzLl9lbnRyeUNvbGxlY3Rpb24gPSB0aGlzLl9idWlsZFNlZ21lbnRDb2xsZWN0aW9uKHN0YW5kYXJkUm91dGUucnd5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRocmVlIGZ1bmN0aW9ucywgc3ByZWFkIHRoZWlyIHJlc3VsdCBpbiBhbiBhcnJheSB0aGVuIHJldHVybiB0aGUgY29tcGFjdGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4cGVjdHMgdG8gcmVjZWl2ZSBhcnJheXMgYXMgcmVzdWx0cyBmcm9tIHRoZSB0aHJlZSBtZXRob2RzIHBhc3NlZCBpbi5cbiAgICAgKiBUaGlzIHdyYXBwZXIgbWV0aG9kIGlzIHByb3ZpZGVkIHRvIG1haW50YWluIGEgY29uc2lzdGVudCBpbnRlcmZhY2Ugd2hpbGUgYWxsb3dpbmcgZm9yIGEgdmFyeWluZyBzZXRcbiAgICAgKiBvZiBtZXRob2RzIHRvIGJlIGNhbGxlZCBpbiB0aGUgcGxhY2Ugb2YgZWFjaCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX2dlbmVyYXRlRml4TGlzdFxuICAgICAqIEBwYXJhbSBlbnRyeVNlZ21lbnQge2Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSBib2R5U2VnbWVudCB7ZnVuY3Rpb259XG4gICAgICogQHBhcmFtIGV4aXRTZWdtZW50IHtmdW5jdGlvbn1cbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZUZpeExpc3QgPSAoZW50cnlTZWdtZW50LCBib2R5U2VnbWVudCwgZXhpdFNlZ21lbnQpID0+IHtcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgb25lIG9mIHRoZXNlIGZ1bmN0aW9ucyBkb2VzbnQgZmluZCBhIHJlc3VsdCBzZXQgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gICAgICAgIC8vIHdlIGxldmVyYWdlIHRoZW4gYGxvZGFzaC5jb21wYWN0KClgIGJlbG93IHRvIHJlbW92ZSBhbnkgZW1wdHkgdmFsdWVzIGZyb20gdGhlIGFycmF5IGJlZm9yZVxuICAgICAgICAvLyByZXR1cm5pbmcgdGhlIGBmaXhMaXN0YC5cbiAgICAgICAgLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBjYWxsZWQgc3luY2hyb25vdXNseSBhbmQgb3JkZXIgb2Ygb3BlcmF0aW9uIGlzIHZlcnkgaW1wb3J0YW50IGhlcmUuXG4gICAgICAgIGNvbnN0IGZpeExpc3QgPSBbXG4gICAgICAgICAgICAuLi5lbnRyeVNlZ21lbnQsXG4gICAgICAgICAgICAuLi5ib2R5U2VnbWVudCxcbiAgICAgICAgICAgIC4uLmV4aXRTZWdtZW50XG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIF9jb21wYWN0KGZpeExpc3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGBydW53YXlOYW1lYCBhbmQgYGV4aXRGaXhOYW1lYCwgZmluZCBhIGxpc3Qgb2YgZml4ZXMgZm9yIHRoZSBgcnd5YCwgYGJvZHlgIGFuZCBgZXhpdFBvaW50c2Agc2VnbWVudHMuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX2ZpbmRGaXhMaXN0Rm9yU2lkQnlSdW53YXlBbmRFeGl0XG4gICAgICogQHBhcmFtIHJ1bndheU5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gZXhpdEZpeE5hbWUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIGZpeExpc3Qge2FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRGaXhMaXN0Rm9yU2lkQnlSdW53YXlBbmRFeGl0ID0gKHJ1bndheU5hbWUsIGV4aXRGaXhOYW1lKSA9PiB0aGlzLl9nZW5lcmF0ZUZpeExpc3QoXG4gICAgICAgIHRoaXMuX2ZpbmRGaXhMaXN0SW5CeUNvbGxlY3Rpb25BbmRTZWdtZW50TmFtZSgncnd5JywgJ19lbnRyeUNvbGxlY3Rpb24nLCBydW53YXlOYW1lKSxcbiAgICAgICAgdGhpcy5fZmluZEJvZHlGaXhMaXN0KCksXG4gICAgICAgIHRoaXMuX2ZpbmRGaXhMaXN0SW5CeUNvbGxlY3Rpb25BbmRTZWdtZW50TmFtZSgnZXhpdFBvaW50cycsICdfZXhpdENvbGxlY3Rpb24nLCBleGl0Rml4TmFtZSlcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYGVudHJ5Rml4TmFtZWAgYW5kL29yIGEgYHJ1bndheU5hbWVgLCBmaW5kIGEgbGlzdCBvZiBmaXhlcyBmb3IgdGhlIGBlbnRyeVBvaW50c2AsXG4gICAgICogYGJvZHlgIGFuZCBgcnd5YCBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfZmluZEZpeExpc3RGb3JTdGFyQnlFbnRyeUFuZFJ1bndheVxuICAgICAqIEBwYXJhbSBlbnRyeUZpeE5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gcnVud2F5TmFtZSB7c3RyaW5nfSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgX2ZpbmRGaXhMaXN0Rm9yU3RhckJ5RW50cnlBbmRSdW53YXkgPSAoZW50cnlGaXhOYW1lLCBydW53YXlOYW1lKSA9PiB0aGlzLl9nZW5lcmF0ZUZpeExpc3QoXG4gICAgICAgIHRoaXMuX2ZpbmRGaXhMaXN0SW5CeUNvbGxlY3Rpb25BbmRTZWdtZW50TmFtZSgnZW50cnlQb2ludHMnLCAnX2VudHJ5Q29sbGVjdGlvbicsIGVudHJ5Rml4TmFtZSksXG4gICAgICAgIHRoaXMuX2ZpbmRCb2R5Rml4TGlzdCgpLFxuICAgICAgICB0aGlzLl9maW5kRml4TGlzdEluQnlDb2xsZWN0aW9uQW5kU2VnbWVudE5hbWUoJ3J3eScsICdfZXhpdENvbGxlY3Rpb24nLCBydW53YXlOYW1lKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBgb3JpZ2luYWxDb2xsZWN0aW9uTmFtZWAsIGBjb2xsZWN0aW9uTmFtZWAgYW5kIGEgYHNlZ21lbnROYW1lYCwgcmV0dXJuIGEgbm9ybWFsaXplZCBsaXN0IG9mXG4gICAgICogZml4ZXMgd2l0aCByZXN0cmljdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX2ZpbmRGaXhMaXN0SW5CeUNvbGxlY3Rpb25BbmRTZWdtZW50TmFtZVxuICAgICAqIEBwYXJhbSBvcmlnaW5hbENvbGxlY3Rpb25OYW1lIHtzdHJpbmd9ICB0aGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgY29sbGVjdGlvbiBmcm9tIGFpcnBvcnQganNvbixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIG9mOiBbZW50cnlQb2ludHMsIHJ3eSwgZXhpdFBvaW50c11cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbk5hbWUge3N0cmluZ30gIGNvbGxlY3Rpb25OYW1lIGFzIGRlZmluZWQgaGVyZSwgb25lIG9mOiBbX2VudHJ5Q29sbGVjdGlvbiwgX2V4aXRDb2xsZWN0aW9uXVxuICAgICAqIEBzZWdtZW50TmFtZSB7c3RyaW5nfSAgbmFtZSBvZiB0aGUgc2VnbWVudCB0byBzZWFyY2ggZm9yXG4gICAgICogQHJldHVybiBhcnJheSB7YXJyYXk8YXJyYXk+fVxuICAgICAqL1xuICAgIF9maW5kRml4TGlzdEluQnlDb2xsZWN0aW9uQW5kU2VnbWVudE5hbWUob3JpZ2luYWxDb2xsZWN0aW9uTmFtZSwgY29sbGVjdGlvbk5hbWUsIHNlZ21lbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ29sbGVjdGlvbiA9IF9nZXQodGhpcywgb3JpZ2luYWxDb2xsZWN0aW9uTmFtZSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBfZ2V0KHRoaXMsIGNvbGxlY3Rpb25OYW1lLCBudWxsKTtcblxuICAgICAgICAvLyBzcGVjaWZpY2FsbHkgY2hlY2tpbmcgZm9yIGFuIGVtcHR5IHN0cmluZyBoZXJlIGJlY2F1c2UgdGhpcyBwYXJhbSBnZXRzIGEgZGVmYXVsdCBvZiAnJyB3aGVuXG4gICAgICAgIC8vIGl0IGlzIHJlY2VpdmVkIGluIHRvIHRoZSBwdWJsaWMgbWV0aG9kXG4gICAgICAgIGlmICghb3JpZ2luYWxDb2xsZWN0aW9uIHx8ICFjb2xsZWN0aW9uIHx8IHNlZ21lbnROYW1lID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZmluZFdheXBvaW50c0ZvclNlZ21lbnROYW1lKHNlZ21lbnROYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHYXRoZXIgYSBsaXN0IG9mIGBTdGFuZGFyZFdheXBvaW50TW9kZWxgIG9iamVjdHMgZm9yIGEgcGFydGljdWxhciByb3V0ZS5cbiAgICAgKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZU1vZGVsXG4gICAgICogQG1ldGhvZCBfZmluZFN0YW5kYXJkV2F5cG9pbnRNb2RlbHNGb3JSb3V0ZVxuICAgICAqIEBwYXJhbSBlbnRyeSB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBleHRpIHtzdHJpbmd9XG4gICAgICogQHJldHVybiB7YXJyYXk8U3RhbmRhcmRXYXlwb2ludE1vZGVsPn1cbiAgICAgKi9cbiAgICBfZmluZFN0YW5kYXJkV2F5cG9pbnRNb2RlbHNGb3JSb3V0ZShlbnRyeSwgZXhpdCkge1xuICAgICAgICBsZXQgZW50cnlTZWdtZW50SXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IGV4aXRTZWdtZW50SXRlbXMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5fZW50cnlDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeVNlZ21lbnQgPSB0aGlzLl9lbnRyeUNvbGxlY3Rpb24uZmluZFNlZ21lbnRCeU5hbWUoZW50cnkpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5U2VnbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAnZW50cnknIHRvIGV4aXN0IGluIHRoZSBSb3V0ZVNlZ21lbnRDb2xsZWN0aW9uLCBidXQgJyR7dGhpcy5pY2FvfScgYCArXG4gICAgICAgICAgICAgICAgYGRvZXMgbm90IGhhdmUgYW4gZW50cnkgb2YgJyR7ZW50cnl9J2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyeVNlZ21lbnRJdGVtcyA9IGVudHJ5U2VnbWVudC5pdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9leGl0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZXhpdFNlZ21lbnQgPSB0aGlzLl9leGl0Q29sbGVjdGlvbi5maW5kU2VnbWVudEJ5TmFtZShleGl0KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGl0U2VnbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAnZXhpdCcgdG8gZXhpc3QgaW4gdGhlIFJvdXRlU2VnbWVudENvbGxlY3Rpb24sIGJ1dCAnJHt0aGlzLmljYW99JyBgICtcbiAgICAgICAgICAgICAgICBgZG9lcyBub3QgaGF2ZSBhbiBleGl0IG9mICcke2V4aXR9J2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0U2VnbWVudEl0ZW1zID0gZXhpdFNlZ21lbnQuaXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVGaXhMaXN0KFxuICAgICAgICAgICAgZW50cnlTZWdtZW50SXRlbXMsXG4gICAgICAgICAgICB0aGlzLl9ib2R5U2VnbWVudE1vZGVsLml0ZW1zLFxuICAgICAgICAgICAgZXhpdFNlZ21lbnRJdGVtc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgbGlzdCBvZiB3YXlwb2ludHMgZm9yIHRoZSBgYm9keWAgc2VnbWVudFxuICAgICAqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlTW9kZWxcbiAgICAgKiBAbWV0aG9kIF9maW5kQm9keUZpeExpc3RcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQm9keUZpeExpc3QoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ib2R5ID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYm9keVNlZ21lbnRNb2RlbC5maW5kV2F5cG9pbnRzRm9yU2VnbWVudCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlYWNoIGBTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbGAgaW4gdGhlIGxpc3QgdGhlIHdpdGggZGlzYW5jZSBmcm9tIHRoZSBwcmV2aW91cyB3YXlwb2ludCwgYW5kXG4gICAgICogdGhhdCB3YXlwb2ludCdzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVNb2RlbFxuICAgICAqIEBtZXRob2QgX3VwZGF0ZVdheXBvaW50c1dpdGhQcmV2aW91c1dheXBvaW50RGF0YVxuICAgICAqIEBwYXJtYSB3YXlwb2ludE1vZGVsTGlzdCB7YXJyYXk8U3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWw+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVdheXBvaW50c1dpdGhQcmV2aW91c1dheXBvaW50RGF0YSh3YXlwb2ludE1vZGVsTGlzdCkge1xuICAgICAgICBfZm9yRWFjaCh3YXlwb2ludE1vZGVsTGlzdCwgKHdheXBvaW50LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNXYXlwb2ludCA9IHdheXBvaW50TW9kZWxMaXN0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXlwb2ludCA9IHdheXBvaW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2VCZXR3ZWVuV2F5cG9pbnRzKHdheXBvaW50LnBvc2l0aW9uLCBwcmV2aW91c1dheXBvaW50LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHdheXBvaW50LmRpc3RhbmNlRnJvbVByZXZpb3VzV2F5cG9pbnQgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIHdheXBvaW50LnByZXZpb3VzU3RhbmRhcmRXYXlwb2ludE5hbWUgPSBwcmV2aW91c1dheXBvaW50Lm5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBfaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBCYXNlTW9kZWwgZnJvbSAnLi4vLi4vYmFzZS9CYXNlTW9kZWwnO1xuaW1wb3J0IEZpeENvbGxlY3Rpb24gZnJvbSAnLi4vRml4L0ZpeENvbGxlY3Rpb24nO1xuaW1wb3J0IFdheXBvaW50IGZyb20gJy4uLy4uL2FpcmNyYWZ0L0ZsaWdodE1hbmFnZW1lbnRTeXN0ZW0vV2F5cG9pbnQnO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBOQU1FX0lOREVYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IE5BTUVfSU5ERVggPSAwO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBSRVNUUklDVElPTl9JTkRFWFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBSRVNUUklDVElPTl9JTkRFWCA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IFJFU1RSSUNUSU9OX1NFUEFSQVRPUlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBSRVNUUklDVElPTl9TRVBBUkFUT1IgPSAnfCc7XG5cbi8qKlxuICogQHByb3BlcnR5IEFMVElUVURFX1JFU1RSSUNUSU9OX1BSRUZJWFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBBTFRJVFVERV9SRVNUUklDVElPTl9QUkVGSVggPSAnQSc7XG5cbi8qKlxuICogQHByb3BlcnR5IFNQRUVEX1JFU1RSSUNUSU9OX1BSRUZJWFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBTUEVFRF9SRVNUUklDVElPTl9QUkVGSVggPSAnUyc7XG5cbi8qKlxuICogQSByb3V0ZSB3YXlwb2ludCBkZXNjcmliZXMgYSBgZml4TmFtZWAgYW5kIGFueSBhbHRpdHVkZSBvciBzcGVlZCByZXN0cmljdGlvbnMgZm9yIHRoYXQgZml4LlxuICpcbiAqIEBjbGFzcyBTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbFxuICogQGV4dGVuZHMgQmFzZU1vZGVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsIGV4dGVuZHMgQmFzZU1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RzIGByb3V0ZVdheXBvaW50YCB0byBiZSBpbiBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gICAgICogLSBbXCJGUkFXR1wiLCBcIkE4MCt8UzIxMCtcIl1cbiAgICAgKiAtIFtcIkZSQVdHXCIsIFwiQTgwLXxTMjEwXCJdXG4gICAgICogLSBbXCJGUkFXR1wiLCBcIkE4MFwiXVxuICAgICAqIC0gW1wiRlJBV0dcIiwgXCJTMjEwXCJdXG4gICAgICogLSBcIkZSQVdHXCJcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSByb3V0ZVdheXBvaW50IHthcnJheXxzdHJpbmd9XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm91dGVXYXlwb2ludCkge1xuICAgICAgICBzdXBlcihyb3V0ZVdheXBvaW50KTtcblxuICAgICAgICBpZiAodHlwZW9mIHJvdXRlV2F5cG9pbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoZSBmaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgcmVzdHJpY3Rpb25zIGZvciBhIGdpdmVuIGZpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBleDpcbiAgICAgICAgICogLSBcIkE4MCt8UzIxMFwiXG4gICAgICAgICAqIC0gXCJBODAtXCJcbiAgICAgICAgICogLSBcIlMyMzBcIlxuICAgICAgICAgKlxuICAgICAgICAgKiB1c2luZyBudWxsIGhlcmUgdG8gbWF0Y2ggY3VycmVudCBhcGksIGlmIHJlc3RyaWN0aW9ucyBkb250IGV4aXN0IGZvciBhIGdpdmVuIHdheXBvaW50XG4gICAgICAgICAqIHRoZSBjb25zdW1lcnMgYXJlIGV4cGVjdGluZyB0aGlzIHRvIGJlIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfcmVzdHJpY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzdHJpY3Rpb25zID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTk9UIElOIFVTRVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXF1aXJlZCBhbHRpdHVkZSBmb3IgYSBmaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9hbHRpdHVkZSAob3B0aW9uYWwpXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FsdGl0dWRlID0gbnVsbDtcblxuICAgICAgICAvLyBUT0RPOiBUaGlzIHdpbGwgbmVlZCB0byBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgZnV0dXJlIGFzIGFuIGVtdW5lcmF0aW9uLiBTb21ldGhpbmcgdG8gdGhlIGVmZmVjdCBvZjoge0JFTE9XfEFUfEFCT1ZFfVxuICAgICAgICAvKipcbiAgICAgICAgICogTk9UIElOIFVTRVxuICAgICAgICAgKlxuICAgICAgICAgKiBBbHRpdHVkZSBjb25zdHJhaW50cywgaWYgYW55LCBmb3IgYSBmaXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfYWx0aXR1ZGVDb25zdHJhaW50IChvcHRpb25zKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWx0aXR1ZGVDb25zdHJhaW50ID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5PVCBJTiBVU0VcbiAgICAgICAgICpcbiAgICAgICAgICogU3BlZWQgY29uc3RyYWludCwgaWYgYW55LCBmb3IgYSBmaXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfc3BlZWQgKG9wdGlvbmFsKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zcGVlZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0b24gaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50IHdheXBvaW50XG4gICAgICAgICAqXG4gICAgICAgICAqIFNwZWNpZmljIGJpdHMgb2YgdGhpcyBwcm9wZXJ0eSBhcmUgZXhwb3NlZCB2aWEgcHVibGljIGdldHRlcnMuXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5ldmVyIGJlIG1vZGlmaWVkIGJ5IGFuIGV4dGVyYWwgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3dheXBvaW50UG9zaXRpb25cbiAgICAgICAgICogQHR5cGUge1Bvc2l0aW9uTW9kZWx9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dheXBvaW50UG9zaXRpb24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXN0YW5jZSBpbiBubSBmcm9tIHRoZSBwcmV2aW91cyB3YXlwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBzZXQgZXh0ZXJhbGx5IGJ5IHRoZSBgU3RhbmRhcmRSb3V0ZU1vZGVsYCBhbmQgdXNlZCBvbmx5IHdoZW4gY2FsbGVkIHZpYVxuICAgICAgICAgKiBgQXJyaXZhbEJhc2UucHJlU3Bhd24oKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgbXV0YWJsZSBhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIHJlLXVzZWQgYWZ0ZXIgaXRzIGluaXRpYWwgdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgZGlzdGFuY2VGcm9tUHJldmlvdXNXYXlwb2ludFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXN0YW5jZUZyb21QcmV2aW91c1dheXBvaW50ID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhlIHByZXZpb3VzIGBTdGFuZGFyZFdheXBvaW50TW9kZWxgIG9iamVjdCBpbiBhIHJvdXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IGV4dGVyYWxseSBieSB0aGUgYFN0YW5kYXJkUm91dGVNb2RlbGAgYW5kIHVzZWQgb25seSB3aGVuIGNhbGxlZCB2aWFcbiAgICAgICAgICogYEFycml2YWxCYXNlLnByZVNwYXduKClgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIG11dGFibGUgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSByZS11c2VkIGFmdGVyIGl0cyBpbml0aWFsIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHByZXZpb3VzU3RhbmRhcmRXYXlwb2ludE5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJydcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNTdGFuZGFyZFdheXBvaW50TmFtZSA9ICcnO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KHJvdXRlV2F5cG9pbnQpXG4gICAgICAgICAgICAgICAgICAgLmNsb25lUG9pc2l0b25Gcm9tRml4KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoaXMgd2F5cG9pbnQncyBgcG9zaXRpb25gIHByb3BlcnlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dheXBvaW50UG9zaXRpb24ucG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoaXMgd2F5cG9pbnQncyBgZ3BzYCBwb3NpdGlvbiBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdwc1xuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBncHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXlwb2ludFBvc2l0aW9uLmdwcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhpcyB3YXlwb2ludCdzIGBncHNYWWAgcG9zaXRpb24gcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncHNcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZ3BzWFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXlwb2ludFBvc2l0aW9uLmdwc1hZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCByZXR1cm4gYSBub3JtYWxpemVkIGZpeCBpbiB0aGUgc2hhcGUgb2YgYFtGSVhOQU1FLCBGSVhfUkVTVFJJQ1RJT05TXWAuXG4gICAgICpcbiAgICAgKiBGaXhlcyB3aXRob3V0IHJlc3RyaWN0aW9ucyBhcmUgYnJvdWdodCBpbiB0byB0aGUgYXBwbGljYXRpb24gYXMgYSBzaW5nbGUgc3RyaW5nLCBob3dldmVyLCBhbGxcbiAgICAgKiBmaXhlcyBhcmUgY29uc3VtZWQgYXMgYW4gYXJyYXkuIGBfcmVzdHJpY3Rpb25zYCBhcmUgaW5pdGlhbGl6ZWQgYXMgbnVsbCwgdGh1cyBpZiB0aGVyZSBhcmVcbiAgICAgKiBubyByZXN0cmljdGlvbnMgZm9yIGEgZml4IHRoaXMgZ2V0dGVyIHdpbGwgcmV0dXJuIGBbRklYTkFNRSwgbnVsbF1gXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQHByb3BlcnR5IGZpeFxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBmaXgoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5uYW1lLCB0aGlzLl9yZXN0cmljdGlvbnNdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2QuIFNob3VsZCBiZSBydW4gb25seSBvbmNlIG9uIGluc3RhbnRpYXRpb24uXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBwYXJhbSByb3V0ZVdheXBvaW50IHthcnJheXxzdHJpbmd9XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXQocm91dGVXYXlwb2ludCkge1xuICAgICAgICAvLyBpZiB3ZSByZWNlaXZlIGEgc3RyaW5nLCB0aGlzIGZpeCBkb2VzbnQgaGF2ZSBhbnkgcmVzdHJpY3Rpb25zIHNvIHdlIG9ubHkgbmVlZCB0byBzZXQgYG5hbWVgXG4gICAgICAgIGlmICh0eXBlb2Ygcm91dGVXYXlwb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHJvdXRlV2F5cG9pbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYW1lID0gcm91dGVXYXlwb2ludFtOQU1FX0lOREVYXTtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IHByb3BlcnR5LiBzaG91bGQgZW5kIHVwIGFzIGEgZ2V0dGVyIHRoYXQgd3JhcHMgcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgIHRoaXMuX3Jlc3RyaWN0aW9ucyA9IHJvdXRlV2F5cG9pbnRbUkVTVFJJQ1RJT05fSU5ERVhdO1xuXG4gICAgICAgIHRoaXMuX3BhcnNlV2F5cG9pbnRSZXN0cmljdGlvbnMocm91dGVXYXlwb2ludFtSRVNUUklDVElPTl9JTkRFWF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlc2V0IHRoZSBjdXJyZW50IG1vZGVsIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQG1ldGhvZCByZXNldFxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fcmVzdHJpY3Rpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9hbHRpdHVkZUNvbnN0cmFpbnQgPSAnJztcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG1hdGNoaW5nIGZpeCBmcm9tIHRoZSBgRml4Q29sbGVjdGlvbmAgYW5kIGNsb25lIGl0cyBgUG9zaXRpb25Nb2RlbGAgdGhpcyBgX3dheXBvaW50UG9zaXRpb25gXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQG1ldGhvZCBfY2xvbmVQb2lzaXRvbkZyb21GaXhcbiAgICAgKiBAcGFyYW0gZml4Q29sbGVjdGlvbiB7Rml4Q29sbGVjdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb25lUG9pc2l0b25Gcm9tRml4KCkge1xuICAgICAgICBjb25zdCBmaXhNb2RlbCA9IEZpeENvbGxlY3Rpb24uZmluZEZpeEJ5TmFtZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmICghZml4TW9kZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIGZvbGxvd2luZyBmaXggd2FzIG5vdCBmb3VuZCBpbiB0aGUgbGlzdCBvZiBmaXhlcyBmb3IgdGhpcyBBaXJwb3J0OiAke3RoaXMubmFtZX1gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93YXlwb2ludFBvc2l0aW9uID0gZml4TW9kZWwuY2xvbmVQb3NpdGlvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWxcbiAgICAgKiBAbWV0aG9kIGdlbmVyYXRlRm1zV2F5cG9pbnRcbiAgICAgKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydEluc3RhbmNlTW9kZWx9XG4gICAgICogQHJldHVybiB7V2F5cG9pbnR9XG4gICAgICovXG4gICAgZ2VuZXJhdGVGbXNXYXlwb2ludChhaXJwb3J0KSB7XG4gICAgICAgIGNvbnN0IGZtc1dheXBvaW50ID0ge1xuICAgICAgICAgICAgZml4OiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBmaXhSZXN0cmljdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBhbHQ6IHRoaXMuX2FsdGl0dWRlLFxuICAgICAgICAgICAgICAgIHNwZDogdGhpcy5fc3BlZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV3IFdheXBvaW50KGZtc1dheXBvaW50LCBhaXJwb3J0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhbnkgd2F5cG9pbnQgcmVzdHJpY3Rpb25zXG4gICAgICpcbiAgICAgKiBQYXJzZSBhIHNpbmdsZSBzdHJpbmcgaW50bzpcbiAgICAgKiAtIGB0aGlzLl9hbHRpdHVkZWAgICAgICAgICAgICA9IGV4cHJlc3NlZCBpbiBmZWV0XG4gICAgICogLSBgdGhpcy5fYWx0aXR1ZGVDb25zdHJhaW50YCAgPSB7QkVMT1d8QVR8QUJPVkV9XG4gICAgICogLSBgdGhpcy5fc3BlZWRgICAgICAgPSBleHByZXNzZWQgaW4ga3RzXG4gICAgICpcbiAgICAgKiBFeGFwbWxlczpcbiAgICAgKiAtIFwiQTgwK3xTMjEwXCJcbiAgICAgKiAtIFwiQTgwLXxTMjEwXCJcbiAgICAgKiAtIFwiQTgwXCJcbiAgICAgKiAtIFwiUzIxMFwiXG4gICAgICpcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQG1ldGhvZCBfcGFyc2VXYXlwb2ludFJlc3RyaWN0aW9uc1xuICAgICAqIEBwYXJhbSB3YXlwb2ludFJlc3RyaWN0aW9ucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhcnNlV2F5cG9pbnRSZXN0cmljdGlvbnMod2F5cG9pbnRSZXN0cmljdGlvbnMpIHtcbiAgICAgICAgaWYgKF9pc05pbCh3YXlwb2ludFJlc3RyaWN0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3RyaWN0aW9uUGllY2VzID0gdGhpcy5fZXh0cmFjdFJlc3RyaWN0aW9uUGllY2VzKHdheXBvaW50UmVzdHJpY3Rpb25zKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3RyaWN0aW9uUGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN0cmljdGlvbiA9IHJlc3RyaWN0aW9uUGllY2VzW2ldO1xuXG4gICAgICAgICAgICAvLyBsb29raW5nIGF0IHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSByZXN0cmljdGlvblBpZWNlIGhlcmUuXG4gICAgICAgICAgICBpZiAocmVzdHJpY3Rpb25bMF0gPT09IEFMVElUVURFX1JFU1RSSUNUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFsdGl0dWRlUmVzdHJpY3Rpb24ocmVzdHJpY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN0cmljdGlvblswXSA9PT0gU1BFRURfUkVTVFJJQ1RJT05fUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3BlZWRSZXN0cmljdGlvbihyZXN0cmljdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFN0YW5kYXJkUm91dGVXYXlwb2ludE1vZGVsXG4gICAgICogQG1ldGhvZCBfc2V0QWx0aXR1ZGVSZXN0cmljdGlvblxuICAgICAqIEBwYXJhbSBhbHRpdHVkZVJlc3RyaWN0aW9uIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0QWx0aXR1ZGVSZXN0cmljdGlvbihhbHRpdHVkZVJlc3RyaWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2FsdGl0dWRlID0gYWx0aXR1ZGVSZXN0cmljdGlvbi5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBTdGFuZGFyZFJvdXRlV2F5cG9pbnRNb2RlbFxuICAgICAqIEBtZXRob2QgX3NldFNwZWVkUmVzdHJpY3Rpb25cbiAgICAgKiBAcGFyYW0gc3BlZWRSZXN0cmljdGlvbiB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNwZWVkUmVzdHJpY3Rpb24oc3BlZWRSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkUmVzdHJpY3Rpb24uc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgU3RhbmRhcmRSb3V0ZVdheXBvaW50TW9kZWxcbiAgICAgKiBAbWV0aG9kIF9leHRyYWN0UmVzdHJpY3Rpb25QaWVjZXNcbiAgICAgKiBAcGFyYW0gd2F5cG9pbnRSZXN0cmljdGlvbnMge2FycmF5PHN0cmluZz59XG4gICAgICogQEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leHRyYWN0UmVzdHJpY3Rpb25QaWVjZXMod2F5cG9pbnRSZXN0cmljdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHdheXBvaW50UmVzdHJpY3Rpb25zLnNwbGl0KFJFU1RSSUNUSU9OX1NFUEFSQVRPUik7XG4gICAgfVxufVxuIiwiaW1wb3J0IF91bmlxdWVJZCBmcm9tICdsb2Rhc2gvdW5pcXVlSWQnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZnJvbSB3aGljaCBhIGNvbGxlY3Rpb24gdHlwZSBjbGFzcyBjYW4gaW5oZXJpdCBmcm9tLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbWVhbnQgdG8gYmUgZXh0ZW5kZWQgYW5kIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBjbGFzcyBCYXNlQ29sbGVjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQ29sbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGZvciBCYXNlQ29sbGVjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5pZ3VlIHN0cmluZyBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpZmZlcmVudGlhdGUgdGhpcyBtb2RlbCBpbnN0YW5jZSBmcm9tIGFub3RoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfaWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lkID0gX3VuaXF1ZUlkKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfaXRlbXNcbiAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIG1vZGVsIHByb3BlcnRpZXMuIFNob3VsZCBiZSBydW4gb24gaW5zdGFudGlhdGlvbiBhbmQsIHRob3VnaCBub3QgZGVzaXJlZCxcbiAgICAgKiBjb3VsZCBiZSBydW4gbXVsdGlwbGUgdGltZXMgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yIG9yIGZyb20gYSBwdWJsaWMgZmFzY2FkZS5cbiAgICAgKlxuICAgICAqIEBmb3IgQmFzZUNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIF9pbml0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFzZUNvbGxlY3Rpb24jX2luaXQgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGJ5IHRoZSBleHRlbmRpbmcgY2xhc3MnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0b3J5IHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogV2hlbiBpbXBsZW1lbnRlZCBieSB0aGUgaW5oZXJpdGluZyBjbGFzcywgdGhpcyBtZXRob2Qgc2hvdWxkIHVuLXNldCBhbGwgY2xhc3MgcHJvcGVydGllc1xuICAgICAqIGFuZCByZW1vdmUgYW55IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQGZvciBCYXNlQ29sbGVjdGlvblxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jhc2VDb2xsZWN0aW9uI2Rlc3Ryb3kgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGJ5IHRoZSBleHRlbmRpbmcgY2xhc3MnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgX3VuaXF1ZUlkIGZyb20gJ2xvZGFzaC91bmlxdWVJZCc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIE1vZGVsIG9iamVjdHMgdG8gaW5oZXJpdCBmcm9tLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbWVhbnQgdG8gYmUgZXh0ZW5kZWQgYW5kIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBjbGFzcyBCYXNlTW9kZWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaWd1ZSBzdHJpbmcgaWQgdGhhdCBjYW4gYmUgdXNlZCB0byBkaWZmZXJlbnRpYXRlIHRoaXMgbW9kZWwgaW5zdGFuY2UgZnJvbSBhbm90aGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2lkXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pZCA9IF91bmlxdWVJZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIG1vZGVsIHByb3BlcnRpZXMuIFNob3VsZCBiZSBydW4gb24gaW5zdGFudGlhdGlvbiBhbmQsIHRob3VnaCBub3QgZGVzaXJlZCxcbiAgICAgKiBjb3VsZCBiZSBydW4gbXVsdGlwbGUgdGltZXMgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yIG9yIGZyb20gYSBwdWJsaWMgZmFzY2FkZS5cbiAgICAgKlxuICAgICAqIEBmb3IgQmFzZU1vZGVsXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jhc2VNb2RlbCNfaW5pdCBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY2xhc3MgZXh0ZW5kaW5nIEJhc2VNb2RlbCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3RvcnkgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBXaGVuIGltcGxlbWVudGVkIGJ5IHRoZSBpbmhlcml0aW5nIGNsYXNzLCB0aGlzIG1ldGhvZCBzaG91bGQgdW4tc2V0IGFsbCBjbGFzcyBwcm9wZXJ0aWVzXG4gICAgICogYW5kIHJlbW92ZSBhbnkgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAZm9yIEJhc2VNb2RlbFxuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFzZU1vZGVsI3Jlc2V0IG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjbGFzcyBleHRlbmRpbmcgQmFzZU1vZGVsJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IF9oYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgbW9kZWxTb3VyY2VQb29sIGZyb20gJy4vTW9kZWxTb3VyY2VQb29sJztcbmltcG9ydCB7IENMQVNTX01BUCB9IGZyb20gJy4vbW9kZWxTb3VyY2VDbGFzc01hcCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBwdWxpYyBnYXRld2F5IHRvIHRoZSBgbW9kZWxTb3VyY2VQb29sYC5cbiAqXG4gKiBUaGlzIGNsYXNzIGhhcyBvbmx5IG9uZSBjb25jZXJuLCBicm9rZXJpbmcgY2hhbmdlcyB0byB0aGUgYG1vZGVsU291cmNlUG9vbGAuXG4gKlxuICogQGNsYXNzIE1vZGVsU291cmNlRmFjdG9yeVxuICovXG5jbGFzcyBNb2RlbFNvdXJjZUZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbW9kZWwgdHlwZSwgcmV0cmlldmUgYSBtb2RlbCBmcm9tIHRoZSBgbW9kZWxTb3VyY2VQb29sYC5cbiAgICAgKlxuICAgICAqIEBmb3IgTW9kZWxTb3VyY2VGYWN0b3J5XG4gICAgICogQG1ldGhvZCBnZXRNb2RlbFNvdXJjZUZvclR5cGVcbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgbmFtZS4gbXVzdCBiZSBpbmNsZHVlZCBpbiBgQ0xBU1NfTUFQYCBkaWN0b25hcnlcbiAgICAgKiBAcGFyYW0gYXJncyB7KltdfSAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyB1c2VkIGZvciBpbml0aWFsaXppbmcgYSBgbW9kZWxTb3VyY2VgIGluc3RhbmNlXG4gICAgICogQHJldHVybiBtb2RlbFNvdXJjZSB7Y29uc3RydWN0b3J9ICAgIG9uZSBvZiBDTEFTU19NQVBcbiAgICAgKi9cbiAgICBnZXRNb2RlbFNvdXJjZUZvclR5cGUodHlwZSwgLi4uYXJncykge1xuICAgICAgICBpZiAoIV9oYXMoQ0xBU1NfTUFQLCB0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBwYXNzZWQgdG8gTW9kZWxTb3VyY2VGYWN0b3J5OiAke3R5cGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbFNvdXJjZSA9IG1vZGVsU291cmNlUG9vbC5yZWxlYXNlUmV1c2FibGUodHlwZSwgLi4uYXJncyk7XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsU291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG1vZGVsIGJhY2sgdG8gdGhlIGBtb2RlbFNvdXJjZVBvb2xgLlxuICAgICAqXG4gICAgICogQGZvciBNb2RlbFNvdXJjZUZhY3RvcnlcbiAgICAgKiBAbWV0aG9kIHJldHVybk1vZGVsVG9Qb29sXG4gICAgICogQHBhcmFtIG1vZGVsIHtjb25zdHJ1Y3Rvcn0gIG9uZSBvZiBDTEFTU19NQVBcbiAgICAgKi9cbiAgICByZXR1cm5Nb2RlbFRvUG9vbChtb2RlbCkge1xuICAgICAgICBpZiAoIV9oYXMoQ0xBU1NfTUFQLCBtb2RlbC5jb25zdHJ1Y3Rvci5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBwYXNzZWQgdG8gTW9kZWxTb3VyY2VGYWN0b3J5OiAke21vZGVsLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbFNvdXJjZVBvb2wucmV0dXJuUmV1c2FibGUobW9kZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IE1vZGVsU291cmNlRmFjdG9yeSgpO1xuIiwiaW1wb3J0IF9maW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2hhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBfaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBfd2l0aG91dCBmcm9tICdsb2Rhc2gvd2l0aG91dCc7XG5pbXBvcnQgQmFzZUNvbGxlY3Rpb24gZnJvbSAnLi4vQmFzZUNvbGxlY3Rpb24nO1xuaW1wb3J0IHtcbiAgICBDTEFTU19NQVAsXG4gICAgQ0xBU1NfTUFQX0xFTkdUSFxufSBmcm9tICcuL21vZGVsU291cmNlQ2xhc3NNYXAnO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBNQVhfUE9PTF9TSVpFX1BFUl9NT0RFTFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBNQVhfUE9PTF9TSVpFX1BFUl9NT0RFTCA9IDMwMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgTUFYX1BPT0xfU0laRVxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBNQVhfUE9PTF9TSVpFID0gTUFYX1BPT0xfU0laRV9QRVJfTU9ERUwgKiBDTEFTU19NQVBfTEVOR1RIO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBtb2RlbCBvYmplY3RzIHRoYXQgYXJlIG5vdCBpbiB1c2UuXG4gKlxuICogVGhpcyBwcm92aWRlczpcbiAqIC0gYSB3YXkgdG8gaW5zdGFudGlhdGUgYSBgTUFYX1BPT0xfU0laRV9QRVJfTU9ERUxgIG51bWJlciBvZiBtb2RlbCBvYmplY3RzXG4gKiAtIGEgd2F5IHRvIHJlbGVhc2UgYSBtb2RlbCBmb3IgdXNlIHdpdGhpbiB0aGUgYXBwIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICogLSBhIHdheSB0byByZXR1cm4gYSBtb2RlbCBhZnRlciB1c2UgYW5kIGFkZCBpdCBiYWNrIGludG8gdGhlIHBvb2xcbiAqXG4gKiBUaGlzIGFsbG93cyBmb3IgZGVjcmVhc2VkIGdhcmJhZ2UgY29sbGVjdGlvbiBiZWNhdXNlIHRoZSBtb2RlbCBpbnN0YW5jZXMgYmVpbmcgdXNlZCBhcmUgYWxyZWFkeSBjcmVhdGVkLiBUaGVcbiAqIGFwcCBpc24ndCBhbHdheXMgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgY2xhc3NlcywgaW5zdGVhZCBpdCBpcyBjcmVhdGluZywgdXNpbmcgYW5kIHJlLXVzaW5nIHRoZSBzYW1lIG1vZGVscy5cbiAqXG4gKiBzZWU6IChPYmplY3QgUG9vbClbaHR0cHM6Ly9zb3VyY2VtYWtpbmcuY29tL2Rlc2lnbl9wYXR0ZXJucy9vYmplY3RfcG9vbF0gb25cbiAqIChzb3VyY2VtYWtpbmcuY29tKVtodHRwczovL3NvdXJjZW1ha2luZy5jb21dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBjbGFzcyBNb2RlbFNvdXJjZVBvb2xcbiAqIEBleHRlbmRzIEJhc2VDb2xsZWN0aW9uXG4gKi9cbmNsYXNzIE1vZGVsU291cmNlUG9vbCBleHRlbmRzIEJhc2VDb2xsZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZm9yIE1vZGVsU291cmNlUG9vbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIE5PVCBJTiBVU0VcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBwZXIgbW9kZWwvcmV1c2FibGUgYWxsb3dpbmcgaW4gdGhlIHBvb2xcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBhbHNvIHVzZWQgZm9yIHByZS13YXJtaW5nIHRoZSBwb29sIG9uIGluc3RhbnRpYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9tYXhQb29sU2l6ZVBlck1vZGVsXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IE1BWF9QT09MX1NJWkVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heFBvb2xTaXplUGVyTW9kZWwgPSBNQVhfUE9PTF9TSVpFO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlUG9vbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJldXNhYmxlIHRvIHRoZSBwb29sXG4gICAgICpcbiAgICAgKiBAZm9yIE1vZGVsU291cmNlUG9vbFxuICAgICAqIEBtZXRob2QgcmV0dXJuUmV1c2FibGVcbiAgICAgKiBAcGFyYW0gbW9kZWxUb0FkZCB7Y29uc3RydWN0b3J9IG9uZSBvZiBDTEFTU19NQVBcbiAgICAgKi9cbiAgICByZXR1cm5SZXVzYWJsZShtb2RlbFRvQWRkKSB7XG4gICAgICAgIGlmICghX2hhcyhDTEFTU19NQVAsIG1vZGVsVG9BZGQuY29uc3RydWN0b3IubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnN0cnVjdG9yIHBhc3NlZCB0byBNb2RlbFNvdXJjZVBvb2w6ICR7bW9kZWxUb0FkZC5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChtb2RlbFRvQWRkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSByZXVzYWJsZSBmcm9tIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXQgZm9yIHVzZSBieSB0aGUgY2FsbGVyXG4gICAgICpcbiAgICAgKiBAZm9yIE1vZGVsU291cmNlUG9vbFxuICAgICAqIEBtZXRob2QgcmVsZWFzZVJldXNhYmxlXG4gICAgICogQHBhcmFtIGNvbnN0cnVjdG9yTmFtZSB7c3RyaW5nfSAgY29uc3RydWN0b3IgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIHsqW119ICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMgdXNlZCBmb3IgaW5pdGlhbGl6aW5nIGEgYG1vZGVsU291cmNlYCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4gbW9kZWwge2NvbnN0cnVjdG9yfSAgICAgIG9uZSBvZiBDTEFTU19NQVBcbiAgICAgKi9cbiAgICByZWxlYXNlUmV1c2FibGUoY29uc3RydWN0b3JOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2ZpbmRNb2RlbEJ5Q29uc3RydWN0b3JOYW1lKGNvbnN0cnVjdG9yTmFtZSk7XG5cbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwgPSBuZXcgQ0xBU1NfTUFQW2NvbnN0cnVjdG9yTmFtZV0oLi4uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbC5pbml0KC4uLmFyZ3MpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbiBpbnN0YW50aWF0aW9uIHByZS13YXJtIHRoZSBwb29sIHdpdGggcmV1c2FibGVzIHNvIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBjcmVhdGVkIGF0IHJ1biB0aW1lLlxuICAgICAqXG4gICAgICogQGZvciBNb2RlbFNvdXJjZVBvb2xcbiAgICAgKiBAbWV0aG9kIF9oeWRyYXRlUG9vbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2h5ZHJhdGVQb29sKCkge1xuICAgICAgICBfZm9yRWFjaChDTEFTU19NQVAsIChNb2RlbFNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfUE9PTF9TSVpFX1BFUl9NT0RFTDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgTW9kZWxTb3VyY2UoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIE1vZGVsU291cmNlUG9vbFxuICAgICAqIEBtZXRob2QgX2ZpbmRNb2RlbEJ5Q29uc3RydWN0b3JOYW1lXG4gICAgICogQHBhcmFtIGNvbnN0cnVjdG9yTmFtZSB7c3RyaW5nfSAgdGhlIG5hbWUgb2YgYSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4gbW9kZWwge2NvbnN0cnVjdG9yfSAgICAgIG9uZSBvZiBDTEFTU19NQVBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTW9kZWxCeUNvbnN0cnVjdG9yTmFtZShjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBfZmluZCh0aGlzLl9pdGVtcywgKG1vZGVsKSA9PiBtb2RlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSBjb25zdHJ1Y3Rvck5hbWUpO1xuXG4gICAgICAgIGlmIChfaXNOaWwobW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0obW9kZWwpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzcGVjaWZpYyBpbnN0YW5jZSBmcm9tIHRoZSBwb29sXG4gICAgICpcbiAgICAgKiBXaGVuIGEgcmV1c2FibGUgaGFzIGJlZW4gcmVxdWVzdGVkLCBpdCBtdXNoIGJlIHJlbW92ZWQgZnJvbSB0aGUgcG9vbFxuICAgICAqXG4gICAgICogQGZvciBNb2RlbFNvdXJjZVBvb2xcbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVJdGVtXG4gICAgICogQHBhcmFtIG1vZGVsIHtjb25zdHJ1Y3Rvcn0gb25lIG9mIENMQVNTX01BUFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUl0ZW0obW9kZWwpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBfd2l0aG91dCh0aGlzLl9pdGVtcywgbW9kZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IE1vZGVsU291cmNlUG9vbCgpO1xuIiwiaW1wb3J0IF9rZXlzIGZyb20gJ2xvZGFzaC9rZXlzJztcbmltcG9ydCBGaXhNb2RlbCBmcm9tICcuLi8uLi9haXJwb3J0L0ZpeC9GaXhNb2RlbCc7XG4vLyBpbXBvcnQgV2F5cG9pbnQgZnJvbSAnLi4vLi4vYWlyY3JhZnQvV2F5cG9pbnQnO1xuLy8gaW1wb3J0IFBvc2l0aW9uTW9kZWwgZnJvbSAnLi4vUG9zaXRpb25Nb2RlbCc7XG5cbi8qKlxuICogQSBtYXAgb2YgQ29uc3RydWN0b3IgbmFtZXMgdG8gY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKlxuICogQHByb3BlcnR5IENMQVNTX01BUFxuICogQHR5cGUge29iamVjdH1cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfTUFQID0ge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBDTEFTU19NQVBcbiAgICAgKiBAcHJvcGVydHkgRml4TW9kZWxcbiAgICAgKiBAdHlwZSB7Rml4TW9kZWx9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgRml4TW9kZWw6IEZpeE1vZGVsXG5cbiAgICAvLyBUT0RPOiBGdXR1cmUgYWRkaXRpb25zIHRvIHRoZSBwb29sIGVhY2ggb2YgdGhlc2UgbW9kZWxzIG5lZWQgc29tZSB3b3JrIGluIG9yZXIgdG8gaW50ZWdyYXRlXG4gICAgLy8gaW50byB0aGUgcG9vbCBzdHJ1Y3R1cmVcbiAgICAvL1xuICAgIC8vIC8qKlxuICAgIC8vICAqIEBtZW1iZXJvZiBDTEFTU19NQVBcbiAgICAvLyAgKiBAcHJvcGVydHkgV2F5cG9pbnRcbiAgICAvLyAgKiBAdHlwZSB7V2F5cG9pbnR9XG4gICAgLy8gICogQGZpbmFsXG4gICAgLy8gICovXG4gICAgLy8gV2F5cG9pbnQ6IFdheXBvaW50XG4gICAgLy8gLyoqXG4gICAgLy8gICogQG1lbWJlcm9mIENMQVNTX01BUFxuICAgIC8vICAqIEBwcm9wZXJ0eSBQb3NpdGlvbk1vZGVsXG4gICAgLy8gICogQHR5cGUge1Bvc2l0aW9uTW9kZWx9XG4gICAgLy8gICogQGZpbmFsXG4gICAgLy8gICovXG4gICAgLy8gUG9zaXRpb25Nb2RlbDogUG9zaXRpb25Nb2RlbFxufTtcblxuLyoqXG4gKiBQcm92aWRlIGEgbGVuZ3RoIG51bWJlciB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBleHRlcm5hbGx5XG4gKlxuICogU2luY2UgQ0xBU1NfTUFQIGlzIGFuIG9iamVjdCwgZGV0ZXJtaW5pbmcgdGhlIGxlbmd0aCAobnVtYmVyIG9mIGtleXMpIGlzIGEgdHdvLXN0ZXAgcHJvY2Vzcy5cbiAqIFdlIGRvIHRoYXQgaGVyZSBzbyBhbnkgY2xhc3MgdGhhdCBuZWVkcyB0byBrbm93IHRoZSBsZW5ndGggY2FuIHNpbXBseSBpbXBvcnQgdGhpcyBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJvcGVydHkgQ0xBU1NfTUFQX0xFTkdUSFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX01BUF9MRU5HVEggPSBfa2V5cyhDTEFTU19NQVApLmxlbmd0aDtcbiIsImltcG9ydCBfaXNOdW1iZXIgZnJvbSAnbG9kYXNoL2lzTnVtYmVyJztcbmltcG9ydCBfdW5pcXVlSWQgZnJvbSAnbG9kYXNoL3VuaXF1ZUlkJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlRGlzdGFuY2VUb1BvaW50Rm9yWCxcbiAgICBjYWxjdWxhdGVEaXN0YW5jZVRvUG9pbnRGb3JZLFxuICAgIGFkanVzdEZvck1hZ25ldGljTm9ydGgsXG4gICAgaGFzQ2FyZGluYWxEaXJlY3Rpb25JbkNvb3JkaW5hdGVcbn0gZnJvbSAnLi9wb3NpdGlvbk1vZGVsSGVscGVycyc7XG5pbXBvcnQgeyBkaXN0YW5jZVRvUG9pbnQgfSBmcm9tICcuLi9tYXRoL2NpcmNsZSc7XG5pbXBvcnQge1xuICAgIGRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgcGFyc2VDb29yZGluYXRlLFxuICAgIHBhcnNlRWxldmF0aW9uXG59IGZyb20gJy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5cbi8qKlxuICogQHByb3BlcnR5IExBVElUVURFX0lOREVYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IExBVElUVURFX0lOREVYID0gMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgTE9OR0lUVURFX0lOREVYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IExPTkdJVFVERV9JTkRFWCA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IEVMRVZBVElPTl9JTkRFWFxuICogQHR5cGUge251bWJlcn1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBFTEVWQVRJT05fSU5ERVggPSAyO1xuXG5cbi8qKlxuICogQSBwaHlzaWNhbCBsb2NhdGlvbiBvbiB0aGUgRWFydGgncyBzdXJmYWNlXG4gKlxuICogcHJvcGVydGllczpcbiAqICAgbGF0aXR1ZGUgLSBMYXRpdHVkZSBpbiBkZWNpbWFsIGRlZ3JlZXNcbiAqICAgbG9uZ2l0dWRlIC0gTG9uZ2l0dWRlIGluIGRlY2ltYWwgZGVncmVlc1xuICogICBlbGV2YXRpb24gLSBFbGV2YXRpb24gaW4gZmVldFxuICogICByZWZlcmVuY2VfcG9zaXRpb24gLSBQb3NpdGlvbiB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyBvZmZzZXRzXG4gKiAgIHggLSBPZmZzZXQgZnJvbSByZWZlcmVuY2UgcG9zaXRpb24gaW4ga21cbiAqICAgeSAtIE9mZnNldCBmcm9tIHJlZmVyZW5jZSBwb3NpdGlvbiBpbiBrbVxuICogICBwb3NpdGlvbiAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIHgseSBwYWlyXG4gKlxuICogQGNsYXNzIFBvc2l0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uTW9kZWwge1xuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIG1heSBjb250YWluIGFuIG9wdGlvbmFsIGVsZXZhdGlvbiBhcyBhIHRoaXJkIGVsZW1lbnQuXG4gICAgICogSXQgbXVzdCBiZSBzdWZmaXhlZCBieSBlaXRoZXIgJ2Z0JyBvciAnbScgdG8gaW5kaWNhdGUgdGhlIHVuaXRzLlxuICAgICAqXG4gICAgICogTGF0aXR1ZGUgYW5kIExvbmdpdHVkZSBudW1iZXJzIG1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAgICAgKiAgIERlY2ltYWwgZGVncmVlcyAtICdONDcuMTEyMzg4MTEyJ1xuICAgICAqICAgRGVjaW1hbCBtaW51dGVzIC0gJ04zOGQzOC4xMDk4MDgnXG4gICAgICogICBEZWNpbWFsIHNlY29uZHMgLSAnTjU4ZDI3bTEyLjEzOCdcbiAgICAgKlxuICAgICAqIEBmb3IgUG9zaXRpb25Nb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBjb29yZGluYXRlcyB7YXJyYXl9ICAgICAgICAgICAgICAgQXJyYXkgY29udGFpbmluZyBvZmZzZXQgcGFpciBvciBsYXRpdHVkZS9sb25naXR1ZGUgcGFpclxuICAgICAqIEBwYXJhbSByZWZlcmVuY2Uge1Bvc2l0aW9uTW9kZWx8bnVsbH0gICAgUG9zaXRpb24gdG8gdXNlIGZvciBjYWxjdWxhdGluZyBvZmZzZXRzIHdoZW4gbGF0L2xvbmcgZ2l2ZW5cbiAgICAgKiBAcGFyYW0gbWFnbmV0aWNfbm9ydGgge251bWJlcn0gICAgICAgICAgIG1hZ25ldGljIG5vcnRoIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBtb2RlIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgU2V0IHRvICdHUFMnIHRvIGluZGljYXRlIHlvdSBhcmUgaW5wdXR0aW5nIGxhdC9sb25nIHRoYXQgc2hvdWxkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjb252ZXJ0ZWQgdG8gcG9zaXRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMgPSBbXSwgcmVmZXJlbmNlLCBtYWduZXRpY19ub3J0aCA9IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfaWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lkID0gX3VuaXF1ZUlkKCdwb3NpdGlvbi1tb2RlbC0nKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGxhdGl0dWRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0aXR1ZGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgbG9uZ2l0dWRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGVsZXZhdGlvblxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsZXZhdGlvbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZWZlcmVuY2VfcG9zaXRpb25cbiAgICAgICAgICogQHR5cGUge1Bvc2l0aW9uTW9kZWx8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmZXJlbmNlX3Bvc2l0aW9uID0gcmVmZXJlbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgbWFnbmV0aWNfbm9ydGhcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFnbmV0aWNfbm9ydGggPSBtYWduZXRpY19ub3J0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHhcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHlcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0gMDtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbml0KGNvb3JkaW5hdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHgsIHkgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMueCxcbiAgICAgICAgICAgIHRoaXMueVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdQUyBjb29yZGluYXRlcyBpbiBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gb3JkZXJcbiAgICAgKiBGb3IgcmV2ZXJzZSBvcmRlciwgc2VlIGBQb3NpdGlvbk1vZGVsLmdwc1hZYFxuICAgICAqIEBwcm9wZXJ0eSBncHNcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZ3BzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5sYXRpdHVkZSxcbiAgICAgICAgICAgIHRoaXMubG9uZ2l0dWRlXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR1BTIGNvb3JkaW5hdGVzIGluIFt4LHldIG9yZGVyXG4gICAgICogRm9yIHJldmVyc2Ugb3JkZXIsIHNlZSBgUG9zaXRpb25Nb2RlbC5ncHNgXG4gICAgICogQHByb3BlcnR5IGdwc1hZXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGdwc1hZKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5sb25naXR1ZGUsXG4gICAgICAgICAgICB0aGlzLmxhdGl0dWRlXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFnbmV0aWMgbm9ydGggb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZXhwcmVzc2VkIGluIHJhZGlhbnNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtYWduZXRpY05vcnRoSW5SYWRpYW5zXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtYWduZXRpY05vcnRoSW5SYWRpYW5zKCkge1xuICAgICAgICByZXR1cm4gZGVncmVlc1RvUmFkaWFucyh0aGlzLm1hZ25ldGljX25vcnRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFBvc2l0aW9uTW9kZWxcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKi9cbiAgICBpbml0KGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMubGF0aXR1ZGUgPSBwYXJzZUNvb3JkaW5hdGUoY29vcmRpbmF0ZXNbTEFUSVRVREVfSU5ERVhdKTtcbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSBwYXJzZUNvb3JkaW5hdGUoY29vcmRpbmF0ZXNbTE9OR0lUVURFX0lOREVYXSk7XG5cbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyB1c2luZyBjb2Vyc2lvbiBhbmQgc2hvdWRsZCBiZSB1cGRhdGVkIHRvIGJlIG1vcmUgZXhwbGljaXRcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzW0VMRVZBVElPTl9JTkRFWF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbGV2YXRpb24gPSBwYXJzZUVsZXZhdGlvbihjb29yZGluYXRlc1tFTEVWQVRJT05fSU5ERVhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNjcmVlblBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBQb3NpdGlvbk1vZGVsXG4gICAgICogQG1ldGhvZCBkaXN0YW5jZVRvXG4gICAgICogQHBhcmFtIHBvaW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGRpc3RhbmNlVG8ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlVG9Qb2ludChcbiAgICAgICAgICAgIHRoaXMubGF0aXR1ZGUsXG4gICAgICAgICAgICB0aGlzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgIHBvaW50LmxhdGl0dWRlLFxuICAgICAgICAgICAgcG9pbnQubG9uZ2l0dWRlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgYFBvc2l0aW9uTW9kZWxgIGhhcyBhIHJlZmVyZW5jZSBgUG9zaXRpb25Nb2RlbGBcbiAgICAgKiBXaXRob3V0IHRoZSByZWZlcmVuY2UgcG9zaXRpb24sIHRoZSByb3RhdGlvbiBkdWUgdG8gbWFnbmV0aWMgdmFyaWF0aW9uIHdpbGwgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAZm9yIFBvc2l0aW9uTW9kZWxcbiAgICAgKiBAbWV0aG9kIF9oYXNSZWZlcmVuY2VQb3NpdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBiYXNlZCBvbiBhIHJlZmVyZW5jZSBwb3NpdGlvblxuICAgICAqL1xuICAgIF9oYXNSZWZlcmVuY2VQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlX3Bvc2l0aW9uICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzIG9mIHRoZSBgUG9zaXRpb25Nb2RlbGAsIHVzZWQgZm9yIGRyYXdpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEBmb3IgUG9zaXRpb25Nb2RlbFxuICAgICAqIEBtZXRob2QgX2NhbGN1bGF0ZVNjcmVlblBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlU2NyZWVuUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzUmVmZXJlbmNlUG9zaXRpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3gsIHldID0gUG9zaXRpb25Nb2RlbC5jYWxjdWxhdGVQb3NpdGlvbih0aGlzLmdwcywgdGhpcy5yZWZlcmVuY2VfcG9zaXRpb24sIHRoaXMubWFnbmV0aWNfbm9ydGgpO1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB4L3kgcG9zaXRpb24gZnJvbSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIGFuZCBhIHJlZmVyZW5jZVBvc3Rpb25cbiAqXG4gKiBQcm92aWRlcyBhIHN0YXRpYyBtZXRob2QgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIHdpdGhvdXQgaW5zdGFudGlhdGluZyBhIGBQb3NpdGlvbk1vZGVsYCBjbGFzcy5cbiAqXG4gKiBAZnVuY3Rpb24gZ2V0UG9zaXRpb25cbiAqIEBwYXJhbSBjb29yZGluYXRlcyB7YXJyYXk8c3RyaW5nPn1cbiAqIEBwYXJhbSByZWZlcmVuY2VQb3N0aW9uIHtQb3NpdGlvbk1vZGVsfG51bGx9XG4gKiBAcGFyYW0gbWFnbmV0aWNOb3J0aCB7bnVtYmVyfVxuICogQHJldHVybiB7YXJyYXl9XG4gKiBAc3RhdGljXG4gKi9cblBvc2l0aW9uTW9kZWwuY2FsY3VsYXRlUG9zaXRpb24gPSAoY29vcmRpbmF0ZXMsIHJlZmVyZW5jZVBvc3Rpb24sIG1hZ25ldGljTm9ydGgpID0+IHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzIHx8ICFyZWZlcmVuY2VQb3N0aW9uIHx8ICFfaXNOdW1iZXIobWFnbmV0aWNOb3J0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIuIFBvc2l0aW9uTW9kZWwuZ2V0UG9zaXRpb24oKSByZXF1aXJlcyBjb29yZGluYXRlcywgcmVmZXJlbmNlUG9zdGlvbiAnICtcbiAgICAgICAgICAgICdhbmQgbWFnbmV0aWNOb3J0aCBhcyBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF0aXR1ZGUgPSBwYXJzZUNvb3JkaW5hdGUoY29vcmRpbmF0ZXNbTEFUSVRVREVfSU5ERVhdKTtcbiAgICBjb25zdCBsb25naXR1ZGUgPSBwYXJzZUNvb3JkaW5hdGUoY29vcmRpbmF0ZXNbTE9OR0lUVURFX0lOREVYXSk7XG5cbiAgICBjb25zdCBjYW52YXNQb3NpdGlvblggPSBjYWxjdWxhdGVEaXN0YW5jZVRvUG9pbnRGb3JYKFxuICAgICAgICByZWZlcmVuY2VQb3N0aW9uLFxuICAgICAgICByZWZlcmVuY2VQb3N0aW9uLmxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGVcbiAgICApO1xuXG4gICAgY29uc3QgY2FudmFzUG9zaXRpb25ZID0gY2FsY3VsYXRlRGlzdGFuY2VUb1BvaW50Rm9yWShcbiAgICAgICAgcmVmZXJlbmNlUG9zdGlvbixcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIHJlZmVyZW5jZVBvc3Rpb24ubG9uZ2l0dWRlXG4gICAgKTtcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gYWRqdXN0Rm9yTWFnbmV0aWNOb3J0aChjYW52YXNQb3NpdGlvblgsIGNhbnZhc1Bvc2l0aW9uWSwgbWFnbmV0aWNOb3J0aCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgXTtcbn07XG4iLCJpbXBvcnQgeyBkaXN0YW5jZVRvUG9pbnQgfSBmcm9tICcuLi9tYXRoL2NpcmNsZSc7XG5pbXBvcnQgeyBSRUdFWCB9IGZyb20gJy4uL2NvbnN0YW50cy9nbG9iYWxDb25zdGFudHMnO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBoYXNDYXJkaW5hbERpcmVjdGlvbkluQ29vcmRpbmF0ZVxuICogQHBhcmFtIGNvb3JkaW5hdGUge3N0cmluZ31cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNDYXJkaW5hbERpcmVjdGlvbkluQ29vcmRpbmF0ZSA9IChjb29yZGluYXRlKSA9PiBSRUdFWC5DT01QQVNTX0RJUkVDVElPTi50ZXN0KGNvb3JkaW5hdGUpO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZVRvUG9pbnRGb3JYXG4gKiBAcGFyYW0gcmVmZXJlbmNlUG9zdGlvbiB7UG9zaXRpb25Nb2RlbH1cbiAqIEBwYXJhbSBsYXRpdHVkZSB7bnVtYmVyfVxuICogQHBhcmFtIGxvbmdpdHVkZSB7bnVtYmVyfVxuICogQHJldHVybiB4IHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVEaXN0YW5jZVRvUG9pbnRGb3JYID0gKHJlZmVyZW5jZVBvc3Rpb24sIGxhdGl0dWRlLCBsb25naXR1ZGUpID0+IHtcbiAgICBsZXQgeCA9IGRpc3RhbmNlVG9Qb2ludChcbiAgICAgICAgcmVmZXJlbmNlUG9zdGlvbi5sYXRpdHVkZSxcbiAgICAgICAgcmVmZXJlbmNlUG9zdGlvbi5sb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGVcbiAgICApO1xuXG4gICAgaWYgKHJlZmVyZW5jZVBvc3Rpb24ubG9uZ2l0dWRlID4gbG9uZ2l0dWRlKSB7XG4gICAgICAgIHggKj0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqXG4gKlxuICogQGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlVG9Qb2ludEZvcllcbiAqIEBwYXJhbSByZWZlcmVuY2VQb3N0aW9uIHtQb3NpdGlvbk1vZGVsfVxuICogQHBhcmFtIGxhdGl0dWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gbG9uZ2l0dWRlIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHkge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZURpc3RhbmNlVG9Qb2ludEZvclkgPSAocmVmZXJlbmNlUG9zdGlvbiwgbGF0aXR1ZGUsIGxvbmdpdHVkZSkgPT4ge1xuICAgIGxldCB5ID0gZGlzdGFuY2VUb1BvaW50KFxuICAgICAgICByZWZlcmVuY2VQb3N0aW9uLmxhdGl0dWRlLFxuICAgICAgICByZWZlcmVuY2VQb3N0aW9uLmxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZVxuICAgICk7XG5cblxuICAgIGlmIChyZWZlcmVuY2VQb3N0aW9uLmxhdGl0dWRlID4gbGF0aXR1ZGUpIHtcbiAgICAgICAgeSAqPSAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4geTtcbn07XG5cbi8qKlxuICogQWRqdXN0IHRvIHVzZSBtYWduZXRpYyBub3J0aCBpbnN0ZWFkIG9mIHRydWUgbm9ydGhcbiAqXG4gKiBAZnVuY3Rpb24gYWRqdXN0Rm9yTWFnbmV0aWNOb3J0aFxuICogQHBhcmFtIG9yaWdpbmFsWCB7c3RyaW5nfVxuICogQHBhcmFtIG9yaWdpbmFsWSB7c3RyaW5nfVxuICogQHBhcmFtIG1hZ25ldGljTm9ydGgge251bWJlcn1cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFkanVzdEZvck1hZ25ldGljTm9ydGggPSAob3JpZ2luYWxYLCBvcmlnaW5hbFksIG1hZ25ldGljTm9ydGgpID0+IHtcbiAgICBsZXQgdCA9IE1hdGguYXRhbjIob3JpZ2luYWxZLCBvcmlnaW5hbFgpICsgbWFnbmV0aWNOb3J0aDtcbiAgICBjb25zdCByID0gTWF0aC5zcXJ0KChvcmlnaW5hbFggKiBvcmlnaW5hbFgpICsgKG9yaWdpbmFsWSAqIG9yaWdpbmFsWSkpO1xuXG5cbiAgICBjb25zdCB4ID0gciAqIE1hdGguY29zKHQpO1xuICAgIGNvbnN0IHkgPSByICogTWF0aC5zaW4odCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IF9jbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IF9oYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgeyBrbSwgZGVncmVlc1RvUmFkaWFucyB9IGZyb20gJy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5pbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3RpbWVIZWxwZXJzJztcbmltcG9ydCB7IHNpbiwgY29zLCByb3VuZCwgY2FsY3VsYXRlTWlkZGxlLCBleHRyYXBvbGF0ZV9yYW5nZV9jbGFtcCwgY2xhbXAgfSBmcm9tICcuLi9tYXRoL2NvcmUnO1xuaW1wb3J0IHsgdGF1IH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsgZGlzdGFuY2UyZCB9IGZyb20gJy4uL21hdGgvZGlzdGFuY2UnO1xuaW1wb3J0IHsgdnNjYWxlLCB2dHVybiwgcG9zaXRpdmVfaW50ZXJzZWN0aW9uX3dpdGhfcmVjdCB9IGZyb20gJy4uL21hdGgvdmVjdG9yJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4uL2NvbnN0YW50cy9zZWxlY3RvcnMnO1xuaW1wb3J0IHsgTE9HIH0gZnJvbSAnLi4vY29uc3RhbnRzL2xvZ0xldmVsJztcbmltcG9ydCB7IEZMSUdIVF9NT0RFUywgRkxJR0hUX0NBVEVHT1JZIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FpcmNyYWZ0Q29uc3RhbnRzJztcblxuLy8gVGVtcG9yYXJ5IGNvbnN0IGRlY2xhcmF0aW9uIGhlcmUgdG8gYXR0YWNoIHRvIHRoZSB3aW5kb3cgQU5EIHVzZSBhcyBpbnRlcm5hbCBwcm9wZXJ0eVxuY29uc3QgY2FudmFzID0ge307XG5cbi8qKlxuICogQHByb3BlcnR5IEJBU0VfQ0FOVkFTX0ZPTlRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgQkFTRV9DQU5WQVNfRk9OVCA9ICcxMHB4IG1vbm9PbmUsIG1vbm9zcGFjZSc7XG5cbi8qKlxuICogQHByb3BlcnR5IERFRkFVTFRfQ0FOVkFTX1NJWkVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgREVGQVVMVF9DQU5WQVNfU0laRSA9IHtcbiAgICBIRUlHSFQ6IDQ4MCxcbiAgICBXSURUSDogNjQwXG59O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBDT0xPUlNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgQ09MT1JTID0ge1xuICAgIFdISVRFXzAwOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKScsXG4gICAgV0hJVEVfMDI6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiknLFxuICAgIFdISVRFXzAzOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpJyxcbiAgICBXSElURV8wNDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC40KScsXG4gICAgV0hJVEVfMDU6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknLFxuICAgIFdISVRFXzA3OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICBXSElURV8wODogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsXG4gICAgV0hJVEU6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEuMCknLFxuICAgIExJR0hUX1NJTFZFUl8wMzogJ3JnYmEoMjI0LCAyMjQsIDIyNCwgMC4zKScsXG4gICAgTElHSFRfU0lMVkVSOiAncmdiYSgyMjQsIDIyNCwgMjI0LCAxLjApJyxcbiAgICBSRURfMDY6ICdyZ2JhKDIyNCwgMTI4LCAxMjgsIDAuNiknLFxuICAgIFJFRF8wODogJ3JnYmEoMjI0LCAxMjgsIDEyOCwgMC44KScsXG4gICAgUkVEOiAncmdiYSgyMjQsIDEyOCwgMTI4LCAxLjApJyxcbiAgICBDT1JBTF9SRUQ6ICdyZ2JhKDI1NSwgNjQsIDY0LCAxLjApJyxcbiAgICBCUklHSFRfUkVEOiAncmdiYSgyNTUsIDAsIDAsIDAuNyknLFxuICAgIEdSQUlOX0JST1dOOiAncmdiYSgyMjQsIDIxMCwgMTgwLCAxLjApJyxcbiAgICBERVBBUlRVUkVfQ09MT1I6ICdyZ2JhKDEyOCwgMjU1LCAyNTUsIDAuNiknLFxuICAgIFZJREVPX01BUF9TVFJPS0U6ICdyZ2JhKDE5MywgMjE4LCAyMDUsIDEpJyxcbiAgICBERVBBUlRVUkVfU1RST0tFOiAncmdiYSgxMjgsIDI1NSwgMjU1LCAwLjkpJyxcbiAgICBBSVJTUEFDRV9SQURJVVNfRklMTDogJ3JnYmEoMjAwLCAyNTUsIDIwMCwgMC4wMiknLFxuICAgIEFJUlNQQUNFX1JBRElVU19TVFJPS0U6ICdyZ2JhKDIwMCwgMjU1LCAyMDAsIDAuMjUpJyxcbiAgICBBSVJTUEFDRV9SQU5HRV9SSU5HX0NPTE9SOiAncmdiYSgyMDAsIDI1NSwgMjAwLCAwLjEpJyxcbiAgICBDUk9TU0hBSVJfU1RST0tFOiAncmdiYSgxMzYsIDE1MywgMTUzLCAxKScsXG4gICAgUkVTVFJJQ1RFRF9BSVJTUEFDRV9TVFJPS0U6ICdyZ2JhKDE1MCwgMjAwLCAyNTUsIDAuMyknLFxuICAgIFJFU1RSSUNURURfQUlSU1BBQ0VfRklMTDogJ3JnYmEoMTUwLCAyMDAsIDI1NSwgMC40KSdcbn07XG5cbi8qKlxuICogQGNsYXNzIENhbnZhc0NvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udmFzQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoJGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy4kd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmNhbnZhcy5jb250ZXh0cyA9IHt9O1xuICAgICAgICB0aGlzLmNhbnZhcy5wYW5ZID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXMucGFuWCA9IDA7XG4gICAgICAgIC8vIHJlc2l6ZSBjYW52YXMgdG8gZml0IHdpbmRvdz9cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplID0gdHJ1ZTtcbiAgICAgICAgLy8gYWxsIGNhbnZhc2VzIGFyZSB0aGUgc2FtZSBzaXplXG4gICAgICAgIHRoaXMuY2FudmFzLnNpemUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IERFRkFVTFRfQ0FOVkFTX1NJWkUuSEVJR0hULFxuICAgICAgICAgICAgd2lkdGg6IERFRkFVTFRfQ0FOVkFTX1NJWkUuV0lEVEhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMubGFzdCA9IHRpbWUoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbnZhcy5kcmF3X2xhYmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfcmVzdHJpY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfc2lkcyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfdGVycmFpbiA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoKVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqL1xuICAgIF9pbml0KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBkaXNhYmxlXG4gICAgICovXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJHdpbmRvdyA9IG51bGw7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHt9O1xuICAgICAgICB0aGlzLmNhbnZhcy5jb250ZXh0cyA9IHt9O1xuICAgICAgICB0aGlzLmNhbnZhcy5wYW5ZID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXMucGFuWCA9IDA7XG4gICAgICAgIC8vIHJlc2l6ZSBjYW52YXMgdG8gZml0IHdpbmRvdz9cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplID0gdHJ1ZTtcbiAgICAgICAgLy8gYWxsIGNhbnZhc2VzIGFyZSB0aGUgc2FtZSBzaXplXG4gICAgICAgIHRoaXMuY2FudmFzLnNpemUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IERFRkFVTFRfQ0FOVkFTX1NJWkUuSEVJR0hULFxuICAgICAgICAgICAgd2lkdGg6IERFRkFVTFRfQ0FOVkFTX1NJWkUuV0lEVEhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMubGFzdCA9IHRpbWUoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbnZhcy5kcmF3X2xhYmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfcmVzdHJpY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfc2lkcyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzLmRyYXdfdGVycmFpbiA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfaW5pdF9wcmVcbiAgICAgKi9cbiAgICBjYW52YXNfaW5pdF9wcmUoKSB7XG4gICAgICAgIHByb3AuY2FudmFzID0gY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2luaXRcbiAgICAgKi9cbiAgICBjYW52YXNfaW5pdCgpIHtcbiAgICAgICAgdGhpcy5jYW52YXNfYWRkKCduYXZhaWRzJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfYWRqdXN0X2hpZHBpXG4gICAgICovXG4gICAgY2FudmFzX2FkanVzdF9oaWRwaSgpIHtcbiAgICAgICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICBsb2coYGRldmljZVBpeGVsUmF0aW86ICR7ZHByfWApO1xuXG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0byBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKGRwciA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGlzIHNlbGVjdG9yLCAkaGlkZWZDYW52YXNcbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSBzZWxlY3RvciB3aXRoIGNvbnN0YW50XG4gICAgICAgIGNvbnN0IGhpZGVmQ2FudmFzID0gJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5OQVZBSURTX0NBTlZBUykuZ2V0KDApO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5jYW52YXMuc2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0O1xuXG4gICAgICAgICQoaGlkZWZDYW52YXMpLmF0dHIoJ3dpZHRoJywgdyAqIGRwcik7XG4gICAgICAgICQoaGlkZWZDYW52YXMpLmF0dHIoJ2hlaWdodCcsIGggKiBkcHIpO1xuICAgICAgICAkKGhpZGVmQ2FudmFzKS5jc3MoJ3dpZHRoJywgdyk7XG4gICAgICAgICQoaGlkZWZDYW52YXMpLmNzcygnaGVpZ2h0JywgaCk7XG5cbiAgICAgICAgY29uc3QgY3R4ID0gaGlkZWZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICB0aGlzLmNhbnZhcy5jb250ZXh0cy5uYXZhaWRzID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBjYW52YXNfY29tcGxldGUoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLmxhc3QgPSB0aW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGNhbnZhc19yZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy5yZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNpemUud2lkdGggPSB0aGlzLiR3aW5kb3cud2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0ID0gdGhpcy4kd2luZG93LmhlaWdodCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuc2l6ZS53aWR0aCAtPSAyNTA7XG4gICAgICAgIHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0IC09IDM2O1xuXG4gICAgICAgIF9mb3JFYWNoKHRoaXMuY2FudmFzLmNvbnRleHRzLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLnNpemUud2lkdGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNfYWRqdXN0X2hpZHBpKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfdXBkYXRlX3Bvc3RcbiAgICAgKi9cbiAgICBjYW52YXNfdXBkYXRlX3Bvc3QoKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSB3aW5kb3cuZ2FtZUNvbnRyb2xsZXIuZ2FtZV90aW1lKCkgLSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5zdGFydDtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBleHRyYXBvbGF0ZV9yYW5nZV9jbGFtcCgwLjEsIGVsYXBzZWQsIDAuNCwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGZyYW1lc3RlcCA9IE1hdGgucm91bmQoZXh0cmFwb2xhdGVfcmFuZ2VfY2xhbXAoMSwgd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUuc3BlZWR1cCwgMTAsIDMwLCAxKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmRpcnR5IHx8ICghd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfcGF1c2VkKCkgJiYgcHJvcC50aW1lLmZyYW1lcyAlIGZyYW1lc3RlcCA9PT0gMCkgfHwgZWxhcHNlZCA8IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gdGhpcy5jYW52YXNfZ2V0KCduYXZhaWRzJyk7XG4gICAgICAgICAgICBjb25zdCBmYWRpbmcgPSBlbGFwc2VkIDwgMTtcblxuICAgICAgICAgICAgY2MuZm9udCA9ICcxMXB4IG1vbm9PbmUsIG1vbm9zcGFjZSc7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgaXMgdGhlIHJhdGlvbmFsZSBoZXJlPyB3aXRoIHR3byBvcnMgYW5kIGEgdHJ1ZSwgdGhpcyBibG9jayB3aWxsIGFsd2F5cyBiZSBleGVjdHV0ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMuZGlydHkgfHwgZmFkaW5nIHx8IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYy5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc19jbGVhcihjYyk7XG5cbiAgICAgICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1pZGRsZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlTWlkZGxlKHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY2MuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfdmlkZW9NYXAoY2MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfdGVycmFpbihjYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19yZXN0cmljdGVkKGNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3J1bndheXMoY2MpO1xuICAgICAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjYy5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfZml4ZXMoY2MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfc2lkcyhjYyk7XG4gICAgICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuXG5cbiAgICAgICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xsZWQgdHJhZmZpYyByZWdpb24gLSAoQ1RSKVxuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIGFpcnBvcnQgY2VudGVyXG4gICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgcm91bmQodGhpcy5jYW52YXMuc2l6ZS53aWR0aCAvIDIgKyB0aGlzLmNhbnZhcy5wYW5YKSxcbiAgICAgICAgICAgICAgICByb3VuZCh0aGlzLmNhbnZhcy5zaXplLmhlaWdodCAvIDIgKyB0aGlzLmNhbnZhcy5wYW5ZKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgaW5jb3JyZWN0IHVzYWdlIG9mIGEgdGVybmFyeS4gdGVybmFyaWVzIHNob3VsZCBiZSB1c2VkIGZvciBhIHNzaWdubWVudCBub3QgZnVuY3Rpb24gY2FsbHMuXG4gICAgICAgICAgICAvLyBkcmF3IGFpcnNwYWNlIGJvcmRlclxuICAgICAgICAgICAgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuYWlyc3BhY2VcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2FudmFzX2RyYXdfYWlyc3BhY2VfYm9yZGVyKGNjKVxuICAgICAgICAgICAgICAgIDogdGhpcy5jYW52YXNfZHJhd19jdHIoY2MpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3JhbmdlX3JpbmdzKGNjKTtcbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBtYXJraW5ncyBmb3IgRU5HTSBwb2ludCBtZXJnZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmljYW8gPT09ICdFTkdNJykge1xuICAgICAgICAgICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1pZGRsZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlTWlkZGxlKHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19lbmdtX3JhbmdlX3JpbmdzKGNjKTtcbiAgICAgICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXBhc3NcbiAgICAgICAgICAgIGNjLmZvbnQgPSAnYm9sZCAxMHB4IG1vbm9PbmUsIG1vbm9zcGFjZSc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy5kaXJ0eSB8fCBmYWRpbmcgfHwgdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1pZGRsZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlTWlkZGxlKHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X2NvbXBhc3MoY2MpO1xuICAgICAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2MuZm9udCA9IEJBU0VfQ0FOVkFTX0ZPTlQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy5kaXJ0eSB8fCB0aGlzLmNhbnZhc19zaG91bGRfZHJhdygpIHx8IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY2MuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1pZGRsZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlTWlkZGxlKHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19hbGxfYWlyY3JhZnQoY2MpO1xuICAgICAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgY2MuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIGNjLnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVNaWRkbGUodGhpcy5jYW52YXMuc2l6ZS53aWR0aCksXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlTWlkZGxlKHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfYWxsX2luZm8oY2MpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICBjYy5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgY2MudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1pZGRsZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoKSxcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVNaWRkbGUodGhpcy5jYW52YXMuc2l6ZS5oZWlnaHQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3J1bndheV9sYWJlbHMoY2MpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICBjYy5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19zY2FsZShjYyk7XG4gICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgICAgIGNjLmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X2RpcmVjdGlvbnMoY2MpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfYWRkXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjYW52YXNfYWRkKG5hbWUpIHtcbiAgICAgICAgJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5DQU5WQVNFUykuYXBwZW5kKGA8Y2FudmFzIGlkPScke25hbWV9LWNhbnZhcyc+PC9jYW52YXM+YCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRzW25hbWVdID0gJChgIyR7bmFtZX0tY2FudmFzYCkuZ2V0KDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19nZXRcbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNhbnZhc19nZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuY29udGV4dHNbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfY2xlYXJcbiAgICAgKiBAcGFyYW0gY2Mge29iamVjdH1cbiAgICAgKi9cbiAgICBjYW52YXNfY2xlYXIoY2MpIHtcbiAgICAgICAgY2MuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLnNpemUud2lkdGgsIHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19zaG91bGRfZHJhd1xuICAgICAqL1xuICAgIGNhbnZhc19zaG91bGRfZHJhdygpIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWUoKSAtIHRoaXMuY2FudmFzLmxhc3Q7XG5cbiAgICAgICAgaWYgKGVsYXBzZWQgPiAoMSAvIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLnNwZWVkdXApKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5sYXN0ID0gdGltZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19ydW53YXlcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gcnVud2F5XG4gICAgICogQHBhcmFtIG1vZGVcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19ydW53YXkoY2MsIHJ1bndheSwgbW9kZSkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChydW53YXkubGVuZ3RoIC8gMikpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHJ1bndheS5hbmdsZTtcblxuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICByb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHJ1bndheS5wb3NpdGlvblswXSkpICsgdGhpcy5jYW52YXMucGFuWCxcbiAgICAgICAgICAgIC1yb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHJ1bndheS5wb3NpdGlvblsxXSkpICsgdGhpcy5jYW52YXMucGFuWVxuICAgICAgICApO1xuICAgICAgICBjYy5yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgIC8vIHJ1bndheSBib2R5XG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSAnIzg5OSc7XG4gICAgICAgICAgICBjYy5saW5lV2lkdGggPSAyLjg7XG5cbiAgICAgICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY2MubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgY2MubGluZVRvKDAsIC0yICogbGVuZ3RoMik7XG4gICAgICAgICAgICBjYy5zdHJva2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4dGVuZGVkIGNlbnRlcmxpbmVzXG4gICAgICAgICAgICBpZiAoIXJ1bndheS5pbHMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSAnIzQ2NSc7XG4gICAgICAgICAgICBjYy5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNjLm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGNjLmxpbmVUbygwLCB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHJ1bndheS5pbHMubG9jX21heERpc3QpKTtcbiAgICAgICAgICAgIGNjLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19ydW53YXlfbGFiZWxcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gcnVud2F5XG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfcnVud2F5X2xhYmVsKGNjLCBydW53YXkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IHJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgocnVud2F5Lmxlbmd0aCAvIDIpKSArIDAuNTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBydW53YXkuYW5nbGU7XG4gICAgICAgIGNvbnN0IHRleHRfaGVpZ2h0ID0gMTQ7XG5cbiAgICAgICAgY2MudHJhbnNsYXRlKFxuICAgICAgICAgICAgcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChydW53YXkucG9zaXRpb25bMF0pKSArIHRoaXMuY2FudmFzLnBhblgsXG4gICAgICAgICAgICAtcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChydW53YXkucG9zaXRpb25bMV0pKSArIHRoaXMuY2FudmFzLnBhbllcbiAgICAgICAgKTtcbiAgICAgICAgY2Mucm90YXRlKGFuZ2xlKTtcblxuICAgICAgICBjYy50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY2MudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgbGVuZ3RoMiArIHRleHRfaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIGNjLnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICByb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHJ1bndheS5sYWJlbFBvc1swXSkpLFxuICAgICAgICAgICAgLXJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgocnVud2F5LmxhYmVsUG9zWzFdKSlcbiAgICAgICAgKTtcbiAgICAgICAgY2MuZmlsbFRleHQocnVud2F5Lm5hbWUsIDAsIDApO1xuICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19ydW53YXlzXG4gICAgICogQHBhcmFtIGNjXG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfcnVud2F5cyhjYykge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzLmRyYXdfbGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5XSElURV8wNDtcbiAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLldISVRFXzA0O1xuICAgICAgICBjYy5saW5lV2lkdGggPSA0O1xuXG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcblxuICAgICAgICAvLyBFeHRlbmRlZCBDZW50ZXJsaW5lc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFpcnBvcnQucnVud2F5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19ydW53YXkoY2MsIGFpcnBvcnQucnVud2F5c1tpXVswXSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfcnVud2F5KGNjLCBhaXJwb3J0LnJ1bndheXNbaV1bMV0sIHRydWUpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVud2F5c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFpcnBvcnQucnVud2F5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19ydW53YXkoY2MsIGFpcnBvcnQucnVud2F5c1tpXVswXSwgZmFsc2UpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19ydW53YXlfbGFiZWxzXG4gICAgICogQHBhcmFtIGNjXG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfcnVud2F5X2xhYmVscyhjYykge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzLmRyYXdfbGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDg7XG5cbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFpcnBvcnQucnVud2F5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19ydW53YXlfbGFiZWwoY2MsIGFpcnBvcnQucnVud2F5c1tpXVswXSk7XG4gICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3J1bndheV9sYWJlbChjYywgYWlycG9ydC5ydW53YXlzW2ldWzFdKTtcbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfc2NhbGVcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19zY2FsZShjYykge1xuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDg7XG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gQ09MT1JTLldISVRFXzA4O1xuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDEwO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSA1O1xuICAgICAgICBjb25zdCBsZW5ndGggPSByb3VuZCgxIC8gcHJvcC51aS5zY2FsZSAqIDUwKTtcbiAgICAgICAgY29uc3QgcHhfbGVuZ3RoID0gcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChsZW5ndGgpKTtcblxuICAgICAgICBjYy50cmFuc2xhdGUoMC41LCAwLjUpO1xuXG4gICAgICAgIGNjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGNjLm1vdmVUbyh0aGlzLmNhbnZhcy5zaXplLndpZHRoIC0gb2Zmc2V0LCBvZmZzZXQpO1xuICAgICAgICBjYy5saW5lVG8odGhpcy5jYW52YXMuc2l6ZS53aWR0aCAtIG9mZnNldCwgb2Zmc2V0ICsgaGVpZ2h0KTtcbiAgICAgICAgY2MubGluZVRvKHRoaXMuY2FudmFzLnNpemUud2lkdGggLSBvZmZzZXQgLSBweF9sZW5ndGgsIG9mZnNldCArIGhlaWdodCk7XG4gICAgICAgIGNjLmxpbmVUbyh0aGlzLmNhbnZhcy5zaXplLndpZHRoIC0gb2Zmc2V0IC0gcHhfbGVuZ3RoLCBvZmZzZXQpO1xuICAgICAgICBjYy5zdHJva2UoKTtcblxuICAgICAgICBjYy50cmFuc2xhdGUoLTAuNSwgLTAuNSk7XG5cbiAgICAgICAgY2MudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGNjLmZpbGxUZXh0KFxuICAgICAgICAgICAgYCR7bGVuZ3RofSBrbWAsIHRoaXMuY2FudmFzLnNpemUud2lkdGggLSBvZmZzZXQgLSBweF9sZW5ndGggKiAwLjUsXG4gICAgICAgICAgICBvZmZzZXQgKyBoZWlnaHQgKyAxN1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfZml4XG4gICAgICogQHBhcmFtIGNjXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gZml4XG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfZml4KGNjLCBuYW1lLCBmaXgpIHtcbiAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNjLm1vdmVUbygwLCAtNSk7XG4gICAgICAgIGNjLmxpbmVUbyg0LCAzKTtcbiAgICAgICAgY2MubGluZVRvKC00LCAzKTtcbiAgICAgICAgY2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNjLmZpbGwoKTtcbiAgICAgICAgY2Muc3Ryb2tlKCk7XG5cbiAgICAgICAgY2MudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGNjLnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICBjYy5zdHJva2VUZXh0KG5hbWUsIDAsIDYpO1xuICAgICAgICBjYy5maWxsVGV4dChuYW1lLCAwLCA2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X2ZpeGVzXG4gICAgICogQHBhcmFtIGNjXG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfZml4ZXMoY2MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcy5kcmF3X2xhYmVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2MubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjYy5mb250ID0gQkFTRV9DQU5WQVNfRk9OVDtcblxuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIC8vIFRPRE86IHBlcmhhcHMgdGhpcyBjb3VsZCBiZSBhIG1vZGVsIG1ldGhvZD9cbiAgICAgICAgX2ZvckVhY2goYWlycG9ydC5yZWFsX2ZpeGVzLCAoZml4LCBpKSA9PiB7XG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChmaXgucG9zaXRpb25bMF0pKSArIHRoaXMuY2FudmFzLnBhblgsXG4gICAgICAgICAgICAgICAgLXJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoZml4LnBvc2l0aW9uWzFdKSkgKyB0aGlzLmNhbnZhcy5wYW5ZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBkcmF3IG91dGxpbmUgKGRyYXcgd2l0aCBlcmFzZXIpXG4gICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuNjcpJztcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuNjcpJztcbiAgICAgICAgICAgIGNjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICAgICAgY2MubGluZVdpZHRoID0gNDtcblxuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19maXgoY2MsIGZpeC5uYW1lLCBmaXgucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5XSElURV8wMDtcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5XSElURV8wNTtcbiAgICAgICAgICAgIGNjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICBjYy5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X2ZpeChjYywgZml4Lm5hbWUsIGZpeC5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYnJlYWsgdGhpcyBtZXRob2QgdXAgaW50byBzbWFsbGVyIGNodW5rc1xuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfc2lkc1xuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X3NpZHMoY2MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcy5kcmF3X3NpZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjb3VudCBvZiBzaWQgdGV4dCBkcmF3biBmb3IgYSBzcGVjaWZpYyB0cmFuc2l0aW9uXG4gICAgICAgIGNvbnN0IHRleHRfYXRfcG9pbnQgPSBbXTtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gQ09MT1JTLkRFUEFSVFVSRV9DT0xPUjtcbiAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLkRFUEFSVFVSRV9DT0xPUjtcbiAgICAgICAgY2Muc2V0TGluZURhc2goWzEsIDEwXSk7XG4gICAgICAgIGNjLmZvbnQgPSAnaXRhbGljIDE0cHggbW9ub09uZSwgbW9ub3NwYWNlJztcblxuICAgICAgICBfZm9yRWFjaChhaXJwb3J0LnNpZENvbGxlY3Rpb24uZHJhdywgKHNpZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHdyaXRlX3NpZF9uYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmaXhYID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBmaXhZID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFfaGFzKHNpZCwgJ2RyYXcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2ZvckVhY2goc2lkLmRyYXcsIChmaXhMaXN0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXRfbmFtZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpeExpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgZXhpdFBvaW50IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeExpc3Rbal0uaW5kZXhPZignKicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdF9uYW1lID0gZml4TGlzdFtqXS5yZXBsYWNlKCcqJywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVfc2lkX25hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXggPSBhaXJwb3J0LmdldEZpeFBvc2l0aW9uKGZpeExpc3Rbal0ucmVwbGFjZSgnKicsICcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgVW5hYmxlIHRvIGRyYXcgbGluZSB0byAnJHtmaXhMaXN0W2pdfScgYmVjYXVzZSBpdHMgcG9zaXRpb24gaXMgbm90IGRlZmluZWQhYCwgTE9HLldBUk5JTkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZml4WCA9IHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoZml4WzBdKSArIHRoaXMuY2FudmFzLnBhblg7XG4gICAgICAgICAgICAgICAgICAgIGZpeFkgPSAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChmaXhbMV0pICsgdGhpcy5jYW52YXMucGFuWTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5tb3ZlVG8oZml4WCwgZml4WSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5saW5lVG8oZml4WCwgZml4WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYy5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0X25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjb3VudCBmb3IgdGhpcyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih0ZXh0X2F0X3BvaW50W2V4aXRfbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X2F0X3BvaW50W2V4aXRfbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb2ludCBmb3IgZHJhd2luZyBkZXBlbmRpbmcgb24gaG93IG1hbnkgc2lkcyB3ZSBoYXZlIGRyYXduIHRleHQgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB5X3BvaW50ID0gZml4WSArICgxNSAqIHRleHRfYXRfcG9pbnRbZXhpdF9uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGNjLmZpbGxUZXh0KGAke3NpZC5pZGVudGlmaWVyfS4ke2V4aXRfbmFtZX1gLCBmaXhYICsgMTAsIHlfcG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRfYXRfcG9pbnRbZXhpdF9uYW1lXSArPSAxOyAgLy8gSW5jcmVtZW50IHRoZSBjb3VudCBmb3IgdGhpcyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3cml0ZV9zaWRfbmFtZSkge1xuICAgICAgICAgICAgICAgIGNjLmZpbGxUZXh0KHNpZC5pZGVudGlmaWVyLCBmaXhYICsgMTAsIGZpeFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X3NlcGFyYXRpb25faW5kaWNhdG9yXG4gICAgICogQHBhcmFtIGNjXG4gICAgICogQHBhcmFtIGFpcmNyYWZ0XG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfc2VwYXJhdGlvbl9pbmRpY2F0b3IoY2MsIGFpcmNyYWZ0KSB7XG4gICAgICAgIC8vIERyYXcgYSB0cmFpbGluZyBpbmRpY2F0b3IgMi41IE5NICg0LjZrbSkgYmVoaW5kIGxhbmRpbmcgYWlyY3JhZnQgdG8gaGVscCB3aXRoIHRyYWZmaWMgc3BhY2luZ1xuICAgICAgICBjb25zdCByd3kgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKS5nZXRSdW53YXkoYWlyY3JhZnQuZm1zLmN1cnJlbnRXYXlwb2ludC5ydW53YXkpO1xuXG4gICAgICAgIGlmICghcnd5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbmdsZSA9IHJ3eS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuUkVEXzA4O1xuICAgICAgICBjYy5saW5lV2lkdGggPSAzO1xuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGFpcmNyYWZ0LnBvc2l0aW9uWzBdKSArIHRoaXMuY2FudmFzLnBhblgsXG4gICAgICAgICAgICAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhaXJjcmFmdC5wb3NpdGlvblsxXSkgKyB0aGlzLmNhbnZhcy5wYW5ZXG4gICAgICAgICk7XG4gICAgICAgIGNjLnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYy5tb3ZlVG8oLTUsIC13aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KDUuNTU2KSk7ICAvLyA1LjU1NmttID0gMy4wbm1cbiAgICAgICAgY2MubGluZVRvKCs1LCAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weCg1LjU1NikpOyAgLy8gNS41NTZrbSA9IDMuMG5tXG4gICAgICAgIGNjLnN0cm9rZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfYWlyY3JhZnRfcmluZ3NcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gYWlyY3JhZnRcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19haXJjcmFmdF9yaW5ncyhjYywgYWlyY3JhZnQpIHtcbiAgICAgICAgY2Muc2F2ZSgpO1xuXG4gICAgICAgIGlmIChhaXJjcmFmdC5oYXNBbGVydHMoKVswXSkge1xuICAgICAgICAgICAgaWYgKGFpcmNyYWZ0Lmhhc0FsZXJ0cygpWzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVkIHZpb2xhdGlvbiBjaXJjbGVcbiAgICAgICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5SRUQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdoaXRlIHdhcm5pbmcgY2lyY2xlXG4gICAgICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IGNjLmZpbGxTdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYy5hcmMoMCwgMCwgd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChrbSgzKSksIDAsIHRhdSgpKTsgIC8vIDNubSBSQURJVVNcbiAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X2FpcmNyYWZ0X2RlcGFydHVyZV93aW5kb3dcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gYWlyY3JhZnRcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19haXJjcmFmdF9kZXBhcnR1cmVfd2luZG93KGNjLCBhaXJjcmFmdCkge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGFpcmNyYWZ0LmRlc3RpbmF0aW9uIC0gTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5ERVBBUlRVUkVfU1RST0tFO1xuICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgY2MuYXJjKFxuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFuWCxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhblksXG4gICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpLmN0cl9yYWRpdXMpLFxuICAgICAgICAgICAgYW5nbGUgLSAwLjA4NzI2LFxuICAgICAgICAgICAgYW5nbGUgKyAwLjA4NzI2KTtcbiAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X2FpcmNyYWZ0XG4gICAgICogQHBhcmFtIGNjXG4gICAgICogQHBhcmFtIGFpcmNyYWZ0XG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfYWlyY3JhZnQoY2MsIGFpcmNyYWZ0KSB7XG4gICAgICAgIGxldCBhbG1vc3RfbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcC5pbnB1dC5jYWxsc2lnbi5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICBhaXJjcmFmdC5tYXRjaENhbGxzaWduKHByb3AuaW5wdXQuY2FsbHNpZ24uc3Vic3RyKDAsIHByb3AuaW5wdXQuY2FsbHNpZ24ubGVuZ3RoIC0gMSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgYWxtb3N0X21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wLmlucHV0LmNhbGxzaWduLmxlbmd0aCA+IDAgJiYgYWlyY3JhZnQubWF0Y2hDYWxsc2lnbihwcm9wLmlucHV0LmNhbGxzaWduKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoICYmIChhaXJjcmFmdC5kZXN0aW5hdGlvbiAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19haXJjcmFmdF9kZXBhcnR1cmVfd2luZG93KGNjLCBhaXJjcmFmdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFpcmNyYWZ0LmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0gMztcbiAgICAgICAgLy8gVHJhaWxsaW5nXG4gICAgICAgIGxldCB0cmFpbGxpbmdfbGVuZ3RoID0gMTI7XG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgaWYgKGRwciA+IDEpIHtcbiAgICAgICAgICAgIHRyYWlsbGluZ19sZW5ndGggKj0gcm91bmQoZHByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLnNhdmUoKTtcblxuICAgICAgICBpZiAoIWFpcmNyYWZ0Lmluc2lkZV9jdHIpIHtcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5MSUdIVF9TSUxWRVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZW5ndGggPSBhaXJjcmFmdC5wb3NpdGlvbl9oaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFhaXJjcmFmdC5pbnNpZGVfY3RyKSB7XG4gICAgICAgICAgICAgICAgY2MuZ2xvYmFsQWxwaGEgPSAwLjMgLyAobGVuZ3RoIC0gaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNjLmdsb2JhbEFscGhhID0gMSAvIChsZW5ndGggLSBpKTtcbiAgICAgICAgICAgICAgICBjYy5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhaXJjcmFmdC5wb3NpdGlvbl9oaXN0b3J5W2ldWzBdKSArIHRoaXMuY2FudmFzLnBhblggLSAxLFxuICAgICAgICAgICAgICAgICAgICAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhaXJjcmFmdC5wb3NpdGlvbl9oaXN0b3J5W2ldWzFdKSArIHRoaXMuY2FudmFzLnBhblkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNjLnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoYWlyY3JhZnQucG9zaXRpb25faGlzdG9yeS5sZW5ndGggPiB0cmFpbGxpbmdfbGVuZ3RoKSB7XG4gICAgICAgICAgICBhaXJjcmFmdC5wb3NpdGlvbl9oaXN0b3J5ID0gYWlyY3JhZnQucG9zaXRpb25faGlzdG9yeS5zbGljZShhaXJjcmFmdC5wb3NpdGlvbl9oaXN0b3J5Lmxlbmd0aCAtIHRyYWlsbGluZ19sZW5ndGgsIGFpcmNyYWZ0LnBvc2l0aW9uX2hpc3RvcnkubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhaXJjcmFmdC5pc1ByZWNpc2lvbkd1aWRlZCgpKSB7XG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3NlcGFyYXRpb25faW5kaWNhdG9yKGNjLCBhaXJjcmFmdCk7XG4gICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBpZiBhbGwgdGhlc2UgcGFyZW5zIGFyZSBhY3RhbGx5IG5lZWRlZCwgYWJzdHJhY3QgdGhpcyBvdXQgdG8gYSBmdW5jdGlvbiB0aGF0IGNhbiByZXR1cm4gYSBib29sLlxuICAgICAgICAvLyBBaXJjcmFmdFxuICAgICAgICAvLyBEcmF3IHRoZSBmdXR1cmUgcGF0aFxuICAgICAgICBpZiAoKHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLm9wdGlvbi5nZXQoJ2RyYXdQcm9qZWN0ZWRQYXRocycpID09PSAnYWx3YXlzJykgfHxcbiAgICAgICAgICAoKHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLm9wdGlvbi5nZXQoJ2RyYXdQcm9qZWN0ZWRQYXRocycpID09PSAnc2VsZWN0ZWQnKSAmJlxuICAgICAgICAgICAoKGFpcmNyYWZ0Lndhcm5pbmcgfHwgbWF0Y2gpICYmICFhaXJjcmFmdC5pc1RheGlpbmcoKSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19mdXR1cmVfdHJhY2soY2MsIGFpcmNyYWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFsZXJ0cyA9IGFpcmNyYWZ0Lmhhc0FsZXJ0cygpO1xuXG4gICAgICAgIGlmICghYWlyY3JhZnQuaW5zaWRlX2N0cikge1xuICAgICAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLkxJR0hUX1NJTFZFUl8wMztcbiAgICAgICAgfSBlbHNlIGlmIChhbG1vc3RfbWF0Y2gpIHtcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5HUkFJTl9CUk9XTjtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLldISVRFO1xuICAgICAgICB9IGVsc2UgaWYgKGFpcmNyYWZ0Lndhcm5pbmcgfHwgYWxlcnRzWzFdKSB7XG4gICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuUkVEO1xuICAgICAgICB9IGVsc2UgaWYgKGFpcmNyYWZ0LmhpdCkge1xuICAgICAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLkNPUkFMX1JFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5XSElURTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gY2MuZmlsbFN0eWxlO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWFpcmNyYWZ0Lmluc2lkZV9jdHIpIHtcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5XSElURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMuY2FudmFzLnNpemUud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgY2MudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGNsYW1wKC13LCB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGFpcmNyYWZ0LnBvc2l0aW9uWzBdKSArIHRoaXMuY2FudmFzLnBhblgsIHcpLFxuICAgICAgICAgICAgICAgIGNsYW1wKC1oLCAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhaXJjcmFmdC5wb3NpdGlvblsxXSkgKyB0aGlzLmNhbnZhcy5wYW5ZLCBoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjYy5hcmMoMCwgMCwgcm91bmQoc2l6ZSAqIDEuNSksIDAsIHRhdSgpKTtcbiAgICAgICAgICAgIGNjLmZpbGwoKTtcblxuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2MudHJhbnNsYXRlKFxuICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhaXJjcmFmdC5wb3NpdGlvblswXSkgKyB0aGlzLmNhbnZhcy5wYW5YLFxuICAgICAgICAgICAgLXdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoYWlyY3JhZnQucG9zaXRpb25bMV0pICsgdGhpcy5jYW52YXMucGFuWVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghYWlyY3JhZnQuaGl0KSB7XG4gICAgICAgICAgICBjYy5zYXZlKCk7XG5cbiAgICAgICAgICAgIGxldCB0YWlsX2xlbmd0aCA9IGFpcmNyYWZ0Lmdyb3VuZFNwZWVkIC8gMTU7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0YWlsX2xlbmd0aCA9IDE1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IGFpcmNyYWZ0Lmdyb3VuZFRyYWNrO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdnNjYWxlKHZ0dXJuKGFuZ2xlKSwgdGFpbF9sZW5ndGgpO1xuXG4gICAgICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNjLm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGNjLmxpbmVUbyhlbmRbMF0sIC1lbmRbMV0pO1xuICAgICAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWlyY3JhZnQubm90aWNlIHx8IGFsZXJ0c1swXSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19haXJjcmFmdF9yaW5ncyhjYywgYWlyY3JhZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNjLmFyYygwLCAwLCBzaXplLCAwLCB0YXUoKSk7XG4gICAgICAgIGNjLmZpbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGRhc2hlZCBsaW5lIGZyb20gbGFzdCBjb29yZGluYXRlIG9mIGZ1dHVyZSB0cmFjayB0aHJvdWdoXG4gICAgICogYW55IGxhdGVyIHJlcXVlc3RlZCBmaXhlcy5cbiAgICAgKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfZnV0dXJlX3RyYWNrX2ZpeGVzXG4gICAgICogQHBhcmFtIGNjXG4gICAgICogQHBhcmFtIGFpcmNyYWZ0XG4gICAgICogQHBhcmFtIGZ1dHVyZV90cmFja1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X2Z1dHVyZV90cmFja19maXhlcyhjYywgYWlyY3JhZnQsIGZ1dHVyZV90cmFjaykge1xuICAgICAgICBpZiAoYWlyY3JhZnQuZm1zLndheXBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydCA9IGZ1dHVyZV90cmFjay5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB4ID0gd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChmdXR1cmVfdHJhY2tbc3RhcnRdWzBdKSArIHRoaXMuY2FudmFzLnBhblg7XG4gICAgICAgIGNvbnN0IHkgPSAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChmdXR1cmVfdHJhY2tbc3RhcnRdWzFdKSArIHRoaXMuY2FudmFzLnBhblk7XG5cbiAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNjLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgY2Muc2V0TGluZURhc2goWzMsIDEwXSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhaXJjcmFmdC5mbXMud2F5cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWFpcmNyYWZ0LmZtcy53YXlwb2ludHNbaV0ubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZml4ID0gYWlyY3JhZnQuZm1zLndheXBvaW50c1tpXS5sb2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZ4ID0gd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChmaXhbMF0pICsgdGhpcy5jYW52YXMucGFuWDtcbiAgICAgICAgICAgIGNvbnN0IGZ5ID0gLXdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoZml4WzFdKSArIHRoaXMuY2FudmFzLnBhblk7XG5cbiAgICAgICAgICAgIGNjLmxpbmVUbyhmeCwgZnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVuIHBoeXNpY3MgdXBkYXRlcyBpbnRvIHRoZSBmdXR1cmUsIGRyYXcgZnV0dXJlIHRyYWNrXG4gICAgICpcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X2Z1dHVyZV90cmFja1xuICAgICAqIEBwYXJhbSBjY1xuICAgICAqIEBwYXJhbSBhaXJjcmFmdFxuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X2Z1dHVyZV90cmFjayhjYywgYWlyY3JhZnQpIHtcbiAgICAgICAgbGV0IGlsc19sb2NrZWQ7XG4gICAgICAgIGxldCBsb2NrZWRTdHJva2U7XG4gICAgICAgIGxldCB3YXNfbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGZ1dHVyZV90cmFjayA9IFtdO1xuICAgICAgICBjb25zdCBzYXZlX2RlbHRhID0gd2luZG93LmdhbWVDb250cm9sbGVyLmdhbWUuZGVsdGE7XG4gICAgICAgIGNvbnN0IGZtc190d2luID0gX2Nsb25lRGVlcChhaXJjcmFmdC5mbXMpO1xuICAgICAgICBjb25zdCB0d2luID0gX2Nsb25lRGVlcChhaXJjcmFmdCk7XG5cbiAgICAgICAgdHdpbi5mbXMgPSBmbXNfdHdpbjtcbiAgICAgICAgdHdpbi5mbXMuYWlyY3JhZnQgPSB0d2luO1xuICAgICAgICB0d2luLnByb2plY3RlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLmRlbHRhID0gNTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDYwOyBpKyspIHtcbiAgICAgICAgICAgIHR3aW4udXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGlsc19sb2NrZWQgPSB0d2luLmlzUHJlY2lzaW9uR3VpZGVkKCkgJiZcbiAgICAgICAgICAgICAgICB0d2luLmNhdGVnb3J5ID09PSBGTElHSFRfQ0FURUdPUlkuQVJSSVZBTCAmJlxuICAgICAgICAgICAgICAgIHR3aW4ubW9kZSA9PT0gRkxJR0hUX01PREVTLkxBTkRJTkc7XG5cbiAgICAgICAgICAgIGZ1dHVyZV90cmFjay5wdXNoKFt0d2luLnBvc2l0aW9uWzBdLCB0d2luLnBvc2l0aW9uWzFdLCBpbHNfbG9ja2VkXSk7XG5cbiAgICAgICAgICAgIGlmIChpbHNfbG9ja2VkICYmIHR3aW4uYWx0aXR1ZGUgPCA1MDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLmRlbHRhID0gc2F2ZV9kZWx0YTtcbiAgICAgICAgY2Muc2F2ZSgpO1xuXG4gICAgICAgIGlmIChhaXJjcmFmdC5jYXRlZ29yeSA9PT0gRkxJR0hUX0NBVEVHT1JZLkRFUEFSVFVSRSkge1xuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuREVQQVJUVVJFX0NPTE9SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuUkVEXzA2O1xuICAgICAgICAgICAgbG9ja2VkU3Ryb2tlID0gQ09MT1JTLlJFRDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzY3JlZW4nO1xuICAgICAgICBjYy5saW5lV2lkdGggPSAyO1xuICAgICAgICBjYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1dHVyZV90cmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBmdXR1cmVfdHJhY2tbaV07XG4gICAgICAgICAgICBpbHNfbG9ja2VkID0gdHJhY2tbMl07XG5cbiAgICAgICAgICAgIGNvbnN0IHggPSB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHRyYWNrWzBdKSArIHRoaXMuY2FudmFzLnBhblg7XG4gICAgICAgICAgICBjb25zdCB5ID0gLXdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgodHJhY2tbMV0pICsgdGhpcy5jYW52YXMucGFuWTtcblxuICAgICAgICAgICAgaWYgKGlsc19sb2NrZWQgJiYgIXdhc19sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBjYy5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgLy8gZW5kIHRoZSBjdXJyZW50IHBhdGgsIHN0YXJ0IGEgbmV3IHBhdGggd2l0aCBsb2NrZWRTdHJva2VcbiAgICAgICAgICAgICAgICBjYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IGxvY2tlZFN0cm9rZTtcbiAgICAgICAgICAgICAgICBjYy5saW5lV2lkdGggPSAzO1xuICAgICAgICAgICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNjLm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgICAgIHdhc19sb2NrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2MubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYy5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYy5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jYW52YXNfZHJhd19mdXR1cmVfdHJhY2tfZml4ZXMoY2MsIHR3aW4sIGZ1dHVyZV90cmFjayk7XG4gICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X2FsbF9haXJjcmFmdFxuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X2FsbF9haXJjcmFmdChjYykge1xuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuTElHSFRfU0lMVkVSO1xuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5MSUdIVF9TSUxWRVI7XG4gICAgICAgIGNjLmxpbmVXaWR0aCA9IDI7XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lKCdjYW52YXNfZHJhd19hbGxfYWlyY3JhZnQnKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3AuYWlyY3JhZnQubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19haXJjcmFmdChjYywgcHJvcC5haXJjcmFmdC5saXN0W2ldKTtcbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLnRpbWVFbmQoJ2NhbnZhc19kcmF3X2FsbF9haXJjcmFmdCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhbiBhaXJjcmFmdCdzIGRhdGEgYmxvY2tcbiAgICAgKiAoYm94IHRoYXQgY29udGFpbnMgY2FsbHNpZ24sIGFsdGl0dWRlLCBzcGVlZClcbiAgICAgKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYW52YXNfZHJhd19pbmZvXG4gICAgICogQHBhcmFtIGNjXG4gICAgICogQHBhcmFtIGFpcmNyYWZ0XG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfaW5mbyhjYywgYWlyY3JhZnQpIHtcbiAgICAgICAgaWYgKCFhaXJjcmFmdC5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZmxpcCB0aGUgbG9naWMgaGVyZSBhbmQgcmV0dXJuIGVhcmx5IHRvIG1ha2UgY29kZSBtb3JlIHJlYWRhYmxlLlxuICAgICAgICBpZiAoIWFpcmNyYWZ0LmhpdCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBTZXR1cFxuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBjcyA9IGFpcmNyYWZ0LmdldENhbGxzaWduKCk7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nTFIgPSA1O1xuICAgICAgICAgICAgLy8gd2lkdGggb2YgZGF0YWJsb2NrIChzY2FsZXMgdG8gZml0IGNhbGxzaWduKVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjbGFtcCgxLCA1LjggKiBjcy5sZW5ndGgpICsgKHBhZGRpbmdMUiAqIDIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGgyID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgLy8gaGVpZ2h0IG9mIGRhdGFibG9ja1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gMzE7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQyID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIC8vIHdpZHRoIG9mIGNvbG9yZWQgYmFyXG4gICAgICAgICAgICBjb25zdCBiYXJfd2lkdGggPSB3aWR0aCAvIDE4O1xuICAgICAgICAgICAgY29uc3QgYmFyX3dpZHRoMiA9IGJhcl93aWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBJTFNfZW5hYmxlZCA9IGFpcmNyYWZ0LmZtcy5jdXJyZW50V2F5cG9pbnQucnVud2F5ICYmIGFpcmNyYWZ0LmNhdGVnb3J5ID09PSBGTElHSFRfQ0FURUdPUlkuQVJSSVZBTDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2tfc2l6ZSA9IGhlaWdodCAvIDM7XG4gICAgICAgICAgICBjb25zdCBsb2NrX29mZnNldCA9IGxvY2tfc2l6ZSAvIDg7XG4gICAgICAgICAgICBjb25zdCBwaSA9IE1hdGguUEk7XG4gICAgICAgICAgICBjb25zdCBwb2ludDEgPSBsb2NrX3NpemUgLSBiYXJfd2lkdGgyO1xuICAgICAgICAgICAgbGV0IGFsdF90cmVuZF9jaGFyID0gJyc7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQxIC0gbG9ja19vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBiID0gYmFyX3dpZHRoMjtcbiAgICAgICAgICAgIGNvbnN0IGNsaXBwaW5nX21hc2tfYW5nbGUgPSBNYXRoLmF0YW4oYiAvIGEpO1xuICAgICAgICAgICAgLy8gZGVzY3JpYmVzIGhvdyBmYXIgYXJvdW5kIHRvIGFyYyB0aGUgYXJtcyBvZiB0aGUgaWxzIGxvY2sgY2FzZVxuICAgICAgICAgICAgY29uc3QgcGlfc2xpY2UgPSBwaSAvIDI0O1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYWxtb3N0X21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENhbGxzaWduIE1hdGNoaW5nXG4gICAgICAgICAgICBpZiAocHJvcC5pbnB1dC5jYWxsc2lnbi5sZW5ndGggPiAxICYmIGFpcmNyYWZ0Lm1hdGNoQ2FsbHNpZ24ocHJvcC5pbnB1dC5jYWxsc2lnbi5zdWJzdHIoMCwgcHJvcC5pbnB1dC5jYWxsc2lnbi5sZW5ndGggLSAxKSkpIHtcbiAgICAgICAgICAgICAgICBhbG1vc3RfbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcC5pbnB1dC5jYWxsc2lnbi5sZW5ndGggPiAwICYmIGFpcmNyYWZ0Lm1hdGNoQ2FsbHNpZ24ocHJvcC5pbnB1dC5jYWxsc2lnbikpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjb2xvciwgaW50ZW5zaXR5LCBhbmQgc3R5bGUgZWxlbWVudHNcbiAgICAgICAgICAgIGxldCBhbHBoYSA9IDAuMjtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGFscGhhID0gMC45O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhaXJjcmFmdC5pbnNpZGVfY3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZiAoYWxtb3N0X21hdGNoKSB2YXIgYWxwaGEgPSAwLjc1O1xuICAgICAgICAgICAgICAgIGFscGhhID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZWQgPSBgcmdiYSgyMjQsIDEyOCwgMTI4LCAke2FscGhhfSlgO1xuICAgICAgICAgICAgY29uc3QgZ3JlZW4gPSBgcmdiYSggNzYsIDExOCwgOTcsICR7YWxwaGF9KWA7XG4gICAgICAgICAgICBjb25zdCBibHVlID0gYHJnYmEoMTI4LCAyNTUsIDI1NSwgJHthbHBoYX0pYDtcbiAgICAgICAgICAgIGNvbnN0IHdoaXRlID0gYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHthbHBoYX0pYDtcbiAgICAgICAgICAgIGNjLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIGNlbnRlciBvZiB3aGVyZSB0aGUgZGF0YSBibG9jayBpcyB0byBiZSBkcmF3blxuICAgICAgICAgICAgY29uc3QgYWNfcG9zID0gW1xuICAgICAgICAgICAgICAgIHJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoYWlyY3JhZnQucG9zaXRpb25bMF0pKSArIHRoaXMuY2FudmFzLnBhblgsXG4gICAgICAgICAgICAgICAgLXJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoYWlyY3JhZnQucG9zaXRpb25bMV0pKSArIHRoaXMuY2FudmFzLnBhbllcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIGdhbWUgd2lsbCBtb3ZlIEZEQiB0byB0aGUgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChhaXJjcmFmdC5kYXRhYmxvY2tEaXIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKC13aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGFpcmNyYWZ0LnBvc2l0aW9uWzFdKSArIHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0IC8gMiA8IGhlaWdodCAqIDEuNSkge1xuICAgICAgICAgICAgICAgICAgICBjYy50cmFuc2xhdGUoYWNfcG9zWzBdLCBhY19wb3NbMV0gKyBoZWlnaHQyICsgMTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNjLnRyYW5zbGF0ZShhY19wb3NbMF0sIGFjX3Bvc1sxXSAtIGhlaWdodDIgLSAxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHdhbnRzIHRvIHNwZWNpZnkgRkRCIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3RyOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIDM2MDogWzAsIC1oZWlnaHQyIC0gMTJdLFxuICAgICAgICAgICAgICAgICAgICA0NTogW3dpZHRoMiArIDguNSwgLWhlaWdodDIgLSA4LjVdLFxuICAgICAgICAgICAgICAgICAgICA5MDogW3dpZHRoMiArIGJhcl93aWR0aDIgKyAxMiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIDEzNTogW3dpZHRoMiArIDguNSwgaGVpZ2h0MiArIDguNV0sXG4gICAgICAgICAgICAgICAgICAgIDE4MDogWzAsIGhlaWdodDIgKyAxMl0sXG4gICAgICAgICAgICAgICAgICAgIDIyNTogWy13aWR0aDIgLSA4LjUsIGhlaWdodDIgKyA4LjVdLFxuICAgICAgICAgICAgICAgICAgICAyNzA6IFstd2lkdGgyIC0gYmFyX3dpZHRoMiAtIDEyLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgMzE1OiBbLXdpZHRoMiAtIDguNSwgLWhlaWdodDIgLSA4LjVdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNjLnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgYWNfcG9zWzBdICsgZGlzcGxhY2VtZW50c1thaXJjcmFmdC5kYXRhYmxvY2tEaXJdWzBdLFxuICAgICAgICAgICAgICAgICAgICBhY19wb3NbMV0gKyBkaXNwbGFjZW1lbnRzW2FpcmNyYWZ0LmRhdGFibG9ja0Rpcl1bMV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IGRhdGFibG9jayBzaGFwZXNcbiAgICAgICAgICAgIGlmICghSUxTX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBCb3hcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBncmVlbjtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGJveFxuICAgICAgICAgICAgICAgIGNjLmZpbGxSZWN0KC13aWR0aDIsIC1oZWlnaHQyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSAoYWlyY3JhZnQuY2F0ZWdvcnkgPT09IEZMSUdIVF9DQVRFR09SWS5ERVBBUlRVUkUpID8gYmx1ZSA6IHJlZDtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGNvbG9yZWQgYmFyXG4gICAgICAgICAgICAgICAgY2MuZmlsbFJlY3QoLXdpZHRoMiAtIGJhcl93aWR0aCwgLWhlaWdodDIsIGJhcl93aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm94IHdpdGggSUxTIExvY2sgSW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgY2Muc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBncmVlbiBwYXJ0IG9mIGJveCAoZXhjbHVkZXMgc3BhY2Ugd2hlcmUgSUxTIENsZWFyYW5jZSBJbmRpY2F0b3IganV0cyBpbilcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBncmVlbjtcbiAgICAgICAgICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjYy5tb3ZlVG8oLXdpZHRoMiwgaGVpZ2h0Mik7ICAvLyBib3R0b20tbGVmdCBjb3JuZXJcbiAgICAgICAgICAgICAgICBjYy5saW5lVG8od2lkdGgyLCBoZWlnaHQyKTsgICAvLyBib3R0b20tcmlnaHQgY29ybmVyXG4gICAgICAgICAgICAgICAgY2MubGluZVRvKHdpZHRoMiwgLWhlaWdodDIpOyAgLy8gdG9wLXJpZ2h0IGNvcm5lclxuICAgICAgICAgICAgICAgIGNjLmxpbmVUbygtd2lkdGgyLCAtaGVpZ2h0Mik7IC8vIHRvcC1sZWZ0IGNvcm5lclxuICAgICAgICAgICAgICAgIGNjLmxpbmVUbygtd2lkdGgyLCAtcG9pbnQxKTsgIC8vIGJlZ2luIHNpZGUgY3V0b3V0XG4gICAgICAgICAgICAgICAgY2MuYXJjKC13aWR0aDIgLSBiYXJfd2lkdGgyLCAtbG9ja19vZmZzZXQsIGxvY2tfc2l6ZSAvIDIgKyBiYXJfd2lkdGgyLCBjbGlwcGluZ19tYXNrX2FuZ2xlIC0gcGkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICBjYy5saW5lVG8oLXdpZHRoMiArIGxvY2tfc2l6ZSAvIDIsIGxvY2tfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjYy5hcmMoLXdpZHRoMiAtIGJhcl93aWR0aDIsIGxvY2tfb2Zmc2V0LCBsb2NrX3NpemUgLyAyICsgYmFyX3dpZHRoMiwgMCwgcGkgLyAyIC0gY2xpcHBpbmdfbWFza19hbmdsZSk7XG4gICAgICAgICAgICAgICAgY2MuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY2MuZmlsbCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBJTFMgQ2xlYXJhbmNlIEluZGljYXRvclxuICAgICAgICAgICAgICAgIGNjLnRyYW5zbGF0ZSgtd2lkdGgyIC0gYmFyX3dpZHRoMiwgMCk7XG4gICAgICAgICAgICAgICAgY2MubGluZVdpZHRoID0gYmFyX3dpZHRoO1xuICAgICAgICAgICAgICAgIGNjLnN0cm9rZVN0eWxlID0gcmVkO1xuICAgICAgICAgICAgICAgIGNjLmJlZ2luUGF0aCgpOyAvLyB0b3AgYXJjIHN0YXJ0XG4gICAgICAgICAgICAgICAgY2MuYXJjKDAsIC1sb2NrX29mZnNldCwgbG9ja19zaXplIC8gMiwgLXBpX3NsaWNlLCBwaSArIHBpX3NsaWNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjYy5tb3ZlVG8oMCwgLWxvY2tfc2l6ZSAvIDIpO1xuICAgICAgICAgICAgICAgIGNjLmxpbmVUbygwLCAtaGVpZ2h0Mik7XG4gICAgICAgICAgICAgICAgY2Muc3Ryb2tlKCk7IC8vIHRvcCBhcmMgZW5kXG4gICAgICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7IC8vIGJvdHRvbSBhcmMgc3RhcnRcbiAgICAgICAgICAgICAgICBjYy5hcmMoMCwgbG9ja19vZmZzZXQsIGxvY2tfc2l6ZSAvIDIsIHBpX3NsaWNlLCBwaSAtIHBpX3NsaWNlKTtcbiAgICAgICAgICAgICAgICBjYy5tb3ZlVG8oMCwgbG9ja19zaXplIC0gYmFyX3dpZHRoKTtcbiAgICAgICAgICAgICAgICBjYy5saW5lVG8oMCwgaGVpZ2h0Mik7XG4gICAgICAgICAgICAgICAgY2Muc3Ryb2tlKCk7ICAvLyBib3R0b20gYXJjIGVuZFxuXG4gICAgICAgICAgICAgICAgaWYgKGFpcmNyYWZ0Lm1vZGUgPT09IEZMSUdIVF9NT0RFUy5MQU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvY2FsaXplciBDYXB0dXJlIEluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgICAgICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGNjLmFyYygwLCAwLCBsb2NrX3NpemUgLyA1LCAwLCBwaSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICBjYy5maWxsKCk7IC8vIERyYXcgTG9jYWxpemVyIENhcHR1cmUgRG90XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2MudHJhbnNsYXRlKHdpZHRoMiArIGJhcl93aWR0aDIsIDApO1xuICAgICAgICAgICAgICAgIC8vIHVuY2xlYXIgaG93IHRoaXMgd29ya3MuLi5cbiAgICAgICAgICAgICAgICBjYy5iZWdpblBhdGgoKTsgLy8gaWYgcmVtb3ZlZCwgd2hpdGUgbGluZXMgYXBwZWFyIG9uIHRvcCBvZiBib3R0b20gaGFsZiBvZiBsb2NrIGNhc2VcbiAgICAgICAgICAgICAgICBjYy5zdHJva2UoKTsgLy8gaWYgcmVtb3ZlZCwgd2hpdGUgbGluZXMgYXBwZWFyIG9uIHRvcCBvZiBib3R0b20gaGFsZiBvZiBsb2NrIGNhc2VcblxuICAgICAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dFxuICAgICAgICAgICAgY29uc3QgZ2FwID0gMzsgICAgICAgICAgLy8gaGVpZ2h0IG9mIFRPVEFMIHZlcnRpY2FsIHNwYWNlIGJldHdlZW4gdGhlIHJvd3MgKDAgZm9yIHRvdWNoaW5nKVxuICAgICAgICAgICAgY29uc3QgbGluZWhlaWdodCA9IDQuNTsgLy8gaGVpZ2h0IG9mIHRleHQgcm93ICh1c2VkIGZvciBzcGFjaW5nIGJhc2lzKVxuICAgICAgICAgICAgY29uc3Qgcm93MXRleHQgPSBjcztcbiAgICAgICAgICAgIGNvbnN0IHJvdzJ0ZXh0ID0gYCR7bHBhZChyb3VuZChhaXJjcmFmdC5hbHRpdHVkZSAqIDAuMDEpLCAzKX0gJHtscGFkKHJvdW5kKGFpcmNyYWZ0Lmdyb3VuZFNwZWVkICogMC4xKSwgMil9YDtcblxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoZSBpZi9lbHNlIGluIGZhdm9yIG9mIGFuIGluaXRpYWwgYXNzaWdubWVudCwgYW5kIHVwZGF0ZSB3aXRoIGlmIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKGFpcmNyYWZ0Lmluc2lkZV9jdHIpIHtcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5XSElURV8wMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFpcmNyYWZ0LnRyZW5kID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc21hbGwgZGFzaCAoc3ltYm9sYSBmb250KVxuICAgICAgICAgICAgICAgIGFsdF90cmVuZF9jaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoMHgyMDExKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWlyY3JhZnQudHJlbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYWx0X3RyZW5kX2NoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDFGODUxKTsgLy8gdXAgYXJyb3cgKHN5bWJvbGEgZm9udClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWlyY3JhZnQudHJlbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgYWx0X3RyZW5kX2NoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCgweDFGODUzKTsgLy8gZG93biBhcnJvdyAoc3ltYm9sYSBmb250KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IGZ1bGwgZGF0YWJsb2NrIHRleHRcbiAgICAgICAgICAgIGNjLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIGNjLmZpbGxUZXh0KHJvdzF0ZXh0LCAtd2lkdGgyICsgcGFkZGluZ0xSLCAtZ2FwIC8gMiAtIGxpbmVoZWlnaHQpO1xuICAgICAgICAgICAgY2MuZmlsbFRleHQocm93MnRleHQsIC13aWR0aDIgKyBwYWRkaW5nTFIsIGdhcCAvIDIgKyBsaW5laGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIERyYXcgY2xpbWIvbGV2ZWwvZGVzY2VuZCBzeW1ib2xcbiAgICAgICAgICAgIGNjLmZvbnQgPSAnMTBweCBzeW1ib2xhJzsgLy8gY2hhbmdlIGZvbnQgdG8gdGhlIG9uZSB3aXRoIGV4dGVuZGVkIHVuaWNvZGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgY2MudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjYy5maWxsVGV4dChhbHRfdHJlbmRfY2hhciwgLXdpZHRoMiArIHBhZGRpbmdMUiArIDIwLjIsIGdhcCAvIDIgKyBsaW5laGVpZ2h0IC0gMC4yNSk7XG4gICAgICAgICAgICBjYy5mb250ID0gQkFTRV9DQU5WQVNfRk9OVDsgIC8vIGNoYW5nZSBiYWNrIHRvIG5vcm1hbCBmb250XG5cbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfYWxsX2luZm9cbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19hbGxfaW5mbyhjYykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3AuYWlyY3JhZnQubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19pbmZvKGNjLCBwcm9wLmFpcmNyYWZ0Lmxpc3RbaV0pO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19jb21wYXNzXG4gICAgICogQHBhcmFtIGNjXG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfY29tcGFzcyhjYykge1xuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICBjYWxjdWxhdGVNaWRkbGUodGhpcy5jYW52YXMuc2l6ZS53aWR0aCksXG4gICAgICAgICAgICBjYWxjdWxhdGVNaWRkbGUodGhpcy5jYW52YXMuc2l6ZS5oZWlnaHQpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBjb25zdCBzaXplID0gODA7XG4gICAgICAgIGNvbnN0IHNpemUyID0gc2l6ZSAvIDI7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSAxNjtcbiAgICAgICAgY29uc3QgZG90ID0gMTY7XG4gICAgICAgIGxldCB3aW5kc3BlZWRfbGluZTtcbiAgICAgICAgbGV0IGhpZ2h3aW5kO1xuXG4gICAgICAgIC8vIFNoaWZ0IGNvbXBhc3MgbG9jYXRpb25cbiAgICAgICAgY2MudHJhbnNsYXRlKC1zaXplMiAtIHBhZGRpbmcsIC1zaXplMiAtIHBhZGRpbmcpO1xuICAgICAgICBjYy5saW5lV2lkdGggPSA0O1xuXG4gICAgICAgIC8vIE91dGVyIGNpcmNsZVxuICAgICAgICBjYy5maWxsU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAwLjcpJztcbiAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNjLmFyYygwLCAwLCBzaXplMiwgMCwgdGF1KCkpO1xuICAgICAgICBjYy5maWxsKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgY2lyY2xlXG4gICAgICAgIGNjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYy5hcmMoMCwgMCwgZG90IC8gMiwgMCwgdGF1KCkpO1xuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5XSElURV8wNztcbiAgICAgICAgY2Muc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gV2luZCBWYWx1ZVxuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDc7XG4gICAgICAgIGNjLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjYy50ZXh0QmFzZWxpbmUgPSAnY2VudGVyJztcbiAgICAgICAgY2MuZm9udCA9ICc5cHggbW9ub09uZSwgbW9ub3NwYWNlJztcbiAgICAgICAgY2MuZmlsbFRleHQoYWlycG9ydC53aW5kLnNwZWVkLCAwLCAzLjgpO1xuICAgICAgICBjYy5mb250ID0gJ2JvbGQgMTBweCBtb25vT25lLCBtb25vc3BhY2UnO1xuXG4gICAgICAgIC8vIFdpbmQgbGluZVxuICAgICAgICBpZiAoYWlycG9ydC53aW5kLnNwZWVkID4gOCkge1xuICAgICAgICAgICAgd2luZHNwZWVkX2xpbmUgPSBhaXJwb3J0LndpbmQuc3BlZWQgLyAyO1xuICAgICAgICAgICAgaGlnaHdpbmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZHNwZWVkX2xpbmUgPSBhaXJwb3J0LndpbmQuc3BlZWQ7XG4gICAgICAgICAgICBoaWdod2luZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICBjYy50cmFuc2xhdGUoXG4gICAgICAgICAgICAtZG90IC8gMiAqIHNpbihhaXJwb3J0LndpbmQuYW5nbGUpLFxuICAgICAgICAgICAgZG90IC8gMiAqIGNvcyhhaXJwb3J0LndpbmQuYW5nbGUpXG4gICAgICAgICk7XG4gICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGNjLnJvdGF0ZShhaXJwb3J0LndpbmQuYW5nbGUpO1xuICAgICAgICBjYy5saW5lVG8oMCwgZXh0cmFwb2xhdGVfcmFuZ2VfY2xhbXAoMCwgd2luZHNwZWVkX2xpbmUsIDE1LCAwLCBzaXplMiAtIGRvdCkpO1xuXG4gICAgICAgIC8vIFRPRE86IHNpbXBsaWZ5LiByZXBsYWNlIHdpdGggaW5pdGlhbCBhc3NpZ25tZW50IGFuZCByZS1hc3NpZ25tZW50IGluIGlmIGNvbmRpdGlvblxuICAgICAgICAvLyBDb2xvciB3aW5kIGxpbmUgcmVkIGZvciBoaWdoLXdpbmRcbiAgICAgICAgaWYgKGhpZ2h3aW5kKSB7XG4gICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5CUklHSFRfUkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDc7XG4gICAgICAgIH1cblxuICAgICAgICBjYy5saW5lV2lkdGggPSAyO1xuICAgICAgICBjYy5zdHJva2UoKTtcbiAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEVfMDc7XG4gICAgICAgIGNjLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjYy50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuICAgICAgICBmb3IgKGxldCBpID0gOTA7IGkgPD0gMzYwOyBpICs9IDkwKSB7XG4gICAgICAgICAgICBjYy5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyg5MCkpO1xuXG4gICAgICAgICAgICBsZXQgYW5nbGU7XG4gICAgICAgICAgICBpZiAoaSA9PT0gOTApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGAwJHtpfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICAgICAgY2MuZmlsbFRleHQoYW5nbGUsIDAsIC1zaXplMiArIDQpO1xuICAgICAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBjaXJjdWxhciBhaXJzcGFjZSBib3JkZXJcbiAgICAgKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYW52YXNfZHJhd19jdHJcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19jdHIoY2MpIHtcbiAgICAgICAgLy8gRHJhdyBhIGdlbnRsZSBmaWxsIGNvbG9yIHdpdGggYm9yZGVyIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBhaXJwb3J0J3MgY3RyX3JhZGl1c1xuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5BSVJTUEFDRV9SQURJVVNfU1RST0tFO1xuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuQUlSU1BBQ0VfUkFESVVTX0ZJTEw7XG4gICAgICAgIGNjLmJlZ2luUGF0aCgpO1xuICAgICAgICBjYy5hcmMoMCwgMCwgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuY3RyX3JhZGl1cyAqIHByb3AudWkuc2NhbGUsIDAsIHRhdSgpKTtcbiAgICAgICAgY2MuZmlsbCgpO1xuICAgICAgICBjYy5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHBvbHlnb25hbCBhaXJzcGFjZSBib3JkZXJcbiAgICAgKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYW52YXNfZHJhd19haXJzcGFjZV9ib3JkZXJcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19haXJzcGFjZV9ib3JkZXIoY2MpIHtcbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuICAgICAgICBpZiAoIWFpcnBvcnQuYWlyc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzX2RyYXdfY3RyKGNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0eWxlXG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gQ09MT1JTLkFJUlNQQUNFX1JBRElVU19TVFJPS0U7XG4gICAgICAgIGNjLmZpbGxTdHlsZSA9IENPTE9SUy5BSVJTUEFDRV9SQURJVVNfRklMTDtcblxuICAgICAgICAvLyBkcmF3IGFpcnNwYWNlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWlycG9ydC5haXJzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9seSA9ICQubWFwKGFpcnBvcnQucGVyaW1ldGVyLnBvbHksICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzZWVtcyBzdHJhbmdlLiBhcmUgd2UgcmV0dXJuaW5nIGEgc2luZ2xlLWluZGV4IGFycmF5IGV2ZXJ5dGltZT8gd2hhdCBkb2VzIHYucG9zaXRpb24gbG9vayBsaWtlP1xuICAgICAgICAgICAgICAgIHJldHVybiBbdi5wb3NpdGlvbl07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5jYW52YXNfZHJhd19wb2x5KGNjLCBwb2x5KTtcbiAgICAgICAgICAgIGNjLmNsaXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfZmFuY3lfcmluZ3NcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gZml4X29yaWdpblxuICAgICAqIEBwYXJhbSBmaXgxXG4gICAgICogQHBhcmFtIGZpeDJcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd19mYW5jeV9yaW5ncyhjYywgZml4X29yaWdpbiwgZml4MSwgZml4Mikge1xuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IGFpcnBvcnQuZ2V0Rml4UG9zaXRpb24oZml4X29yaWdpbik7XG4gICAgICAgIGNvbnN0IGYxID0gYWlycG9ydC5nZXRGaXhQb3NpdGlvbihmaXgxKTtcbiAgICAgICAgY29uc3QgZjIgPSBhaXJwb3J0LmdldEZpeFBvc2l0aW9uKGZpeDIpO1xuICAgICAgICBjb25zdCBtaW5EaXN0ID0gTWF0aC5taW4oZGlzdGFuY2UyZChvcmlnaW4sIGYxKSwgZGlzdGFuY2UyZChvcmlnaW4sIGYyKSk7XG4gICAgICAgIGNvbnN0IGhhbGZQSSA9IE1hdGguUEkgLyAyO1xuICAgICAgICBjb25zdCBleHRlbmRfcmluZyA9IGRlZ3JlZXNUb1JhZGlhbnMoMTApO1xuICAgICAgICBjb25zdCBzdGFydF9hbmdsZSA9IE1hdGguYXRhbjIoZjFbMF0gLSBvcmlnaW5bMF0sIGYxWzFdIC0gb3JpZ2luWzFdKSAtIGhhbGZQSSAtIGV4dGVuZF9yaW5nO1xuICAgICAgICBjb25zdCBlbmRfYW5nbGUgPSBNYXRoLmF0YW4yKGYyWzBdIC0gb3JpZ2luWzBdLCBmMlsxXSAtIG9yaWdpblsxXSkgLSBoYWxmUEkgKyBleHRlbmRfcmluZztcbiAgICAgICAgY29uc3QgeCA9IHJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgob3JpZ2luWzBdKSkgKyB0aGlzLmNhbnZhcy5wYW5YO1xuICAgICAgICBjb25zdCB5ID0gLXJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgob3JpZ2luWzFdKSkgKyB0aGlzLmNhbnZhcy5wYW5ZO1xuICAgICAgICAvLyA1Tk0gPSA5LjI3a21cbiAgICAgICAgY29uc3QgcmFkaXVzID0gOS4yNztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjYy5hcmMoXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgobWluRGlzdCAtIChpICogcmFkaXVzKSksXG4gICAgICAgICAgICAgICAgc3RhcnRfYW5nbGUsIGVuZF9hbmdsZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfZW5nbV9yYW5nZV9yaW5nc1xuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIC8vIERyYXcgcmFuZ2UgcmluZ3MgZm9yIEVOR00gYWlycG9ydCB0byBhc3Npc3QgaW4gcG9pbnQgbWVyZ2VcbiAgICBjYW52YXNfZHJhd19lbmdtX3JhbmdlX3JpbmdzKGNjKSB7XG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjAwLCAyNTUsIDIwMCwgMC4zKSc7XG4gICAgICAgIGNjLnNldExpbmVEYXNoKFszLCA2XSk7XG5cbiAgICAgICAgdGhpcy5jYW52YXNfZHJhd19mYW5jeV9yaW5ncyhjYywgJ0JBVkFEJywgJ0dNNDI4JywgJ0dNNDMyJyk7XG4gICAgICAgIHRoaXMuY2FudmFzX2RyYXdfZmFuY3lfcmluZ3MoY2MsICdUSVRMQScsICdHTTQxOCcsICdHTTQyMicpO1xuICAgICAgICB0aGlzLmNhbnZhc19kcmF3X2ZhbmN5X3JpbmdzKGNjLCAnSU5TVVYnLCAnR000MDMnLCAnR000MTYnKTtcbiAgICAgICAgdGhpcy5jYW52YXNfZHJhd19mYW5jeV9yaW5ncyhjYywgJ1ZBTFBVJywgJ0dNNDEwJywgJ0dNNDAyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19yYW5nZV9yaW5nc1xuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X3JhbmdlX3JpbmdzKGNjKSB7XG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgLy8gY29udmVydCBpbnB1dCBwYXJhbSBmcm9tIG5tIHRvIGttXG4gICAgICAgIGNvbnN0IHJhbmdlUmluZ1JhZGl1cyA9IGttKGFpcnBvcnQucnJfcmFkaXVzX25tKTtcblxuICAgICAgICAvLyBGaWxsIHVwIGFpcnBvcnQncyBjdHJfcmFkaXVzIHdpdGggcmluZ3Mgb2YgdGhlIHNwZWNpZmllZCByYWRpdXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgKiByYW5nZVJpbmdSYWRpdXMgPCBhaXJwb3J0LmN0cl9yYWRpdXM7IGkrKykge1xuICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjYy5saW5ld2lkdGggPSAxO1xuICAgICAgICAgICAgY2MuYXJjKDAsIDAsIHJhbmdlUmluZ1JhZGl1cyAqIHByb3AudWkuc2NhbGUgKiBpLCAwLCB0YXUoKSk7XG4gICAgICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5BSVJTUEFDRV9SQU5HRV9SSU5HX0NPTE9SO1xuICAgICAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X3BvbHlcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKiBAcGFyYW0gcG9seVxuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X3BvbHkoY2MsIHBvbHkpIHtcbiAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgX2ZvckVhY2gocG9seSwgKHNpbmdsZVBvbHksIHYpID0+IHtcbiAgICAgICAgICAgIGNjLmxpbmVUbyhcbiAgICAgICAgICAgICAgICB3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHNpbmdsZVBvbHlbMF0pLFxuICAgICAgICAgICAgICAgIC13aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KHNpbmdsZVBvbHlbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgY2Muc3Ryb2tlKCk7XG4gICAgICAgIGNjLmZpbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENhbnZhc0NvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGNhbnZhc19kcmF3X3RlcnJhaW5cbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd190ZXJyYWluKGNjKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMuZHJhd190ZXJyYWluKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5XSElURV8wNDtcbiAgICAgICAgY2MuZmlsbFN0eWxlID0gQ09MT1JTLldISVRFXzAyO1xuICAgICAgICBjYy5saW5lV2lkdGggPSBjbGFtcCgwLjUsIChwcm9wLnVpLnNjYWxlIC8gMTApLCAyKTtcbiAgICAgICAgY2MubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbiAgICAgICAgbGV0IG1heF9lbGV2YXRpb24gPSAwO1xuXG4gICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgY2MudHJhbnNsYXRlKHRoaXMuY2FudmFzLnBhblgsIHRoaXMuY2FudmFzLnBhblkpO1xuXG4gICAgICAgICQuZWFjaChhaXJwb3J0LnRlcnJhaW4gfHwgW10sIChlbGV2YXRpb24sIHRlcnJhaW5MZXZlbCkgPT4ge1xuICAgICAgICAgICAgbWF4X2VsZXZhdGlvbiA9IE1hdGgubWF4KG1heF9lbGV2YXRpb24sIGVsZXZhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGByZ2JhKCR7cHJvcC51aS50ZXJyYWluLmNvbG9yc1tlbGV2YXRpb25dfSwgYDtcblxuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBgJHtjb2xvcn0gJHtwcm9wLnVpLnRlcnJhaW4uYm9yZGVyX29wYWNpdHl9KWA7XG4gICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBgJHtjb2xvcn0gJHtwcm9wLnVpLnRlcnJhaW4uZmlsbF9vcGFjaXR5fSlgO1xuXG4gICAgICAgICAgICBfZm9yRWFjaCh0ZXJyYWluTGV2ZWwsICh0ZXJyYWluR3JvdXApID0+IHtcbiAgICAgICAgICAgICAgICBjYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgIF9mb3JFYWNoKHRlcnJhaW5Hcm91cCwgKHRlcnJhaW5JdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGEgZm9yL2luPyBpcyBpdCBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgX2ZvckVhY2godGVycmFpbkl0ZW0sICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3NlIGVxdWFscyBpcyBpbXBvcnRhbnQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLm1vdmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weCh0ZXJyYWluSXRlbVtpbmRleF1bMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weCh0ZXJyYWluSXRlbVtpbmRleF1bMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY2MubGluZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgodGVycmFpbkl0ZW1baW5kZXhdWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weCh0ZXJyYWluSXRlbVtpbmRleF1bMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNjLmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjYy5zdHJva2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYy5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKG1heF9lbGV2YXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDEwO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLnNpemUud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0O1xuICAgICAgICBjb25zdCBib3hfd2lkdGggPSAzMDtcbiAgICAgICAgY29uc3QgYm94X2hlaWdodCA9IDU7XG5cbiAgICAgICAgY2MuZm9udCA9IEJBU0VfQ0FOVkFTX0ZPTlQ7XG4gICAgICAgIGNjLmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDEwMDA7IGkgPD0gbWF4X2VsZXZhdGlvbjsgaSArPSAxMDAwKSB7XG4gICAgICAgICAgICBjYy5zYXZlKCk7XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGUgY29vcmRpbmF0ZXMgZm9yIGV2ZXJ5IGJsb2NrIHRvIG5vdCB1c2UgdGhlc2UgWCAmIFkgdHdpY2UgaW4gcmVjdCBhbmQgdGV4dFxuICAgICAgICAgICAgLy8gLjUgaW4gWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgdXNlZCB0byBtYWtlIDFweCByZWN0YW5nbGUgZml0IGV4YWN0bHkgaW50byAxIHB4XG4gICAgICAgICAgICAvLyBhbmQgbm90IGJlIGJsdXJyZWRcbiAgICAgICAgICAgIGNjLnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB3aWR0aCAvIDIgLSAxNDAuNSAtIChtYXhfZWxldmF0aW9uIC0gaSkgLyAxMDAwICogKGJveF93aWR0aCArIDEpLFxuICAgICAgICAgICAgICAgIC1oZWlnaHQgLyAyICsgb2Zmc2V0ICsgMC41XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjYy5yZWN0KDAsIDAsIGJveF93aWR0aCAtIDEsIGJveF9oZWlnaHQpO1xuICAgICAgICAgICAgY2MuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSBtYXAsIHRlcnJhaW4gb2YgaGlnaGVyIGxldmVscyBoYXMgZmlsbCBvZiBhbGwgdGhlIGxvd2VyIGxldmVsc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBmaWxsIGl0IGJlbG93IGV4YWN0bHkgYXMgaW4gdGhlIG1hcFxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaTsgaiArPSAxMDAwKSB7XG4gICAgICAgICAgICAgICAgY2MuZmlsbFN0eWxlID0gYHJnYmEoJHtwcm9wLnVpLnRlcnJhaW4uY29sb3JzW2pdfSwgJHtwcm9wLnVpLnRlcnJhaW4uZmlsbF9vcGFjaXR5fSlgO1xuICAgICAgICAgICAgICAgIGNjLmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBgcmdiYSgke3Byb3AudWkudGVycmFpbi5jb2xvcnNbaV19LCAke3Byb3AudWkudGVycmFpbi5ib3JkZXJfb3BhY2l0eX0pYDtcbiAgICAgICAgICAgIGNjLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyB3cml0ZSBlbGV2YXRpb24gc2lnbnMgb25seSBmb3IgdGhlIG91dGVyIGVsZXZhdGlvbnNcbiAgICAgICAgICAgIGlmIChpID09PSBtYXhfZWxldmF0aW9uIHx8IGkgPT09IDEwMDApIHtcbiAgICAgICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEU7XG4gICAgICAgICAgICAgICAgY2MudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgY2MudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgY2MuZmlsbFRleHQoYCR7aX0nYCwgYm94X3dpZHRoIC8gMiArIDAuNSwgb2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNjLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfcmVzdHJpY3RlZFxuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X3Jlc3RyaWN0ZWQoY2MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcy5kcmF3X3Jlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gQ09MT1JTLlJFU1RSSUNURURfQUlSU1BBQ0VfU1RST0tFO1xuICAgICAgICBjYy5saW5lV2lkdGggPSBNYXRoLm1heChwcm9wLnVpLnNjYWxlIC8gMywgMik7XG4gICAgICAgIGNjLmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgY2MuZm9udCA9IEJBU0VfQ0FOVkFTX0ZPTlQ7XG5cbiAgICAgICAgY29uc3QgYWlycG9ydCA9IHdpbmRvdy5haXJwb3J0Q29udHJvbGxlci5haXJwb3J0X2dldCgpO1xuXG4gICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgY2MudHJhbnNsYXRlKHRoaXMuY2FudmFzLnBhblgsIHRoaXMuY2FudmFzLnBhblkpO1xuXG4gICAgICAgIF9mb3JFYWNoKGFpcnBvcnQucmVzdHJpY3RlZF9hcmVhcywgKGFyZWEpID0+IHtcbiAgICAgICAgICAgIGNjLmZpbGxTdHlsZSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc19kcmF3X3BvbHkoY2MsIGFyZWEuY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuUkVTVFJJQ1RFRF9BSVJTUEFDRV9GSUxMO1xuICAgICAgICAgICAgY2MudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjYy50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKGFyZWEuaGVpZ2h0ID09PSBJbmZpbml0eSA/ICdVTkwnIDogJ0ZMJyArIE1hdGguY2VpbChhcmVhLmhlaWdodCAvIDEwMDApICogMTApO1xuICAgICAgICAgICAgbGV0IGhlaWdodF9zaGlmdCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChhcmVhLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRfc2hpZnQgPSAtMTI7XG5cbiAgICAgICAgICAgICAgICBjYy5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgYXJlYS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICByb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGFyZWEuY2VudGVyWzBdKSksXG4gICAgICAgICAgICAgICAgICAgIC1yb3VuZCh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KGFyZWEuY2VudGVyWzFdKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYy5maWxsVGV4dChcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgcm91bmQod2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChhcmVhLmNlbnRlclswXSkpLFxuICAgICAgICAgICAgICAgIGhlaWdodF9zaGlmdCAtIHJvdW5kKHdpbmRvdy51aUNvbnRyb2xsZXIua21fdG9fcHgoYXJlYS5jZW50ZXJbMV0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfdmlkZW9NYXBcbiAgICAgKiBAcGFyYW0gY2NcbiAgICAgKi9cbiAgICBjYW52YXNfZHJhd192aWRlb01hcChjYykge1xuICAgICAgICBpZiAoIV9oYXMod2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCksICdtYXBzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNjLnN0cm9rZVN0eWxlID0gQ09MT1JTLlZJREVPX01BUF9TVFJPS0U7XG4gICAgICAgIGNjLmxpbmVXaWR0aCA9IHByb3AudWkuc2NhbGUgLyAxNTtcbiAgICAgICAgY2MubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjYy5mb250ID0gQkFTRV9DQU5WQVNfRk9OVDtcblxuICAgICAgICBjb25zdCBhaXJwb3J0ID0gd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCk7XG4gICAgICAgIGNvbnN0IG1hcCA9IGFpcnBvcnQubWFwcy5iYXNlO1xuXG4gICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgY2MudHJhbnNsYXRlKHRoaXMuY2FudmFzLnBhblgsIHRoaXMuY2FudmFzLnBhblkpO1xuXG4gICAgICAgIF9mb3JFYWNoKG1hcCwgKG1hcEl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGNjLm1vdmVUbyh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KG1hcEl0ZW1bMF0pLCAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChtYXBJdGVtWzFdKSk7XG4gICAgICAgICAgICAvLyBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNjLmxpbmVUbyh3aW5kb3cudWlDb250cm9sbGVyLmttX3RvX3B4KG1hcEl0ZW1bMl0pLCAtd2luZG93LnVpQ29udHJvbGxlci5rbV90b19weChtYXBJdGVtWzNdKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNjLnN0cm9rZSgpO1xuICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqIERyYXdzIGNyb3NzaGFpcnMgdGhhdCBwb2ludCB0byB0aGUgY3VycmVudGx5IHRyYW5zbGF0ZWQgbG9jYXRpb25cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgY2FudmFzX2RyYXdfY3Jvc3NoYWlyc1xuICAgICAqIEBwYXJhbSBjY1xuICAgICAqL1xuICAgIGNhbnZhc19kcmF3X2Nyb3NzaGFpcnMoY2MpIHtcbiAgICAgICAgY2Muc2F2ZSgpO1xuICAgICAgICBjYy5zdHJva2VTdHlsZSA9IENPTE9SUy5DUk9TU0hBSVJfU1RST0tFO1xuICAgICAgICBjYy5saW5lV2lkdGggPSAzO1xuICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgY2MubW92ZVRvKC0xMCwgMCk7XG4gICAgICAgIGNjLmxpbmVUbygxMCwgMCk7XG4gICAgICAgIGNjLnN0cm9rZSgpO1xuICAgICAgICBjYy5iZWdpblBhdGgoKTtcbiAgICAgICAgY2MubW92ZVRvKDAsIC0xMCk7XG4gICAgICAgIGNjLmxpbmVUbygwLCAxMCk7XG4gICAgICAgIGNjLnN0cm9rZSgpO1xuICAgICAgICBjYy5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBDYW52YXNDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjYW52YXNfZHJhd19kaXJlY3Rpb25zXG4gICAgICogQHBhcmFtIGNjXG4gICAgICovXG4gICAgY2FudmFzX2RyYXdfZGlyZWN0aW9ucyhjYykge1xuICAgICAgICBpZiAod2luZG93LmdhbWVDb250cm9sbGVyLmdhbWVfcGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhbGxzaWduID0gcHJvcC5pbnB1dC5jYWxsc2lnbi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoY2FsbHNpZ24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIHNlbGVjdGVkIGFpcmNyYWZ0LlxuICAgICAgICBjb25zdCBhaXJjcmFmdCA9IHByb3AuYWlyY3JhZnQubGlzdC5maWx0ZXIoKHApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwLmlzVmlzaWJsZSgpICYmIHAuZ2V0Q2FsbHNpZ24oKS50b1VwcGVyQ2FzZSgpID09PSBjYWxsc2lnbjtcbiAgICAgICAgfSlbMF07XG5cbiAgICAgICAgaWYgKCFhaXJjcmFmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy50b19jYW52YXNfcG9zKGFpcmNyYWZ0LnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcmVjdFBvcyA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgcmVjdFNpemUgPSBbdGhpcy5jYW52YXMuc2l6ZS53aWR0aCwgdGhpcy5jYW52YXMuc2l6ZS5oZWlnaHRdO1xuXG4gICAgICAgIGNjLnNhdmUoKTtcbiAgICAgICAgY2Muc3Ryb2tlU3R5bGUgPSBDT0xPUlMuTElHSFRfU0lMVkVSO1xuICAgICAgICBjYy5maWxsU3R5bGUgPSBDT0xPUlMuV0hJVEU7XG4gICAgICAgIGNjLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgICBmb3IgKGxldCBhbHBoYSA9IDA7IGFscGhhIDwgMzYwOyBhbHBoYSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBbXG4gICAgICAgICAgICAgICAgc2luKGRlZ3JlZXNUb1JhZGlhbnMoYWxwaGEpKSxcbiAgICAgICAgICAgICAgICAtY29zKGRlZ3JlZXNUb1JhZGlhbnMoYWxwaGEpKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgY29uc3QgcCA9IHBvc2l0aXZlX2ludGVyc2VjdGlvbl93aXRoX3JlY3QocG9zLCBkaXIsIHJlY3RQb3MsIHJlY3RTaXplKTtcblxuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrTGVuID0gKGFscGhhICUgNSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIChhbHBoYSAlIDEwID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDE2XG4gICAgICAgICAgICAgICAgICAgICAgICA6IDEyKVxuICAgICAgICAgICAgICAgICAgICA6IDhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtXZWlnaHQgPSAoYWxwaGEgJSAzMCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgOiAxXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gLW1hcmtMZW4gKiBkaXJbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSAtbWFya0xlbiAqIGRpclsxXTtcblxuICAgICAgICAgICAgICAgIGNjLmxpbmVXaWR0aCA9IG1hcmtXZWlnaHQ7XG4gICAgICAgICAgICAgICAgY2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY2MubW92ZVRvKHBbMF0sIHBbMV0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWFya1ggPSBwWzBdICsgZHg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya1kgPSBwWzFdICsgZHk7XG5cbiAgICAgICAgICAgICAgICBjYy5saW5lVG8obWFya1gsIG1hcmtZKTtcbiAgICAgICAgICAgICAgICBjYy5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSAlIDEwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNjLmZvbnQgPSAoYWxwaGEgJSAzMCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9sZCAxMHB4IG1vbm9PbmUsIG1vbm9zcGFjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogQkFTRV9DQU5WQVNfRk9OVCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9ICcnICsgYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGNjLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGNjLmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtYIC0gZGlyWzBdICogKHRleHRXaWR0aCAvIDIgKyA0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtZIC0gZGlyWzFdICogNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2MucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgQ2FudmFzQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgdG9fY2FudmFzX1xuICAgICAqIEBwYXJhbSBwb3Mge31cbiAgICAgKi9cbiAgICB0b19jYW52YXNfcG9zKHBvcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc2l6ZS53aWR0aCAvIDIgKyB0aGlzLmNhbnZhcy5wYW5YICsga20ocG9zWzBdKSxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNpemUuaGVpZ2h0IC8gMiArIHRoaXMuY2FudmFzLnBhblkgLSBrbShwb3NbMV0pXG4gICAgICAgIF07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ09NTUFORF9ERUZJTklUSU9OIH0gZnJvbSAnLi9jb21tYW5kRGVmaW5pdGlvbnMnO1xuXG4vKipcbiAqIEEgZGVmaW5pdGlvbiBvZiBhIHNwZWNpZmljIGNvbW1hbmQgYW5kIGl0J3MgYXJndW1lbnRzLlxuICpcbiAqIENvbmF0aW5zIGEgY29tbWFuZCBuYW1lLCB3aGljaCBtYXBzIDE6MSB3aXRoIGEgbmFtZSBkZWZpbmVkIGluIGBjb21tYW5kTWFwLmpzYCBhbmQgYGNvbW1hbmREZWZpbml0aW9ucy5qc2AuXG4gKiBDb21tYW5kcyBtYXkgaGF2ZSBhbiBhbGlhcyBvciBtYW55LCB3ZSBjYXJlIG9ubHkgYWJvdXQgdGhlIHJvb3QgY29tbWFuZC4gVGhlIGNvbW1hbmQgbWFwIHdpbGwgbWFwIGFueVxuICogYWxpYXMgdG8gYSByb290IGNvbW1hbmQgYW5kIHRoaXMgYENvbW1hbmRNb2RlbGAgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgdGhvc2Ugcm9vdCBjb21tYW5kcy4gSXQgaGFzXG4gKiBubyB3YXkgb2Yga25vd2luZyB3aGF0IHRoZSBvcmlnaW5hbCBhbGlhcyB3YXMsIGlmIG9uZSB3YXMgdXNlZC5cbiAqXG4gKiBFYWNoIGBDb21tYW5kTW9kZWxgIHdpbGwgYmUgZXhwZWN0ZWQgdG8gaGF2ZSwgYXQgYSBtaW5pbXVtLCBhIGBuYW1lYCBhbmQgYSBtYXRjaGluZyBgQ09NTUFORF9ERUZJTklUSU9OYC5cbiAqXG4gKiBAY2xhc3MgQ29tbWFuZE1vZGVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbW1hbmRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGZvciBDb21tYW5kTW9kZWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbW1hbmQgbmFtZSwgc2hvdWxkIG1hdGNoIGEgY29tbWFuZCBpbiB0aGUgQ09NTUFORFMgY29uc3RhbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBDT01NQU5EX0RFRklOSVRJT04gZm9yIHRoaXMgcGFydGljdWxhciBjb21tYW5kLlxuICAgICAgICAgKiB0aGlzIGdpdmVzIHVzIGFjY2VzcyB0byBib3RoIHRoZSBgdmFsaWRhdGVgIGFuZCBgcGFyc2VgIG1ldGhvZHNcbiAgICAgICAgICogdGhhdCBiZWxvbmcgdG8gdGhpcyBjb21tYW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTdG9yaW5nIHRoaXMgYXMgYSBjbGFzcyBwcm9wZXJ0eSBhbGxvd3MgdXMgdG8gZG8gdGhlIGxvb2t1cCBvbmNlXG4gICAgICAgICAqIGFuZCB0aGVuIG1ha2UgaXQgYXZhaWxhYmxlIHRvIHRoZSByZXN0IG9mIHRoZSBjbGFzcyBzbyBpdCBjYW5cbiAgICAgICAgICogYmUgcmVmZXJlbmNlZCB3aGVuIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9jb21tYW5kRGVmaW5pdGlvblxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tbWFuZERlZmluaXRpb24gPSBDT01NQU5EX0RFRklOSVRJT05bbmFtZV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxpc3Qgb2YgY29tbWFuZCBhcmd1bWVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogLSBhc3N1bWVkIHRvIGJlIHRoZSB0ZXh0IGNvbW1hbmQgbmFtZXNcbiAgICAgICAgICogLSBtYXkgYmUgZW1wdHksIGRlcGVuZGluZyBvbiB0aGUgY29tbWFuZFxuICAgICAgICAgKiAtIHNob3VsZCBvbmx5IGV2ZXIgYmUgc3RyaW5ncyBvbiBpbml0aWFsIHNldCBpbW1lZGlhdGVseSBhZnRlciBpbnN0YW50aWF0aW9uXG4gICAgICAgICAqIC0gd2lsbCBsYXRlciBiZSBwYXJzZWQgdmlhIHRoZSBgX2NvbW1hbmREZWZpbml0aW9uLnBhcnNlKClgIG1ldGhvZCB0byB0aGVcbiAgICAgICAgICogICBjb3JyZWN0IGRhdGEgdHlwZXMgYW5kIHNoYXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhcmdzXG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJncyA9IFtdO1xuXG4gICAgICAgIC8vIFRPRE86IG1heSBuZWVkIHRvIHRocm93IGhlcmUgaWYgYF9jb21tYW5kRGVmaW5pdGlvbmAgaXMgdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIFtuYW1lLCAuLi5hcmdzXVxuICAgICAqXG4gICAgICogV2UgdXNlIHRoaXMgc2hhcGUgc29sZWx5IHRvIG1hdGNoIHRoZSBleGlzdGluZyBhcGkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbmFtZUFuZEFyZ3NcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbmFtZUFuZEFyZ3MoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgICAgICAuLi50aGlzLmFyZ3NcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBpbml0aWFsIGFyZ3Mgb2ZmIHRvIHRoZSB2YWxpZGF0b3JcbiAgICAgKlxuICAgICAqIEBmb3IgQ29tbWFuZE1vZGVsXG4gICAgICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHZhbGlkYXRlQXJncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmREZWZpbml0aW9uLnZhbGlkYXRlKHRoaXMuYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgaW5pdGlhbCBhcmdzLCBzZXQgZnJvbSB0aGUgYENvbW1hbmRQYXJzZXJgIHJpZ2h0IGFmdGVyIGluc3RhbnRpYXRpb24sIG9mZiB0b1xuICAgICAqIHRoZSBwYXJzZXIgZm9yIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZm9yIENvbW1hbmRNb2RlbFxuICAgICAqIEBtZXRob2QgcGFyc2VBcmdzXG4gICAgICovXG4gICAgcGFyc2VBcmdzKCkge1xuICAgICAgICAvLyB0aGlzIGNvbXBsZXRlbHkgb3ZlcndyaXRlcyBjdXJyZW50IGFyZ3MuIHRoaXMgaXMgaW50ZW5kZWQgYmVjYXVzZSBhbGwgYXJncyBhcmUgcmVjZWl2ZWQgYXNcbiAgICAgICAgLy8gc3RyaW5ncyBidXQgY29uc3VtZWQgYXMgc3RyaW5ncywgbnVtYmVycyBvciBib29sZWFucy4gYW5kIHdoZW4gdGhlIGFyZ3MgYXJlIGluaXRpYWxseSBzZXRcbiAgICAgICAgLy8gdGhleSBtYXkgbm90IGFsbCBiZSBhdmFpbGFibGUgeWV0XG4gICAgICAgIHRoaXMuYXJncyA9IHRoaXMuX2NvbW1hbmREZWZpbml0aW9uLnBhcnNlKHRoaXMuYXJncyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IF9jb21wYWN0IGZyb20gJ2xvZGFzaC9jb21wYWN0JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX2hhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSAnbG9kYXNoL2lzU3RyaW5nJztcbmltcG9ydCBfbWFwIGZyb20gJ2xvZGFzaC9tYXAnO1xuaW1wb3J0IF90YWlsIGZyb20gJ2xvZGFzaC90YWlsJztcbmltcG9ydCBDb21tYW5kTW9kZWwgZnJvbSAnLi9Db21tYW5kTW9kZWwnO1xuaW1wb3J0IHsgdW5pY29kZVRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2dlbmVyYWxVdGlsaXRpZXMnO1xuaW1wb3J0IHtcbiAgICBTWVNURU1fQ09NTUFORFMsXG4gICAgQ09NTUFORF9NQVBcbn0gZnJvbSAnLi9jb21tYW5kTWFwJztcbmltcG9ydCB7IFJFR0VYIH0gZnJvbSAnLi4vY29uc3RhbnRzL2dsb2JhbENvbnN0YW50cyc7XG5cbi8qKlxuICogU3ltYm9sIHVzZWQgdG8gc3BsaXQgdGhlIGNvbW1hbmQgc3RyaW5nIGFzIGl0IGVudGVycyB0aGUgY2xhc3MuXG4gKlxuICogQHByb3BlcnR5IENPTU1BTkRfQVJHU19TRVBBUkFUT1JcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgQ09NTUFORF9BUkdTX1NFUEFSQVRPUiA9ICcgJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0YWtpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGAkY29tbWFuZElucHV0YCBhbmQgcGFyc2luZyBpdFxuICogb3V0IGludG8gY29tbWFuZHMgYW5kIGFyZ3VtZW50cy5cbiAqXG4gKiBFdmVyeXRoaW5nIHRoaXMgY2xhc3MgbmVlZHMgY29tZXMgaW4gYXMgYSBzaW5nbGUgc3RyaW5nIHByb3ZpZGVkIGJ5IGBJbnB1dENvbnRyb2xsZXIuaW5wdXRfcnVuKClgLlxuICogZXg6XG4gKiAtIGB0aW1ld2FycCA1MGBcbiAqIC0gYEFBNzc3IGZoIDAyNzAgZCAwNTAgc3AgMjAwYFxuICogLSBgQUE3NzcgaG9sZCBkdW1iYSBsZWZ0IDJtaW5gXG4gKlxuICogKipEaWZmZXJlbnRpYXRpb24gb2YgY29tbWFuZHMgYW5kIGFyZ3VtZW50cyBpcyBkZXRlcm1pbmllZCBieSBzcGxpdHRpbmcgdGhlIHN0cmluZyBvbiBhbiBlbXB0eSBzcGFjZS4gVGhpc1xuICogaXMgdmVyeSBpbXBvcnRhbnQsIHNvIGxlZ2FjeSBjb21tYW5kcyBkaWQgbm90IGhhdmUgc3BhY2VzIGJldHdlZW4gdGhlIGNvbW1hbmQgYW5kIGFyZ3VtZW50LiBXaXRoIHRoaXNcbiAqIGltcGxlbWVudGF0aW9uIF9ldmVyeV8gY29tbWFuZCBzaGFsbCBoYXZlIGEgc3BhY2UgYmV0d2VlbiBpdHNlbGYgYW5kIGl0J3MgYXJndW1lbnRzLioqXG4gKlxuICogQ29tbWFuZHMgYXJlIGJyb2tlbiBvdXQgaW50byB0d28gY2F0ZWdvcmllczogYFN5c3RlbWAgYW5kIGBUcmFuc21pdGAuXG4gKiAtIFN5c3RlbSBjb21tYW5kcyBhcmUgemVybyBvciBzaW5nbGUgYXJndW1lbnQgY29tbWFuZHMgdGhhdCBhcmUgdXNlZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYXBwXG4gKiAgIGl0c2xlZi4gVGhpbmdzIGxpa2UgYHRpbWV3YXJwYCBvciBgdHV0b3JpYWxgIGFyZSBleGFtcGxlcyBvZiBzeXN0ZW0gY29tbWFuZHMuXG4gKlxuICogLSBUcmFuc21pdCBjb21tYW5kcyBhcmUgaW5zdHJ1Y3Rpb25zIG1lYW50IGZvciBhIHNwZWNpZmljIGFpcmNyYWZ0IHdpdGhpbiB0aGUgY29udHJvbGxlZCBhaXJzcGFjZS5cbiAqICAgVGhlc2UgY29tbWFuZHMgY2FuIGhhdmUgemVybyB0byBtYW55IGFyZ3VtZW50cywgZGVwZW5kaW5nIG9uIHRoZSBjb21tYW5kLiBTb21lIGV4YW1wbGVzIG9mIHRyYW5zbWl0XG4gKiAgIGNvbW1hbmRzIGFyZSBgdG9gLCBgdGF4aWAsIGBob2xkYC5cbiAqXG4gKiBDb21tYW5kcyBnbyB0aHJvdWdoIGEgbGlmZWN5Y2xlIGFzIHRoZXkgbW92ZSBmcm9tIHJhdyB0byBwYXJzZWQ6XG4gKiAtIHVzZXIgdHlwZXMgY29tbWFuZCBhbmQgcHJlc3NlcyBlbnRlclxuICogLSBjb21tYW5kIHN0cmluZyBpcyBjYXB0dXJlZCB2aWEgaW5wdXQgdmFsdWUsIHRoZW4gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoaXMgY2xhc3NcbiAqIC0gZGV0ZXJtaW5lIGlmIGNvbW1hbmQgc3RyaW5nIGlzIGEgYFN5c3RlbSBDb21tYW5kYCBvciBgVHJhbnNtaXRgXG4gKiAtIGNyZWF0aW9uIG9mIGBDb21tYW5kTW9kZWxgIG9iamVjdHMgZm9yIGVhY2ggY29tbWFuZC9hcmdtZW50IGdyb3VwIGZvdW5kXG4gKiAtIHZhbGlkYXRlIGNvbW1hbmQgYXJndW1lbnRzIChudW1iZXIgb2YgYXJndW1lbnRzIGFuZCBkYXRhIHR5cGUpXG4gKiAtIHBhcnNlIGNvbW1hbmQgYXJndW1lbnRzXG4gKlxuICogQWxsIGF2YWlsYWJsZSBjb21tYW5kcyBhcmUgZGVmaW5lZCBpbiB0aGUgYGNvbW1hbmRNYXBgLiBUd28gdGVybXMgb2Ygbm90ZSBhcmUgYWxpYXMgYW5kIHJvb3QgY29tbWFuZC5cbiAqIFdlIHdvdWxkIGNhbGwgdGhlIGB0YWtlb2ZmYCBjb21tYW5kIGEgcm9vdCBjb21tYW5kIGFuZCBgdG9gIGFuZCBgY3RvYCBhbGlzZXMuIFRoZSByb290IGNvbW1hbmQgaXMgdGhlXG4gKiBvbmUgdGhhdCBzaGFyZXMgdGhlIHNhbWUga2V5IGFzIHRoZSBjb21tYW5kIGRlZmluaXRpb24gd2hpY2ggZ2l2ZXMgdXMgdGhlIGNvcnJlY3QgdmFsaWRhdG9yIGFuZCBwYXJzZXIuXG4gKiBUaGUgcm9vdCBjb21tYW5kIGlzIGFsc28gd2hhdCB0aGUgYEFpcmNyYWZ0SW5zdGFuY2VNb2RlbGAgaXMgZXhwZWN0aW5nIHdoZW4gaXQgcmVjZWl2ZXMgY29tbWFuZHNcbiAqIGZyb20gdGhlIGBJbnB1dENvbnRyb2xsZXJgLlxuICpcbiAqIEBjbGFzcyBDb21tYW5kUGFyc2VyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbW1hbmRQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBmb3IgQ29tbWFuZFBhcnNlclxuICAgICAqIEBwYXJhbSByYXdDb21tYW5kV2l0aEFyZ3Mge3N0cmluZ30gIHN0cmluZyBwcmVzZW50IGluIHRoZSBgJGNvbW1hbmRJbnB1dGAgd2hlbiB0aGUgdXNlciBwcmVzc2VkIGBlbnRlcmBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYXdDb21tYW5kV2l0aEFyZ3MgPSAnJykge1xuICAgICAgICBpZiAoIV9pc1N0cmluZyhyYXdDb21tYW5kV2l0aEFyZ3MpKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyLiBDb21tYW5kUGFyc2VyIGV4cGVjdHMgYSBzdHJpbmcgYnV0IHJlY2VpdmVkICR7dHlwZW9mIHJhd0NvbW1hbmRXaXRoQXJnc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21tYW5kIG5hbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQ291bGQgYmUgZWl0aGVyIFRyYW5zbWl0IG9yIGEgU3lzdGVtIGNvbW1hbmRcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBjb25zdW1lZCBieSB0aGUgYElucHV0Q29udHJvbGxlcmAgYWZ0ZXIgcGFyc2luZyBoZXJlIGFuZCBpcyB1c2VkIHRvXG4gICAgICAgICAqIGRldGVybWluZSB3aGF0IHRvIGRvIHdpdGggdGhlIHBhcnNlZCBjb21tYW5kKHMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWlyY3JhZnQgY2FsbHNpZ25cbiAgICAgICAgICpcbiAgICAgICAgICogdGhpcyBpcyBvcHRpb25hbCBhbmQgbm90IGluY2x1ZGVkIHdpdGggc3lzdGVtIGNvbW1hbmRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxzaWduID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgYENvbW1hbmRNb2RlbGAgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogRWFjaCBjb21tYW5kIGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBgQ29tbWFuZE1vZGVsYCwgZXZlbiBTeXN0ZW0gY29tbWFuZHMuIFRoaXMgcHJvdmlkZXNcbiAgICAgICAgICogYSBjb25zaXN0ZW50IGludGVyZmFjZSBmb3Igb2J0YWluaW5nIGNvbW1hbmRzIGFuZCBhcmd1bWVudHMgKHZpYSBnZXR0ZXIpIGFuZCBhbHNvXG4gICAgICAgICAqIGFsb293cyBmb3IgZWFzeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbGVnYWN5IEFQSSBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHthcnJheTxDb21tYW5kTW9kZWw+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21tYW5kTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2V4dHJhY3RDb21tYW5kc0FuZEFyZ3MocmF3Q29tbWFuZFdpdGhBcmdzLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBbY29tbWFuZE5hbWUsIC4uLmFyZ3NdXG4gICAgICpcbiAgICAgKiBXZSB1c2UgdGhpcyBzaGFwZSBzb2xlbHkgdG8gbWF0Y2ggdGhlIGV4aXN0aW5nIGFwaS5cbiAgICAgKlxuICAgICAqIFdoZW4gY29tbWFuZCBpcyBhIFN5c3RlbSBjb21tYW5kOlxuICAgICAqIC0gY29tbWFuZExpc3QgaXMgYXNzdW1lZCB0byBoYXZlIGEgbGVuZ3RoIG9uIDFcbiAgICAgKiAtIGNvbW1hbmRMaXN0WzBdLmFyZ3NbMF0gaXMgYXNzdW1lZCB0byBoYXZlIGEgc2luZ2xlIHN0cmluZyB2YWx1ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8YXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXQgYXJncygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZCAhPT0gU1lTVEVNX0NPTU1BTkRTLnRyYW5zbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTGlzdFswXS5hcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9tYXAodGhpcy5jb21tYW5kTGlzdCwgKGNvbW1hbmQpID0+IGNvbW1hbmQubmFtZUFuZEFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VwdCB0aGUgZW50aXJlIHN0cmluZyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IgYW5kIGF0dGVtcHQgdG8gYnJlYWsgaXQgdXAgaW50bzpcbiAgICAgKiAtIFN5c3RlbSBjb21tYW5kIGFuZCBpdHMgYXJndW1lbnRzXG4gICAgICogLSBUcmFuc21pdCBjb21tYW5kcyBhbmQgdGhpZXIgYXJndW1lbnRzXG4gICAgICpcbiAgICAgKiBAZm9yIENvbW1hbmRQYXJzZXJcbiAgICAgKiBAbWV0aG9kIF9leHRyYWN0Q29tbWFuZHNBbmRBcmdzXG4gICAgICogQHBhcmFtIHJhd0NvbW1hbmRXaXRoQXJncyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dHJhY3RDb21tYW5kc0FuZEFyZ3MocmF3Q29tbWFuZFdpdGhBcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRPckNhbGxzaWduSW5kZXggPSAwO1xuICAgICAgICBjb25zdCBjb21tYW5kQXJnU2VnbWVudHNXaXRoQ2FsbHNpZ24gPSByYXdDb21tYW5kV2l0aEFyZ3Muc3BsaXQoQ09NTUFORF9BUkdTX1NFUEFSQVRPUik7XG4gICAgICAgIGNvbnN0IGNhbGxzaWduT3JTeXN0ZW1Db21tYW5kTmFtZSA9IGNvbW1hbmRBcmdTZWdtZW50c1dpdGhDYWxsc2lnbltjb21tYW5kT3JDYWxsc2lnbkluZGV4XTtcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgYSBzbGljZSBvZiB0aGUgYXJyYXkgdGhhdCByZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgIGNvbnN0IGNvbW1hbmRBcmdTZWdtZW50cyA9IF90YWlsKGNvbW1hbmRBcmdTZWdtZW50c1dpdGhDYWxsc2lnbik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzU3lzdGVtQ29tbWFuZChjYWxsc2lnbk9yU3lzdGVtQ29tbWFuZE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWlsZFN5c3RlbUNvbW1hbmRNb2RlbChjb21tYW5kQXJnU2VnbWVudHNXaXRoQ2FsbHNpZ24pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWlsZFRyYW5zbWl0Q29tbWFuZE1vZGVscyhjYWxsc2lnbk9yU3lzdGVtQ29tbWFuZE5hbWUsIGNvbW1hbmRBcmdTZWdtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgYSBgQ29tbWFuZE1vZGVsYCBmb3IgYSBTeXN0ZW0gY29tbWFuZCB0aGVuIGFkZCB0aGF0IG1vZGVsIHRvIHRoZSBgY29tbWFuZExpc3RgXG4gICAgICpcbiAgICAgKiBAZm9yIENvbW1hbmRQYXJzZXJcbiAgICAgKiBAbWV0aG9kIF9idWlsZFN5c3RlbUNvbW1hbmRNb2RlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2J1aWxkU3lzdGVtQ29tbWFuZE1vZGVsKGNvbW1hbmRBcmdTZWdtZW50cykge1xuICAgICAgICBjb25zdCBjb21tYW5kSW5kZXggPSAwO1xuICAgICAgICBjb25zdCBhcmdJbmRleCA9IDE7XG4gICAgICAgIGNvbnN0IGNvbW1hbmROYW1lID0gY29tbWFuZEFyZ1NlZ21lbnRzW2NvbW1hbmRJbmRleF07XG4gICAgICAgIGNvbnN0IGNvbW1hbmRNb2RlbCA9IG5ldyBDb21tYW5kTW9kZWwoY29tbWFuZE5hbWUpO1xuICAgICAgICBjb21tYW5kTW9kZWwuYXJncy5wdXNoKGNvbW1hbmRBcmdTZWdtZW50c1thcmdJbmRleF0pO1xuXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmROYW1lO1xuICAgICAgICB0aGlzLmNvbW1hbmRMaXN0LnB1c2goY29tbWFuZE1vZGVsKTtcblxuICAgICAgICB0aGlzLl92YWxpZGF0ZUFuZFBhcnNlQ29tbWFuZEFyZ3VtZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGBDb21tYW5kTW9kZWxgIG9iamVjdHMgZm9yIGVhY2ggdHJhbnNtaXQgY29tbWFuZHMgdGhlbiBhZGQgdGhlbSB0byB0aGUgYGNvbW1hbmRMaXN0YFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRUcmFuc21pdENvbW1hbmRNb2RlbHMoY2FsbHNpZ25PclN5c3RlbUNvbW1hbmROYW1lLCBjb21tYW5kQXJnU2VnbWVudHMpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gU1lTVEVNX0NPTU1BTkRTLnRyYW5zbWl0O1xuICAgICAgICB0aGlzLmNhbGxzaWduID0gY2FsbHNpZ25PclN5c3RlbUNvbW1hbmROYW1lO1xuICAgICAgICB0aGlzLmNvbW1hbmRMaXN0ID0gdGhpcy5fYnVpbGRDb21tYW5kTGlzdChjb21tYW5kQXJnU2VnbWVudHMpO1xuXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQW5kUGFyc2VDb21tYW5kQXJndW1lbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9vcCB0aHJvdWdoIHRoZSBjb21tYW5kQXJnU2VnbWVudHMgYXJyYXkgYW5kIGVpdGhlciBjcmVhdGUgYSBuZXcgYENvbW1hbmRNb2RlbGAgb3IgYWRkXG4gICAgICogYXJndW1lbnRzIHRvIGEgYENvbW1hbmRNb2RlbGAuXG4gICAgICpcbiAgICAgKiBjb21tYW5kQXJnU2VnbWVudHMgd2lsbCBjb250YWluIGJvdGggY29tbWFuZHMgYW5kIGFyZ3VtZW50cyAodmVyeSBjb250cml2ZWQgZXhhbXBsZSk6XG4gICAgICogLSBgW2NtZCwgYXJnLCBhcmcsIGNtZCwgY21kLCBhcmcsIGFyZywgYXJnXWBcbiAgICAgKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGluZyB0aGF0XG4gICAgICogdGhlIGZpcnN0IGl0ZW0gaXQgcmVjZWl2ZXMsIHRoYXQgaXMgbm90IGEgc3BhY2UsIGlzIGEgY29tbWFuZC4gd2UgdGhlbiBwdXNoIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGFycmF5IGl0ZW0gdG8gdGhlIGFyZ3MgYXJyYXkgdW50aWwgd2UgZmluZCBhbm90aGVyIGNvbW1hbmQuIHRoZW4gd2UgcmVwZWF0IHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogdGhpcyBhbGxvd3MgdXMgdG8gY3JlYXRlIHNldmVyYWwgYENvbW1hbmRNb2RlbGAgd2l0aCBhcmd1bWVudHMgYW5kIG9ubHkgbG9vcCBvdmVyIHRoZW0gb25jZS5cbiAgICAgKlxuICAgICAqIEBmb3IgQ29tbWFuZFBhcnNlclxuICAgICAqIEBtZXRob2QgX2J1aWxkQ29tbWFuZExpc3RcbiAgICAgKiBAcGFyYW0gY29tbWFuZEFyZ1NlZ21lbnRzIHthcnJheTxzdHJpbmc+fVxuICAgICAqIEByZXR1cm4ge2FycmF5PENvbW1hbmRNb2RlbD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRDb21tYW5kTGlzdChjb21tYW5kQXJnU2VnbWVudHMpIHtcbiAgICAgICAgbGV0IGNvbW1hbmRNb2RlbDtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIHN0aWxsIGZlZWxzIGlja3kgYW5kIGNvdWxkIGJlIHNpbXBsaWZpZWQgc29tZSBtb3JlXG4gICAgICAgIGNvbnN0IGNvbW1hbmRMaXN0ID0gX21hcChjb21tYW5kQXJnU2VnbWVudHMsIChjb21tYW5kT3JBcmcpID0+IHtcbiAgICAgICAgICAgIGlmIChjb21tYW5kT3JBcmcgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChSRUdFWC5VTklDT0RFLnRlc3QoY29tbWFuZE9yQXJnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRTdHJpbmcgPSB1bmljb2RlVG9TdHJpbmcoY29tbWFuZE9yQXJnKTtcbiAgICAgICAgICAgICAgICBjb21tYW5kTW9kZWwgPSBuZXcgQ29tbWFuZE1vZGVsKENPTU1BTkRfTUFQW2NvbW1hbmRTdHJpbmddKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kTW9kZWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9oYXMoQ09NTUFORF9NQVAsIGNvbW1hbmRPckFyZykgJiYgIXRoaXMuX2lzQWxpYXNDb21tYW5kQW5BcmcoY29tbWFuZE1vZGVsLCBjb21tYW5kT3JBcmcpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZE1vZGVsID0gbmV3IENvbW1hbmRNb2RlbChDT01NQU5EX01BUFtjb21tYW5kT3JBcmddKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kTW9kZWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21tYW5kTW9kZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UndmUgbWFkZSBpdCBoZXJlIGFuZCBjb21tYW5kTW9kZWwgaXMgc3RpbGwgdW5kZWZpbmVkLCBhIGNvbW1hbmQgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWFuZE1vZGVsLmFyZ3MucHVzaChjb21tYW5kT3JBcmcpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIHJldHVybiBfY29tcGFjdChjb21tYW5kTGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgYWRkcmVzc2luZyBhIHZlcnkgc3BlY2lmaWMgc2l0dWF0aW9uXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjdXJyZW50IGNvbW1hbmQgaXMgYGhlYWRpbmdgIGFuZCBvbmUgb2YgdGhlIGFyZ3VtZW50cyBpcyBgbGAsIHRoZSBwYXJzZXIgaW50ZXJwcmV0c1xuICAgICAqIHRoZSBgbGAgYXMgYW5vdGhlciBjb21tYW5kLiBgbGAgaXMgYW4gYWxpYXMgZm9yIHRoZSBgbGFuZGAgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhhdCBhIGNvbW1hbmRTdHJpbmcgd2lsbCBsb29rIGxpa2U6XG4gICAgICogYEFBMzIxIHQgbCAwNDJgXG4gICAgICpcbiAgICAgKiBXZSBsb29rIGZvciB0aGUgYGhlYWRpbmdgIGNvbW1hbmQgYW5kIG5vIGV4aXN0aW5nIGFyZ3VtZW50cywgYXMgdGhlIGBsYCB3b3VsZCBiZWNvbWUgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgaW4gdGhpcyBzaXR1YXRpb24uXG4gICAgICpcbiAgICAgKiBAZm9yIENvbW1hbmRQYXJzZXJcbiAgICAgKiBAbWV0aG9kIF9pc0FsaWFzQ29tbWFuZEFuQXJnXG4gICAgICogQHBhcmFtIGNvbW1hbmRNb2RlbCB7Q29tbWFuZE1vZGVsfVxuICAgICAqIEBwYXJhbSBjb21tYW5kT3JBcmcge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc0FsaWFzQ29tbWFuZEFuQXJnKGNvbW1hbmRNb2RlbCwgY29tbWFuZE9yQXJnKSB7XG4gICAgICAgIGlmICghY29tbWFuZE1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZE1vZGVsLm5hbWUgPT09ICdoZWFkaW5nJyAmJiBjb21tYW5kTW9kZWwuYXJncy5sZW5ndGggPT09IDAgJiYgY29tbWFuZE9yQXJnID09PSAnbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZSBvZmYgdGhlIGBfdmFsaWRhdGVDb21tYW5kQXJndW1lbnRzYCBtZXRob2QgYW5kIHRocm93cyBhbnkgZXJyb3JzIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAZm9yIENvbW1hbmRQYXJzZXJcbiAgICAgKiBAbWV0aG9kIF92YWxpZGF0ZUFuZFBhcnNlQ29tbWFuZEFyZ3VtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQW5kUGFyc2VDb21tYW5kQXJndW1lbnRzKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gdGhpcy5fdmFsaWRhdGVDb21tYW5kQXJndW1lbnRzKCk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgX2ZvckVhY2godmFsaWRhdGlvbkVycm9ycywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGBDb21tYW5kTW9kZWxgIGluIHRoZSBgY29tbWFuZExpc3RgLCBmaXJzdCB2YWxpZGF0ZSBpdCdzIGFyZ3VtZW50c1xuICAgICAqIHRoZW4gcGFyc2UgdGhvc2UgYXJndW1lbnRzIGludG8gYSBjb25zdW1hYmxlIGFycmF5LlxuICAgICAqXG4gICAgICogQGZvciBDb21tYW5kUGFyc2VyXG4gICAgICogQG1ldGhvZCBfdmFsaWRhdGVDb21tYW5kQXJndW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVDb21tYW5kQXJndW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gX2NvbXBhY3QoX21hcCh0aGlzLmNvbW1hbmRMaXN0LCAoY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFzRXJyb3IgPSBjb21tYW5kLnZhbGlkYXRlQXJncygpO1xuXG4gICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IHJldHVybiBoZXJlIHNvIGFsbCB0aGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gYXQgb25jZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gd2l0aGluIHRoZSBjYWxsaW5nIG1ldGhvZFxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNFcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWFuZC5wYXJzZUFyZ3MoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRpb24gb2YgYm9vbGVhbiBsb2dpYyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgYGNhbGxzaWduT3JTeXN0ZW1Db21tYW5kTmFtZWBcbiAgICAgKiBpcyBpbiBmYWN0IGEgc3lzdGVtIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBmb3IgQ29tbWFuZFBhcnNlclxuICAgICAqIEBtZXRob2QgX2lzU3lzdGVtQ29tbWFuZFxuICAgICAqIEBwYXJhbSBjYWxsc2lnbk9yU3lzdGVtQ29tbWFuZE5hbWUge3N0cmluZ31cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc1N5c3RlbUNvbW1hbmQoY2FsbHNpZ25PclN5c3RlbUNvbW1hbmROYW1lKSB7XG4gICAgICAgIHJldHVybiBfaGFzKFNZU1RFTV9DT01NQU5EUywgY2FsbHNpZ25PclN5c3RlbUNvbW1hbmROYW1lKSAmJlxuICAgICAgICAgICAgY2FsbHNpZ25PclN5c3RlbUNvbW1hbmROYW1lICE9PSBTWVNURU1fQ09NTUFORFMudHJhbnNtaXQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNWYWxpZERpcmVjdGlvblN0cmluZyB9IGZyb20gJy4vYXJndW1lbnRWYWxpZGF0b3JzJztcbmltcG9ydCB7XG4gICAgY29udmVydFRvVGhvdXNhbmRzLFxuICAgIGNvbnZlcnRTdHJpbmdUb051bWJlclxufSBmcm9tICcuLi91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMnO1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHBvc3NpYmxlIHRoZSBob2xkIGNvbW1hbmQgYXJndW1lbnQgbmFtZXMuXG4gKlxuICogRW51bWVyYXRlZCBoZXJlIGJhc2UgdGhlc2UgbmFuZXMgYXJlIHNoYXJlZCBhY2Nyb3NzIHNldmVyYWwgZnVuY3Rpb25zIGFuZCB0aGlzXG4gKiBwcm92aWRlcyBhIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGguXG4gKlxuICogQHByb3BlcnR5IEhPTERfQ09NTUFORF9BUkdfTkFNRVNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgSE9MRF9DT01NQU5EX0FSR19OQU1FUyA9IHtcbiAgICBUVVJOX0RJUkVDVElPTjogJ3R1cm5EaXJlY3Rpb24nLFxuICAgIExFR19MRU5HVEg6ICdsZWdMZW5ndGgnLFxuICAgIEZJWF9OQU1FOiAnZml4TmFtZSdcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBmbGlnaHQgbGV2ZWwgYWx0aXR1ZGUgdG8gYSBudW1iZXIgaW4gdGhvdXNhbmRzIGFuZCBjb252ZXJ0cyBzZWNvbmQgYXJnIHRvIGEgYm9vbGVhblxuICpcbiAqIEBmdW5jdGlvbiBhbHRpdHVkZVBhcnNlclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7YXJyYXk8bnVtYmVyLCBib29sZWFuPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsdGl0dWRlUGFyc2VyID0gKGFyZ3MpID0+IHtcbiAgICBjb25zdCBhbHRpdHVkZSA9IGNvbnZlcnRUb1Rob3VzYW5kcyhhcmdzWzBdKTtcbiAgICAvLyB0aGUgdmFsaWRhdG9yIHdpbGwgaGF2ZSBhbHJlYWR5IGNhdWdodCBhbiBpbnZhbGlkIHZhbHVlIGhlcmUuIGlmIG9uZSBleGlzdHMsIGl0IGlzIGFzc3VtZWQgdG8gYmUgdmFsaWQgYW5kXG4gICAgLy8gdGh1cyB3ZSByZXR1cm4gdHJ1ZS4gb3RoZXJ3aXNlIGl0cyBmYWxzZVxuICAgIGNvbnN0IHNob3VsZEV4cGVkaXRlID0gdHlwZW9mIGFyZ3NbMV0gIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIFthbHRpdHVkZSwgc2hvdWxkRXhwZWRpdGVdO1xufTtcblxuLyoqXG4gKiBBY2NlcHRzIGEgZGlyZWN0aW9uIHN0cmluZzpcbiAqIC0gYGxlZnQgLyBsIC8gcmlnaHQgLyByYFxuICpcbiAqIGFuZCByZXR1cm5zIGBsZWZ0IC8gcmlnaHRgXG4gKlxuICogQGZ1bmN0aW9uIGRpcmVjdGlvbk5vcm1hbGl6ZXJcbiAqIEBwYXJhbSBkaXJlY3Rpb24ge3N0cmluZ31cbiAqIEByZXR1cm4gbm9ybWFsaXplZERpcmVjdGlvbiB7c3RyaW5nfVxuICovXG5jb25zdCBkaXJlY3Rpb25Ob3JtYWxpemVyID0gKGRpcmVjdGlvbikgPT4ge1xuICAgIGxldCBub3JtYWxpemVkRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2wnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWREaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyJykge1xuICAgICAgICBub3JtYWxpemVkRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZERpcmVjdGlvbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNvbnNpc3RlbnQgYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZSBubyBtYXR0ZXIgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAqXG4gKiBDb252ZXJ0cyBhIGZsaWdodCBsZXZlbCBhbHRpdHVkZSB0byBhIG51bWJlciBpbiB0aG91c2FuZHMgYW5kIGNvbnZlcnRzIHNlY29uZCBhcmcgdG8gYSBib29sZWFuXG4gKlxuICogQGZ1bmN0aW9uIGhlYWRpbmdQYXJzZXJcbiAqIEBwYXJhbSBhcmdzIHthcnJheX1cbiAqIEByZXR1cm4ge2FycmF5PHN0cmluZywgbnVtYmVyLCBib29sZWFuPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhlYWRpbmdQYXJzZXIgPSAoYXJncykgPT4ge1xuICAgIGxldCBkaXJlY3Rpb247XG4gICAgbGV0IGhlYWRpbmc7XG4gICAgbGV0IGlzSW5jcmVtZW50YWwgPSBmYWxzZTtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gZXhpc3RpbmcgYXBpIGlzIGV4cGV0aW5nIHVuZGVmaW5lZCB2YWx1ZXMgdG8gYmUgZXhhY3RseSBudWxsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaGVhZGluZyA9IGNvbnZlcnRTdHJpbmdUb051bWJlcihhcmdzWzBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtkaXJlY3Rpb24sIGhlYWRpbmcsIGlzSW5jcmVtZW50YWxdO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpc0luY3JlbWVudGFsID0gYXJnc1sxXS5sZW5ndGggPT09IDI7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb25Ob3JtYWxpemVyKGFyZ3NbMF0pO1xuICAgICAgICAgICAgaGVhZGluZyA9IGNvbnZlcnRTdHJpbmdUb051bWJlcihhcmdzWzFdKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtkaXJlY3Rpb24sIGhlYWRpbmcsIGlzSW5jcmVtZW50YWxdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY3VycmVkIHBhcnNpbmcgdGhlIEhlYWRpbmcgYXJndW1lbnRzJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdGVkIGJvb2xlYW4gbG9naWMgdXNlZCB0byBkZXRtaW5lIGlmIGEgc3RyaW5nIGNvbnRhaW5zIGBtaW5gIG9yIGBubWAuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgc3BlY2lmaWNhbGx5IHdpdGggdGhlIGBmaW5kSG9sZENvbW1hbmRCeVR5cGVgLlxuICpcbiAqIEBmdW5jdGlvbiBpc0xlZ0xlbmd0aEFyZ1xuICogQHBhcmFtIGFyZyB7c3RyaW5nfVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNMZWdMZW5ndGhBcmcgPSAoYXJnKSA9PiBhcmcuaW5kZXhPZignbWluJykgIT09IC0xIHx8IGFyZy5pbmRleE9mKCdubScpICE9PSAtMTtcblxuLyoqXG4gKiBHaXZlbiBhIHR5cGUgYW5kIGFuIGFyZ3VtZW50IGxpc3QsIGZpbmQgdGhlIGZpcnN0IG9jY3VyYW5jZSBvZiBgdHlwZWAgZnJvbSB3aXRoaW4gdGhlIGFyZ3VtZW50IGxpc3QuXG4gKlxuICogV2UgYXJlIGxvb2tpbmcgZm9yIG9uZSBvZiB0aHJlZSB0aGluZ3MgaGVyZTpcbiAqIC0gYHR1cm5EaXJlY3Rpb25gIC0gYSB2YXJpYXRpb24gb2YgbGVmdCBvciByaWdodFxuICogLSBgbGVnTGVuZ3RoYCAtIGxlbmd0aCBvZiBob2xkIGxlZyBpbiBlaXRoZXIgbWludXRlcyAobWluKSBvciBuYXV0aWNhbCBtaWxlcyAobm0pXG4gKiAtIGBmaXhOYW1lYCAtIGFzc3VtZWQgdG8gYmUgYSBzdHJpbmcgdGhhdCBpc24ndCBhIGB0dXJuRGlyZWN0aW9uYCBvciBgbGVnTGVuZ3RoYC4gVGhlIHBhcnNlciBoYXMgbm8gd2F5IG9mXG4gKiAgICAgICAgICAgICAgIGtub3dpbmcgaWYgYSBjZXJ0YWluIHN0cmluZyBpcyBhbiBhY3R1YWwgYGZpeE5hbWVgLiBXZSBjYW4gb25seSBkZXRlcm1pbmUgdGhhdCBpdCBpc24ndCBhXG4gKiAgICAgICAgICAgICAgIGB0dXJuRGlyZWN0aW9uYCBvciBgbGVnTGVuZ3RoYC4gVGhpcyB3aWxsIGVycm9yIGZyb20gd2l0aGluIHRoZSBgcnVuSG9sZGAgbWV0aG9kIGlmIHRoZVxuICogICAgICAgICAgICAgICBgZml4TmFtZWAgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBmdW5jdGlvbiBmaW5kSG9sZENvbW1hbmRCeVR5cGVcbiAqIEBwYXJhbSB0eXBlIHtIT0xEX0NPTU1BTkRfQVJHX05BTUVTfVxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kSG9sZENvbW1hbmRCeVR5cGUgPSAodHlwZSwgYXJncykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBIT0xEX0NPTU1BTkRfQVJHX05BTUVTLlRVUk5fRElSRUNUSU9OOlxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZERpcmVjdGlvblN0cmluZyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb25Ob3JtYWxpemVyKGFyZyk7XG4gICAgICAgICAgICBjYXNlIEhPTERfQ09NTUFORF9BUkdfTkFNRVMuTEVHX0xFTkdUSDpcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGVnTGVuZ3RoQXJnKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIGNhc2UgSE9MRF9DT01NQU5EX0FSR19OQU1FUy5GSVhfTkFNRTpcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZERpcmVjdGlvblN0cmluZyhhcmcpIHx8IGlzTGVnTGVuZ3RoQXJnKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogVGhlIGBob2xkYCBjb21tYW5kIGFjY2VwdHMgYXJndW1lbnRzIGluIGFueSBvcmRlciB0aHVzLCB3ZSB1c2UgdGhlIGBmaW5kSG9sZENvbW1hbmRCeVR5cGVgIGhlbHBlclxuICogbWV0aG9kIHRvIGRvIHRoYXQgZm9yIHVzLiBUaGlzIHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRwIGZpbmQgdGhlIGNvcnJlY3QgYXJndW1lbnQsIG5vIG1hdHRlciB0aGUgb3JkZXIsXG4gKiBhbmQgY29uc2lzdGVudGx5IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBzaGFwZS5cbiAqXG4gKiBAZnVuY3Rpb24gaG9sZFBhcnNlclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7YXJyYXk8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhvbGRQYXJzZXIgPSAoYXJncykgPT4ge1xuICAgIC8vIGV4aXN0aW5nIGFwaSBpcyBleHBldGluZyB1bmRlZmluZWQgdmFsdWVzIHRvIGJlIGV4YWN0bHkgbnVsbFxuICAgIGNvbnN0IGZpeE5hbWUgPSBmaW5kSG9sZENvbW1hbmRCeVR5cGUoSE9MRF9DT01NQU5EX0FSR19OQU1FUy5GSVhfTkFNRSwgYXJncyk7XG4gICAgY29uc3QgdHVybkRpcmVjdGlvbiA9IGZpbmRIb2xkQ29tbWFuZEJ5VHlwZShIT0xEX0NPTU1BTkRfQVJHX05BTUVTLlRVUk5fRElSRUNUSU9OLCBhcmdzKTtcbiAgICBjb25zdCBsZWdMZW5ndGggPSBmaW5kSG9sZENvbW1hbmRCeVR5cGUoSE9MRF9DT01NQU5EX0FSR19OQU1FUy5MRUdfTEVOR1RILCBhcmdzKTtcblxuICAgIHJldHVybiBbdHVybkRpcmVjdGlvbiwgbGVnTGVuZ3RoLCBmaXhOYW1lXTtcbn07XG4iLCJpbXBvcnQgX2lzTmFOIGZyb20gJ2xvZGFzaC9pc05hTic7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJ2xvZGFzaC9pc1N0cmluZyc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoL2ZvckVhY2gnO1xuaW1wb3J0IHsgY29udmVydFN0cmluZ1RvTnVtYmVyIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IEVYUEVESVRFIH0gZnJvbSAnLi9jb21tYW5kTWFwJztcbmltcG9ydCB7IEVSUk9SX01FU1NBR0UgfSBmcm9tICcuL2NvbW1hbmRQYXJzZXJNZXNzYWdlcyc7XG5cbi8qKlxuICogQ2hlY2sgdGhhdCBgYXJnc2AgaGFzIGV4YWN0bHkgemVybyB2YWx1ZXNcbiAqXG4gKiBAZnVuY3Rpb24gemVyb0FyZ3VtZW50c1ZhbGlkYXRvclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHplcm9Bcmd1bWVudHNWYWxpZGF0b3IgPSAoYXJncyA9IFtdKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBFUlJPUl9NRVNTQUdFLlpFUk9fQVJHX0xFTkdUSDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IGBhcmdzYCBoYXMgZXhhY3RseSBvbmUgdmFsdWVcbiAqXG4gKiBAZnVuY3Rpb24gc2luZ2xlQXJndW1lbnRWYWxpZGF0b3JcbiAqIEBwYXJhbSBhcmdzIHthcnJheX1cbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzaW5nbGVBcmd1bWVudFZhbGlkYXRvciA9IChhcmdzID0gW10pID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuU0lOR0xFX0FSR19MRU5HVEg7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBgYXJnc2AgaGFzIGV4YWN0bHkgemVybyBvciBvbmUgdmFsdWVcbiAqXG4gKiBAZnVuY3Rpb24gemVyb09yT25lQXJndW1lbnRWYWxpZGF0b3JcbiAqIEBwYXJhbSBhcmdzIHthcnJheX1cbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBjb25zdCB6ZXJvT3JPbmVBcmd1bWVudFZhbGlkYXRvciA9IChhcmdzID0gW10pID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiBFUlJPUl9NRVNTQUdFLlpFUk9fT1JfT05FX0FSR19MRU5HVEg7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBgYXJnc2AgaGFzIGV4YWN0bHkgb25lIG9yIHR3byB2YWx1ZXNcbiAqXG4gKiBAZnVuY3Rpb24gb25lT3JUd29Bcmd1bWVudFZhbGlkYXRvclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IG9uZU9yVHdvQXJndW1lbnRWYWxpZGF0b3IgPSAoYXJncyA9IFtdKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMSB8fCBhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuT05FX09SX1RXT19BUkdfTEVOR1RIO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYGFyZ3NgIGhhcyBleGFjdGx5IG9uZSwgdHdvIG9yIHRocmVlIHZhbHVlc1xuICpcbiAqIEBmdW5jdGlvbiBvbmVUb1RocmVlQXJndW1lbnRzVmFsaWRhdG9yXG4gKiBAcGFyYW0gYXJncyB7YXJyYXl9XG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3Qgb25lVG9UaHJlZUFyZ3VtZW50c1ZhbGlkYXRvciA9IChhcmdzID0gW10pID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgIHJldHVybiBFUlJPUl9NRVNTQUdFLk9ORV9UT19USFJFRV9BUkdfTEVOR1RIO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYGFyZ3NgIGhhcyBleGFjdGx5IG9uZSBvciB0aHJlZSB2YWx1ZXNcbiAqXG4gKiBAZnVuY3Rpb24gb25lT3JUaHJlZUFyZ3VtZW50c1ZhbGlkYXRvclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGNvbnN0IG9uZU9yVGhyZWVBcmd1bWVudHNWYWxpZGF0b3IgPSAoYXJncyA9IFtdKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxICYmIGFyZ3MubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBFUlJPUl9NRVNTQUdFLk9ORV9PUl9USFJFRV9BUkdfTEVOR1RIO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYXJncyBpcyB0aGUgcmVxdWlyZWQgbGVuZ3RoIGFuZCB0aGUgZGF0YSBpcyBvZiB0aGUgY29ycmVjdCB0eXBlXG4gKlxuICogYGBgXG4gKiBBbGxvd2VkIGFyZ3VtZW50IHNoYXBlczpcbiAqIC0gWycwMzAnXVxuICogLSBbJzAzMCcsICdleHBlZGl0ZSddXG4gKiAtIFsnMDMwJywgJ3gnXVxuICogYGBgXG4gKlxuICogQGZ1bmN0aW9uIGFsdGl0dWRlVmFsaWRhdG9yXG4gKiBAcGFyYW0gYXJncyB7YXJyYXl9XG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgYWx0aXR1ZGVWYWxpZGF0b3IgPSAoYXJncyA9IFtdKSA9PiB7XG4gICAgY29uc3QgaGFzTGVuZ3RoRXJyb3IgPSBvbmVPclR3b0FyZ3VtZW50VmFsaWRhdG9yKGFyZ3MpO1xuXG4gICAgaWYgKGhhc0xlbmd0aEVycm9yKSB7XG4gICAgICAgIHJldHVybiBoYXNMZW5ndGhFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIgJiYgRVhQRURJVEUuaW5kZXhPZihhcmdzWzFdKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuQUxUSVRVREVfRVhQRURJVEVfQVJHO1xuICAgIH1cbn07XG5cbi8qKlxuICogVmVyaWZpZXMgYSBsaXN0IG9mIGZpeCBuYW1lcyBhcmUgYWxsIHN0cmluZ3MgYW5kIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKlxuICogQGZ1bmN0aW9uIGZpeFZhbGlkYXRvclxuICogQHBhcmFtIGFyZ3Mge2FycmF5fVxuICogQHJldHVybiB7YXJyYXk8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZpeFZhbGlkYXRvciA9IChhcmdzID0gW10pID0+IHtcbiAgICBsZXQgaGFzVHlwZUVycm9yO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gRVJST1JfTUVTU0FHRS5PTkVfT1JfTU9SRV9BUkdfTEVOR1RIO1xuICAgIH1cblxuICAgIF9mb3JFYWNoKGFyZ3MsIChhcmcpID0+IHtcbiAgICAgICAgaWYgKCFfaXNTdHJpbmcoYXJnKSAmJiAhaGFzVHlwZUVycm9yKSB7XG4gICAgICAgICAgICBoYXNUeXBlRXJyb3IgPSBFUlJPUl9NRVNTQUdFLk1VU1RfQkVfU1RSSU5HO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzVHlwZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBoYXNUeXBlRXJyb3I7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgb25lIG9mIGBsZWZ0IC8gbCAvIHJpZ2h0IC8gcmBcbiAqXG4gKiBAZnVuY3Rpb24gaXNWYWxpZERpcmVjdGlvblN0cmluZ1xuICogQHBhcmFtIHZhbHVlIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZERpcmVjdGlvblN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ2xlZnQnIHx8XG4gICAgICAgIHZhbHVlID09PSAnbCcgfHxcbiAgICAgICAgdmFsdWUgPT09ICdyaWdodCcgfHxcbiAgICAgICAgdmFsdWUgPT09ICdyJztcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYXJncyBpcyB0aGUgcmVxdWlyZWQgbGVuZ3RoIGFuZCB0aGUgZGF0YSBpcyBvZiB0aGUgY29ycmVjdCB0eXBlIGZvciB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICpcbiAqIGBgYFxuICogQWxsb3dlZCBhcmd1bWVudHMgc2hhcGVzOlxuICogLSBbJzE4MCddXG4gKiAtIFsnbGVmdCcsICcxODAnXVxuICogLSBbJ2wnLCAnMTgwJ11cbiAqIC0gWydsZWZ0JywgJzgwJ11cbiAqIC0gWydsJywgJzgwJ11cbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvbiBoZWFkaW5nVmFsaWRhdG9yXG4gKiBAcGFyYW0gYXJncyB7YXJyYXl9XG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgY29uc3QgaGVhZGluZ1ZhbGlkYXRvciA9IChhcmdzID0gW10pID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBjb25zdCBoYXNMZW5ndGhFcnJvciA9IG9uZU9yVHdvQXJndW1lbnRWYWxpZGF0b3IoYXJncyk7XG4gICAgbGV0IG51bWJlckZyb21TdHJpbmc7XG5cbiAgICBpZiAoaGFzTGVuZ3RoRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGhhc0xlbmd0aEVycm9yO1xuICAgIH1cblxuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIG51bWJlckZyb21TdHJpbmcgPSBjb252ZXJ0U3RyaW5nVG9OdW1iZXIoYXJnc1swXSk7XG5cbiAgICAgICAgICAgIGlmIChfaXNOYU4obnVtYmVyRnJvbVN0cmluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRVJST1JfTUVTU0FHRS5IRUFESU5HX01VU1RfQkVfTlVNQkVSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbnVtYmVyRnJvbVN0cmluZyA9IGNvbnZlcnRTdHJpbmdUb051bWJlcihhcmdzWzFdKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRGlyZWN0aW9uU3RyaW5nKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuSU5WQUxJRF9ESVJFQ1RJT05fU1RSSU5HO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyRnJvbVN0cmluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRVJST1JfTUVTU0FHRS5IRUFESU5HX01VU1RfQkVfTlVNQkVSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZGVmYXVsdCBjYXNlIGlzIGluY2x1ZGVkIG9ubHkgZm9yIHNlbXRhbnRpY3MsIHRoaXMgc2hvdWxkIG5vdCBldmVyIGJlIHJlYWNoYWJsZVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY3VycmVkIHBhcnNpbmcgdGhlIEhlYWRpbmcgYXJndW1lbnRzJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBhcmdzIGlzIHRoZSByZXF1aXJlZCBsZW5ndGggYW5kIHRoZSBkYXRhIGlzIG9mIHRoZSBjb3JyZWN0IHR5cGVcbiAqXG4gKiBgYGBcbiAqIEFsbG93ZWQgYXJndW1lbnQgc2hhcGVzOlxuICogLSBbJ2R1bWJhJ11cbiAqIC0gWydkdW1iYScsICdsZWZ0JywgJzJtaW4nXVxuICogLSBbJ2R1bWJhJywgJ2xlZnQnLCAnMm5tJ11cbiAqIC0gWydkdW1iYScsICdyaWdodCcsICcybWluJ11cbiAqIC0gWydkdW1iYScsICdyaWdodCcsICcybm0nXVxuICogYGBgXG4gKlxuICogQGZ1bmN0aW9uIGhvbGRWYWxpZGF0b3JcbiAqIEBwYXJhbSBhcmdzIHthcnJheX1cbiAqIEByZXR1cm4ge2FycmF5PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBob2xkVmFsaWRhdG9yID0gKGFyZ3MgPSBbXSkgPT4ge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuWkVST19UT19USFJFRV9BUkdfTEVOR1RIO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIV9pc1N0cmluZyhhcmdzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIEVSUk9SX01FU1NBR0UuTVVTVF9CRV9TVFJJTkc7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4gKiBSb290IGNvbW1hbmRzIGRlZmluZWQgaW4gdGhlIGBjb21tYW5kTWFwYCBoYXZlIGEgbWF0Y2hpbmcgZGVmaW5pdGlvbiBkZWZpbmVkIGhlcmUuIFRoaXMgZGVmaW5pdGlvblxuICogZ2l2ZSB1cyBhY2Nlc3MgdG8gdmFpbGRhdGUgYW5kIHBhcnNlIGZ1bmN0aW9ucy4gU29tZSBjb21tYW5kcyBkb24ndCByZXF1aXJlIGVpdGhlciBmdW5jdGlvbiBhbmQgc2ltcGx5XG4gKiBwYXNzIHRoZSBhcmd1bWVudHMgdGhyb3VnaCB2aWEgYG5vb3BgLiBPdGhlciBjb21tYW5kcyBjb21tYW5kcyBoYXZlIHZlcnkgdW5pcXVlIGRlbWFuZHMgZm9yIGhvd1xuICogYXJndW1lbnRzIGFyZSBmb3JtYXR0ZWQsIHRoZXNlIGZ1bmN0aW9ucyBsZXQgdXMgdmFsaWRhdGUgYW5kIHBhcnNlIG9uIGEgY2FzZSBieSBjYXNlIGJhc2lzLlxuICpcbiAqIEtleXMgYXJlIGxvd2VyY2FzZWQgaGVyZSBzbyB0aGV5IGNhbiBiZSBhY2Nlc3NlZCBwcm9ncmFtYXRpY2FsbHkgdXNpbmcgaW5wdXQgc3RyaW5nIHNlZ21lbnRzXG4gKiB0aGF0IGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGZvciBlYXNlIG9mIGNvbXBhcmlzb24uXG4gKlxuICogQGZpbGVvdmVydmlld1xuICovXG5pbXBvcnQge1xuICAgIGNvbnZlcnRUb1Rob3VzYW5kcyxcbiAgICBjb252ZXJ0U3RyaW5nVG9OdW1iZXJcbn0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7XG4gICAgemVyb0FyZ3VtZW50c1ZhbGlkYXRvcixcbiAgICBzaW5nbGVBcmd1bWVudFZhbGlkYXRvcixcbiAgICB6ZXJvT3JPbmVBcmd1bWVudFZhbGlkYXRvcixcbiAgICBhbHRpdHVkZVZhbGlkYXRvcixcbiAgICBmaXhWYWxpZGF0b3IsXG4gICAgaGVhZGluZ1ZhbGlkYXRvcixcbiAgICBob2xkVmFsaWRhdG9yXG59IGZyb20gJy4vYXJndW1lbnRWYWxpZGF0b3JzJztcbmltcG9ydCB7XG4gICAgYWx0aXR1ZGVQYXJzZXIsXG4gICAgaGVhZGluZ1BhcnNlcixcbiAgICBob2xkUGFyc2VyXG59IGZyb20gJy4vYXJndW1lbnRQYXJzZXJzJztcblxuLyoqXG4gKiBBIG5vLW9wIGZ1bmN0aW9uIHVzZWQgZm9yIGNvbW1hbmQgZGVmaW5pdGlvbnMgdGhhdCBkbyBub3QgbmVlZCBhIHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBpbW1lZGlhdGVseSByZXR1cm4gYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gaXQgYW5kIGlzXG4gKiB1c2VkIGluIHBsYWNlIG9mIGFuIGFjdHVhbCBwYXJzZXIuIHRoaXMgd2F5IGBjb21tYW5kLnBhcnNlYCBjYW4gc3RpbGxcbiAqIGJlIGNhbGxlZCBldmVuIHdpdGggY29tbWFuZHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlIHBhcnNlZC5cbiAqXG4gKiBAZnVuY3Rpb24gbm9vcFxuICogQHBhcmFtIGFyZ3Mgeyp9XG4gKiBAcmV0dXJuIHsqfVxuICovXG5jb25zdCBub29wID0gKGFyZ3MpID0+IGFyZ3M7XG5cbi8qKlxuICogU3lzdGVtIGFuZCBBaXJjcmFmdCBjb21tYW5kIGRlZmluaXRpb25zIHRoYXQgYWNjZXB0IHplcm8gYXJndW1lbnRzXG4gKlxuICogQHByb3BlcnR5IFpFUk9fQVJHX0NPTU1BTkRTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFpFUk9fQVJHX0NPTU1BTkRTID0ge1xuICAgIC8vIHN5c3RlbSBjb21tYW5kc1xuICAgIGF1dG86IHtcbiAgICAgICAgdmFsaWRhdGU6IHplcm9Bcmd1bWVudHNWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICBjbGVhcjoge1xuICAgICAgICB2YWxpZGF0ZTogemVyb0FyZ3VtZW50c1ZhbGlkYXRvcixcbiAgICAgICAgcGFyc2U6IG5vb3BcbiAgICB9LFxuICAgIHBhdXNlOiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgdHV0b3JpYWw6IHtcbiAgICAgICAgdmFsaWRhdGU6IHplcm9Bcmd1bWVudHNWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICB2ZXJzaW9uOiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG5cbiAgICAvLyBBaXJjcmFmdCBjb21tYW5kc1xuICAgIGFib3J0OiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgY2xlYXJlZEFzRmlsZWQ6IHtcbiAgICAgICAgdmFsaWRhdGU6IHplcm9Bcmd1bWVudHNWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICBjbGltYlZpYVNJRDoge1xuICAgICAgICB2YWxpZGF0ZTogemVyb0FyZ3VtZW50c1ZhbGlkYXRvcixcbiAgICAgICAgcGFyc2U6IG5vb3BcbiAgICB9LFxuICAgIGRlYnVnOiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgZGVsZXRlOiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgZGVzY2VuZFZpYVNUQVI6IHtcbiAgICAgICAgdmFsaWRhdGU6IHplcm9Bcmd1bWVudHNWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICBmbHlQcmVzZW50SGVhZGluZzoge1xuICAgICAgICB2YWxpZGF0ZTogemVyb0FyZ3VtZW50c1ZhbGlkYXRvcixcbiAgICAgICAgcGFyc2U6IG5vb3BcbiAgICB9LFxuICAgIHNheVJvdXRlOiB7XG4gICAgICAgIHZhbGlkYXRlOiB6ZXJvQXJndW1lbnRzVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgdGFrZW9mZjoge1xuICAgICAgICB2YWxpZGF0ZTogemVyb0FyZ3VtZW50c1ZhbGlkYXRvcixcbiAgICAgICAgcGFyc2U6IG5vb3BcbiAgICB9XG59O1xuXG4vKipcbiAqIFN5c3RlbSBhbmQgQWlyY3JhZnQgY29tbWFuZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYXJndW1lbnRcbiAqXG4gKiB0aGVzZSBjb21tYW5kcyBhY2NlcHQgYSBzaW5nbGUgYXJndW1lbnQgYW5kIG1heSByZXF1aXJlIGZ1cnRoZXIgcGFyc2luZywgZWc6IChzdHJpbmcgLT4gbnVtYmVyKVxuICpcbiAqIEBwcm9wZXJ0eSBTSU5HTEVfQVJHX0NPTU1BTkRTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFNJTkdMRV9BUkdfQ09NTUFORFMgPSB7XG4gICAgJ2AnOiB7XG4gICAgICAgIHZhbGlkYXRlOiBzaW5nbGVBcmd1bWVudFZhbGlkYXRvcixcbiAgICAgICAgLy8gY2FsbGluZyBtZXRob2QgaXMgZXhwZWN0aW5nIGFuIGFycmF5IHdpdGggdmFsdWVzIHRoYXQgd2lsbCBnZXQgc3ByZWFkIGxhdGVyLCB0aHVzIHdlIHB1cnBvc2x5XG4gICAgICAgIC8vIHJldHVybiBhbiBhcnJheSBoZXJlXG4gICAgICAgIHBhcnNlOiAoYXJncykgPT4gW2NvbnZlcnRTdHJpbmdUb051bWJlcihhcmdzKV1cbiAgICB9LFxuICAgIGFpcnBvcnQ6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgcmF0ZToge1xuICAgICAgICB2YWxpZGF0ZTogc2luZ2xlQXJndW1lbnRWYWxpZGF0b3IsXG4gICAgICAgIC8vIGNhbGxpbmcgbWV0aG9kIGlzIGV4cGVjdGluZyBhbiBhcnJheSB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgZ2V0IHNwcmVhZCBsYXRlciwgdGh1cyB3ZSBwdXJwb3NseVxuICAgICAgICAvLyByZXR1cm4gYW4gYXJyYXkgaGVyZVxuICAgICAgICBwYXJzZTogKGFyZ3MpID0+IFtjb252ZXJ0U3RyaW5nVG9OdW1iZXIoYXJncyldXG4gICAgfSxcbiAgICB0aW1ld2FycDoge1xuICAgICAgICB2YWxpZGF0ZTogc2luZ2xlQXJndW1lbnRWYWxpZGF0b3IsXG4gICAgICAgIC8vIGNhbGxpbmcgbWV0aG9kIGlzIGV4cGVjdGluZyBhbiBhcnJheSB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgZ2V0IHNwcmVhZCBsYXRlciwgdGh1cyB3ZSBwdXJwb3NseVxuICAgICAgICAvLyByZXR1cm4gYW4gYXJyYXkgaGVyZVxuICAgICAgICBwYXJzZTogKGFyZ3MpID0+IFtjb252ZXJ0U3RyaW5nVG9OdW1iZXIoYXJncyldXG4gICAgfSxcblxuICAgIGRpcmVjdDoge1xuICAgICAgICB2YWxpZGF0ZTogc2luZ2xlQXJndW1lbnRWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICBsYW5kOiB7XG4gICAgICAgIHZhbGlkYXRlOiBzaW5nbGVBcmd1bWVudFZhbGlkYXRvcixcbiAgICAgICAgLy8gVE9ETzogc3BsaXQgdGhpcyBvdXQgdG8gY3VzdG9tIHBhcnNlciBvbmNlIHRoZSBudWxsIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgICAgcGFyc2U6IChhcmdzKSA9PiBbbnVsbCwgYXJnc1swXV1cbiAgICB9LFxuICAgIG1vdmVEYXRhQmxvY2s6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgcm91dGU6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgcmVyb3V0ZToge1xuICAgICAgICB2YWxpZGF0ZTogc2luZ2xlQXJndW1lbnRWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBub29wXG4gICAgfSxcbiAgICBzaWQ6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgc3BlZWQ6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICAvLyBjYWxsaW5nIG1ldGhvZCBpcyBleHBlY3RpbmcgYW4gYXJyYXkgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGdldCBzcHJlYWQgbGF0ZXIsIHRodXMgd2UgcHVycG9zbHlcbiAgICAgICAgLy8gcmV0dXJuIGFuIGFycmF5IGhlcmVcbiAgICAgICAgcGFyc2U6IChhcmcpID0+IFtjb252ZXJ0U3RyaW5nVG9OdW1iZXIoYXJnKV1cbiAgICB9LFxuICAgIHN0YXI6IHtcbiAgICAgICAgdmFsaWRhdGU6IHNpbmdsZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH1cbn07XG5cbi8qKlxuICogU3lzdGVtIGFuZCBBaXJjcmFmdCBjb21tYW5kcyB0aGF0IGFjY2VwdCBhcmd1bWVudHMgc3BlY2lmaWMgdG8gdGhlIGNvbW1hbmRcbiAqXG4gKiBUaGVzZSBkZWZpbml0aW9ucyB3aWxsIGxpa2VseSByZWZlcmVuY2UgZnVuY3Rpb25zIGZvciB2YWxpZGF0ZSBhbmQgcGFyc2UgdGhhdCBhcmUgc3BlY2lmaWMgb25seVxuICogdG8gb25lIGNvbW1hbmRcbiAqXG4gKiBAcHJvcGVydHkgQ1VTVE9NX0FSR19DT01NQU5EU1xuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBDVVNUT01fQVJHX0NPTU1BTkRTID0ge1xuICAgIHRheGk6IHtcbiAgICAgICAgdmFsaWRhdGU6IHplcm9Pck9uZUFyZ3VtZW50VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG5cbiAgICAvLyB0aGVzZSBjb21tYW5kcyBoYXZlIHNwZWNpZmljIGFyZ3VtZW50IHJlcXVpcmVtZW50cyBhbmQgbWF5IG5lZWQgdG8gYmUgcGFyc2VkXG4gICAgLy8gaW50byB0aGUgY29ycmVjdCB0eXBlIChzdGluZyAtPiBudW1iZXIpXG4gICAgYWx0aXR1ZGU6IHtcbiAgICAgICAgdmFsaWRhdGU6IGFsdGl0dWRlVmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogYWx0aXR1ZGVQYXJzZXJcbiAgICB9LFxuICAgIGZpeDoge1xuICAgICAgICB2YWxpZGF0ZTogZml4VmFsaWRhdG9yLFxuICAgICAgICBwYXJzZTogbm9vcFxuICAgIH0sXG4gICAgaGVhZGluZzoge1xuICAgICAgICB2YWxpZGF0ZTogaGVhZGluZ1ZhbGlkYXRvcixcbiAgICAgICAgcGFyc2U6IGhlYWRpbmdQYXJzZXJcbiAgICB9LFxuICAgIGhvbGQ6IHtcbiAgICAgICAgdmFsaWRhdGU6IGhvbGRWYWxpZGF0b3IsXG4gICAgICAgIHBhcnNlOiBob2xkUGFyc2VyXG4gICAgfVxufTtcblxuLyoqXG4gKiBTaW5nbGUgZXhwb3J0ZWQgY29uc3RhbnQgdGhhdCBjb21iaW5lcyBhbGwgdGhlIGRlZmluaXRpb25zIGFib3ZlXG4gKlxuICogQHByb3BlcnR5IENPTU1BTkRfREVGSU5JVElPTlxuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgY29uc3QgQ09NTUFORF9ERUZJTklUSU9OID0ge1xuICAgIC4uLlpFUk9fQVJHX0NPTU1BTkRTLFxuICAgIC4uLlNJTkdMRV9BUkdfQ09NTUFORFMsXG4gICAgLi4uQ1VTVE9NX0FSR19DT01NQU5EU1xufTtcbiIsIi8qKlxuICogTGlzdCBvZiBTeXN0ZW0gQ29tbWFuZHNcbiAqXG4gKiBXaGVuIGEgY29tbWFuZCBpcyBwYXJzZWQsIHRoZSB2YWx1ZSBoZXJlIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICogb2YgdGhlIGBDb21tYW5kUGFyc2VyYFxuICpcbiAqIEBwcm9wZXJ0eSBTWVNURU1fQ09NTUFORFNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFNZU1RFTV9DT01NQU5EUyA9IHtcbiAgICBhdXRvOiAnYXV0bycsXG4gICAgY2xlYXI6ICdjbGVhcicsXG4gICAgcGF1c2U6ICdwYXVzZScsXG4gICAgdHV0b3JpYWw6ICd0dXRvcmlhbCcsXG4gICAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuXG4gICAgLy8gc2luZ2xlIGFyZyBjb21tYW5kc1xuICAgICdgJzogJ21vdmVEYXRhQmxvY2snLFxuICAgIGFpcnBvcnQ6ICdhaXJwb3J0JyxcbiAgICByYXRlOiAncmF0ZScsXG4gICAgdGltZXdhcnA6ICd0aW1ld2FycCcsXG4gICAgdHJhbnNtaXQ6ICd0cmFuc21pdCdcbn07XG5cbi8qKlxuICogU29tZSBjb21tYW5kcyBhcmUgY29udmVydGVkIHRvIHVuaWNvZGUgKHRvIHByb3ZpZGUgYXJyb3cgY2hhcmFjdGVycykgZm9yIHNwZWNpZmljIHNob3J0a2V5c1xuICpcbiAqIFRoaXMgbWFwcyB0aG9zZSB1bmljb2RlIHZhbHVlcywgY29udmVydGVkIHRvIGEgc3RyaW5nLCB0byB0aGUgY29ycmVjdCByb290IGNvbW1hbmRcbiAqXG4gKiBAcHJvcGVydHkgVU5JQ09ERV9DT01NQU5EU1xuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5jb25zdCBVTklDT0RFX0NPTU1BTkRTID0ge1xuICAgICdcXFxcdTJCNjEnOiAnYWx0aXR1ZGUnLFxuICAgICdcXFxcdTJCNjMnOiAnYWx0aXR1ZGUnLFxuICAgICdcXFxcdTJCQTInOiAnaGVhZGluZycsXG4gICAgJ1xcXFx1MkJBMyc6ICdoZWFkaW5nJyxcbiAgICAnXFxcXHUyQjUwJzogJ2xhbmQnXG59O1xuXG4vKipcbiAqIENvbXBsZXRlIG1hcCBvZiBjb21tYW5kc1xuICpcbiAqIFRoaXMgbGlzdCBpbmNsdWRlcyBib3RoIFN5c3RlbSBhbmQgVW5pY29kZSBjb21tYW5kcywgYXMgd2VsbCBhcyBhbGwgdGhlIHZhcmlvdXMgYWlyY3JhZnRcbiAqIGNvbW1hbmRzLlxuICpcbiAqIEFsaWFzZWQgY29tbWFuZHMgbWFwIHRvIGEgc2luZ2xlIHJvb3QgY29tbWFuZCB0aGF0IGlzIHNoYXJlZCBhbW9uZyBhbGwgYWxpYXNlcy4gVGhlIHZhbHVlc1xuICogaGVyZSB0aGVuIG1hcCB0byBhIGBDT01NQU5EX0RFRklOSVRJT05gIHdoaWNoIGNvbnRhaW5zIGB2YWxpZGF0ZWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIGZvclxuICogZWFjaCByb290IGNvbW1hbmQuIFNvbWUgY29tbWFuZHMgaGF2ZSB2ZXJ5IHVuaXF1ZSBkZW1hbmRzIGZvciBob3cgYXJndW1lbnRzIGFyZSBmb3JtYXR0ZWQsXG4gKiB0aG9zZSBmdW5jdGlvbnMgbGV0IHVzIGRvIHRoYXQgb24gYSBjYXNlIGJ5IGNhc2UgYmFzaXMuXG4gKlxuICogS2V5cyBhcmUgbG93ZXJjYXNlZCBoZXJlIHNvIHRoZXkgY2FuIGJlIGFjY2Vzc2VkIHByb2dyYW1hdGljYWxseSB1c2luZyBpbnB1dCBzdHJpbmcgc2VnbWVudHNcbiAqIHRoYXQgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgZm9yIGVhc2Ugb2YgY29tcGFyaXNvbi5cbiAqXG4gKiBAcHJvcGVyeSBDT01NQU5EX01BUFxuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgY29uc3QgQ09NTUFORF9NQVAgPSB7XG4gICAgLi4uU1lTVEVNX0NPTU1BTkRTLFxuICAgIC4uLlVOSUNPREVfQ09NTUFORFMsXG5cbiAgICB0YXhpOiAndGF4aScsXG4gICAgd2FpdDogJ3RheGknLFxuICAgIHc6ICd0YXhpJyxcbiAgICBzaWQ6ICdzaWQnLFxuICAgIHN0YXI6ICdzdGFyJyxcbiAgICBjbGVhcmVkQXNGaWxlZDogJ2NsZWFyZWRBc0ZpbGVkJyxcbiAgICBjYWY6ICdjbGVhcmVkQXNGaWxlZCcsXG4gICAgY2xpbWJWaWFTSUQ6ICdjbGltYlZpYVNJRCcsXG4gICAgY3ZzOiAnY2xpbWJWaWFTSUQnLFxuICAgIGRlc2NlbmRWaWFTVEFSOiAnZGVzY2VuZFZpYVNUQVInLFxuICAgIGR2czogJ2Rlc2NlbmRWaWFTVEFSJyxcbiAgICBjbGltYjogJ2FsdGl0dWRlJyxcbiAgICBjOiAnYWx0aXR1ZGUnLFxuICAgIGRlc2NlbmQ6ICdhbHRpdHVkZScsXG4gICAgZDogJ2FsdGl0dWRlJyxcbiAgICBhbHRpdHVkZTogJ2FsdGl0dWRlJyxcbiAgICBhOiAnYWx0aXR1ZGUnLFxuICAgIHRha2VvZmY6ICd0YWtlb2ZmJyxcbiAgICB0bzogJ3Rha2VvZmYnLFxuICAgIGN0bzogJ3Rha2VvZmYnLFxuICAgIGZwaDogJ2ZseVByZXNlbnRIZWFkaW5nJyxcbiAgICBoZWFkaW5nOiAnaGVhZGluZycsXG4gICAgZmg6ICdoZWFkaW5nJyxcbiAgICBoOiAnaGVhZGluZycsXG4gICAgdHVybjogJ2hlYWRpbmcnLFxuICAgIHQ6ICdoZWFkaW5nJyxcbiAgICBzcGVlZDogJ3NwZWVkJyxcbiAgICBzbG93OiAnc3BlZWQnLFxuICAgIHNwOiAnc3BlZWQnLFxuICAgICcrJzogJ3NwZWVkJyxcbiAgICAnLSc6ICdzcGVlZCcsXG4gICAgaWxzOiAnbGFuZCcsXG4gICAgaTogJ2xhbmQnLFxuICAgIGxhbmQ6ICdsYW5kJyxcbiAgICBsOiAnbGFuZCcsXG4gICAgJyonOiAnbGFuZCcsXG4gICAgcmVyb3V0ZTogJ3Jlcm91dGUnLFxuICAgIHJyOiAncmVyb3V0ZScsXG4gICAgcm91dGU6ICdyb3V0ZScsXG4gICAgc3I6ICdzYXlSb3V0ZScsXG4gICAgZjogJ2ZpeCcsXG4gICAgZml4OiAnZml4JyxcbiAgICB0cmFjazogJ2ZpeCcsXG4gICAgZGlyZWN0OiAnZGlyZWN0JyxcbiAgICBwZDogJ2RpcmVjdCcsXG4gICAgZGN0OiAnZGlyZWN0JyxcbiAgICBhYm9ydDogJ2Fib3J0JyxcbiAgICBob2xkOiAnaG9sZCcsXG4gICAgZGVsZXRlOiAnZGVsZXRlJyxcbiAgICBkZWw6ICdkZWxldGUnLFxuICAgIGtpbGw6ICdkZWxldGUnXG59O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBFWFBFRElURVxuICogQHR5cGUge2FycmF5fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBFRElURSA9IFsnZXhwZWRpdGUnLCAneCddO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuLyoqXG4gKiBAcHJvcGVydHkgSU5WQUxJRF9BUkdcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgSU5WQUxJRF9BUkcgPSAnSW52YWxpZCBhcmd1bWVudCc7XG5cbi8qKlxuICogQHByb3BlcnR5IElOVkFMSURfQVJHX0xFTkdUSFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBmaW5hbFxuICovXG5jb25zdCBJTlZBTElEX0FSR19MRU5HVEggPSBgJHtJTlZBTElEX0FSR30gbGVuZ3RoYDtcblxuLyoqXG4gKiBFbmNhcHN1bGF0aW9uIG9mIGVycm9yIG1lc3NhZ2luZyB1c2VkIHdpdGggYGFyZ3VtZW50VmFsaWRhdG9yc2AgZnVuY3Rpb25zXG4gKlxuICogQHByb3BlcnR5IEVSUk9SX01FU1NBR0VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEVSUk9SX01FU1NBR0UgPSB7XG4gICAgWkVST19BUkdfTEVOR1RIOiBgJHtJTlZBTElEX0FSR19MRU5HVEh9LiBFeHBlY3RlZCBleGFjdGx5IHplcm8gYXJndW1lbnRzYCxcbiAgICBTSU5HTEVfQVJHX0xFTkdUSDogYCR7SU5WQUxJRF9BUkdfTEVOR1RIfS4gRXhwZWN0ZWQgZXhhY3RseSBvbmUgYXJndW1lbnRgLFxuICAgIFpFUk9fT1JfT05FX0FSR19MRU5HVEg6IGAke0lOVkFMSURfQVJHX0xFTkdUSH0uIEV4cGVjdGVkIHplcm8gb3Igb25lIGFyZ3VtZW50YCxcbiAgICBaRVJPX1RPX1RIUkVFX0FSR19MRU5HVEg6IGAke0lOVkFMSURfQVJHX0xFTkdUSH0uIEV4cGVjdGVkIHplcm8gdG8gdGhyZWUgYXJndW1lbnRzYCxcbiAgICBPTkVfT1JfTU9SRV9BUkdfTEVOR1RIOiBgJHtJTlZBTElEX0FSR19MRU5HVEh9LiBFeHBlY3RlZCBvbmUgb3IgbW9yZSBhcmd1bWVudHNgLFxuICAgIE9ORV9PUl9UV09fQVJHX0xFTkdUSDogYCR7SU5WQUxJRF9BUkdfTEVOR1RIfS4gRXhwZWN0ZWQgb25lIG9yIHR3byBhcmd1bWVudHNgLFxuICAgIE9ORV9UT19USFJFRV9BUkdfTEVOR1RIOiBgJHtJTlZBTElEX0FSR19MRU5HVEh9LiBFeHBlY3RlZCBvbmUsIHR3bywgb3IgdGhyZWUgYXJndW1lbnRzYCxcbiAgICBPTkVfT1JfVEhSRUVfQVJHX0xFTkdUSDogYCR7SU5WQUxJRF9BUkdfTEVOR1RIfS4gRXhwZWN0ZWQgb25lIG9yIHRocmVlIGFyZ3VtZW50c2AsXG4gICAgQUxUSVRVREVfRVhQRURJVEVfQVJHOiBgJHtJTlZBTElEX0FSR30uIEFsdGl0dWRlIGFjY2VwdHMgb25seSBcImV4cGVkaXRlXCIgb3IgXCJ4XCIgYXMgYSBzZWNvbmQgYXJndW1lbnRgLFxuICAgIEhFQURJTkdfTVVTVF9CRV9OVU1CRVI6IGAke0lOVkFMSURfQVJHfS4gSGVhZGluZyBtdXN0IGJlIGEgbnVtYmVyYCxcbiAgICBNVVNUX0JFX1NUUklORzogYCR7SU5WQUxJRF9BUkd9LiBNdXN0IGJlIGEgc3RyaW5nYCxcbiAgICBJTlZBTElEX0RJUkVDVElPTl9TVFJJTkc6IGAke0lOVkFMSURfQVJHfS4gRXhwZWN0ZWQgb25lIG9mICdsZWZ0IC8gbCAvIHJpZ2h0IC8gcicgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHdoZW4gcGFzc2VkIHRocmVlIGFyZ3VtZW50c2AsXG4gICAgSEVBRElOR19BQ0NFUFRTX0JPT0xFQU5fQVNfVEhJUkRfQVJHOiBgJHtJTlZBTElEX0FSR30uIEhlYWRpbmcgYWNjZXB0cyBhIGJvb2xlYW4gZm9yIHRoZSB0aGlyZCBhcmd1bWVudCB3aGVuIHBhc3NlZCB0aHJlZSBhcmd1bWVudHNgXG59O1xuIiwiLyoqXG4gKiBAcHJvcGVydHkgRkxJR0hUX01PREVTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBGTElHSFRfTU9ERVMgPSB7XG4gICAgLy8gLSAnYXByb24nIGlzIHRoZSBpbml0aWFsIHN0YXR1cyBvZiBhIG5ldyBkZXBhcnRpbmcgcGxhbmUuIEFmdGVyXG4gICAgLy8gICB0aGUgcGxhbmUgaXMgaXNzdWVkIHRoZSAndGF4aScgY29tbWFuZCwgdGhlIHBsYW5lIHRyYW5zaXRpb25zIHRvXG4gICAgLy8gICAndGF4aScgbW9kZVxuICAgIC8vIC0gJ3RheGknIGRlc2NyaWJlcyB0aGUgcHJvY2VzcyBvZiBnZXR0aW5nIHJlYWR5IGZvciB0YWtlb2ZmLiBBZnRlclxuICAgIC8vICAgYSBkZWxheSwgdGhlIHBsYW5lIGJlY29tZXMgcmVhZHkgYW5kIHRyYW5zaXRpb25zIGludG8gJ3dhaXRpbmcnIG1vZGVcbiAgICAvLyAtICd3YWl0aW5nJzogdGhlIHBsYW5lIGlzIHJlYWR5IGZvciB0YWtlb2ZmIGFuZCBhd2FpdHMgY2xlYXJlbmNlIHRvXG4gICAgLy8gICB0YWtlIG9mZlxuICAgIC8vIC0gJ3Rha2VvZmYnIGlzIGFzc2lnbmVkIHRvIHBsYW5lcyBpbiB0aGUgcHJvY2VzcyBvZiB0YWtpbmcgb2ZmLiBUaGVzZVxuICAgIC8vICAgcGxhbmVzIGFyZSBzdGlsbCBvbiB0aGUgZ3JvdW5kIG9yIGhhdmUgbm90IHlldCByZWFjaGVkIHRoZSBtaW5pbXVtXG4gICAgLy8gICBhbHRpdHVkZVxuICAgIC8vIC0gJ2NydXNlJyBkZXNjcmliZXMsIHRoYXQgYSBwbGFuZSBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0IGFuZFxuICAgIC8vICAgbm90IGZvbGxvd2luZyBhbiBJTFMgcGF0aC4gUGxhbmVzIG9mIGNhdGVnb3J5ICdhcnJpdmFsJyBlbnRlcmluZyB0aGVcbiAgICAvLyAgIHBsYXlpbmcgZmllbGQgYWxzbyBoYXZlIHRoaXMgc3RhdGUuIElmIGFuIElMUyBwYXRoIGlzIHBpY2tlZCB1cCwgdGhlXG4gICAgLy8gICBwbGFuZSB0cmFuc2l0aW9ucyB0byAnbGFuZGluZydcbiAgICAvLyAtICdsYW5kaW5nJyB0aGUgcGxhbmUgaXMgZm9sbG93aW5nIGFuIElMUyBwYXRoIG9yIGlzIG9uIHRoZSBydW53YXkgaW5cbiAgICAvLyAgIHRoZSBwcm9jZXNzIG9mIHN0b3BwaW5nLiBJZiBhbiBJTFMgYXBwcm9hY2ggb3IgYSBsYW5kaW5nIGlzIGFib3J0ZWQsXG4gICAgLy8gICB0aGUgcGxhbmUgcmVlbnRlcnMgJ2NydWlzZScgbW9kZVxuICAgIEFQUk9OOiAnYXByb24nLFxuICAgIFRBWEk6ICd0YXhpJyxcbiAgICBXQUlUSU5HOiAnd2FpdGluZycsXG4gICAgVEFLRU9GRjogJ3Rha2VvZmYnLFxuICAgIENSVUlTRTogJ2NydWlzZScsXG4gICAgTEFORElORzogJ2xhbmRpbmcnXG59O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBGTElHSFRfQ0FURUdPUllcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEZMSUdIVF9DQVRFR09SWSA9IHtcbiAgICBBUlJJVkFMOiAnYXJyaXZhbCcsXG4gICAgREVQQVJUVVJFOiAnZGVwYXJ0dXJlJ1xufTtcblxuLyoqXG4gKiBAcHJvcGVydHkgV0FZUE9JTlRfTkFWX01PREVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFdBWVBPSU5UX05BVl9NT0RFID0ge1xuICAgIEZJWDogJ2ZpeCcsXG4gICAgSEVBRElORzogJ2hlYWRpbmcnLFxuICAgIEhPTEQ6ICdob2xkJyxcbiAgICBSV1k6ICdyd3knXG59O1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHBvc3NpYmxlIEZMaWdodCBQbGFuIExlZyB0eXBlcy5cbiAqXG4gKiBAcHJvcGVydHkgRlBfTEVHX1RZUEVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEZQX0xFR19UWVBFID0ge1xuICAgIFNJRDogJ3NpZCcsXG4gICAgU1RBUjogJ3N0YXInLFxuICAgIElBUDogJ2lhcCcsXG4gICAgQVdZOiAnYXd5JyxcbiAgICBGSVg6ICdmaXgnLFxuICAgIE1BTlVBTDogJ1ttYW51YWxdJ1xufTtcbiIsIi8qKlxuICogQHByb3BlcnR5IEFJUlBPUlRfQ09OU1RBTlRTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBBSVJQT1JUX0NPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgREVGQVVMVF9TUEFXTl9BTFRJVFVERV9NSU5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIERFRkFVTFRfU1BBV05fQUxUSVRVREVfTUlOOiAxMDAwMCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBERUZBVUxUX1NQQVdOX0FMVElUVURFX01BWFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgREVGQVVMVF9TUEFXTl9BTFRJVFVERV9NQVg6IDEwMDAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IERFRkFVTFRfU1BBV05fQUlSQ1JBRlRfU1BFRURfS1RTXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBERUZBVUxUX1NQQVdOX0FJUkNSQUZUX1NQRUVEX0tUUzogMjUwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IE1JTl9FTlRSQUlMX0RJU1RBTkNFX05NXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBNSU5fRU5UUkFJTF9ESVNUQU5DRV9OTTogNS41XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiwgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuLyoqXG4gKiBOYW1lIGVudW1lcmF0aW9uIG9mIGF2YWlsYWJsZSBnYW1lIG9wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkgR0FNRV9PUFRJT05fTkFNRVNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEdBTUVfT1BUSU9OX05BTUVTID0ge1xuICAgIENPTlRST0xfTUVUSE9EOiAnY29udHJvbE1ldGhvZCcsXG4gICAgRFJBV19QUk9KRUNURURfUEFUSFM6ICdkcmF3UHJvamVjdGVkUGF0aHMnLFxuICAgIFNJTVBMSUZZX1NQRUVEUzogJ3NpbXBsaWZ5U3BlZWRzJyxcbiAgICBTT0ZUX0NFSUxJTkc6ICdzb2Z0Q2VpbGluZydcbn07XG5cbi8qKlxuICogVXNlciBvcHRpb25zXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgcHJlc2VudGVkIGluIGEgbW9kYWwgYW5kIGFyZSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlXG4gKlxuICogQHByb3BlcnR5IEdBTUVfT1BUSU9OX1ZBTFVFU1xuICogQHR5cGUge2FycmF5PG9iamVjdD59XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEdBTUVfT1BUSU9OX1ZBTFVFUyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6IEdBTUVfT1BUSU9OX05BTUVTLkNPTlRST0xfTUVUSE9ELFxuICAgICAgICBkZWZhdWx0VmFsdWU6ICdjbGFzc2ljJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb250cm9sIE1ldGhvZCcsXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICBbJ0NsYXNzaWMnLCAnY2xhc3NpYyddLFxuICAgICAgICAgICAgWydBcnJvdyBLZXlzJywgJ2Fycm93cyddXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogR0FNRV9PUFRJT05fTkFNRVMuRFJBV19QUk9KRUNURURfUEFUSFMsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogJ3NlbGVjdGVkJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEcmF3IGFpcmNyYWZ0IHByb2plY3RlZCBwYXRoJyxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgIFsnQWx3YXlzJywgJ2Fsd2F5cyddLFxuICAgICAgICAgICAgWydTZWxlY3RlZCcsICdzZWxlY3RlZCddLFxuICAgICAgICAgICAgWydOZXZlcicsICduZXZlciddXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogR0FNRV9PUFRJT05fTkFNRVMuU0lNUExJRllfU1BFRURTLFxuICAgICAgICBkZWZhdWx0VmFsdWU6ICd5ZXMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1VzZSBzaW1wbGlmaWVkIGFpcnNwZWVkcycsXG4gICAgICAgIGhlbHA6ICdDb250cm9scyB1c2Ugb2YgYSBzaW1wbGlmaWVkIGNhbGN1bGF0aW9uIHdoaWNoIHJlc3VsdHMgaW4gYWlyY3JhZnQgYWx3YXlzIG1vdmluZyBhY3Jvc3MgdGhlIGdyb3VuZCBhdCB0aGUgc3BlZWQgYXNzaWduZWQuICBJbiByZWFsaXR5IGFpcmNyYWZ0IHdpbGwgbW92ZSBmYXN0ZXIgYXMgdGhleSBpbmNyZWFzZSBhbHRpdHVkZS4nLFxuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgWydZZXMnLCAneWVzJ10sXG4gICAgICAgICAgICBbJ05vJywgJ25vJ11cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBHQU1FX09QVElPTl9OQU1FUy5TT0ZUX0NFSUxJTkcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogJ25vJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBbGxvdyBkZXBhcnR1cmVzIHZpYSBjbGltYicsXG4gICAgICAgIGhlbHA6ICdOb3JtYWxseSBhaXJjcmFmdCBkZXBhcnRzIHRoZSBhaXJzcGFjZSBieSBmbHlpbmcgYmV5b25kIHRoZSBob3Jpem9udGFsIGJvdW5kcy4gIElmIHNldCB0byB5ZXMsIGFpcmNyYWZ0IG1heSBhbHNvIGRlcGFydCB0aGUgYWlyc3BhY2UgYnkgY2xpbWJpbmcgYWJvdmUgaXQuJyxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgIFsnWWVzJywgJ3llcyddLFxuICAgICAgICAgICAgWydObycsICdubyddXG4gICAgICAgIF1cbiAgICB9XG5dO1xuIiwiLyoqXG4gKiBDb21tb25seSB1c2VkIHRpbWUgY29udmVyc2lvbiByYXRlc1xuICpcbiAqIEBwcm9wZXJ0eSBUSU1FXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBUSU1FID0ge1xuICAgIE9ORV9IT1VSX0lOX1NFQ09ORFM6IDM2MDAsXG4gICAgT05FX0hPVVJfSU5fTUlOVVRFUzogNjAsXG4gICAgT05FX0hPVVJfSU5fTUlMTElTRUNPTkRTOiAzNjAwMDAwLFxuICAgIE9ORV9NSU5VVEVfSU5fSE9VUlM6IDEgLyA2MCxcbiAgICBPTkVfTUlOVVRFX0lOX1NFQ09ORFM6IDYwLFxuICAgIE9ORV9NSU5VVEVfSU5fTUlMTElTRUNPTkRTOiA2MDAwMCxcbiAgICBPTkVfU0VDT05EX0lOX0hPVVJTOiAxIC8gMzYwMCxcbiAgICBPTkVfU0VDT05EX0lOX01JTlVURVM6IDEgLyA2MCxcbiAgICBPTkVfU0VDT05EX0lOX01JTExJU0VDT05EUzogMTAwMCxcbiAgICBPTkVfTUlMTElTRUNPTkRfSU5fSE9VUlM6IDEgLyAzNjAwMDAwLFxuICAgIE9ORV9NSUxMSVNFQ09ORF9JTl9NSU5VVEVTOiAxIC8gNjAwMDAsXG4gICAgT05FX01JTExJU0VDT05EX0lOX1NFQ09ORFM6IDEgLyAxMDAwXG59O1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAqXG4gKiBAcHJvcGVydHkgUkVHRVhcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IFJFR0VYID0ge1xuICAgIENPTVBBU1NfRElSRUNUSU9OOiAvXltORVNXXS8sXG4gICAgU1c6IC9bU1ddLyxcbiAgICBMQVRfTE9ORzogL14oW05FU1ddKShcXGQrKFxcLlxcZCspPykoW2QgwrBdKFxcZCsoXFwuXFxkKyk/KSk/KFttICddKFxcZCsoXFwuXFxkKyk/KSk/JC8sXG4gICAgVU5JQ09ERTogL1teXFx1MDAwMC1cXHUwMGZmXS9cbn07XG4iLCIvKipcbiAqIEBwcm9wZXJ0eSBMT0dcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IExPRyA9IHtcbiAgICBERUJVRzogMCxcbiAgICBJTkZPOiAxLFxuICAgIFdBUk5JTkc6IDIsXG4gICAgRVJST1I6IDMsXG4gICAgRkFUQUw6IDRcbn07XG4iLCJpbXBvcnQgX21hcFZhbHVlcyBmcm9tICdsb2Rhc2gvbWFwVmFsdWVzJztcblxuLyoqXG4gKiBDU1MgY2xhc3NuYW1lcyB1c2VkIHRocm91Z2h0IHRoZSBhcHAuXG4gKlxuICogQHByb3BlcnR5IENMQVNTTkFNRVNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTTkFNRVMgPSB7XG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICBBSVJDUkFGVDogJ2FpcmNyYWZ0JyxcbiAgICBBTExfU0VUOiAnYWxsU2V0JyxcbiAgICBBTFRJVFVERTogJ2FsdGl0dWRlJyxcbiAgICBBUlJJVkFMOiAnYXJyaXZhbCcsXG4gICAgQ0FMTFNJR046ICdjYWxsc2lnbicsXG4gICAgQ09OVFJPTDogJ2NvbnRyb2wnLFxuICAgIERFUEFSVFVSRTogJ2RlcGFydHVyZScsXG4gICAgREVTVElOQVRJT046ICdkZXN0aW5hdGlvbicsXG4gICAgRkFTVF9GT1JXQVJEUzogJ2Zhc3QtZm9yd2FyZHMnLFxuICAgIEZPTExPV0lOR19TVEFSOiAnZm9sbG93aW5nU1RBUicsXG4gICAgSEVBRElORzogJ2hlYWRpbmcnLFxuICAgIEhJRERFTjogJ2hpZGRlbicsXG4gICAgSE9MRDogJ2hvbGQnLFxuICAgIExFRlQ6ICdsZWZ0JyxcbiAgICBMT09LSU5HX0dPT0Q6ICdsb29raW5nR29vZCcsXG4gICAgTUVTU0FHRTogJ21lc3NhZ2UnLFxuICAgIE5FR0FUSVZFOiAnbmVnYXRpdmUnLFxuICAgIE5FWFQ6ICduZXh0JyxcbiAgICBOT1RfU0VMRUNUQUJMRTogJ25vdFNlbGVjdGFibGUnLFxuICAgIE9QRU46ICdvcGVuJyxcbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxuICAgIFBBVVNFX1RPR0dMRTogJ3BhdXNlLXRvZ2dsZScsXG4gICAgUFJFVjogJ3ByZXYnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIFJVTldBWTogJ3J1bndheScsXG4gICAgU1BFRUNIX1RPR0dMRTogJ3NwZWVjaC10b2dnbGUnLFxuICAgIFNQRUVEOiAnc3BlZWQnLFxuICAgIFNQRUVEXzI6ICdzcGVlZC0yJyxcbiAgICBTUEVFRF81OiAnc3BlZWQtNScsXG4gICAgU1RSSVA6ICdzdHJpcCcsXG4gICAgU1dJVENIX0FJUlBPUlQ6ICdzd2l0Y2gtYWlycG9ydCcsXG4gICAgVE9HR0xFX0xBQkVMUzogJ3RvZ2dsZS1sYWJlbHMnLFxuICAgIFRPR0dMRV9SRVNUUklDVEVEX0FSRUFTOiAndG9nZ2xlLXJlc3RyaWN0ZWQtYXJlYXMnLFxuICAgIFRPR0dMRV9URVJSQUlOOiAndG9nZ2xlLXRlcnJhaW4nLFxuICAgIFRPR0dMRV9UVVRPUklBTDogJ3RvZ2dsZS10dXRvcmlhbCcsXG4gICAgVE9HR0xFX1NJRFM6ICd0b2dnbGUtc2lkcycsXG4gICAgV0FSTjogJ3dhcm4nLFxuICAgIFdBUk5JTkdfQlVUVE9OOiAnd2FybmluZy1idXR0b24nXG59O1xuXG4vKipcbiAqIENTUyBJRHMgdXNlZCB0aHJvdWdob3V0IHRoZSBhcHAuXG4gKlxuICogQHByb3BlcnR5IFNFTEVDVE9SX0lEU1xuICogQHR5cGUge09iamVjdH1cbiAqIEBmaW5hbFxuICovXG5leHBvcnQgY29uc3QgSURTID0ge1xuICAgIEFJUlBPUlRfTElTVDogJ2FpcnBvcnQtbGlzdCcsXG4gICAgQUlSUE9SVF9MSVNUX05PVEVTOiAnYWlycG9ydC1saXN0LW5vdGVzJyxcbiAgICBBSVJQT1JUX1NXSVRDSDogJ2FpcnBvcnQtc3dpdGNoJyxcbiAgICBDQU5WQVNFUzogJ2NhbnZhc2VzJyxcbiAgICBDTE9DSzogJ2Nsb2NrJyxcbiAgICBDT01NQU5EOiAnY29tbWFuZCcsXG4gICAgTE9BRElORzogJ2xvYWRpbmcnLFxuICAgIExPQURJTkdfSU5ESUNBVE9SOiAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgTE9HOiAnbG9nJyxcbiAgICBOQVZBSURTX0NBTlZBUzogJ25hdmFpZHMtY2FudmFzJyxcbiAgICBPUFRJT05TX0RJQUxPRzogJ29wdGlvbnMtZGlhbG9nJyxcbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxuICAgIFRPR0dMRV9PUFRJT05TOiAndG9nZ2xlLW9wdGlvbnMnLFxuICAgIFRVVE9SSUFMOiAndHV0b3JpYWwnLFxuICAgIFNDT1JFOiAnc2NvcmUnLFxuICAgIFNJREVCQVI6ICdzaWRlYmFyJyxcbiAgICBTVFJJUFM6ICdzdHJpcHMnXG59O1xuXG4vKipcbiAqIFRha2UgYSBjbGFzc25hbWUgc3RyaW5nIGFuZCByZXR1cm4gYSBjbGFzc25hbWUgc2VsZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCBieSBqUXVlcnkgdG8gZmluZCBhbiBIVE1MIEVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3JzRnJvbUNsYXNzbmFtZXNcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuY29uc3QgYnVpbGRTZWxlY3RvcnNGcm9tQ2xhc3NuYW1lcyA9ICgpID0+IHtcbiAgICBjb25zdCBjbGFzc25hbWVTZWxlY3RvcnMgPSBfbWFwVmFsdWVzKENMQVNTTkFNRVMsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gYC4ke3ZhbHVlfWA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xhc3NuYW1lU2VsZWN0b3JzO1xufTtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3JzRnJvbUlkc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5jb25zdCBidWlsZFNlbGVjdG9yc0Zyb21JZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgaWRTZWxlY3RvcnMgPSBfbWFwVmFsdWVzKElEUywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBgIyR7dmFsdWV9YDtcbiAgICB9KTtcblxuICAgIHJldHVybiBpZFNlbGVjdG9ycztcbn07XG5cbi8qKlxuICogQHByb3BlcnR5IERPTV9TRUxFQ1RPUlNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgRE9NX1NFTEVDVE9SUyA9IHtcbiAgICAuLi5idWlsZFNlbGVjdG9yc0Zyb21DbGFzc25hbWVzKCksXG4gICAgLi4uYnVpbGRTZWxlY3RvcnNGcm9tSWRzKClcbn07XG5cbi8qKlxuICogQ29tYmluYXRvciBjb25zdGFudC5cbiAqXG4gKiBBbGxvd3MgZm9yIGEgc2luZ2xlIGltcG9ydCB0aGF0IGhhcyBhY2Nlc3MgdG8gYm90aCBDTEFTU05BTUVTLCBJRFMgYW5kIERPTV9TRUxFQ1RPUlNcbiAqXG4gKiBAcHJvcGVydHkgU0VMRUNUT1JTXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBTRUxFQ1RPUlMgPSB7XG4gICAgQ0xBU1NOQU1FUyxcbiAgICBJRFMsXG4gICAgRE9NX1NFTEVDVE9SU1xufTtcbiIsIi8qKlxuICogQHByb3BlcnR5IFNUT1JBR0VfS0VZXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9IHtcbiAgICBBVENfU0NBTEU6ICdhdGMtc2NhbGUnLFxuICAgIEFUQ19MQVNUX0FJUlBPUlQ6ICdhdGMtbGFzdC1haXJwb3J0JyxcbiAgICBBVENfU1BFRUNIX0VOQUJMRUQ6ICdhdGMtc3BlZWNoLWVuYWJsZWQnLFxuICAgIEZJUlNUX1JVTl9USU1FOiAnZmlyc3QtcnVuLXRpbWUnXG59O1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBMb2FkYWJsZUNvbnRlbnRNb2RlbCBmcm9tICcuL0xvYWRhYmxlQ29udGVudE1vZGVsJztcblxuLyoqXG4gKiBBc3luY2hyb25vdXMgSlNPTiBhc3NldCBsb2FkaW5nIGZyYW1ld29yay5cbiAqXG4gKiBBbGxvd3MgcXVldWVpbmcgYXNzZXRzIHRvIGJlIGxvYWRlZCwgYXNzZXRzIG1heSBxdWV1ZWQgYXQgYSBoaWdoZXJcbiAqIHByaW9yaXR5IGJ5IHNwZWNpZnlpbmcgdGhlIGBpbW1lZGlhdGVgIG9wdGlvbi4gIEFsbCBhc3NldHMgd2l0aCB0aGVcbiAqIGBpbW1lZGlhdGVgIG9wdGlvbiB3aWxsIGJlIGxvYWRlZCBiZWZvcmUgb3RoZXIgYXNzZXRzLlxuICpcbiAqIEV2ZW50czpcbiAqICAgc3RhcnRMb2FkaW5nIC0gV2hlbiBhbiBhc3NldCBzdGFydCBiZWluZyBsb2FkZWQsIGFzc2V0IHVybCBhcyBkYXRhXG4gKiAgIHN0b3BMb2FkaW5nIC0gV2hlbiB0aGUgbGFzdCBhc3NldCBpbiB0aGUgcXVldWUgaXMgZG93bmxvYWRlZFxuICpcbiAqIEV4YW1wbGU6XG4gKiAgdmFyIHByb21pc2UgPSB6bHNhLmF0Yy5sb2FkQXNzZXQoe3VybDogJ2Fzc2V0cy9haXJjcmFmdC9iNzQ3Lmpzb24nfSk7XG4gKlxuICogQG1vZHVsZSB6bHNhLmF0Yy5sb2FkQXNzZXRcbiAqL1xuLyoqXG4qIEltcGxlbWVudGF0aW9uIG9mIHRoZSBxdWV1ZWluZ1xuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRRdWV1ZUNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2FkaW5nVmlldykge1xuICAgICAgICB0aGlzLmxvYWRpbmdWaWV3ID0gbG9hZGluZ1ZpZXc7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG93UHJpb3JpdHlRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmhpZ2hQcmlvcml0eVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucXVldWVkQ29udGVudCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb3IgdXBkYXRlcyBhIHBpZWNlIG9mIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGEgdXJsIGJlY29taW5nIGFuIGBpbW1lZGlhdGVgIGxvYWRcbiAgICAgKlxuICAgICAqIEBmb3IgQ29udGVudFF1ZXVlXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgYWRkKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGMgPSBuZXcgTG9hZGFibGVDb250ZW50TW9kZWwob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGMudXJsIGluIHRoaXMucXVldWVkQ29udGVudCkge1xuICAgICAgICAgICAgYyA9IHRoaXMucXVldWVkQ29udGVudFtjLnVybF07XG5cbiAgICAgICAgICAgIGlmIChjLmltbWVkaWF0ZSAmJiAoIXRoaXMucXVldWVkQ29udGVudFtjLnVybF0uaW1tZWRpYXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9ICQuaW5BcnJheShjLnVybCwgdGhpcy5sb3dQcmlvcml0eVF1ZXVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hQcmlvcml0eVF1ZXVlLnB1c2godGhpcy5sb3dQcmlvcml0eVF1ZXVlLnNwbGljZShpZHgsIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZENvbnRlbnRbYy51cmxdID0gYztcblxuICAgICAgICAgICAgaWYgKGMuaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdoUHJpb3JpdHlRdWV1ZS5wdXNoKGMudXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb3dQcmlvcml0eVF1ZXVlLnB1c2goYy51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjLmRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIENvbnRlbnRRdWV1ZVxuICAgICAqIEBtZXRob2Qgc3RhcnRMb2FkXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGFydExvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hQcmlvcml0eVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKHRoaXMuaGlnaFByaW9yaXR5UXVldWUuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG93UHJpb3JpdHlRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCh0aGlzLmxvd1ByaW9yaXR5UXVldWUuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgY29udGVudFF1ZXVlXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICogQHBhcmFtIHVybCB7c3RyaW5nfVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgbG9hZCh1cmwpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMucXVldWVkQ29udGVudFt1cmxdO1xuICAgICAgICB0aGlzLmxvYWRpbmdWaWV3LnN0YXJ0TG9hZChjLnVybCk7XG5cbiAgICAgICAgJC5nZXRKU09OKGMudXJsKVxuICAgICAgICAgICAgLmRvbmUoKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSA9PiB7XG4gICAgICAgICAgICAgICAgYy5kZWZlcnJlZC5yZXNvbHZlKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgYy5kZWZlcnJlZC5yZWplY3QoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWx3YXlzKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZWRDb250ZW50W2MudXJsXTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFydExvYWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdWaWV3LnN0b3BMb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBfZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuXG4vKipcbiAqIFNpbXBsZSBjb250YWluZXIgZm9yIGEgZ2l2ZW4gcGllY2Ugb2YgY29udGVudFxuICpcbiAqIEBjbGFzcyBMb2FkYWJsZUNvbnRlbnRNb2RlbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2FkYWJsZUNvbnRlbnRNb2RlbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB0aGlzLmltbWVkaWF0ZSA9IF9nZXQob3B0aW9ucywgJ2ltbWVkaWF0ZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2pzb24nO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGRpZ2l0c19pbnRlZ2VyIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3JhZGlvVXRpbGl0aWVzJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4uL2NvbnN0YW50cy9zZWxlY3RvcnMnO1xuaW1wb3J0IHsgVElNRSB9IGZyb20gJy4uL2NvbnN0YW50cy9nbG9iYWxDb25zdGFudHMnO1xuXG4vKipcbiAqIE1hbmFnZXMgYSBjbG9jayB0aGF0IHN0YXlzIGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCBnYW1lIHRpbWVcbiAqIEBjbGFzcyBHYW1lQ2xvY2tWaWV3XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVDbG9ja1ZpZXcge1xuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNsb2NrVmlld1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0KCRlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEdldCBjdXJyZW50IHRpbWUgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmVcbiAgICAqIEBmb3IgR2FtZUNsb2NrVmlld1xuICAgICogQHByb3BlcnR5IHJlYWxXb3JsZEN1cnJlbnRMb2NhbFRpbWVcbiAgICAqIEByZXR1cm4ge251bWJlcn0gbXMgc2luY2UgMDEvMDEvMTk3MCwgMDA6MDA6MDAgKHVzZXIncyB0aW1lIHpvbmUpXG4gICAgKi9cbiAgICBnZXQgcmVhbFdvcmxkQ3VycmVudExvY2FsVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogR2V0IGN1cnJlbnQgenVsdSB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICogQGZvciBHYW1lQ2xvY2tWaWV3XG4gICAgKiBAcHJvcGVydHkgcmVhbFdvcmxkQ3VycmVudFp1bHVUaW1lXG4gICAgKiBAcmV0dXJuIHV0YyB7bnVtYmVyfSBtcyBzaW5jZSAwMS8wMS8xOTcwLCAwMDowMDowMCBVVENcbiAgICAqL1xuICAgIGdldCByZWFsV29ybGRDdXJyZW50WnVsdVRpbWUoKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB1dGMgPSBkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBUSU1FLk9ORV9NSU5VVEVfSU5fTUlMTElTRUNPTkRTKTtcblxuICAgICAgICByZXR1cm4gdXRjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGZvciBHYW1lQ2xvY2tWaWV3XG4gICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAqIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYSBzdHJpbmcgb2YgdGhlIGN1cnJlbnQgZ2FtZSB0aW1lIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAgKiBAZm9yIEdhbWVDbG9ja1ZpZXdcbiAgICAqIEBwcm9wZXJ0eSB0aW1lU3RyaW5nXG4gICAgKiBAcmV0dXJuIGNsb2NrVGltZSB7c3RyaW5nfSBjdXJyZW50IGdhbWUgdGltZSBmb3JtYXR0ZWQgbGlrZSAnMDM6NDQ6MTcnXG4gICAgKi9cbiAgICBnZW5lcmF0ZUN1cnJlbnRUaW1lU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBnYW1lVGltZSA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLnRpbWU7XG4gICAgICAgIGNvbnN0IGNsb2NrRGF0ZSA9IG5ldyBEYXRlKHRoaXMuc3RhcnRUaW1lICsgKGdhbWVUaW1lICogVElNRS5PTkVfU0VDT05EX0lOX01JTExJU0VDT05EUykpO1xuICAgICAgICBjb25zdCBob3VycyA9IGRpZ2l0c19pbnRlZ2VyKGNsb2NrRGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IGRpZ2l0c19pbnRlZ2VyKGNsb2NrRGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gZGlnaXRzX2ludGVnZXIoY2xvY2tEYXRlLmdldFNlY29uZHMoKSwgMik7XG4gICAgICAgIGNvbnN0IGNsb2NrVGltZSA9IGAke2hvdXJzfToke21pbnV0ZXN9OiR7c2Vjb25kc31gO1xuXG4gICAgICAgIHJldHVybiBjbG9ja1RpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBzdG9yZWQgdGltZSBhbmQgZGlzcGxheWVkIHRpbWUgaW4gd2VicGFnZVxuICAgICogQGZvciBHYW1lQ2xvY2tWaWV3XG4gICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl90aWNrKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGZvciBHYW1lQ2xvY2tWaWV3XG4gICAgKiBAbWV0aG9kIF9pbml0XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2luaXQoJGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuQ0xPQ0spO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLk5PVF9TRUxFQ1RBQkxFKTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLnJlYWxXb3JsZEN1cnJlbnRadWx1VGltZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVwZGF0ZXMgdGhlIERPTSB3aXRoIHRoZSBuZXcgZ2FtZSB0aW1lXG4gICAgKiBAZm9yIEdhbWVDbG9ja1ZpZXdcbiAgICAqIEBtZXRob2QgX3JlbmRlclxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9yZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQudGV4dCh0aGlzLmdlbmVyYXRlQ3VycmVudFRpbWVTdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSB0aW1lIHN0b3JlZCBpbiB0aGUgY2xvY2tcbiAgICAqIEBmb3IgR2FtZUNsb2NrVmlld1xuICAgICogQG1ldGhvZCBfdGlja1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF90aWNrKCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZSA9IHdpbmRvdy5nYW1lQ29udHJvbGxlci5nYW1lLnRpbWUgKiBUSU1FLk9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTO1xuICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLnN0YXJ0VGltZSArIGVsYXBzZWRUaW1lO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLW1peGVkLW9wZXJhdG9ycywgZnVuYy1uYW1lcywgb2JqZWN0LXNob3J0aGFuZCxcbm5vLXVuZGVmLCBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC9mb3JFYWNoJztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IEdhbWVPcHRpb25zIGZyb20gJy4vR2FtZU9wdGlvbnMnO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi9tYXRoL2NvcmUnO1xuaW1wb3J0IHsgU0VMRUNUT1JTIH0gZnJvbSAnLi4vY29uc3RhbnRzL3NlbGVjdG9ycyc7XG5pbXBvcnQgeyBUSU1FIH0gZnJvbSAnLi4vY29uc3RhbnRzL2dsb2JhbENvbnN0YW50cyc7XG5cbi8vIFRlbXBvcmFyeSBjb25zdCBkZWNsYXJhdGlvbiBoZXJlIHRvIGF0dGFjaCB0byB0aGUgd2luZG93IEFORCB1c2UgYXMgaW50ZXJuYWwgcHJvcGVydHlcbmNvbnN0IGdhbWUgPSB7fTtcblxuLy8gVE9ETzogUmVtZW1iZXIgdG8gbW92ZSBtZSB0byB3aGVyZXZlciB0aGUgY29uc3RhbnRzIGVuZCB1cCBiZWluZyBtb3ZlZCB0b1xuLyoqXG4gKiBEZWZpbml0aW9ucyBvZiBwb2ludCB2YWx1ZXMgZm9yIGdpdmVuIGdhbWUgZXZlbnRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBHQU1FX0VWRU5UU19QT0lOVF9WQUxVRVMgPSB7XG4gICAgQUlSU1BBQ0VfQlVTVDogLTIwMCxcbiAgICBBUlJJVkFMOiAxMCxcbiAgICBDT0xMSVNJT046IC0xMDAwLFxuICAgIERFUEFSVFVSRTogMTAsXG4gICAgRVhUUkVNRV9DUk9TU1dJTkRfT1BFUkFUSU9OOiAtMTUsXG4gICAgRVhUUkVNRV9UQUlMV0lORF9PUEVSQVRJT046IC03NSxcbiAgICBHT19BUk9VTkQ6IC01MCxcbiAgICBISUdIX0NST1NTV0lORF9PUEVSQVRJT046IC01LFxuICAgIEhJR0hfVEFJTFdJTkRfT1BFUkFUSU9OOiAtMjUsXG4gICAgSUxMRUdBTF9BUFBST0FDSF9DTEVBUkFOQ0U6IC0xMCxcbiAgICBOT1RfQ0xFQVJFRF9PTl9ST1VURTogLTI1LFxuICAgIFNFUEFSQVRJT05fTE9TUzogLTIwMFxufTtcblxuLyoqXG4gKiBMaXN0IG9mIGdhbWUgZXZlbnRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgR0FNRV9FVkVOVFMgPSB7XG4gICAgQUlSU1BBQ0VfQlVTVDogJ0FJUlNQQUNFX0JVU1QnLFxuICAgIEFSUklWQUw6ICdBUlJJVkFMJyxcbiAgICBDT0xMSVNJT046ICdDT0xMSVNJT04nLFxuICAgIERFUEFSVFVSRTogJ0RFUEFSVFVSRScsXG4gICAgRVhUUkVNRV9DUk9TU1dJTkRfT1BFUkFUSU9OOiAnRVhUUkVNRV9DUk9TU1dJTkRfT1BFUkFUSU9OJyxcbiAgICBFWFRSRU1FX1RBSUxXSU5EX09QRVJBVElPTjogJ0VYVFJFTUVfVEFJTFdJTkRfT1BFUkFUSU9OJyxcbiAgICBHT19BUk9VTkQ6ICdHT19BUk9VTkQnLFxuICAgIEhJR0hfQ1JPU1NXSU5EX09QRVJBVElPTjogJ0hJR0hfQ1JPU1NXSU5EX09QRVJBVElPTicsXG4gICAgSElHSF9UQUlMV0lORF9PUEVSQVRJT046ICdISUdIX1RBSUxXSU5EX09QRVJBVElPTicsXG4gICAgSUxMRUdBTF9BUFBST0FDSF9DTEVBUkFOQ0U6ICdJTExFR0FMX0FQUFJPQUNIX0NMRUFSQU5DRScsXG4gICAgTk9UX0NMRUFSRURfT05fUk9VVEU6ICdOT1RfQ0xFQVJFRF9PTl9ST1VURScsXG4gICAgU0VQQVJBVElPTl9MT1NTOiAnU0VQQVJBVElPTl9MT1NTJ1xufTtcblxuLyoqXG4gKiBAY2xhc3MgR2FtZUNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdldERlbHRhVGltZSkge1xuICAgICAgICB0aGlzLmdldERlbHRhVGltZSA9IGdldERlbHRhVGltZTtcbiAgICAgICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICAgICAgdGhpcy5nYW1lLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2FtZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nYW1lLnNwZWVkdXAgPSAxO1xuICAgICAgICB0aGlzLmdhbWUuZnJlcXVlbmN5ID0gMTtcbiAgICAgICAgdGhpcy5nYW1lLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLmdhbWUuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5nYW1lLmRlbHRhID0gMDtcbiAgICAgICAgdGhpcy5nYW1lLmV2ZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmdhbWUudGltZW91dHMgPSBbXTtcbiAgICAgICAgdGhpcy5nYW1lLmxhc3Rfc2NvcmUgPSAwO1xuICAgICAgICB0aGlzLmdhbWUuc2NvcmUgPSAwO1xuICAgICAgICB0aGlzLmdhbWUub3B0aW9uID0gbmV3IEdhbWVPcHRpb25zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaW5pdF9wcmVcbiAgICAgKi9cbiAgICBpbml0X3ByZSgpIHtcbiAgICAgICAgdGhpcy5nYW1lX2luaXRpYWxpemVCbHVyRnVuY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzX2luaXRpYWxpemVFdmVudENvdW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBJbml0aWFsaXplIGBHYW1lQ29udHJvbGxlci5ldmVudHNgIHRvIGNvbnRhaW4gYXBwcm9wcmlhdGUgcHJvcGVydGllcyB3aXRoIHZhbHVlcyBvZiAwXG4gICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgKiBAbWV0aG9kIGV2ZW50c19pbml0aWFsaXplRXZlbnRDb3VudFxuICAgICogQHJldHVyblxuICAgICovXG4gICAgZXZlbnRzX2luaXRpYWxpemVFdmVudENvdW50KCkge1xuICAgICAgICBfZm9yRWFjaChHQU1FX0VWRU5UUywgKGdhbWVFdmVudCwga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdhbWUuZXZlbnRzW2tleV0gPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJlY29yZCBhIGdhbWUgZXZlbnQgdG8gdGhpcy5nYW1lLmV2ZW50cywgYW5kIHVwZGF0ZSB0aGlzLmdhbWUuc2NvcmVcbiAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAqIEBtZXRob2QgZXZlbnRzX3JlY29yZE5ld1xuICAgICogQHBhcmFtIGdhbWVFdmVudCB7U3RyaW5nfSBvbmUgb2YgdGhlIGV2ZW50cyBsaXN0ZWQgaW4gR0FNRV9FVkVOVFNcbiAgICAqL1xuICAgIGV2ZW50c19yZWNvcmROZXcoZ2FtZUV2ZW50KSB7XG4gICAgICAgIGlmICghX2hhcyhHQU1FX0VWRU5UUywgZ2FtZUV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBnYW1lIGV2ZW50IGxpc3RlZCBpbiBHQU1FX0VWRU5UUywgYnV0IGluc3RlYWQgcmVjZWl2ZWQgJHtnYW1lRXZlbnR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdhbWUuZXZlbnRzW2dhbWVFdmVudF0gKz0gMTtcbiAgICAgICAgdGhpcy5nYW1lLnNjb3JlICs9IEdBTUVfRVZFTlRTX1BPSU5UX1ZBTFVFU1tnYW1lRXZlbnRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogSW5pdGlhbGl6ZSBibHVyIGZ1bmN0aW9ucyB1c2VkIGR1cmluZyBnYW1lIHBhdXNpbmdcbiAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAqIEBtZXRob2QgZ2FtZV9pbml0aWFsaXplQmx1ckZ1bmN0aW9uc1xuICAgICogQHJldHVyblxuICAgICovXG4gICAgZ2FtZV9pbml0aWFsaXplQmx1ckZ1bmN0aW9ucygpIHtcbiAgICAgICAgLy8gU2V0IGJsdXJyaW5nIGZ1bmN0aW9uXG4gICAgICAgICQod2luZG93KS5ibHVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB1bi1ibHVycmluZyBmdW5jdGlvblxuICAgICAgICAkKHdpbmRvdykuZm9jdXMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nYW1lLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBnYW1lX2dldF93ZWlnaHRlZF9zY29yZVxuICAgICAqL1xuICAgIGdhbWVfZ2V0X3dlaWdodGVkX3Njb3JlKCkge1xuICAgICAgICBjb25zdCBob3Vyc1BsYXllZCA9IHRoaXMuZ2FtZV90aW1lKCkgLyBUSU1FLk9ORV9IT1VSX0lOX1NFQ09ORFM7XG4gICAgICAgIGNvbnN0IHNjb3JlUGVySG91ciA9IHRoaXMuZ2FtZS5zY29yZSAvIGhvdXJzUGxheWVkO1xuXG4gICAgICAgIHJldHVybiBzY29yZVBlckhvdXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZ2FtZV9yZXNldF9zY29yZV9hbmRfZXZlbnRzXG4gICAgICovXG4gICAgZ2FtZV9yZXNldF9zY29yZV9hbmRfZXZlbnRzKCkge1xuICAgICAgICAvLyBSZXNldCBldmVudHNcbiAgICAgICAgX2ZvckVhY2godGhpcy5nYW1lLmV2ZW50cywgKGdhbWVFdmVudCwga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdhbWUuZXZlbnRzW2tleV0gPSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZXNldCBzY29yZVxuICAgICAgICB0aGlzLmdhbWUuc2NvcmUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdhbWVfdGltZXdhcnBfdG9nZ2xlXG4gICAgICovXG4gICAgZ2FtZV90aW1ld2FycF90b2dnbGUoKSB7XG4gICAgICAgIGNvbnN0ICRmYXN0Rm9yd2FyZHMgPSAkKGAuJHtTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5GQVNUX0ZPUldBUkRTfWApO1xuXG4gICAgICAgIGlmICh0aGlzLmdhbWUuc3BlZWR1cCA9PT0gNSkge1xuICAgICAgICAgICAgdGhpcy5nYW1lLnNwZWVkdXAgPSAxO1xuXG4gICAgICAgICAgICAkZmFzdEZvcndhcmRzLnJlbW92ZUNsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlNQRUVEXzUpO1xuICAgICAgICAgICAgJGZhc3RGb3J3YXJkcy5wcm9wKCd0aXRsZScsICdTZXQgdGltZSB3YXJwIHRvIDInKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhbWUuc3BlZWR1cCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5nYW1lLnNwZWVkdXAgPSAyO1xuXG4gICAgICAgICAgICAkZmFzdEZvcndhcmRzLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlNQRUVEXzIpO1xuICAgICAgICAgICAgJGZhc3RGb3J3YXJkcy5wcm9wKCd0aXRsZScsICdTZXQgdGltZSB3YXJwIHRvIDUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5zcGVlZHVwID0gNTtcblxuICAgICAgICAgICAgJGZhc3RGb3J3YXJkcy5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5TUEVFRF8yKTtcbiAgICAgICAgICAgICRmYXN0Rm9yd2FyZHMuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuU1BFRURfNSk7XG4gICAgICAgICAgICAkZmFzdEZvcndhcmRzLnByb3AoJ3RpdGxlJywgJ1Jlc2V0IHRpbWUgd2FycCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZ2FtZV9wYXVzZVxuICAgICAqL1xuICAgIGdhbWVfcGF1c2UoKSB7XG4gICAgICAgIGNvbnN0ICRwYXVzZVRvZ2dsZSA9ICQoYC4ke1NFTEVDVE9SUy5DTEFTU05BTUVTLlBBVVNFX1RPR0dMRX1gKTtcbiAgICAgICAgdGhpcy5nYW1lLnBhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgJHBhdXNlVG9nZ2xlLmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLkFDVElWRSk7XG4gICAgICAgICRwYXVzZVRvZ2dsZS5hdHRyKCd0aXRsZScsICdSZXN1bWUgc2ltdWxhdGlvbicpO1xuICAgICAgICAkKCdodG1sJykuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUEFVU0VEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBnYW1lX3VucGF1c2VcbiAgICAgKi9cbiAgICBnYW1lX3VucGF1c2UoKSB7XG4gICAgICAgIGNvbnN0ICRwYXVzZVRvZ2dsZSA9ICQoYC4ke1NFTEVDVE9SUy5DTEFTU05BTUVTLlBBVVNFX1RPR0dMRX1gKTtcbiAgICAgICAgdGhpcy5nYW1lLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgICRwYXVzZVRvZ2dsZS5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICAkcGF1c2VUb2dnbGUuYXR0cigndGl0bGUnLCAnUGF1c2Ugc2ltdWxhdGlvbicpO1xuICAgICAgICAkKCdodG1sJykucmVtb3ZlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuUEFVU0VEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBnYW1lX3BhdXNlX3RvZ2dsZVxuICAgICAqL1xuICAgIGdhbWVfcGF1c2VfdG9nZ2xlKCkge1xuICAgICAgICAvLyBUT0RPOiBzaW1wbGlmeSBpZi9lbHNlIGxvZ2ljLiBzaG91bGQgb25seSBuZWVkIGFuIGlmIHdpdGggYW4gZWFybHkgZXhpdFxuICAgICAgICBpZiAodGhpcy5nYW1lLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nYW1lX3VucGF1c2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZV9wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZ2FtZV9wYXVzZWRcbiAgICAgKiBAcmV0dXJuXG4gICAgICovXG4gICAgZ2FtZV9wYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nYW1lLmZvY3VzZWQgfHwgdGhpcy5nYW1lLnBhdXNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBnYW1lX3RpbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2FtZV90aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYW1lLnRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgZ2FtZV9kZWx0YVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnYW1lX2RlbHRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYW1lLmRlbHRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdhbWVfc3BlZWR1cFxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBnYW1lX3NwZWVkdXAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nYW1lX3BhdXNlZCgpID8gdGhpcy5nYW1lLnNwZWVkdXAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdhbWVfdGltZW91dFxuICAgICAqIEBwYXJhbSBmdW5jIHtmdW5jdGlvbn1cbiAgICAgKiBAcHJhbSBkZWxheSB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB0aGF0XG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJuIGdhbWVUaW1lb3V0XG4gICAgICovXG4gICAgZ2FtZV90aW1lb3V0KGZ1bmMsIGRlbGF5LCB0aGF0LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGdhbWVUaW1lb3V0ID0gW2Z1bmMsIHRoaXMuZ2FtZV90aW1lKCkgKyBkZWxheSwgZGF0YSwgZGVsYXksIGZhbHNlLCB0aGF0XTtcblxuICAgICAgICB0aGlzLmdhbWUudGltZW91dHMucHVzaChnYW1lVGltZW91dCk7XG5cbiAgICAgICAgcmV0dXJuIGdhbWVUaW1lb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdhbWVfaW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0gZnVuYyB7ZnVuY3Rpb259XG4gICAgICogQHByYW0gZGVsYXkge251bWJlcn1cbiAgICAgKiBAcGFyYW0gdGhhdFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybiB0b1xuICAgICAqL1xuICAgIGdhbWVfaW50ZXJ2YWwoZnVuYywgZGVsYXksIHRoYXQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdG8gPSBbZnVuYywgdGhpcy5nYW1lX3RpbWUoKSArIGRlbGF5LCBkYXRhLCBkZWxheSwgdHJ1ZSwgdGhhdF07XG5cbiAgICAgICAgdGhpcy5nYW1lLnRpbWVvdXRzLnB1c2godG8pO1xuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBnYW1lX2NsZWFyX3RpbWVvdXRcbiAgICAgKiBAcGFyYW0gZ2FtZVRpbWVvdXRcbiAgICAgKi9cbiAgICBnYW1lX2NsZWFyX3RpbWVvdXQoZ2FtZVRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5nYW1lLnRpbWVvdXRzLnNwbGljZSh0aGlzLmdhbWUudGltZW91dHMuaW5kZXhPZihnYW1lVGltZW91dCksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdhbWVfdXBkYXRlU2NvcmVcbiAgICAgKiBAcGFyYW0gc2NvcmUge251bWJlcn1cbiAgICAgKi9cbiAgICBnYW1lX3VwZGF0ZVNjb3JlKHNjb3JlKSB7XG4gICAgICAgIGNvbnN0ICRzY29yZSA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuU0NPUkUpO1xuICAgICAgICAkc2NvcmUudGV4dChyb3VuZChzY29yZSkpO1xuXG4gICAgICAgIGlmIChzY29yZSA8IC0wLjUxKSB7XG4gICAgICAgICAgICAkc2NvcmUuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuTkVHQVRJVkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3JlLnJlbW92ZUNsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLk5FR0FUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2FtZS5sYXN0X3Njb3JlID0gc2NvcmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgdXBkYXRlX3ByZVxuICAgICAqL1xuICAgIHVwZGF0ZV9wcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdhbWUuc2NvcmUgIT09IHRoaXMuZ2FtZS5sYXN0X3Njb3JlKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWVfdXBkYXRlU2NvcmUodGhpcy5nYW1lLnNjb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2FtZS5kZWx0YSA9IE1hdGgubWluKHRoaXMuZ2V0RGVsdGFUaW1lKCkgKiB0aGlzLmdhbWUuc3BlZWR1cCwgMTAwKTtcblxuICAgICAgICBpZiAodGhpcy5nYW1lX3BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWUuZGVsdGEgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlBBVVNFRCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdhbWUudGltZSArPSB0aGlzLmdhbWUuZGVsdGE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZ2FtZS50aW1lb3V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJlbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZ2FtZS50aW1lb3V0c1tpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZV90aW1lKCkgPiB0aW1lb3V0WzFdKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dFswXS5jYWxsKHRpbWVvdXRbNV0sIHRpbWVvdXRbMl0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFsxXSArPSB0aW1lb3V0WzNdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lLnRpbWVvdXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBjb21wbGV0ZVxuICAgICAqL1xuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmdhbWUucGF1c2VkID0gZmFsc2U7XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tbWl4ZWQtb3BlcmF0b3JzLCBmdW5jLW5hbWVzLCBvYmplY3Qtc2hvcnRoYW5kICovXG5pbXBvcnQgX2hhcyBmcm9tICdsb2Rhc2gvaGFzJztcbmltcG9ydCB7IEdBTUVfT1BUSU9OX1ZBTFVFUyB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lT3B0aW9uQ29uc3RhbnRzJztcblxuLyoqXG4gKiBTZXQsIHN0b3JlIGFuZCByZXRyaWV2ZSBnYW1lIG9wdGlvbnMuXG4gKlxuICogQGNsYXNzIEdhbWVPcHRpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVPcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLmFkZEdhbWVPcHRpb25zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lT3B0aW9uc1xuICAgICAqIEBtZXRob2QgYWRkR2FtZU9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRHYW1lT3B0aW9ucygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBHQU1FX09QVElPTl9WQUxVRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IEdBTUVfT1BUSU9OX1ZBTFVFU1tpXTtcblxuICAgICAgICAgICAgdGhpcy5hZGRPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZU9wdGlvbnNcbiAgICAgKiBAbWV0aG9kIGFkZE9wdGlvblxuICAgICAqL1xuICAgIGFkZE9wdGlvbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblN0b3JhZ2VOYW1lID0gYHpsc2EuYXRjLm9wdGlvbi4ke2RhdGEubmFtZX1gO1xuICAgICAgICB0aGlzLl9vcHRpb25zW2RhdGEubmFtZV0gPSBkYXRhO1xuXG4gICAgICAgIGxldCBkYXRhTmFtZSA9IGRhdGEuZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAoX2hhcyhsb2NhbFN0b3JhZ2UsIG9wdGlvblN0b3JhZ2VOYW1lKSkge1xuICAgICAgICAgICAgZGF0YU5hbWUgPSBsb2NhbFN0b3JhZ2Vbb3B0aW9uU3RvcmFnZU5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tkYXRhLm5hbWVdID0gZGF0YU5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZvciBHYW1lT3B0aW9uc1xuICAgICAqIEBtZXRob2QgZ2V0RGVzY3JpcHRpb25zXG4gICAgICovXG4gICAgZ2V0RGVzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIEdhbWVPcHRpb25zXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgR2FtZU9wdGlvbnNcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZVtgemxzYS5hdGMub3B0aW9uLiR7bmFtZX1gXSA9IHZhbHVlO1xuICAgICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5yZXF1aXJlKCdyYWYnKS5wb2x5ZmlsbCgpO1xuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5cbi8qKlxuICogRW50cnkgcG9pbnQgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBncmFiIHRoZSBgYm9keWAgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnQgYW5kIHBhc3MgaXQgdG8gdGhlIGFwcC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+IHtcbiAgICBjb25zdCBhaXJwb3J0TG9hZExpc3QgPSB3aW5kb3cuQUlSUE9SVF9MT0FEX0xJU1Q7XG4gICAgY29uc3QgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgY29uc3QgYXBwID0gbmV3IEFwcCgkYm9keSwgYWlycG9ydExvYWRMaXN0KTtcbn0pKCk7XG4iLCJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgcmFkaWFuc1RvRGVncmVlcywgZGVncmVlc1RvUmFkaWFucyB9IGZyb20gJy4uL3V0aWxpdGllcy91bml0Q29udmVydGVycyc7XG5cbi8qKlxuICogMnggUGlcbiAqXG4gKiBAZnVuY3Rpb24gdGF1XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB0YXUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguUEkgKiAyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbmdsZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGhlYWRpbmdzXG4gKlxuICogQGZ1bmN0aW9uIGFuZ2xlX29mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGEgICAgIGhlYWRpbmcsIGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBiICAgICBoZWFkaW5nLCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBhbmdsZV9vZmZzZXQgPSAoYSwgYikgPT4ge1xuICAgIGEgPSByYWRpYW5zVG9EZWdyZWVzKGEpO1xuICAgIGIgPSByYWRpYW5zVG9EZWdyZWVzKGIpO1xuICAgIGxldCBpbnZlcnQgPSBmYWxzZTtcblxuICAgIGlmIChiID4gYSkge1xuICAgICAgICBpbnZlcnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0ZW1wID0gYTtcblxuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHRlbXA7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldCA9IG1vZChhIC0gYiwgMzYwKTtcbiAgICBpZiAob2Zmc2V0ID4gMTgwKSB7XG4gICAgICAgIG9mZnNldCAtPSAzNjA7XG4gICAgfVxuXG4gICAgaWYgKGludmVydCkge1xuICAgICAgICBvZmZzZXQgKj0gLTE7XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gZGVncmVlc1RvUmFkaWFucyhvZmZzZXQpO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbn07XG5cbi8qKlxuICogbm9ybWFsaXplIGFuZ2xlcyB0byB3aXRoaW4gMMKwIC0gMzYwwrBcbiAqIEBwYXJhbSAge251bWJlcn0gZGVncmVlcyBhbiBhbmdsZVxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgIGFuIGFuZ2xlIHdpdGhpbiBbMCwzNjBdXG4gKi9cbmV4cG9ydCBjb25zdCBkZWdyZWVzX25vcm1hbGl6ZSA9IChkZWdyZWVzKSA9PiB7XG4gICAgaWYgKGRlZ3JlZXMgPj0gMCkge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgJSAzNjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIDM2MCArIChkZWdyZWVzICUgMzYwKTtcbn07XG5cbi8qKlxuICogbm9ybWFsaXplIGFuZ2xlcyB0byB3aXRoaW4gMCAtIDLPgFxuICogQHBhcmFtICB7bnVtYmVyfSByYWRpYW5zIGFuIGFuZ2xlXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgYW4gYW5nbGUgd2l0aGluIFswLDLPgF1cbiAqL1xuZXhwb3J0IGNvbnN0IHJhZGlhbnNfbm9ybWFsaXplID0gKHJhZGlhbnMpID0+IHtcbiAgICBpZiAocmFkaWFucyA+PSAwKSB7XG4gICAgICByZXR1cm4gcmFkaWFucyAlICh0YXUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhdSgpICsgKHJhZGlhbnMgJSB0YXUoKSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gbGF0L2xvbmcgY29vcmRpbmF0ZXMgaW4ga21cbiAqXG4gKiBUaGlzIGlzIGEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSGF2ZXJzaW5lIEZvcm11bGFcbiAqXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgbWF0aCBzZWU6XG4gKiAtIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG4gKiAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc5MjgvY2FsY3VsYXRlLWRpc3RhbmNlLWJldHdlZW4tdHdvLWxhdGl0dWRlLWxvbmdpdHVkZS1wb2ludHMtaGF2ZXJzaW5lLWZvcm11bGFcbiAqXG4gKiBAZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50XG4gKiBAcGFyYW0gc3RhcnRMYXRpdHVkZSB7bnVtYmVyfVxuICogQHBhcmFtIHN0YXJ0TG9uZ2l0dWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gZW5kTGF0aXR1ZGUge251bWJlcn1cbiAqIEBwYXJhbSBlbmRMb25naXR1ZGUge251bWJlcn1cbiAqIHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGlzdGFuY2VUb1BvaW50ID0gKHN0YXJ0TGF0aXR1ZGUsIHN0YXJ0TG9uZ2l0dWRlLCBlbmRMYXRpdHVkZSwgZW5kTG9uZ2l0dWRlKSA9PiB7XG4gICAgLy8gVE9ETzogYWRkIHRvIGdsb2JhbCBjb25zdGFudHNcbiAgICBjb25zdCBFQVJUSF9SQURJVVNfS00gPSA2MzcxO1xuICAgIGNvbnN0IHN0YXJ0TGF0aXR1ZGVSYWRpYW5zID0gZGVncmVlc1RvUmFkaWFucyhzdGFydExhdGl0dWRlKTtcbiAgICBjb25zdCBlbmRMYXRpdHVkZVJhZGlhbnMgPSBkZWdyZWVzVG9SYWRpYW5zKGVuZExhdGl0dWRlKTtcbiAgICBjb25zdCBkaXN0YW5jZUxhdGl0dWRlID0gZGVncmVlc1RvUmFkaWFucyhzdGFydExhdGl0dWRlIC0gZW5kTGF0aXR1ZGUpO1xuICAgIGNvbnN0IGRpc3RhbmNlTG9uZ2l0dWRlID0gZGVncmVlc1RvUmFkaWFucyhzdGFydExvbmdpdHVkZSAtIGVuZExvbmdpdHVkZSk7XG5cbiAgICAvLyB0aGUgc3F1YXJlIG9mIGhhbGYgdGhlIGNob3JkIGxlbmd0aCBiZXR3ZWVuIHBvaW50c1xuICAgIGNvbnN0IGEgPSBNYXRoLnBvdyhNYXRoLnNpbihkaXN0YW5jZUxhdGl0dWRlIC8gMiksIDIpICtcbiAgICAgICAgKE1hdGguY29zKHN0YXJ0TGF0aXR1ZGVSYWRpYW5zKSAqIE1hdGguY29zKGVuZExhdGl0dWRlUmFkaWFucykgKiBNYXRoLnBvdyhNYXRoLnNpbihkaXN0YW5jZUxvbmdpdHVkZSAvIDIpLCAyKSk7XG5cblxuICAgIGNvbnN0IGFuZ3VsYXJEaXN0YW5jZUluUmFkaWFucyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cbiAgICByZXR1cm4gYW5ndWxhckRpc3RhbmNlSW5SYWRpYW5zICogRUFSVEhfUkFESVVTX0tNO1xufTtcblxuLy8gLyoqXG4vLyAgKlxuLy8gICogQGZ1bmN0aW9uIGRpc3RFdWNsaWRcbi8vICAqIEBwYXJhbVxuLy8gICogQHBhcmFtXG4vLyAgKiBAcmV0dXJuXG4vLyAgKi9cbi8vIGV4cG9ydCBjb25zdCBkaXN0RXVjbGlkID0gKGxhdDEsIGxvbjEsIGxhdDIsIGxvbjIpID0+IHtcbi8vICAgICAvLyBUT0RPOiBhZGQgdG8gZ2xvYmFsIGNvbnN0YW50c1xuLy8gICAgIGNvbnN0IEVBUlRIX1JBRElVU19LTSA9IDYzNzE7XG4vLyAgICAgY29uc3QgbGF0MSA9IGRlZ3JlZXNUb1JhZGlhbnMobGF0MSk7XG4vLyAgICAgY29uc3QgbGF0MiA9IGRlZ3JlZXNUb1JhZGlhbnMobGF0Mik7XG4vLyAgICAgY29uc3QgZGxhdCA9IGRlZ3JlZXNUb1JhZGlhbnMobGF0MiAtIGxhdDEpO1xuLy8gICAgIGNvbnN0IGRsb24gPSBkZWdyZWVzVG9SYWRpYW5zKGxvbjIgLSBsb24xKTtcbi8vXG4vLyAgICAgY29uc3QgYSA9IE1hdGguc2luKGRsYXQgLyAyKSAqIE1hdGguc2luKGRsYXQgLyAyKSArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLnNpbihkbG9uIC8gMikgKiBNYXRoLnNpbihkbG9uIC8gMik7XG4vLyAgICAgY29uc3QgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG4vLyAgICAgY29uc3QgZCA9IEVBUlRIX1JBRElVU19LTSAqIGM7XG4vL1xuLy8gICAgIHJldHVybiBkOyAvLyBkaXN0YW5jZSwgaW4ga2lsb21ldGVyc1xuLy8gfTtcbiIsImltcG9ydCBfaXNOdW1iZXIgZnJvbSAnbG9kYXNoL2lzTnVtYmVyJztcblxuLyoqXG4gKiBAZnVuY3Rpb24gcm91bmRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJvdW5kID0gKG4sIGZhY3RvciA9IDEpID0+IHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChuIC8gZmFjdG9yKSAqIGZhY3Rvcjtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGFic1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgYWJzID0gKG4pID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMobik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBzaW5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNpbiA9IChhKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguc2luKGEpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY29zXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjb3MgPSAoYSkgPT4ge1xuICAgIHJldHVybiBNYXRoLmNvcyhhKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHRhblxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdGFuID0gKGEpID0+IHtcbiAgICByZXR1cm4gTWF0aC50YW4oYSk7XG59O1xuXG4vLyBUT0RPOiByZW5hbWUgdG8gZmxvb3IsXG4vKipcbiAqIEBmdW5jdGlvbiBmbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZmwgPSAobiwgbnVtYmVyID0gMSkgPT4ge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyBudW1iZXIpICogbnVtYmVyO1xufTtcblxuLy8gVE9ETzogcmVuYW1lIHRvIHJhbmRvbUludGVnZXJcbi8qKlxuICogQGZ1bmN0aW9uIHJhbmRpbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJhbmRpbnQgPSAobG93LCBoaWdoKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93ICsgMSkpICsgbG93O1xufTtcblxuLy8gVE9ETzogcmVuYW1lIHRvIHBsdXJhbGl6ZVxuLyoqXG4gKiBAZnVuY3Rpb24gc1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcyA9IChpKSA9PiB7XG4gICAgcmV0dXJuIChpID09PSAxKSA/ICcnIDogJ3MnO1xufTtcblxuLy8gVE9ETzogcmVuYW1lIHRvIGlzV2l0aGluXG4vKipcbiAqIEBmdW5jdGlvbiB3aXRoaW5cbiAqIEBwYXJhbSBuXG4gKiBAcGFyYW0gY1xuICogQHBhcmFtIHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhpbiA9IChuLCBjLCByKSA9PiB7XG4gICAgcmV0dXJuIG4gPiAoYyArIHIpIHx8IG4gPCAoYyAtIHIpO1xufTtcblxuLy8gVE9ETzogYWRkIGEgZGl2aXNvciBwYXJhbWF0ZXIgdGhhdCBkZmF1bHRzIHRvIGAyYFxuLyoqXG4gKiBHaXZlbiBhIG51bWJlciwgZmluZCB0aGUgbWlkZGxlIHZhbHVlLlxuICpcbiAqIEBtZXRob2QgY2FsY3VsYXRlTWlkZGxlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVNaWRkbGUgPSAodmFsdWUgPSAwKSA9PiB7XG4gICAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyLCBleHBlY3RlZCBhIG51bWJlciBidXQgZm91bmQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdW5kKHZhbHVlIC8gMik7XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gbW9kXG4gKiBAcGFyYW0gZmlyc3RWYWx1ZSB7bnVtYmVyfVxuICogQHBhcmFtIHNlY29uZFZhbHVlIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBtb2QgPSAoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUpID0+IHtcbiAgICByZXR1cm4gKChmaXJzdFZhbHVlICUgc2Vjb25kVmFsdWUpICsgc2Vjb25kVmFsdWUpICUgc2Vjb25kVmFsdWU7XG59O1xuXG4vKipcbiAqIENsYW1wIGEgdmFsdWUgdG8gYmUgd2l0aGluIGEgY2VydGFpbiByYW5nZVxuICpcbiAqIEBmdW5jdGlvbiBjbGFtcFxuICogQHBhcmFtIG1pbiB7bnVtYmVyfVxuICogQHBhcmFtIHZhbHVlVG9DbGFtcCB7bnVtYmVyfVxuICogQHBhcmFtIG1heCB7bnVtYmVyfSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjbGFtcCA9IChtaW4sIHZhbHVlVG9DbGFtcCwgbWF4ID0gSW5maW5pdHkpID0+IHtcbiAgICBsZXQgdGVtcDtcblxuICAgIGlmICghX2lzTnVtYmVyKHZhbHVlVG9DbGFtcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIuIEV4cGVjdGVkIGB2YWx1ZVRvQ2xhbXBgIHRvIGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlVG9DbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xhbXA7XG4gICAgfVxuXG4gICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICB0ZW1wID0gbWF4O1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IHRlbXA7XG4gICAgfVxuXG4gICAgaWYgKG1pbiA+IHZhbHVlVG9DbGFtcCkge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cblxuICAgIGlmIChtYXggPCB2YWx1ZVRvQ2xhbXApIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVUb0NsYW1wO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHZhbHVlJ3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gYSBnaXZlbiByYW5nZSwgYW5kIGV4dHJhcG9sYXRlcyB0byBhbm90aGVyIHJhbmdlLlxuICogTm90ZTogUmV0dXJuIHdpbGwgYmUgb3V0c2lkZSByYW5nZTIgaWYgdGFyZ2V0X3ZhbCBpcyBvdXRzaWRlIHJhbmdlMS5cbiAqICAgICAgIElmIHlvdSB3aXNoIHRvIGNsYW1wIGl0IHdpdGhpbiByYW5nZTIsIHVzZSBleHRyYXBvbGF0ZV9yYW5nZV9jbGFtcC5cbiAqIEBmdW5jdGlvbiBleHRyYXBvbGF0ZV9yYW5nZVxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZTFfbWluIG1pbmltdW0gdmFsdWUgb2YgcmFuZ2UgMVxuICogQHBhcmFtICB7bnVtYmVyfSB0YXJnZXRfdmFsIHRhcmdldCB2YWx1ZSB3aXRoaW4gcmFuZ2UgMVxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZTFfbWF4IG1heGltdW0gdmFsdWUgb2YgcmFuZ2UgMVxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZTJfbWluIG1pbmltdW0gdmFsdWUgb2YgcmFuZ2UgMlxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZTJfbWF4IG1heGltdW0gdmFsdWUgb2YgcmFuZ2UgMlxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgIHRhcmdldCB2YWx1ZSB3aWh0aW4gcmFuZ2UgMlxuICovXG5jb25zdCBleHRyYXBvbGF0ZV9yYW5nZSA9IChyYW5nZTFfbWluLCB0YXJnZXRfdmFsLCByYW5nZTFfbWF4LCByYW5nZTJfbWluLCByYW5nZTJfbWF4KSA9PiB7XG4gICAgcmV0dXJuIHJhbmdlMl9taW4gKyAocmFuZ2UyX21heCAtIHJhbmdlMl9taW4pICogKHRhcmdldF92YWwgLSByYW5nZTFfbWluKSAvIChyYW5nZTFfbWF4IC0gcmFuZ2UxX21pbik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgdmFsdWUncyBwb3NpdGlvbiByZWxhdGl2ZSB0byBhIGdpdmVuIHJhbmdlLCBhbmQgZXh0cmFwb2xhdGVzIHRvIChhbmQgY2xhbXBzIHdpdGhpbikgYW5vdGhlciByYW5nZS5cbiAqIE5vdGU6IFJldHVybiB3aWxsIGJlIGNsYW1wZWQgd2l0aGluIHJhbmdlMiwgZXZlbiBpZiB0YXJnZXRfdmFsIGlzIG91dHNpZGUgcmFuZ2UxLlxuICogICAgICAgSWYgeW91IHdpc2ggdG8gYWxsb3cgZXh0cmFwb2xhdGlvbiBiZXlvbmQgdGhlIGJvdW5kcyBvZiByYW5nZTIsIHVzIGV4dHJhcG9sYXRlX3JhbmdlLlxuICogQGZ1bmN0aW9uIGV4dHJhcG9sYXRlX3JhbmdlX2NsYW1wXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJhbmdlMV9taW4gbWluaW11bSB2YWx1ZSBvZiByYW5nZTFcbiAqIEBwYXJhbSAge251bWJlcn0gdGFyZ2V0X3ZhbCB0YXJnZXQgdmFsdWUgcmVsYXRpdmUgdG8gcmFuZ2UxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJhbmdlMV9tYXggbWF4aW11bSB2YWx1ZSBvZiByYW5nZTFcbiAqIEBwYXJhbSAge251bWJlcn0gcmFuZ2UyX21pbiBtaW5pbXVtIHZhbHVlIG9mIHJhbmdlMlxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZTJfbWF4IG1heGltdW0gdmFsdWUgb2YgcmFuZ2UyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgdGFyZ2V0IHZhbHVlIHdpdGhpbiByYW5nZTJcbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhcG9sYXRlX3JhbmdlX2NsYW1wID0gKHJhbmdlMV9taW4sIHRhcmdldF92YWwsIHJhbmdlMV9tYXgsIHJhbmdlMl9taW4sIHJhbmdlMl9tYXgpID0+IHtcbiAgICBjb25zdCBleHRyYXBvbGF0aW9uX3Jlc3VsdCA9IGV4dHJhcG9sYXRlX3JhbmdlKHJhbmdlMV9taW4sIHRhcmdldF92YWwsIHJhbmdlMV9tYXgsIHJhbmdlMl9taW4sIHJhbmdlMl9tYXgpO1xuXG4gICAgcmV0dXJuIGNsYW1wKGV4dHJhcG9sYXRpb25fcmVzdWx0LCByYW5nZTJfbWluLCByYW5nZTJfbWF4KTtcbn07XG4iLCIvKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBpbiBhIDJkIHBsYW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICpcbiAqIEBmdW5jdGlvbiBkaXN0YW5jZTJkXG4gKiBAcGFyYW0gYSB7YXJyYXl9XG4gKiBAcGFyYW0gYiB7YXJyYXl9XG4gKiByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc3RhbmNlMmQgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IHggPSBhWzBdIC0gYlswXTtcbiAgICBjb25zdCB5ID0gYVsxXSAtIGJbMV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn07XG4iLCJpbXBvcnQgeyBzaW4sIGNvcywgdGFuLCBhYnMgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGFuY2UyZCB9IGZyb20gJy4vZGlzdGFuY2UnO1xuaW1wb3J0IHtcbiAgICB2cmFkaWFsLFxuICAgIHZzdWIsXG4gICAgdmxlbixcbiAgICBwb2ludF9pbl9hcmVhLFxuICAgIGRpc3RhbmNlX3RvX3BvbHksXG4gICAgYXJlYV90b19wb2x5XG59IGZyb20gJy4vdmVjdG9yJztcbmltcG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMsIHJhZGlhbnNUb0RlZ3JlZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMnO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBDT05TVEFOVFNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuY29uc3QgQ09OU1RBTlRTID0ge1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgR1JBVklUQVRJT05BTF9NQUdOSVRVREU6IDkuODEsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgRUFSVEhfUkFESVVTX05NXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBFQVJUSF9SQURJVVNfTk06IDM0NDBcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGNhbGNUdXJuUmFkaXVzXG4gKiBAcGFyYW0gc3BlZWQge251bWJlcn0gY3VycmVudFNwZWVkIG9mIGFuIGFpcmNyYWZ0XG4gKiBAcGFyYW0gYmFua0FuZ2xlIHtudW1iZXJ9IGJhbmsgYW5nbGUgb2YgYW4gYWlyY3JhZnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGNUdXJuUmFkaXVzID0gKHNwZWVkLCBiYW5rQW5nbGUpID0+IHtcbiAgICByZXR1cm4gKHNwZWVkICogc3BlZWQpIC8gKENPTlNUQU5UUy5HUkFWSVRBVElPTkFMX01BR05JVFVERSAqIHRhbihiYW5rQW5nbGUpKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGNhbGNUdXJuSW5pdGlhdGlvbkRpc3RhbmNlXG4gKiBAcGFyYW0gc3BlZWQge251bWJlcn0gICAgICAgICAgICBjdXJyZW50U3BlZWQgb2YgYW4gYWlyY3JhZnRcbiAqIEBwYXJhbSBiYW5rQW5nbGUge251bWJlcn0gICAgICAgIGJhbmsgYW5nbGUgb2YgYW4gYWlyY3JhZnRcbiAqIEBwYXJhbSBjb3Vyc2VDaGFuZ2Uge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGNUdXJuSW5pdGlhdGlvbkRpc3RhbmNlID0gKHNwZWVkLCBiYW5rQW5nbGUsIGNvdXJzZUNoYW5nZSkgPT4ge1xuICAgIGNvbnN0IHR1cm5SYWRpdXMgPSBjYWxjVHVyblJhZGl1cyhzcGVlZCwgYmFua0FuZ2xlKTtcblxuICAgIHJldHVybiB0dXJuUmFkaXVzICogdGFuKGNvdXJzZUNoYW5nZSAvIDIpICsgc3BlZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJlYXJpbmcgZnJvbSBgc3RhcnRQb3NpdGlvbmAgdG8gYGVuZFBvc2l0aW9uYFxuICogQGZ1bmN0aW9uIGJlYXJpbmdUb1BvaW50XG4gKiBAcGFyYW0gc3RhcnRQb3NpdGlvbiB7YXJyYXl9ICAgICBwb3NpdGlvbmFsIGFycmF5LCBzdGFydCBwb2ludFxuICogQHBhcmFtIGVuZFBvc2l0aW9uIHthcnJheX0gICAgICAgcG9zaXRpb25hbCBhcnJheSwgZW5kIHBvaW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBiZWFyaW5nVG9Qb2ludCA9IChzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikgPT4gdnJhZGlhbCh2c3ViKGVuZFBvc2l0aW9uLCBzdGFydFBvc2l0aW9uKSk7XG5cbi8vIFRPRE86IHRoaXMgbWF5IGJlIGJldHRlciBzdWl0ZWQgdG8gbGl2ZSBpbiBhbiBBaXJjcmFmdCBtb2RlbCBzb21ld2hlcmUuXG4vKipcbiAqIFJldHVybnMgYW4gb2Zmc2V0IGFycmF5IHNob3dpbmcgaG93IGZhciBbZndkL2J3ZCwgbGVmdC9yaWdodF0gJ2FpcmNyYWZ0JyBpcyBvZiAndGFyZ2V0J1xuICpcbiAqIEBwYXJhbSBhaXJjcmFmdCB7QWlyY3JhZnR9ICAgICAgICAgICB0aGUgYWlyY3JhZnQgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB0YXJnZXQge2FycmF5fSAgICAgICAgICAgICAgICBwb3NpdGlvbmFsIGFycmF5IG9mIHRoZSB0YXJnZXRlZCBwb3NpdGlvbiBbeCx5XVxuICogQHBhcmFtIGhlYWRpbmdUaHJ1VGFyZ2V0IHtudW1iZXJ9ICAgIChvcHRpb25hbCkgVGhlIGhlYWRpbmcgdGhlIGFpcmNyYWZ0IHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGVzdGFibGlzaGVkIG9uIHdoZW4gcGFzc2luZyB0aGUgdGFyZ2V0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgdGhlIGFpcmNyYWZ0J3MgaGVhZGluZy5cbiAqIEByZXR1cm5zIHthcnJheX0gd2l0aCB0d28gZWxlbWVudHM6ICByZXR2YWxbMF0gaXMgdGhlIGxhdGVyYWwgb2Zmc2V0LCBpbiBrbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbFsxXSBpcyB0aGUgbG9uZ2l0dWRpbmFsIG9mZnNldCwgaW4ga21cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWxbMl0gaXMgdGhlIGh5cG90ZW51c2UgKHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UpLCBpbiBrbVxuICovXG5leHBvcnQgY29uc3QgZ2V0T2Zmc2V0ID0gKGFpcmNyYWZ0LCB0YXJnZXQsIGhlYWRpbmdUaHJ1VGFyZ2V0ID0gbnVsbCkgPT4ge1xuICAgIGlmICghaGVhZGluZ1RocnVUYXJnZXQpIHtcbiAgICAgICAgaGVhZGluZ1RocnVUYXJnZXQgPSBhaXJjcmFmdC5oZWFkaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldCA9IFswLCAwLCAwXTtcbiAgICBjb25zdCB2ZWN0b3IgPSB2c3ViKHRhcmdldCwgYWlyY3JhZnQucG9zaXRpb24pOyAvLyB2ZWN0b3IgZnJvbSBhaXJjcmFmdCBwb2ludGluZyB0byB0YXJnZXRcbiAgICBjb25zdCBiZWFyaW5nVG9UYXJnZXQgPSB2cmFkaWFsKHZlY3Rvcik7XG5cbiAgICBvZmZzZXRbMl0gPSB2bGVuKHZlY3Rvcik7XG4gICAgb2Zmc2V0WzBdID0gb2Zmc2V0WzJdICogc2luKGhlYWRpbmdUaHJ1VGFyZ2V0IC0gYmVhcmluZ1RvVGFyZ2V0KTtcbiAgICBvZmZzZXRbMV0gPSBvZmZzZXRbMl0gKiBjb3MoaGVhZGluZ1RocnVUYXJnZXQgLSBiZWFyaW5nVG9UYXJnZXQpO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBwb3NpdGlvbiBieSBmaXgtcmFkaWFsLWRpc3RhbmNlIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGZpeCAgICAgICBwb3NpdGlvbmFsIGFycmF5IG9mIHN0YXJ0IHBvaW50LCBpbiBkZWNpbWFsLWRlZ3JlZXMgW2xhdCxsb25dXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsICAgaGVhZGluZyB0byBwcm9qZWN0IGFsb25nLCBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdCAgICAgZGlzdGFuY2UgdG8gcHJvamVjdCwgaW4gbm1cbiAqIEByZXR1cm5zIHthcnJheX0gICAgICAgICBsb2NhdGlvbiBvZiB0aGUgcHJvamVjdGVkIGZpeCwgaW4gZGVjaW1hbC1kZWdyZWVzIFtsYXQsbG9uXVxuICovXG5leHBvcnQgY29uc3QgZml4UmFkaWFsRGlzdCA9IChmaXgsIHJhZGlhbCwgZGlzdCkgPT4ge1xuICAgIC8vIEZJWE1FOiBpZiBmaXggaXMgYSBGaXhNb2RlbCwgdGhlcmUgbWF5IGFscmVhZHkgYmUgYSBtZXRob2QgZm9yIHRoaXMuIGlmIHRoZXJlIGlzbnQgdGhlcmUgc2hvdWxkIGJlLiBgZml4LnBvc2l0aW9uSW5SYWRpYW5zYFxuICAgIC8vIGNvbnZlcnQgR1BTIGNvb3JkaW5hdGVzIHRvIHJhZGlhbnNcbiAgICBmaXggPSBbXG4gICAgICAgIGRlZ3JlZXNUb1JhZGlhbnMoZml4WzBdKSxcbiAgICAgICAgZGVncmVlc1RvUmFkaWFucyhmaXhbMV0pXG4gICAgXTtcblxuICAgIGNvbnN0IFIgPSBDT05TVEFOVFMuRUFSVEhfUkFESVVTX05NO1xuICAgIC8vIFRPRE86IGFic3RyYWN0IHRoZXNlIHR3byBjYWxjdWxhdGlvbnMgdG8gZnVuY3Rpb25zXG4gICAgY29uc3QgbGF0MiA9IE1hdGguYXNpbihzaW4oZml4WzBdKSAqIGNvcyhkaXN0IC8gUikgKyBjb3MoZml4WzBdKSAqIHNpbihkaXN0IC8gUikgKiBjb3MocmFkaWFsKSk7XG4gICAgY29uc3QgbG9uMiA9IGZpeFsxXSArIE1hdGguYXRhbjIoXG4gICAgICAgIHNpbihyYWRpYWwpICogc2luKGRpc3QgLyBSKSAqIGNvcyhmaXhbMF0pLFxuICAgICAgICBjb3MoZGlzdCAvIFIpIC0gc2luKGZpeFswXSkgKiBzaW4obGF0MilcbiAgICApO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcmFkaWFuc1RvRGVncmVlcyhsYXQyKSxcbiAgICAgICAgcmFkaWFuc1RvRGVncmVlcyhsb24yKVxuICAgIF07XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gaXNXaXRoaW5BaXJzcGFjZVxuICogQHBhcmFtIGFpcnBvcnQge0FpcnBvcnRNb2RlbH1cbiAqIEBwYXJhbSAgcG9zIHthcnJheX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1dpdGhpbkFpcnNwYWNlID0gKGFpcnBvcnQsIHBvcykgPT4ge1xuICAgIGNvbnN0IHBlcmltID0gYWlycG9ydC5wZXJpbWV0ZXI7XG5cbiAgICBpZiAocGVyaW0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50X2luX2FyZWEocG9zLCBwZXJpbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlMmQocG9zLCBhaXJwb3J0LnBvc2l0aW9uLnBvc2l0aW9uKSA8PSBhaXJwb3J0LmN0cl9yYWRpdXM7XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2VUb0JvdW5kYXJ5XG4gKiBAcGFyYW0gYWlycG9ydCB7QWlycG9ydE1vZGVsfVxuICogQHBhcmFtIHBvcyB7YXJyYXl9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlRGlzdGFuY2VUb0JvdW5kYXJ5ID0gKGFpcnBvcnQsIHBvcykgPT4ge1xuICAgIGNvbnN0IHBlcmltID0gYWlycG9ydC5wZXJpbWV0ZXI7XG5cbiAgICBpZiAocGVyaW0pIHtcbiAgICAgICAgLy8ga21cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlX3RvX3BvbHkocG9zLCBhcmVhX3RvX3BvbHkocGVyaW0pKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBobW0sIGBwb3NpdGlvbi5wb3NpdGlvbmA/IHRoYXQgc2VlbXMgZmlzaHlcbiAgICByZXR1cm4gYWJzKGRpc3RhbmNlMmQocG9zLCBhaXJwb3J0LnBvc2l0aW9uLnBvc2l0aW9uKSAtIGFpcnBvcnQuY3RyX3JhZGl1cyk7XG59O1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gvZm9yRWFjaCc7XG5pbXBvcnQgX21hcCBmcm9tICdsb2Rhc2gvbWFwJztcbmltcG9ydCB7IHNpbiwgY29zLCBhYnMsIGNsYW1wIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMgfSBmcm9tICcuLi91dGlsaXRpZXMvdW5pdENvbnZlcnRlcnMnO1xuXG4vKipcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiAyRCB2ZWN0b3JcbiAqXG4gKiBAZnVuY3Rpb24gdmxlblxuICovXG5leHBvcnQgY29uc3QgdmxlbiA9ICh2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgodlswXSAqIHZbMF0pICsgKHZbMV0gKiB2WzFdKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGwgdG8gdmxlbigpIGZhaWxlZC4gdjoke3Z9IHwgRXJyOiR7ZXJyfWApO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbmdsZSBvZiAyRCB2ZWN0b3IsIGluIHJhZGlhbnNcbiAqXG4gKiBAZnVuY3Rpb24gdnJhZGlhbFxuICogQHBhcmFtIHYge31cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHZyYWRpYWwgPSAodikgPT4ge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHZbMF0sIHZbMV0pO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgVmVjdG9ycyAoYWxsIGRpbWVuc2lvbnMpXG4gKlxuICogQGZ1Y3Rpb24gdnN1YlxuICogQHBhcmFtIHYxIHtudW1iZXJ9XG4gKiBAcGFyYW0gdjIge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHZzdWIgPSAodjEsIHYyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdiA9IFtdO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGVhc2llIHJ3aXRoIF9tYXAoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIHYucHVzaCh2MVtpXSAtIHYyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsIHRvIHZzdWIoKSBmYWlsZWQuIHYxOiAke3YxfSB8IHYyOiR7djJ9IHwgRXJyOiAke2Vycn1gKTtcbiAgICB9XG59O1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKiogVkVDVE9SIEZVTkNUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIEZvciBtb3JlIGluZm8sIHNlZSBodHRwOi8vdGhyZWVqcy5vcmcvZG9jcy8jUmVmZXJlbmNlL01hdGgvVmVjdG9yM1xuLy8gUmVtZW1iZXI6IFt4LHldIGNvbnZlbnRpb24gaXMgdXNlZCwgYW5kIGRvZXNuJ3QgbWF0Y2ggW2xhdCxsb25dXG5cbi8qKlxuICogTm9ybWFsaXplIGEgMkQgdmVjdG9yXG4gKiBlZyBzY2FsaW5nIGVsZW1lbnRzIHN1Y2ggdGhhdCBuZXQgbGVuZ3RoIGlzIDFcbiAqIFR1cm5zIHZlY3RvciAndicgaW50byBhICd1bml0IHZlY3RvcidcbiAqL1xuZXhwb3J0IGNvbnN0IHZub3JtID0gKHYsIGxlbmd0aCkgPT4ge1xuICAgIGNvbnN0IHggPSB2WzBdO1xuICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KTtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2luKGFuZ2xlKSAqIGxlbmd0aCxcbiAgICAgICAgY29zKGFuZ2xlKSAqIGxlbmd0aFxuICAgIF07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIDJEIHZlY3RvclxuICogUGFzcyBhIGhlYWRpbmcgKHJhZCkgYW5kIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgdW5pdCB2ZWN0b3JcbiAqL1xuY29uc3QgdmVjdG9yaXplXzJkID0gKGRpcmVjdGlvbikgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNpbihkaXJlY3Rpb24pLFxuICAgICAgICBjb3MoZGlyZWN0aW9uKVxuICAgIF07XG59O1xuXG4vKipcbiAqIEFkZHMgVmVjdG9ycyAoYWxsIGRpbWVuc2lvbnMpXG4gKi9cbmV4cG9ydCBjb25zdCB2YWRkID0gKHYxLCB2MikgPT4ge1xuICAgIC8vIFRPRE86IHdoeSB0cnkvY2F0Y2g/XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdiA9IFtdO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcblxuICAgICAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBkb25lIHdpdGggYSBfbWFwKClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICB2LnB1c2godjFbaV0gKyB2MltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbCB0byB2YWRkKCkgZmFpbGVkLiB2MToke3YxfSB8IHYyOiR7djJ9IHwgRXJyOiR7ZXJyfWApO1xuICAgIH1cbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyBWZWN0b3JzIChhbGwgZGltZW5zaW9ucylcbiAqL1xuLy8gY29uc3Qgdm11bCA9ICh2MSwgdjIpID0+IHtcbi8vICAgICAvLyBUT0RPOiB3aHkgdHJ5L2NhdGNoP1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICAgIGNvbnN0IHYgPSBbXTtcbi8vICAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbih2MS5sZW5ndGgsIHYyLmxlbmd0aCk7XG4vL1xuLy8gICAgICAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBkb25lIHdpdGggYSBfbWFwKClcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4vLyAgICAgICAgICAgICB2LnB1c2godjFbaV0gKiB2MltpXSk7XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIHJldHVybiB2O1xuLy8gICAgIH0gY2F0Y2ggKGVycikge1xuLy8gICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsIHRvIHZtdWwoKSBmYWlsZWQuIHYxOiR7djF9IHwgdjI6JHt2Mn0gfCBFcnI6JHtlcnJ9YCk7XG4vLyAgICAgfVxuLy8gfTtcblxuLyoqXG4gKiBEaXZpZGVzIFZlY3RvcnMgKGFsbCBkaW1lbnNpb25zKVxuICovXG4vLyBjb25zdCB2ZGl2ID0gKHYxLCB2MikgPT4ge1xuLy8gICAgIC8vIFRPRE86IHdoeSB0cnkvY2F0Y2g/XG4vLyAgICAgdHJ5IHtcbi8vICAgICAgICAgY29uc3QgdiA9IFtdO1xuLy8gICAgICAgICBjb25zdCBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsIHYyLmxlbmd0aCk7XG4vL1xuLy8gICAgICAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBkb25lIHdpdGggYSBfbWFwKClcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuLy8gICAgICAgICAgICAgdi5wdXNoKHYxW2ldIC8gdjJbaV0pO1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICByZXR1cm4gdjtcbi8vICAgICB9IGNhdGNoIChlcnIpIHtcbi8vICAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbCB0byB2ZGl2KCkgZmFpbGVkLiB2MToke3YxfSB8IHYyOiR7djJ9IHwgRXJyOiR7ZXJyfWApO1xuLy8gICAgIH1cbi8vIH07XG5cbi8qKlxuICogU2NhbGVzIHZlY3RvcnMgaW4gbWFnbml0dWRlIChhbGwgZGltZW5zaW9ucylcbiAqL1xuZXhwb3J0IGNvbnN0IHZzY2FsZSA9ICh2ZWN0b3JzLCBmYWN0b3IpID0+IHtcbiAgICByZXR1cm4gX21hcCh2ZWN0b3JzLCAodikgPT4gdiAqIGZhY3Rvcik7XG59O1xuXG4vKipcbiAqIFZlY3RvciBkb3QgcHJvZHVjdCAoYWxsIGRpbWVuc2lvbnMpXG4gKi9cbi8vIGNvbnN0IHZkcCA9ICh2MSwgdjIpID0+IHtcbi8vICAgICBsZXQgbiA9IDA7XG4vLyAgICAgY29uc3QgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLCB2Mi5sZW5ndGgpO1xuLy9cbi8vICAgICAvLyBUT0RPOiBtYWJ5ZSB1c2UgX21hcCgpIGhlcmU/XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuLy8gICAgICAgICBuICs9IHYxW2ldICogdjJbaV07XG4vLyAgICAgfVxuLy9cbi8vICAgICByZXR1cm4gbjtcbi8vIH07XG5cbi8qKlxuICogQ29tcHV0ZSBkZXRlcm1pbmFudCBvZiAyRC8zRCB2ZWN0b3JzXG4gKiBSZW1lbWJlcjogTWF5IHJldHVybiBuZWdhdGl2ZSB2YWx1ZXMgKHVuZGVzaXJhYmxlIGluIHNvbWUgc2l0dWF0aW9ucylcbiAqL1xuY29uc3QgdmRldCA9ICh2MSwgdjIsIC8qIG9wdGlvbmFsICovIHYzKSA9PiB7XG4gICAgaWYgKE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKSA9PT0gMikge1xuICAgICAgICAvLyAyeDIgZGV0ZXJtaW5hbnRcbiAgICAgICAgcmV0dXJuICh2MVswXSAqIHYyWzFdKSAtICh2MVsxXSAqIHYyWzBdKTtcbiAgICB9IGVsc2UgaWYgKE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoLCB2My5sZW5ndGgpID09PSAzICYmIHYzKSB7XG4gICAgICAgIC8vIDN4MyBkZXRlcm1pbmFudFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdjFbMF0gKlxuICAgICAgICAgICAgdmRldChbdjJbMV0sIHYyWzJdXSwgW3YzWzFdLCB2M1syXV0pIC0gdjFbMV0gKlxuICAgICAgICAgICAgdmRldChbdjJbMF0sIHYyWzJdXSwgW3YzWzBdLCB2M1syXV0pICsgdjFbMl0gKlxuICAgICAgICAgICAgdmRldChbdjJbMF0sIHYyWzFdXSwgW3YzWzBdLCB2M1sxXV0pXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBWZWN0b3IgY3Jvc3MgcHJvZHVjdCAoM0QvMkQqKVxuICogUGFzc2luZyAzRCB2ZWN0b3IgcmV0dXJucyAzRCB2ZWN0b3JcbiAqIFBhc3NpbmcgMkQgdmVjdG9yIChjbGFzc2ljYWxseSBpbXByb3BlcikgcmV0dXJucyB6LWF4aXMgU0NBTEFSXG4gKiAqTm90ZSBvbiAyRCBpbXBsZW1lbnRhdGlvbjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQzOTg0LzU3NzQ3NjdcbiAqL1xuY29uc3QgdmNwID0gKHYxLCB2MikgPT4ge1xuICAgIGlmIChNYXRoLm1pbih2MS5sZW5ndGgsIHYyLmxlbmd0aCkgPT09IDIpIHtcbiAgICAgICAgLy8gZm9yIDJEIHZlY3RvciAocmV0dXJucyB6LWF4aXMgc2NhbGFyKVxuICAgICAgICByZXR1cm4gdmNwKFt2MVswXSwgdjFbMV0sIDBdLCBbdjJbMF0sIHYyWzFdLCAwXSlbMl07XG4gICAgfVxuXG4gICAgaWYgKE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKSA9PT0gMykge1xuICAgICAgICAvLyBmb3IgM0QgdmVjdG9yIChyZXR1cm5zIDNEIHZlY3RvcilcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHZkZXQoW3YxWzFdLCB2MVsyXV0sIFt2MlsxXSwgdjJbMl1dKSxcbiAgICAgICAgICAgIC12ZGV0KFt2MVswXSwgdjFbMl1dLCBbdjJbMF0sIHYyWzJdXSksXG4gICAgICAgICAgICB2ZGV0KFt2MVswXSwgdjFbMV1dLCBbdjJbMF0sIHYyWzFdXSlcbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdmVjdG9yIHJvdGF0ZWQgYnkgXCJyYWRpYW5zXCIgcmFkaWFuc1xuICovXG5leHBvcnQgY29uc3QgdnR1cm4gPSAocmFkaWFucywgdikgPT4ge1xuICAgIGlmICghdikge1xuICAgICAgICB2ID0gWzAsIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSB2WzBdO1xuICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgIGNvbnN0IGNzID0gY29zKC1yYWRpYW5zKTtcbiAgICBjb25zdCBzbiA9IHNpbigtcmFkaWFucyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICB4ICogY3MgLSB5ICogc24sXG4gICAgICAgIHggKiBzbiArIHkgKiBjc1xuICAgIF07XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYW5kIHdoZXJlIHR3byByYXlzIHdpbGwgaW50ZXJzZWN0LiBBbGwgYW5nbGVzIGluIHJhZGlhbnMuXG4gKiBWYXJpYXRpb24gYmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTY1MjgyLzU3NzQ3NjdcbiAqL1xuZXhwb3J0IGNvbnN0IHJheXNJbnRlcnNlY3QgPSAocG9zMSwgZGlyMSwgcG9zMiwgZGlyMiwgZGVnX2FsbG93YW5jZSkgPT4ge1xuICAgIGlmICghZGVnX2FsbG93YW5jZSkge1xuICAgICAgICAvLyBkZWdyZWVzIGRpdmVyZ2VuY2Ugc3RpbGwgY29uc2lkZXJlZCAncGFyYWxsZWwnXG4gICAgICAgIGRlZ19hbGxvd2FuY2UgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IHAgPSBwb3MxO1xuICAgIGNvbnN0IHEgPSBwb3MyO1xuICAgIGNvbnN0IHIgPSB2ZWN0b3JpemVfMmQoZGlyMSk7XG4gICAgY29uc3QgcyA9IHZlY3Rvcml6ZV8yZChkaXIyKTtcbiAgICBjb25zdCB0ID0gYWJzKHZjcCh2c3ViKHEsIHApLCBzKSAvIHZjcChyLCBzKSk7XG4gICAgY29uc3QgdF9ub3JtID0gYWJzKHZjcCh2c3ViKHZub3JtKHEpLCB2bm9ybShwKSksIHMpIC8gdmNwKHIsIHMpKTtcbiAgICBjb25zdCB1X25vcm0gPSBhYnModmNwKHZzdWIodm5vcm0ocSksIHZub3JtKHApKSwgcikgLyB2Y3AociwgcykpO1xuXG4gICAgaWYgKGFicyh2Y3AociwgcykpIDwgYWJzKHZjcChbMCwgMV0sIHZlY3Rvcml6ZV8yZChkZWdyZWVzVG9SYWRpYW5zKGRlZ19hbGxvd2FuY2UpKSkpKSB7XG4gICAgICAgIC8vIHBhcmFsbGVsICh3aXRoaW4gYWxsb3dhbmNlKVxuICAgICAgICBjb25zdCBjcm9zc1Byb2R1Y3QgPSB2Y3AoXG4gICAgICAgICAgICB2c3ViKHZub3JtKHEpLCB2bm9ybShwKSksXG4gICAgICAgICAgICByXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGNyb3NzUHJvZHVjdCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gY29sbGluZWFyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcmFsbGVsLCBub24taW50ZXJzZWN0aW5nXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCh0X25vcm0gPj0gMCAmJiB0X25vcm0gPD0gMSkgJiYgKHVfbm9ybSA+PSAwICYmIHVfbm9ybSA8PSAxKSkge1xuICAgICAgICAvLyByYXlzIGludGVyc2VjdCBoZXJlXG4gICAgICAgIHJldHVybiB2YWRkKHAsIHZzY2FsZShyLCB0KSk7XG4gICAgfVxuXG4gICAgLy8gZGl2ZXJnaW5nLCBub24taW50ZXJzZWN0aW5nXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGFuZCB3aGVyZSB0d28gcnVud2F5cyB3aWxsIGludGVyc2VjdC5cbiAqIE5vdGU6IFBsZWFzZSBwYXNzIE9OTFkgdGhlIHJ1bndheSBpZGVudGlmaWVyIChlZyAnMjhyJylcbiAqL1xuLy8gY29uc3QgcnVud2F5c0ludGVyc2VjdCA9IChyd3kxX25hbWUsIHJ3eTJfbmFtZSkgPT4ge1xuLy8gICAgIGNvbnN0IGFpcnBvcnQgPSB3aW5kb3cuYWlycG9ydENvbnRyb2xsZXIuYWlycG9ydF9nZXQoKTtcbi8vXG4vLyAgICAgcmV0dXJuIHJheXNJbnRlcnNlY3QoXG4vLyAgICAgICAgIGFpcnBvcnQuZ2V0UnVud2F5KHJ3eTFfbmFtZSkucG9zaXRpb24sXG4vLyAgICAgICAgIGFpcnBvcnQuZ2V0UnVud2F5KHJ3eTFfbmFtZSkuYW5nbGUsXG4vLyAgICAgICAgIGFpcnBvcnQuZ2V0UnVud2F5KHJ3eTJfbmFtZSkucG9zaXRpb24sXG4vLyAgICAgICAgIGFpcnBvcnQuZ2V0UnVud2F5KHJ3eTJfbmFtZSkuYW5nbGUsXG4vLyAgICAgICAgIDkuOSAvLyBjb25zaWRlciBcInBhcmFsbGVsXCIgaWYgcnd5IGhkZ3MgZGlmZmVyIGJ5IG1heGltdW0gb2YgOS45IGRlZ3JlZXNcbi8vICAgICApO1xuLy8gfTtcblxuLyoqXG4gKiAnRmxpcHMnIHZlY3RvcidzIFkgY29tcG9uZW50IGluIGRpcmVjdGlvblxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBjdWxlYnJvbidzIHBvbHkgZWRnZSB2ZWN0b3IgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHZmbGlwWSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIFstdlsxXSwgdlswXV07XG59O1xuXG4vKipcbiAqXG4gKlxuICogc29sdXRpb24gYnkgQGN1bGVicm9uXG4gKiB0dXJuIHBvbHkgZWRnZSBpbnRvIGEgdmVjdG9yLlxuICogdGhlIGVkZ2UgdmVjdG9yIHNjYWxlZCBieSBqIGFuZCBpdHMgbm9ybWFsIHZlY3RvciBzY2FsZWQgYnkgaSBtZWV0XG4gKiBpZiB0aGUgZWRnZSB2ZWN0b3IgcG9pbnRzIGJldHdlZW4gdGhlIHZlcnRpY2VzLFxuICogdGhlbiBub3JtYWwgaXMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlLlxuICogLS0tLS0tLS1cbiAqIHgxICsgeDIgKiBpID09IHgzICsgeDQgKiBqXG4gKiB5MSArIHkyICogaSA9PSB5MyArIHk0ICogalxuICogMCA8IGogPCAxXG4gKiAtLS0tLS0tLVxuICpcbiAqIGkgPT0gKHkzICsgaiB5NCAtIHkxKSAvIHkyXG4gKiB4MSArIHgyIHkzIC8geTIgKyBqIHgyIHk0IC8geTIgLSB4MiB5MSAvIHkyID09IHgzICsgaiB4NFxuICogaiB4MiB5NCAvIHkyIC0gaiB4NCA9PSB4MyAtIHgxIC0geDIgeTMgLyB5MiArIHgyIHkxIC8geTJcbiAqIGogPSAoeDMgLSB4MSAtIHgyIHkzIC8geTIgKyB4MiB5MSAvIHkyKSAvICh4MiB5NCAvIHkyIC0geDQpXG4gKiBpID0gKHkzICsgaiB5NCAtIHkxKSAvIHkyXG4gKlxuICogaSA9PSAoeDMgKyBqIHg0IC0geDEpIC8geDJcbiAqIHkxICsgeTIgeDMgLyB4MiArIGogeTIgeDQgLyB4MiAtIHkyIHgxIC8geDIgPT0geTMgKyBqIHk0XG4gKiBqIHkyIHg0IC8geDIgLSBqIHk0ID09IHkzIC0geTEgLSB5MiB4MyAvIHgyICsgeTIgeDEgLyB4MlxuICogaiA9ICh5MyAtIHkxIC0geTIgeDMgLyB4MiArIHkyIHgxIC8geDIpIC8gKHkyIHg0IC8geDIgLSB5NClcbiAqIGkgPSAoeDMgKyBqIHg0IC0geDEpIC8geDJcbiAqXG4gKiBAZm51Y3Rpb24gZGlzdGFuY2VfdG9fcG9seVxuICogQHBhcmFtIHBvaW50IHthcnJheX1cbiAqIEBwYXJhbSBwb2x5IHthcnJheX1cbiAqIEByZXR1cm4gbnVtYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0YW5jZV90b19wb2x5ID0gKHBvaW50LCBwb2x5KSA9PiB7XG4gICAgY29uc3QgZGlzdHMgPSBfbWFwKHBvbHksICh2ZXJ0ZXgxLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSAoaSA9PT0gMCA/IHBvbHkubGVuZ3RoIDogaSkgLSAxO1xuICAgICAgICBjb25zdCB2ZXJ0ZXgyID0gcG9seVtwcmV2XTtcbiAgICAgICAgY29uc3QgZWRnZSA9IHZzdWIodmVydGV4MiwgdmVydGV4MSk7XG5cbiAgICAgICAgaWYgKHZsZW4oZWRnZSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2bGVuKHZzdWIocG9pbnQsIHZlcnRleDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBvaW50ICsgbm9ybWFsICogaSA9PSB2ZXJ0ZXgxICsgZWRnZSAqIGpcbiAgICAgICAgY29uc3Qgbm9ybSA9IHZmbGlwWShlZGdlKTtcbiAgICAgICAgY29uc3QgeDEgPSBwb2ludFswXTtcbiAgICAgICAgY29uc3QgeDIgPSBub3JtWzBdO1xuICAgICAgICBjb25zdCB4MyA9IHZlcnRleDFbMF07XG4gICAgICAgIGNvbnN0IHg0ID0gZWRnZVswXTtcbiAgICAgICAgY29uc3QgeTEgPSBwb2ludFsxXTtcbiAgICAgICAgY29uc3QgeTIgPSBub3JtWzFdO1xuICAgICAgICBjb25zdCB5MyA9IHZlcnRleDFbMV07XG4gICAgICAgIGNvbnN0IHk0ID0gZWRnZVsxXTtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIGlmICh5MiAhPT0gMCkge1xuICAgICAgICAgICAgaiA9ICh4MyAtIHgxIC0geDIgKiB5MyAvIHkyICsgeDIgKiB5MSAvIHkyKSAvICh4MiAqIHk0IC8geTIgLSB4NCk7XG4gICAgICAgICAgICBrID0gKHkzICsgaiAqIHk0IC0geTEpIC8geTI7XG4gICAgICAgIH0gZWxzZSBpZiAoeDIgIT09IDApIHsgLy8gbm9ybWFsIGNhbid0IGJlIHplcm8gdW5sZXNzIHRoZSBlZGdlIGhhcyAwIGxlbmd0aFxuICAgICAgICAgICAgaiA9ICh5MyAtIHkxIC0geTIgKiB4MyAvIHgyICsgeTIgKiB4MSAvIHgyKSAvICh5MiAqIHg0IC8geDIgLSB5NCk7XG4gICAgICAgICAgICBrID0gKHgzICsgaiAqIHg0IC0geDEpIC8geDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+IDEgfHwgIWopIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICB2bGVuKHZzdWIocG9pbnQsIHZlcnRleDEpKSxcbiAgICAgICAgICAgICAgICB2bGVuKHZzdWIocG9pbnQsIHZlcnRleDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2bGVuKHZzY2FsZShub3JtLCBrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gTWF0aC5taW4oLi4uZGlzdHMpO1xufTtcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9cbmV4cG9ydCBjb25zdCBwb2ludF9pbl9wb2x5ID0gKHBvaW50LCB2cykgPT4ge1xuICAgIC8vIHJheS1jYXN0aW5nIGFsZ29yaXRobSBiYXNlZCBvblxuICAgIC8vIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWxcbiAgICBjb25zdCB4ID0gcG9pbnRbMF07XG4gICAgY29uc3QgeSA9IHBvaW50WzFdO1xuICAgIGxldCBqID0gdnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG5cbiAgICAvLyBwb2x5IG1pZ2h0IG5vdCBiZSB0aGUgY29ycmVjdCB0ZXJtIGhlcmVcbiAgICBfZm9yRWFjaCh2cywgKHBvbHksIGkpID0+IHtcbiAgICAgICAgY29uc3QgeGkgPSBwb2x5WzBdO1xuICAgICAgICBjb25zdCB5aSA9IHBvbHlbMV07XG4gICAgICAgIGNvbnN0IHhqID0gdnNbal1bMF07XG4gICAgICAgIGNvbnN0IHlqID0gdnNbal1bMV07XG4gICAgICAgIGNvbnN0IGludGVyc2VjdCA9ICgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmICh4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XG5cbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGogPSBpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn07XG5cbi8qKlxuICpcbiAqIEBmdW5jdGlvbiBwb2ludF90b19tcG9seVxuICogQHBhcmFtIHBvaW50IHthcnJheX1cbiAqIEBwYXJhbSBtcG9seSB7YXJyYXl9XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBwb2ludF90b19tcG9seSA9IChwb2ludCwgbXBvbHkpID0+IHtcbiAgICAvLyByZXR1cm5zOiBib29sZWFuIGluc2lkZS9vdXRzaWRlICYgZGlzdGFuY2UgdG8gdGhlIHBvbHlnb25cbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG5cbiAgICBfZm9yRWFjaChtcG9seSwgKHJpbmcsIGspID0+IHtcbiAgICAgICAgLy8gcmluZyA9IG1wb2x5W2tdO1xuXG4gICAgICAgIGlmIChwb2ludF9pbl9wb2x5KHBvaW50LCByaW5nKSkge1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbnNpZGUgb3V0ZXIgcmluZywgcmVtZW1iZXIgdGhhdCBhbmQgd2FpdCB0aWxsIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBieSBjaGFuZ2UgaW4gb25lIG9mIGlubmVyIHJpbmdzLCBpdCdzIG91dCBvZiBwb2x5LCByZXR1cm4gZGlzdGFuY2UgdG8gdGhlIGlubmVyIHJpbmdcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VfdG9fcG9seShwb2ludCwgcmluZylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIG5vdCBtYXRjaGVkIHRvIGlubmVyIGNpcmNsZXMsIHJldHVybiB0aGUgbWF0Y2ggdG8gb3V0ZXIgYW5kIGRpc3RhbmNlIHRvIGl0XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zaWRlOiBpbnNpZGUsXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZV90b19wb2x5KHBvaW50LCBtcG9seVswXSlcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAnYXJlYScgdG8gYSAncG9seSdcbiAqL1xuZXhwb3J0IGNvbnN0IGFyZWFfdG9fcG9seSA9IChhcmVhKSA9PiB7XG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgX21hcCgpXG4gICAgLy8gV2hhdCBpcyB0aGUgc2lnbmlmaWNhbmNlIG9mIHJldHVybmluZyBgW3YucG9zaXRpb25dYD8gaXNudCBwb3NpdGlvbiBhbHJlYWR5IGFuIGFycmF5P1xuICAgIHJldHVybiAkLm1hcChhcmVhLnBvbHksICh2KSA9PiBbdi5wb3NpdGlvbl0pO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGEgcG9pbnQgaXMgaW4gYW4gYXJlYVxuICovXG5leHBvcnQgY29uc3QgcG9pbnRfaW5fYXJlYSA9IChwb2ludCwgYXJlYSkgPT4ge1xuICAgIHJldHVybiBwb2ludF9pbl9wb2x5KHBvaW50LCBhcmVhX3RvX3BvbHkoYXJlYSkpO1xufTtcblxuXG4vLyBUT0RPOiB0aGlzIG1pZ2h0IGJlIGJlc3QgYWNjb21wbGlzaGVkIHdpdGggYSBSZWN0YW5nbGUgY2xhc3MsIHdpdGggdGhpcyBmdW5jdGlvbiB3b3JraW5nIGFzIHRoZSBtaWRkbGVtYW5cbi8vIGNyZWF0aW5nIHRoZSBjbGFzcyBhbmQgYXNraW5nIGlmIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cbi8qKlxuICogQ29tcHV0ZSBhIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiBhIHJheSB3aXRoIGEgcmVjdGFuZ2xlLlxuICpcbiAqIEFyZ3M6XG4gKiAgIHBvczogYXJyYXkgb2YgMiBudW1iZXJzLCByZXByZXNlbnRpbmcgcmF5IHNvdXJjZS5cbiAqICAgZGlyOiBhcnJheSBvZiAyIG51bWJlcnMsIHJlcHJlc2VudGluZyByYXkgZGlyZWN0aW9uLlxuICogICByZWN0UG9zOiBhcnJheSBvZiAyIG51bWJlcnMsIHJlcHJlc2VudGluZyByZWN0YW5nbGUgY29ybmVyIHBvc2l0aW9uLlxuICogICByZWN0U2l6ZTogYXJyYXkgb2YgMiBwb3NpdGl2ZSBudW1iZXJzLCByZXByZXNlbnRpbmcgc2l6ZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICpcbiAqIFJldHVybnM6XG4gKiAtIHVuZGVmaW5lZCwgaWYgcG9zIGlzIG91dHNpZGUgb2YgdGhlIHJlY3RhbmdsZS5cbiAqIC0gdW5kZWZpbmVkLCBpbiBjYXNlIG9mIGEgbnVtZXJpY2FsIGVycm9yLlxuICogLSBhcnJheSBvZiAyIG51bWJlcnMgb24gYSByZWN0YW5nbGUgYm91bmRhcnksIGluIGNhc2Ugb2YgYW4gaW50ZXJzZWN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgcG9zaXRpdmVfaW50ZXJzZWN0aW9uX3dpdGhfcmVjdCA9IChwb3MsIGRpciwgcmVjdFBvcywgcmVjdFNpemUpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gcmVjdFBvc1swXTtcbiAgICBjb25zdCByaWdodCA9IHJlY3RQb3NbMF0gKyByZWN0U2l6ZVswXTtcbiAgICBjb25zdCB0b3AgPSByZWN0UG9zWzFdO1xuICAgIGNvbnN0IGJvdHRvbSA9IHJlY3RQb3NbMV0gKyByZWN0U2l6ZVsxXTtcbiAgICBsZXQgdDtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcblxuICAgIGRpciA9IHZub3JtKGRpcik7XG5cbiAgICAvLyBDaGVjayBpZiBwb3MgaXMgb3V0c2lkZSBvZiByZWN0YW5nbGUuXG4gICAgaWYgKGNsYW1wKGxlZnQsIHBvc1swXSwgcmlnaHQpICE9PSBwb3NbMF0gfHwgY2xhbXAodG9wLCBwb3NbMV0sIGJvdHRvbSkgIT09IHBvc1sxXSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbiB3aXRoIHRvcCBzZWdtZW50LlxuICAgIGlmIChkaXJbMV0gPCAwKSB7XG4gICAgICAgIHQgPSAodG9wIC0gcG9zWzFdKSAvIGRpclsxXTtcbiAgICAgICAgeCA9IHBvc1swXSArIGRpclswXSAqIHQ7XG5cbiAgICAgICAgaWYgKGNsYW1wKGxlZnQsIHgsIHJpZ2h0KSA9PT0geCkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB0b3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9uIHdpdGggYm90dG9tIHNlZ21lbnQuXG4gICAgaWYgKGRpclsxXSA+IDApIHtcbiAgICAgICAgdCA9IChib3R0b20gLSBwb3NbMV0pIC8gZGlyWzFdO1xuICAgICAgICB4ID0gcG9zWzBdICsgZGlyWzBdICogdDtcblxuICAgICAgICBpZiAoY2xhbXAobGVmdCwgeCwgcmlnaHQpID09PSB4KSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIGJvdHRvbV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBsZWZ0IHNlZ21lbnQuXG4gICAgaWYgKGRpclswXSA8IDApIHtcbiAgICAgICAgdCA9IChsZWZ0IC0gcG9zWzBdKSAvIGRpclswXTtcbiAgICAgICAgeSA9IHBvc1sxXSArIGRpclsxXSAqIHQ7XG5cbiAgICAgICAgaWYgKGNsYW1wKHRvcCwgeSwgYm90dG9tKSA9PT0geSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCB5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbiB3aXRoIHJpZ2h0IHNlZ21lbnQuXG4gICAgaWYgKGRpclswXSA+IDApIHtcbiAgICAgICAgdCA9IChyaWdodCAtIHBvc1swXSkgLyBkaXJbMF07XG4gICAgICAgIHkgPSBwb3NbMV0gKyBkaXJbMV0gKiB0O1xuXG4gICAgICAgIGlmIChjbGFtcCh0b3AsIHksIGJvdHRvbSkgPT09IHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcmlnaHQsIHldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFpbGVkIHRvIGNvbXB1dGUgaW50ZXJzZWN0aW9uIGR1ZSB0byBudW1lcmljYWwgcHJlY2lzaW9uLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXVudXNlZC12YXJzLCBuby11bmRlZiwgZ2xvYmFsLXJlcXVpcmUgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBfaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IHsgcmFkaW9faGVhZGluZywgcmFkaW9fYWx0aXR1ZGUgfSBmcm9tICcuL3V0aWxpdGllcy9yYWRpb1V0aWxpdGllcyc7XG5pbXBvcnQgeyBTVE9SQUdFX0tFWSB9IGZyb20gJy4vY29uc3RhbnRzL3N0b3JhZ2VLZXlzJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4vY29uc3RhbnRzL3NlbGVjdG9ycyc7XG5cbi8qKlxuICpcbiAqIEBmdW5jdGlvbiBzcGVlY2hfaW5pdFxuICovXG5leHBvcnQgY29uc3Qgc3BlZWNoX2luaXQgPSAoKSA9PiB7XG4gICAgcHJvcC5zcGVlY2ggPSB7fTtcbiAgICBwcm9wLnNwZWVjaC5zeW50aGVzaXMgPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzO1xuICAgIHByb3Auc3BlZWNoLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChfZ2V0KGxvY2FsU3RvcmFnZSwgU1RPUkFHRV9LRVkuQVRDX1NQRUVDSF9FTkFCTEVELCBmYWxzZSkgPT09IHRydWUpIHtcbiAgICAgICAgcHJvcC5zcGVlY2guZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuU1BFRUNIX1RPR0dMRSkuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFKTtcbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gc3BlZWNoX3NheVxuICogQHBhcmFtIHNlbnRlbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBzcGVlY2hfc2F5ID0gKHNlbnRlbmNlKSA9PiB7XG4gICAgaWYgKHByb3Auc3BlZWNoLnN5bnRoZXNpcyAhPSBudWxsICYmIHByb3Auc3BlZWNoLmVuYWJsZWQpIHtcbiAgICAgICAgbGV0IHRleHRUb1NheSA9ICcnO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VudGVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVNlbnRlbmNlID0gc2VudGVuY2VbaV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2luZ2xlU2VudGVuY2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbGxzaWduJzpcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRvU2F5ICs9IGAgJHtzaW5nbGVTZW50ZW5jZS5jb250ZW50LmdldFJhZGlvQ2FsbHNpZ24oKX0gYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWx0aXR1ZGUnOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0VG9TYXkgKz0gYCAke3JhZGlvX2FsdGl0dWRlKHNpbmdsZVNlbnRlbmNlLmNvbnRlbnQpfSBgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGVlZCc6IGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0VG9TYXkgKz0gYCAke3JhZGlvX2hlYWRpbmcoc2luZ2xlU2VudGVuY2UuY29udGVudCl9IGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0VG9TYXkgKz0gYCAke3NpbmdsZVNlbnRlbmNlLmNvbnRlbnR9IGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXR0ZXJhbmNlID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSh0ZXh0VG9TYXkpOyAvLyBtYWtlIHRoZSBvYmplY3RcbiAgICAgICAgdXR0ZXJhbmNlLmxhbmcgPSAnZW4tVVMnOyAvLyBzZXQgdGhlIGxhbmd1YWdlXG4gICAgICAgIHV0dGVyYW5jZS52b2ljZSA9IHByb3Auc3BlZWNoLnN5bnRoZXNpcy5nZXRWb2ljZXMoKS5maWx0ZXIoKHZvaWNlKSA9PiB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHZvaWNlXG4gICAgICAgICAgICByZXR1cm4gdm9pY2UubmFtZSA9PT0gJ0dvb2dsZSBVUyBFbmdsaXNoJztcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHV0dGVyYW5jZS5yYXRlID0gMS4xMjU7IC8vIHNwZWVkIHVwIGp1c3QgYSB0b3VjaFxuXG4gICAgICAgIC8vIHNheSB0aGUgd29yZHNcbiAgICAgICAgcHJvcC5zcGVlY2guc3ludGhlc2lzLnNwZWFrKHV0dGVyYW5jZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIHNwZWVjaF90b2dnbGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNwZWVjaF90b2dnbGUgPSAoKSA9PiB7XG4gICAgY29uc3QgJHNwZWVjaFRvZ2dsZSA9ICQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuU1BFRUNIX1RPR0dMRSk7XG4gICAgcHJvcC5zcGVlY2guZW5hYmxlZCA9ICFwcm9wLnNwZWVjaC5lbmFibGVkO1xuXG4gICAgaWYgKHByb3Auc3BlZWNoLmVuYWJsZWQpIHtcbiAgICAgICAgJHNwZWVjaFRvZ2dsZS5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICRzcGVlY2hUb2dnbGUucmVtb3ZlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFKTtcbiAgICAgICAgcHJvcC5zcGVlY2guc3ludGhlc2lzLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZVtTVE9SQUdFX0tFWS5BVENfU1BFRUNIX0VOQUJMRURdID0gcHJvcC5zcGVlY2guZW5hYmxlZDtcbn07XG4iLCJpbXBvcnQgX2dldCBmcm9tICdsb2Rhc2gvZ2V0JztcblxuY29uc3QgSU5JVF9QT1NJVElPTl9QQURESU5HID0gWzAsIDBdO1xuXG4vKipcbiAqIE1vZGVsIHJlcHJlc2VudGluZyBhIHNpbmdsZSB0dXRvcmlhbCBzdGVwLlxuICpcbiAqIENvbnN1bWVkIGJ5IHR1dG9yaWFsLmpzXG4gKlxuICogQGNsYXNzIFR1dG9yaWFsU3RlcFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUdXRvcmlhbFN0ZXAge1xuICAgIC8qKlxuICAgICAqIEBmb3IgVHV0b3JpYWxTdGVwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBfZ2V0KG9wdGlvbnMsICd0aXRsZScsICc/Jyk7XG4gICAgICAgIHRoaXMudGV4dCA9IF9nZXQob3B0aW9ucywgJ3RleHQnLCAnPycpO1xuICAgICAgICB0aGlzLnBhcnNlID0gX2dldChvcHRpb25zLCAncGFyc2UnLCBudWxsKTtcbiAgICAgICAgdGhpcy5zaWRlID0gX2dldChvcHRpb25zLCAnc2lkZScsICdub25lJyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBfZ2V0KG9wdGlvbnMsICdwb3NpdGlvbicsIElOSVRfUE9TSVRJT05fUEFERElORyk7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IF9nZXQob3B0aW9ucywgJ3BhZGRpbmcnLCBJTklUX1BPU0lUSU9OX1BBRERJTkcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVHV0b3JpYWxTdGVwXG4gICAgICogQG1ldGhvZCBnZXRUZXh0XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSh0aGlzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IF9oYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgVHV0b3JpYWxTdGVwIGZyb20gJy4vVHV0b3JpYWxTdGVwJztcbmltcG9ydCB7IHJvdW5kLCBjbGFtcCB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3RpbWVIZWxwZXJzJztcbmltcG9ydCB7IGhlYWRpbmdfdG9fc3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3VuaXRDb252ZXJ0ZXJzJztcbmltcG9ydCB7IFNUT1JBR0VfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzL3N0b3JhZ2VLZXlzJztcbmltcG9ydCB7IFNFTEVDVE9SUyB9IGZyb20gJy4uL2NvbnN0YW50cy9zZWxlY3RvcnMnO1xuXG5jb25zdCB0dXRvcmlhbCA9IHt9O1xuXG5jb25zdCBUVVRPUklBTF9URU1QTEFURSA9ICcnICtcbiAgICAnPGRpdiBpZD1cInR1dG9yaWFsXCI+JyArXG4gICAgJyAgIDxoMT48L2gxPicgK1xuICAgICcgICA8bWFpbj48L21haW4+JyArXG4gICAgJyAgIDxkaXYgY2xhc3M9XCJwcmV2XCI+PGltZyBzcmM9XCJhc3NldHMvaW1hZ2VzL3ByZXYucG5nXCIgdGl0bGU9XCJQcmV2aW91cyBzdGVwXCIgLz48L2Rpdj4nICtcbiAgICAnICAgPGRpdiBjbGFzcz1cIm5leHRcIj48aW1nIHNyYz1cImFzc2V0cy9pbWFnZXMvbmV4dC5wbmdcIiB0aXRsZT1cIk5leHQgc3RlcFwiIC8+PC9kaXY+JyArXG4gICAgJzwvZGl2Pic7XG5cbi8qKlxuICogQGNsYXNzIFR1dG9yaWFsVmlld1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUdXRvcmlhbFZpZXcge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRlbGVtZW50ID0gbnVsbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUm9vdCBET00gZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgJGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge2pxdWVyeXxIVE1MIEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICRlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvb3QgdHV0b3JpYWwgRE9NIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5ICR0dXRvcmlhbFZpZXdcbiAgICAgICAgICogQHR5cGUge2pxdWVyeXxIVE1MIEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0IGAjdHV0b3JpYWxgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgJHR1dG9yaWFsVG9nZ2xlXG4gICAgICAgICAqIEB0eXBlIHtqcXVlcnl8SFRNTCBFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCBgLnRvZ2dsZS10dXRvcmlhbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHR1dG9yaWFsVG9nZ2xlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJldmlvdXMgdHV0b3JpYWwgc3RlcCBidXR0b25cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5ICR0dXRvcmlhbFByZXZpb3VzXG4gICAgICAgICAqIEB0eXBlIHtqcXVlcnl8SFRNTCBFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCBgLnByZXZgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFByZXZpb3VzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTmV4dCB0dXRvcmlhbCBzdGVwIGJ1dHRvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgJHR1dG9yaWFsTmV4dFxuICAgICAgICAgKiBAdHlwZSB7anF1ZXJ5fEhUTUwgRWxlbWVudH1cbiAgICAgICAgICogQGRlZmF1bHQgYC5uZXh0YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxOZXh0ID0gbnVsbDtcblxuICAgICAgICBwcm9wLnR1dG9yaWFsID0gdHV0b3JpYWw7XG4gICAgICAgIHRoaXMudHV0b3JpYWwgPSB0dXRvcmlhbDtcbiAgICAgICAgdGhpcy50dXRvcmlhbC5zdGVwcyA9IFtdO1xuICAgICAgICB0aGlzLnR1dG9yaWFsLnN0ZXAgPSAwO1xuICAgICAgICB0aGlzLnR1dG9yaWFsLm9wZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9pbml0KClcbiAgICAgICAgICAgIC5sYXlvdXQoKVxuICAgICAgICAgICAgLmVuYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2Qgc2hvdWxkIGJlIHJ1biBvbmNlIG9uIGFwcGxpY2F0aW9uIGluaXQuXG4gICAgICpcbiAgICAgKiBDYWNoZXMgc2VsZWN0b3JzIGluIHZhcmlhYmxzIHNvIHRoZXkgb25seSBuZWVkIHRvIGJlIGxvb2tlZCB1cCBvbmUgdGltZS5cbiAgICAgKlxuICAgICAqIEBmb3IgdHV0b3JpYWxWaWV3XG4gICAgICogQG1ldGhvZCBfaW5pdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kdHV0b3JpYWxWaWV3ID0gJChUVVRPUklBTF9URU1QTEFURSk7XG4gICAgICAgIHRoaXMuJHR1dG9yaWFsVG9nZ2xlID0gJChTRUxFQ1RPUlMuRE9NX1NFTEVDVE9SUy5UT0dHTEVfVFVUT1JJQUwpO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFByZXZpb3VzID0gdGhpcy4kdHV0b3JpYWxWaWV3LmZpbmQoU0VMRUNUT1JTLkRPTV9TRUxFQ1RPUlMuUFJFVik7XG4gICAgICAgIHRoaXMuJHR1dG9yaWFsTmV4dCA9IHRoaXMuJHR1dG9yaWFsVmlldy5maW5kKFNFTEVDVE9SUy5ET01fU0VMRUNUT1JTLk5FWFQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBtZXRob2Qgc2hvdWxkIGJlIHJ1biBvbmNlIG9uIGFwcGxpY2F0aW9uIGluaXQuXG4gICAgICpcbiAgICAgKiBBZGRzIHRoZSBUVVRPUklBTF9URU1QTEFURSB0byB0aGUgdmlld1xuICAgICAqXG4gICAgICogQGZvciB0dXRvcmlhbFZpZXdcbiAgICAgKiBAbWV0aG9kIGxheW91dFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBsYXlvdXQoKSB7XG4gICAgICAgIGlmICghdGhpcy4kZWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAkZWxlbWVudCB0byBiZSBkZWZpbmVkLiBgYm9keWAgdGFnIGRvZXMgbm90IGV4aXN0IGluIHRoZSBET00nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AudHV0b3JpYWwuaHRtbCA9IHRoaXMuJHR1dG9yaWFsVmlldztcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kdHV0b3JpYWxWaWV3KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgbWV0aG9kIHNob3VsZCBiZSBydW4gb25jZSBvbiBhcHBsaWNhdGlvbiBpbml0LlxuICAgICAqXG4gICAgICogQGZvciB0dXRvcmlhbFZpZXdcbiAgICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuJHR1dG9yaWFsUHJldmlvdXMub24oJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLnR1dG9yaWFsX3ByZXYoZXZlbnQpKTtcbiAgICAgICAgdGhpcy4kdHV0b3JpYWxOZXh0Lm9uKCdjbGljaycsIChldmVudCkgPT4gdGhpcy50dXRvcmlhbF9uZXh0KGV2ZW50KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBhbnkgY2xpY2sgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAZm9yIHR1dG9yaWFsVmlld1xuICAgICAqIEBtZXRob2QgZGlzYWJsZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFByZXZpb3VzLm9mZignY2xpY2snLCAoZXZlbnQpID0+IHRoaXMudHV0b3JpYWxfcHJldihldmVudCkpO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbE5leHQub2ZmKCdjbGljaycsIChldmVudCkgPT4gdGhpcy50dXRvcmlhbF9uZXh0KGV2ZW50KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlYXIgZG93biB0aGUgdmlldyBhbmQgdW5zZXQgYW55IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAZm9yIHR1dG9yaWFsVmlld1xuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFRvZ2dsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHR1dG9yaWFsUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbE5leHQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWwgPSB7fTtcbiAgICAgICAgdGhpcy50dXRvcmlhbC5zdGVwcyA9IFtdO1xuICAgICAgICB0aGlzLnR1dG9yaWFsLnN0ZXAgPSAwO1xuICAgICAgICB0aGlzLnR1dG9yaWFsLm9wZW4gPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZm9yIFR1dG9yaWFsVmlld1xuICAgICAqIEBtZXRob2QgdHV0b3JpYWxfaW5pdF9wcmVcbiAgICAgKi9cbiAgICB0dXRvcmlhbF9pbml0X3ByZSgpIHtcbiAgICAgICAgcHJvcC50dXRvcmlhbCA9IHt9O1xuICAgICAgICBwcm9wLnR1dG9yaWFsLnN0ZXBzID0gW107XG4gICAgICAgIHByb3AudHV0b3JpYWwuc3RlcCA9IDA7XG4gICAgICAgIHByb3AudHV0b3JpYWwub3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHR1dG9yaWFsX3Bvc2l0aW9uID0gWzAuMSwgMC44NV07XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnV2VsY29tZSEnLFxuICAgICAgICAgICAgdGV4dDogWydXZWxjb21lIHRvIEFpciBUcmFmZmljIENvbnRyb2wgc2ltdWxhdG9yLiBJdCZyc3F1bztzIG5vdCBlYXN5JyxcbiAgICAgICAgICAgICAgICAgICAndG8gY29udHJvbCBkb3plbnMgb2YgYWlyY3JhZnQgd2hpbGUgbWFpbnRhaW5pbmcgc2FmZSBkaXN0YW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICdiZXR3ZWVuIHRoZW07IHRvIGdldCBzdGFydGVkIHdpdGggdGhlIEFUQyBzaW11bGF0b3IgdHV0b3JpYWwsIGNsaWNrIHRoZSBhcnJvdyBvbicsXG4gICAgICAgICAgICAgICAgICAgJ3RoZSByaWdodC4gWW91IGNhbiBhbHNvIGNsaWNrIHRoZSBncmFkdWF0aW9uIGNhcCBpY29uIGluIHRoZSBsb3dlciByaWdodCBjb3JuZXInLFxuICAgICAgICAgICAgICAgICAgICdvZiB0aGUgd2luZG93IGF0IGFueSB0aW1lIHRvIGNsb3NlIHRoaXMgdHV0b3JpYWwuJ1xuICAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0RlcGFydGluZyBhaXJjcmFmdCcsXG4gICAgICAgICAgICB0ZXh0OiBbJ0xldCZyc3F1bztzIHJvdXRlIHNvbWUgcGxhbmVzIG91dCBvZiBoZXJlLiBPbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuLCB0aGVyZScsXG4gICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBiZSBhIHN0cmlwIHdpdGggYSBibHVlIGJhciBvbiB0aGUgbGVmdCwgbWVhbmluZyB0aGUgc3RyaXAgcmVwcmVzZW50cyBhIGRlcGFydGluZyBhaXJjcmFmdC4nLFxuICAgICAgICAgICAgICAgICAgICdDbGljayB0aGUgZmlyc3Qgb25lICh7Q0FMTFNJR059KS4gVGhlIGFpcmNyYWZ0JnJzcXVvO3MgY2FsbHNpZ24gd2lsbCBhcHBlYXIgaW4gdGhlIGNvbW1hbmQgZW50cnkgYm94JyxcbiAgICAgICAgICAgICAgICAgICAnYW5kIHRoZSBzdHJpcCB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIGNoYW5nZSBjb2xvci4gVGhpcyBtZWFucyB0aGF0IHRoZSBhaXJjcmFmdCBpcyBzZWxlY3RlZC4nXG4gICAgICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQucmVwbGFjZSgne0NBTExTSUdOfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5nZXRDYWxsc2lnbigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogdHV0b3JpYWxfcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnVGF4aWluZycsXG4gICAgICAgICAgICB0ZXh0OiBbJ05vdyB0eXBlIGluICZsc3F1bzt0YXhpJnJzcXVvOyBvciAmbHNxdW87d2FpdCZyc3F1bzsgaW50byB0aGUgY29tbWFuZCBib3ggYWZ0ZXIgdGhlIGNhbGxzaWduIGFuZCBoaXQgUmV0dXJuOycsXG4gICAgICAgICAgICAgICAgICAgJ3RoZSBtZXNzYWdlcyBhcmVhIGFib3ZlIGl0IHdpbGwgc2hvdyB0aGF0IHRoZSBhaXJjcmFmdCBpcyB0YXhpaW5nIHRvIHJ1bndheSAoe1JVTldBWX0pIGluJyxcbiAgICAgICAgICAgICAgICAgICAncHJlcGFyYXRpb24gZm9yIHRha2VvZmYuIChZb3UgY291bGQgYWxzbyBzcGVjaWZ5IHRvIHdoaWNoIHJ1bndheSB0byB0YXhpIHRoZSBhaXJjcmFmdCBieScsXG4gICAgICAgICAgICAgICAgICAgJ2VudGVyaW5nIHRoZSBydW53YXkgbmFtZSBhZnRlciAmbHNxdW87dGF4aSZyc3F1bzsgb3IgJmxzcXVvO3dhaXQmcnNxdW87LiknXG4gICAgICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdC5yZXBsYWNlKCd7UlVOV0FZfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5mbXMuY3VycmVudFdheXBvaW50LnJ1bndheSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ1Rha2VvZmYsIHBhcnQgMScsXG4gICAgICAgICAgICB0ZXh0OiBbJ1doZW4gaXQgYXBwZWFycyBhdCB0aGUgc3RhcnQgb2YgcnVud2F5ICh7UlVOV0FZfSkgKHdoaWNoIG1heSB0YWtlIGEgY291cGxlIG9mIHNlY29uZHMpLCBjbGljayBpdCAob3IgcHJlc3MgdGhlIHVwIGFycm93IG9uY2UpJyxcbiAgICAgICAgICAgICAgICAgICAnYW5kIHR5cGUgaW4gJmxzcXVvO2NhZiZyc3F1bzsgKGZvciAmbHNxdW87Y2xlYXJlZCBhcyBmaWxlZCZyc3F1bzspLiBUaGlzIHRlbGxzIHRoZSBhaXJjcmFmdCBpdCBpcyBjbGVhcmVkIHRvIGZvbGxvdyBpdHMgZmxpZ2h0cGxhbi4nLFxuICAgICAgICAgICAgICAgICAgICdKdXN0IGFzIGluIHJlYWwgbGlmZSwgdGhpcyBzdGVwIG11c3QgYmUgZG9uZSBiZWZvcmUgY2xlYXJpbmcgdGhlIGFpcmNyYWZ0IGZvciB0YWtlb2ZmLCBzbyB0aGV5IGtub3cgd2hlcmUgdGhleVxcJ3JlIHN1cHBvc2VkIHRvIGdvLidcbiAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQucmVwbGFjZSgne1JVTldBWX0nLCBwcm9wLmFpcmNyYWZ0Lmxpc3RbMF0uZm1zLmN1cnJlbnRXYXlwb2ludC5ydW53YXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0dXRvcmlhbF9wb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3N0ZXAoe1xuICAgICAgICAgICAgdGl0bGU6ICdUYWtlb2ZmLCBwYXJ0IDInLFxuICAgICAgICAgICAgdGV4dDogWydOb3cgdGhlIGFpcmNyYWZ0IGlzIHJlYWR5IGZvciB0YWtlIG9mZi4gQ2xpY2sgdGhlIGFpcmNyYWZ0IGFnYWluIChvciBwcmVzcyB1cCBhcnJvdyBvbmNlKScsXG4gICAgICAgICAgICAgICAgICAgJ2FuZCB0eXBlICZsc3F1bzt0YWtlb2ZmJnJzcXVvOyAob3IgJmxzcXVvO3RvJnJzcXVvOykgdG8gY2xlYXIgdGhlIGFpcmNyYWZ0IGZvciB0YWtlIG9mZi4nLFxuICAgICAgICAgICAgICAgICAgICdPbmNlIGl0XFwncyBnb2luZyBmYXN0IGVub3VnaCwgaXQgc2hvdWxkIGxpZnQgb2ZmIHRoZSBncm91bmQgYW5kIHlvdSBzaG91bGQnLFxuICAgICAgICAgICAgICAgICAgICdzZWUgaXRzIGFsdGl0dWRlIGluY3JlYXNpbmcuIE1lYW53aGlsZSwgcmVhZCB0aGUgbmV4dCBzdGVwLidcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AuYWlyY3JhZnQubGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdC5yZXBsYWNlKCd7UlVOV0FZfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5mbXMuY3VycmVudFdheXBvaW50LnJ1bndheSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0FpcmNyYWZ0IHN0cmlwcywgcGFydCAxJyxcbiAgICAgICAgICAgIHRleHQ6IFsnT24gdGhlIHJpZ2h0LCB0aGVyZSZyc3F1bztzIGEgcm93IG9mIHN0cmlwcywgb25lIGZvciBlYWNoIGFpcmNyYWZ0LicsXG4gICAgICAgICAgICAgICAgICAgJ0VhY2ggc3RyaXAgaGFzIGEgYmFyIG9uIGl0cyBsZWZ0IHNpZGUsIGNvbG9yZWQgYmx1ZSBmb3IgZGVwYXJ0dXJlcyBhbmQnLFxuICAgICAgICAgICAgICAgICAgICdyZWQgZm9yIGFycml2YWxzLidcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AuYWlyY3JhZnQubGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdC5yZXBsYWNlKCd7UlVOV0FZfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5mbXMuY3VycmVudFdheXBvaW50LnJ1bndheSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0FpcmNyYWZ0IHN0cmlwcywgcGFydCAyJyxcbiAgICAgICAgICAgIHRleHQ6IFsnVGhlIHRvcCByb3cgc2hvd3MgdGhlIGFpcmNyYWZ0JnJzcXVvO3MgY2FsbHNpZ24sIHdoYXQgaXRcXCdzIGRvaW5nIChwYXJrZWQgYXQgYXByb24sJyxcbiAgICAgICAgICAgICAgICAgICAndXNpbmcgYSBydW53YXksIGZseWluZyB0byBhIGZpeCwgb24gYSBoZWFkaW5nLCBldGMpLCBhbmQgaXRzIGFzc2lnbmVkIGFsdGl0dWRlLiBUaGUgYm90dG9tIHJvdyBzaG93cyB0aGUgbW9kZWwnLFxuICAgICAgICAgICAgICAgICAgICcoe01PREVMfSBoZXJlLCB3aGljaCBpcyBhIHtNT0RFTE5BTUV9KSB0byB0aGUgbGVmdCwgaXRzIGRlc3RpbmF0aW9uIGluIHRoZSBtaWRkbGUsIGFuZCBpdHMgYXNzaWduZWQgc3BlZWQgdG8gdGhlIHJpZ2h0LidcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AuYWlyY3JhZnQubGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdC5yZXBsYWNlKCd7TU9ERUx9JywgcHJvcC5haXJjcmFmdC5saXN0WzBdLm1vZGVsLmljYW8pLnJlcGxhY2UoJ3tNT0RFTE5BTUV9JywgcHJvcC5haXJjcmFmdC5saXN0WzBdLm1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0dXRvcmlhbF9wb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3N0ZXAoe1xuICAgICAgICAgICAgdGl0bGU6ICdNb3ZpbmcgYWlyY3JhZnQnLFxuICAgICAgICAgICAgdGV4dDogWydPbmNlIHtDQUxMU0lHTn0gaGFzIHRha2VuIG9mZiwgeW91XFwnbGwgbm90aWNlIGl0IHdpbGwgY2xpbWIgdG8ge0lOSVRfQUxUfSBieSBpdHNlbGYuIFRoaXMgaXMgb25lIG9mIHRoZSBpbnN0cnVjdGlvbnMgJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlIGdhdmUgdGhlbSB3aGVuIHdlIGNsZWFyZWQgdGhlbSAmbHNxdW87YXMgZmlsZWQmcnNxdW87LiBBaXJjcmFmdCBwZXJmb3JtIGJldHRlciB3aGVuIHRoZXkgYXJlIGFibGUgdG8gY2xpbWIgZGlyZWN0bHknLFxuICAgICAgICAgICAgICAgICAgICAnZnJvbSB0aGUgZ3JvdW5kIHRvIHRoZWlyIGNydWlzZSBhbHRpdHVkZSB3aXRob3V0IGxldmVsaW5nIG9mZiwgc28gbGV0XFwncyBrZWVwIHRoZW0gY2xpbWJpbmchIENsaWNrIGl0IGFuZCB0eXBlICZsc3F1bztjdnMmcnNxdW87IChmb3InLFxuICAgICAgICAgICAgICAgICAgICAnJmxzcXVvO2NsaW1iIHZpYSBTSUQmcnNxdW87KS4gVGhlbiB0aGV5IHdpbGwgZm9sbG93IHRoZSBhbHRpdHVkZXMgYW5kIHNwZWVkcyBkZWZpbmVkIGluIHRoZSB7U0lEX05BTUV9IGRlcGFydHVyZScsXG4gICAgICAgICAgICAgICAgICAgICdwcm9jZWR1cmUuIEZlZWwgZnJlZSB0byBjbGljayB0aGUgc3BlZWR1cCBidXR0b24gb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGlucHV0IGJveCAoaXQmcnNxdW87cyB0d28gc21hbGwgYXJyb3dzKScsXG4gICAgICAgICAgICAgICAgICAgICd0byB3YXRjaCB0aGUgZGVwYXJ0dXJlIGNsaW1iIGFsb25nIHRoZSBTSUQuIFRoZW4ganVzdCBjbGljayBpdCBhZ2FpbiB0byByZXR1cm4gdG8gMXggc3BlZWQuJ1xuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBwYXJzZTogKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC5haXJjcmFmdC5saXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0LnJlcGxhY2UoJ3tDQUxMU0lHTn0nLCBwcm9wLmFpcmNyYWZ0Lmxpc3RbMF0uZ2V0Q2FsbHNpZ24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7SU5JVF9BTFR9Jywgd2luZG93LmFpcnBvcnRDb250cm9sbGVyLmFpcnBvcnRfZ2V0KCkuaW5pdGlhbF9hbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgne1NJRF9OQU1FfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0RlcGFydHVyZSBkZXN0aW5hdGlvbnMnLFxuICAgICAgICAgICAgdGV4dDogWydJZiB5b3Ugem9vbSBvdXQgKHVzaW5nIHRoZSBtb3VzZSB3aGVlbCkgYW5kIGNsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAnb24ge0NBTExTSUdOfSwgeW91IHdpbGwgc2VlIGEgYmx1ZSBkYXNoZWQgbGluZSB0aGF0IHNob3dzIHdoZXJlIHRoZXkgYXJlIGhlYWRpbmcuIEF0IHRoZSBlbmQgb2YgdGhlJyxcbiAgICAgICAgICAgICAgICAgICAnbGluZSBpcyBpdHMgJmxzcXVvO2RlcGFydHVyZSBmaXgmcnNxdW87LiBZb3VyIGdvYWwgaXMgdG8gZ2V0IGV2ZXJ5IGRlcGFydHVyZSBjbGVhcmVkIHRvIHRoZWlyIGZpbGVkIGRlcGFydHVyZSBmaXguIEFzJyxcbiAgICAgICAgICAgICAgICAgICAneW91IGhhdmUgcHJvYmFibHkgbm90aWNlZCwgdGhpcyBpcyB2ZXJ5IGVhc3kgd2l0aCBTSURzLCBhcyB0aGUgYWlyY3JhZnQgZG8gYWxsIHRoZSBoYXJkIHdvcmsgdGhlbXNlbHZlcy4nXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQucmVwbGFjZSgne0NBTExTSUdOfScsIHByb3AuYWlyY3JhZnQubGlzdFswXS5nZXRDYWxsc2lnbigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogdHV0b3JpYWxfcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnQmFzaWMgQ29udHJvbCBJbnN0cnVjdGlvbnM6IEFsdGl0dWRlJyxcbiAgICAgICAgICAgIHRleHQ6IFsnWW91IGNhbiBhc3NpZ24gYWx0aXR1ZGVzIHdpdGggdGhlICZsc3F1bztjbGltYiZyc3F1bzsgY29tbWFuZCwgb3IgYW55IG9mIGl0cyBhbGlhc2VzIChvdGhlciB3b3JkcyB0aGF0JyxcbiAgICAgICAgICAgICAgICAgICAnYWN0IGlkZW50aWNhbGx5KS4gUnVubmluZyB0aGUgY29tbWFuZCAmbHNxdW87Y2xpbWImcnNxdW87IGlzIHRoZSBzYW1lIGFzIHRoZSBjb21tYW5kcyAmbHNxdW87ZGVzY2VuZCZyc3F1bzssICZsc3F1bztkJnJzcXVvOywnLFxuICAgICAgICAgICAgICAgICAgICcmbHNxdW87Y2xlYXImcnNxdW87LCAmbHNxdW87YyZyc3F1bzssICZsc3F1bzthbHRpdHVkZSZyc3F1bzssIG9yICZsc3F1bzthJnJzcXVvOy4gSnVzdCB1c2Ugd2hpY2hldmVyIGZlZWxzIGNvcnJlY3QgaW4geW91ciBzaXR1YXRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAnUmVtZW1iZXIsIGp1c3QgYXMgaW4gcmVhbCBBVEMsIGFsdGl0dWRlcyBhcmUgQUxXQVlTIHdyaXR0ZW4gaW4gaHVuZHJlZHMgb2YgZmVldCwgZWcuICZsc3F1bztkZXNjZW5kIDMwJnJzcXVvOyBmb3IgMywwMDBmdCBvciAmbHNxdW87Y2xpbWInLFxuICAgICAgICAgICAgICAgICAgICcgMTAwJnJzcXVvOyBmb3IgMTAsMDAwZnQuJ1xuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBwYXJzZTogKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC5haXJjcmFmdC5saXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0LnJlcGxhY2UoJ3tDQUxMU0lHTn0nLCBwcm9wLmFpcmNyYWZ0Lmxpc3RbMF0uZ2V0Q2FsbHNpZ24oKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0Jhc2ljIENvbnRyb2wgSW5zdHJ1Y3Rpb25zOiBSYWRhciBWZWN0b3JzJyxcbiAgICAgICAgICAgIHRleHQ6IFsnUmFkYXIgdmVjdG9ycyBhcmUgYW4gYWlyIHRyYWZmaWMgY29udHJvbGxlclxcJ3Mgd2F5IG9mIHRlbGxpbmcgYWlyY3JhZnQgdG8gZmx5IGEgc3BlY2lmaWMgbWFnbmV0aWMgaGVhZGluZy4gV2UgY2FuIGdpdmUgYWlyY3JhZnQgcmFkYXInLFxuICAgICAgICAgICAgICAgICAgICd2ZWN0b3JzIGluIHRocmVlIHdheXMuIFVzdWFsbHksIHlvdSB3aWxsIHVzZSAmbHNxdW87dCBsICMjIyZyc3F1bzsgb3IgJmxzcXVvO3QgciAjIyMmcnNxdW87LiBCZSBjYXJlZnVsLCBhcyBpdCBpcyBib3RoIGVhc3knLFxuICAgICAgICAgICAgICAgICAgICdhbmQgZGFuZ2Vyb3VzIHRvIGdpdmUgYSB0dXJuIGluIHRoZSB3cm9uZyBkaXJlY3Rpb24uIElmIHRoZSBoZWFkaW5nIGlzIG9ubHkgc2xpZ2h0bHkgbGVmdCBvciByaWdodCwgdG8gYXZvaWQgY2hvb3NpbmcgdGhlIHdyb25nIGRpcmVjdGlvbiwnLFxuICAgICAgICAgICAgICAgICAgICd5b3UgY2FuIHRlbGwgdGhlbSB0byAmbHNxdW87Zmx5IGhlYWRpbmcmcnNxdW87IGJ5IHR5cGluZyAmbHNxdW87ZmgjIyMmcnNxdW87LCBhbmQgdGhlIGFpcmNyYWZ0IHdpbGwgc2ltcGx5IHR1cm4gdGhlIHNob3J0ZXN0IGRpcmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgJ3RvIGZhY2UgdGhhdCBoZWFkaW5nLidcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0Jhc2ljIENvbnRyb2wgSW5zdHJ1Y3Rpb25zOiBTcGVlZCcsXG4gICAgICAgICAgICB0ZXh0OiBbJ1NwZWVkIGNvbnRyb2wgaXMgdGhlIFRSQUNPTiBjb250cm9sbGVyXFwncyBiZXN0IGZyaWVuZC4gTWFraW5nIGdvb2QgdXNlIG9mIHNwZWVkIGNvbnRyb2wgY2FuIGhlbHAga2VlcCB0aGUgcGFjZSBtYW5hZ2VhYmxlIGFuZCBhbGxvdycsXG4gICAgICAgICAgICAgICAgICAgJ3lvdSB0byBjYXJlZnVsbHkgc3F1ZWV6ZSBhaXJjcmFmdCBjbG9zZXIgYW5kIGNsb3NlciB0byBtaW5pbXVtcyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzYWZldHkuIFRvIGVudGVyIHNwZWVkIGluc3RydWN0aW9ucywgdXNlIHRoZScsXG4gICAgICAgICAgICAgICAgICAgJyZsc3F1bzsrJnJzcXVvOyBhbmQgJmxzcXVvOy0mcnNxdW87IGtleXMgb24gdGhlIG51bXBhZCwgZm9sbG93ZWQgYnkgdGhlIHNwZWVkLCBpbiBrbm90cy4gTm90ZSB0aGF0IHRoaXMgYXNzaWduZWQgc3BlZWQgaXMgaW5kaWNhdGVkJyxcbiAgICAgICAgICAgICAgICAgICAnYWlyc3BlZWQsIGFuZCBvdXIgcmFkYXIgc2NvcGUgY2FuIG9ubHkgZGlzcGxheSBncm91bmRzcGVlZDsgc28sIHRoZSB2YWx1ZXMgbWF5IGJlIGRpZmZlcmVudC4nXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmFpcmNyYWZ0Lmxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQucmVwbGFjZSgve0FOR0xFfS9nLCBoZWFkaW5nX3RvX3N0cmluZyhwcm9wLmFpcmNyYWZ0Lmxpc3RbMF0uZGVzdGluYXRpb24pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogdHV0b3JpYWxfcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnRml4ZXMnLFxuICAgICAgICAgICAgdGV4dDogWydJbnN0ZWFkIG9mIGd1aWRpbmcgZWFjaCBhaXJjcmFmdCBiYXNlZCBvbiBoZWFkaW5nLCB5b3UgY2FuIGFsc28gY2xlYXIgZWFjaCBhaXJjcmFmdCB0byBwcm9jZWVkIHRvIGEgZml4IG9yIG5hdmFpZCAoc2hvd24gb24gdGhlIG1hcCcsXG4gICAgICAgICAgICAgICAgICAgJ2FzIGEgc21hbGwgdHJpYW5nbGUpLiBKdXN0IHVzZSB0aGUgY29tbWFuZCAmbHNxdW87Zml4JnJzcXVvOyBhbmQgdGhlIG5hbWUgb2YgYSBmaXgsIGFuZCB0aGUgYWlyY3JhZnQgd2lsbCBmbHkgdG8gaXQuIFVwb24gcGFzc2luZyB0aGUnLFxuICAgICAgICAgICAgICAgICAgICdmaXgsIGl0IHdpbGwgY29udGludWUgZmx5aW5nIGFsb25nIGl0cyBwcmVzZW50IGhlYWRpbmcuJ1xuICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBwYXJzZTogKHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC5haXJjcmFmdC5saXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0LnJlcGxhY2UoJ3tDQUxMU0lHTn0nLCBwcm9wLmFpcmNyYWZ0Lmxpc3RbMF0uZ2V0Q2FsbHNpZ24oKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ1Nob3J0Y3V0cycsXG4gICAgICAgICAgICB0ZXh0OiBbJ1lvdSBjYW4gZ2l2ZSBhbiBhaXJjcmFmdCBhIHNob3J0Y3V0IGluIGEgY2hhaW4gb2YgZml4ZXMgdGhyb3VnaCB1c2Ugb2YgdGhlICZsc3F1bztkaXJlY3QmcnNxdW87JyxcbiAgICAgICAgICAgICAgICAgICAnY29tbWFuZCAoJmxzcXVvO2RjdCZyc3F1bzspLiBBbHNvLCB5b3UgY2FuIGFkZCBtb3JlIGZpeGVzIHRvIHRoZSBlbmQgb2YgdGhhdCBsaXN0IHdpdGggdGhlJyxcbiAgICAgICAgICAgICAgICAgICAnJmxzcXVvO3Byb2NlZWQmcnNxdW87ICgmbHNxdW87cHImcnNxdW87KSBjb21tYW5kLiBUaGlzIGlzIHVzZWZ1bCB3aXRoIG92ZXJmbGlnaHRzLCBhbmQgd2hpbGUgeW91IGNhbiBoYXZlJyxcbiAgICAgICAgICAgICAgICAgICAnZGVwYXJ0aW5nIGFpcmNyYWZ0IHVzZSB0aGVzZSBjb21tYW5kcywgaXQgaXMgcHJvYmFibHkgZWFzaWVyIHRvIGFzc2lnbiB0aGVtIGEgU0lEIGlmIG9uZSBpcyBhdmFpbGFibGUgYXQgeW91ciBhaXJwb3J0LidcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0JvbiB2b3lhZ2UsIGFpcmNyYWZ0IScsXG4gICAgICAgICAgICB0ZXh0OiBbJ1doZW4gdGhlIGFpcmNyYWZ0IGNyb3NzZXMgdGhlIGFpcnNwYWNlIGJvdW5kYXJ5LCBpdCB3aWxsICcsXG4gICAgICAgICAgICAgICAgICAgJ2F1dG9tYXRpY2FsbHkgcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSBmbGlnaHQgc3RyaXAgYmF5IG9uIHRoZSByaWdodC4nLFxuICAgICAgICAgICAgICAgICAgICdDb25ncmF0dWxhdGlvbnMsIHlvdSZyc3F1bzt2ZSBzdWNjZXNzZnVsbHkgdGFrZW4gb2ZmIG9uZSBhaXJjcmFmdC4nXG4gICAgICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodikgPT4gdixcbiAgICAgICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0dXRvcmlhbF9wb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3N0ZXAoe1xuICAgICAgICAgICAgdGl0bGU6ICdBcnJpdmFscycsXG4gICAgICAgICAgICB0ZXh0OiBbJ05vdywgb250byBhcnJpdmFscy4gQ2xpY2sgb24gYW55IGFycml2aW5nIGFpcmNyYWZ0IGluIHRoZSByYWRhciBzY3JlZW47IGFmdGVyJyxcbiAgICAgICAgICAgICAgICAgICAneW91JnJzcXVvO3ZlIHNlbGVjdGVkIGl0LCB1c2UgdGhlIGFsdGl0dWRlL2hlYWRpbmcvc3BlZWQgY29udHJvbHMgeW91XFwndmUgbGVhcm5lZCBpbicsXG4gICAgICAgICAgICAgICAgICAgJ29yZGVyIHRvIGd1aWRlIGl0IHRvIGJlIGluIGZyb250IG9mIGEgcnVud2F5LiBNYWtlIHN1cmUgdG8gZ2V0IHRoZSBhaXJjcmFmdCBkb3duIHRvJyxcbiAgICAgICAgICAgICAgICAgICAnYXJvdW5kIDQsMDAwZnQsIGFuZCAxMC0xNSBuYXV0aWNhbCBtaWxlcyAoMi0zIHJhbmdlIHJpbmdzKSBhd2F5IGZyb20gdGhlIGFpcnBvcnQuJyxcbiAgICAgICAgICAgICAgICAgICAnV2hpbGUgeW91IHdvcmsgdGhlIGFpcnBsYW5lLCByZWFkIHRoZSBuZXh0IHN0ZXAuJ1xuICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBwYXJzZTogKHYpID0+IHYsXG4gICAgICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogdHV0b3JpYWxfcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnQXBwcm9hY2ggQ2xlYXJhbmNlcywgcGFydCAxJyxcbiAgICAgICAgICAgIHRleHQ6IFsnWW91IGNhbiBjbGVhciBhaXJjcmFmdCBmb3IgYW4gSUxTIGFwcHJvYWNoIHdpdGggdGhlICZxdW90O0lMUyZxdW90OyBjb21tYW5kLCBmb2xsb3dlZCBieSBhIHJ1bndheSBuYW1lLiBCZWZvcmUgeW91IGNhbiBkbyBzbywgaG93ZXZlciwnLFxuICAgICAgICAgICAgICAgICAgICdpdCBtdXN0IGJlIG9uIGEgaGVhZGluZyB0aGF0IHdpbGwgY3Jvc3MgdGhlIHJ1bndheVxcJ3MgZXh0ZW5kZWQgY2VudGVybGluZSwgdGhhdCBpcyBubyBtb3JlIHRoYW4gMzAgZGVncmVlcyBvZmZzZXQgZnJvbSB0aGUnLFxuICAgICAgICAgICAgICAgICAgICdydW53YXlcXCdzIGhlYWRpbmcuIE9uY2Ugd2UgZXZlbnR1YWxseSBnaXZlIHRoZW0gYW4gYXBwcm9hY2ggY2xlYXJhbmNlLCB5b3UgY2FuIGV4cGVjdCBhaXJjcmFmdCB0byBjYXB0dXJlIHRoZSBJTFNcXCdzIGxvY2FsaXplcicsXG4gICAgICAgICAgICAgICAgICAgJ29uY2UgdGhleVxcJ3JlIHdpdGhpbiBhIGZldyBkZWdyZWVzIG9mIHRoZSBleHRlbmRlZCBjZW50ZXJsaW5lLidcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0FwcHJvYWNoIENsZWFyYW5jZXMsIHBhcnQgMicsXG4gICAgICAgICAgICB0ZXh0OiBbJ1doZW4geW91IGhhdmUgdGhlIGFpcmNyYWZ0IGZhY2luZyB0aGUgcmlnaHQgZGlyZWN0aW9uLCBqdXN0IHNlbGVjdCBpdCBhbmQgdHlwZSAmbHNxdW87aSAmbHQ7cnVud2F5Jmd0OyZyc3F1bzsnLFxuICAgICAgICAgICAgICAgICAgICd3aXRoIHRoZSBydW53YXkgdGhhdCZyc3F1bztzIGluIGZyb250IG9mIGl0LiBPbmNlIGl0XFwncyBjbG9zZSBlbm91Z2ggdG8gY2FwdHVyZSB0aGUgbG9jYWxpemVyLCB0aGUgYXNzaWduZWQgYWx0aXR1ZGUgb24gaXRzIHN0cmlwJyxcbiAgICAgICAgICAgICAgICAgICAnd2lsbCBjaGFuZ2UgdG8gJmxzcXVvO0lMUyBsb2NrZWQmcnNxdW87IChtZWFuaW5nIHRoZSBhaXJjcmFmdCBpcyBjYXBhYmxlIG9mIGd1aWRpbmcgaXRzZWxmIGRvd24gdG8gdGhlIHJ1bndheSB2aWEnLFxuICAgICAgICAgICAgICAgICAgICd0aGUgSW5zdHJ1bWVudCBMYW5kaW5nIFN5c3RlbSksIGFuZCB0aGUgYXNzaWduZWQgaGVhZGluZyBzaG91bGQgbm93IHNob3cgdGhlIHJ1bndheSB0byB3aGljaCBpdCBoYXMgYW4gYXBwcm9hY2ggY2xlYXJhbmNlLidcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ0FwcHJvYWNoIENsZWFyYW5jZXMsIHBhcnQgMycsXG4gICAgICAgICAgICB0ZXh0OiBbJ1lvdSBtYXkgY2hvb3NlIHRvIGVudGVyIG9uZSBjb21tYW5kIGF0IGEgdGltZSwgYnV0IGFpciB0cmFmZmljIGNvbnRyb2xsZXJzIHVzdWFsbHkgZG8gbXVsdGlwbGUuIFBhcnRpY3VsYXJseSBpbiBhcHByb2FjaCBjbGVhcmFuY2VzLCcsXG4gICAgICAgICAgICAgICAgICAgJ3RoZXkgZm9sbG93IGFuIGFjcm9ueW0gJmxkcXVvO1BUQUMmcmRxdW87IGZvciB0aGUgZm91ciBlbGVtZW50cyBvZiBhbiBhcHByb2FjaCBjbGVhcmFuY2UsIHRoZSAmbHNxdW87VCZyc3F1bzsgYW5kICZsc3F1bztDJnJzcXVvOyBvZiB3aGljaCcsXG4gICAgICAgICAgICAgICAgICAgJ3N0YW5kIGZvciAmbHNxdW87VHVybiZyc3F1bzsgYW5kICZsc3F1bztDbGVhcmFuY2UmcnNxdW87LCBib3RoIG9mIHdoaWNoIHdlIGVudGVyZWQgc2VwYXJhdGVseSBpbiB0aGlzIHR1dG9yaWFsLiBUaG91Z2ggbG9uZ2VyLCBpdCBpcyBib3RoICcsXG4gICAgICAgICAgICAgICAgICAgJ2Vhc2llciBhbmQgbW9yZSByZWFsLXdvcmxkIGFjY3VyYXRlIHRvIGVudGVyIHRoZW0gdG9nZXRoZXIsIGxpa2UgdGhpczogJmxzcXVvO2ZoMjUwIGkgMjhyJnJzcXVvOy4nXG4gICAgICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHBhcnNlOiAodikgPT4gdixcbiAgICAgICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0dXRvcmlhbF9wb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3N0ZXAoe1xuICAgICAgICAgICAgdGl0bGU6ICdBYm9ydGluZyBsYW5kaW5ncycsXG4gICAgICAgICAgICB0ZXh0OiBbJ0lmIHRoZSBhaXJjcmFmdCBpcyBlc3RhYmxpc2hlZCBvbiB0aGUgSUxTLCBpdCBzaG91bGQgYmUgYWJsZSB0byBsYW5kIG9uIHRoZSBydW53YXkuIEhvd2V2ZXIsIHNheSB0aGVyZSZyc3F1bztzIGFub3RoZXInLFxuICAgICAgICAgICAgICAgICAgICdhaXJjcmFmdCB0aGF0JnJzcXVvO3MgcGxhbm5pbmcgdG8gdGFrZSBvZmYgZnJvbSB0aGUgc2FtZSBydW53YXkuIFRvIGFib3J0IHRoZSBsYW5kaW5nLCB1c2UgdGhlIGNvbW1hbmQgJmxzcXVvO2Fib3J0JnJzcXVvOy4nLFxuICAgICAgICAgICAgICAgICAgICcoSWYgdGhlIGFpcmNyYWZ0IGlzIG5hdmlnYXRpbmcgdG8gYSBmaXgsIHRoZSAmbHNxdW87YWJvcnQmcnNxdW87IGNvbW1hbmQgd2lsbCBjbGVhciB0aGUgZml4IGluc3RlYWQuKSdcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ1dpbmQgc29jaycsXG4gICAgICAgICAgICB0ZXh0OiBbJ0luIHRoZSBsb3dlciByaWdodCBjb3JuZXIgb2YgdGhlIG1hcCBpcyBhIHNtYWxsIGNpcmNsZSB3aXRoIGEgbGluZS4gSXRcXCdzIGxpa2UgYSBmbGFnOiB0aGUgbGluZSB0cmFpbHMgaW4gdGhlIGRpcmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgJ3RoZSB3aW5kIGlzIGJsb3dpbmcgdG93YXJkLiBJZiBpdCZyc3F1bztzIHBvaW50aW5nIHN0cmFpZ2h0IGRvd24sIHRoZSB3aW5kIGlzIGJsb3dpbmcgZnJvbSB0aGUgTm9ydGgnLFxuICAgICAgICAgICAgICAgICAgICd0byB0aGUgU291dGguIEFpcmNyYWZ0IG11c3QgYmUgYXNzaWduZWQgdG8gZGlmZmVyZW50IHJ1bndheXMgc3VjaCB0aGF0IHRoZXkgYWx3YXlzIHRha2Ugb2ZmIGFuZCBsYW5kIGludG8gdGhlIHdpbmQsIHVubGVzcyB0aGUnLFxuICAgICAgICAgICAgICAgICAgICd3aW5kIGlzIGxlc3MgdGhhbiA1IGtub3RzLidcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfc3RlcCh7XG4gICAgICAgICAgICB0aXRsZTogJ1Njb3JlJyxcbiAgICAgICAgICAgIHRleHQ6IFsnVGhlIGxvd2VyLXJpZ2h0IGNvcm5lciBvZiB0aGUgcGFnZSBoYXMgYSBzbWFsbCBudW1iZXIgaW4gaXQ7IHRoaXMgaXMgeW91ciBzY29yZS4nLFxuICAgICAgICAgICAgICAgICAgICdXaGVuZXZlciB5b3Ugc3VjY2Vzc2Z1bGx5IHJvdXRlIGFuIGFpcmNyYWZ0IHRvIHRoZSBncm91bmQgb3Igb3V0IG9mIHRoZSBzY3JlZW4sIHlvdSBlYXJuIHBvaW50cy4gQXMgeW91IG1ha2UgbWlzdGFrZXMsJyxcbiAgICAgICAgICAgICAgICAgICAnbGlrZSBkaXJlY3RpbmcgYWlyY3JhZnQgdG8gYSBydW53YXkgd2l0aCBhIHN0cm9uZyBjcm9zc3dpbmQvdGFpbHdpbmQsIGxvc2luZyBzZXBhcmF0aW9uIGJldHdlZW4gYWlyY3JhZnQsIG9yIGlnbm9yaW5nIGFuJyxcbiAgICAgICAgICAgICAgICAgICAnYWlyY3JhZnQsIHlvdSB3aWxsIGFsc28gbG9zZSBwb2ludHMuIElmIHlvdSZyc3F1bztkIGxpa2UsIHlvdSBjYW4ganVzdCBpZ25vcmUgdGhlIHNjb3JlOyBpdCBkb2VzbiZyc3F1bzt0IGhhdmUgYW55IGVmZmVjdCcsXG4gICAgICAgICAgICAgICAgICAgJ3dpdGggdGhlIHNpbXVsYXRpb24uJ1xuICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBwYXJzZTogKHYpID0+IHYsXG4gICAgICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogdHV0b3JpYWxfcG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50dXRvcmlhbF9zdGVwKHtcbiAgICAgICAgICAgIHRpdGxlOiAnR29vZCBqb2IhJyxcbiAgICAgICAgICAgIHRleHQ6IFsnSWYgeW91JnJzcXVvO3ZlIGdvbmUgdGhyb3VnaCB0aGlzIGVudGlyZSB0dXRvcmlhbCwgeW91IHNob3VsZCBkbyBwcmV0dHkgd2VsbCB3aXRoIHRoZSBwcmVzc3VyZS4nLFxuICAgICAgICAgICAgICAgICAgICdJbiB0aGUgVFJBQ09OLCBtaW5pbXVtIHNlcGFyYXRpb24gaXMgMyBtaWxlcyBsYXRlcmFsbHkgb3IgMTAwMCBmZWV0IHZlcnRpY2FsbHkuIEtlZXAgdGhlbSBzZXBhcmF0ZWQsJyxcbiAgICAgICAgICAgICAgICAgICAna2VlcCB0aGVtIG1vdmluZywgYW5kIHlvdVxcJ2xsIGJlIGEgY29udHJvbGxlciBpbiBubyB0aW1lISdcbiAgICAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgcGFyc2U6ICh2KSA9PiB2LFxuICAgICAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHR1dG9yaWFsX3Bvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmb3IgVHV0b3JpYWxWaWV3XG4gICAgICogQG1ldGhvZCB0dXRvcmlhbF90b2dnbGVcbiAgICAgKi9cbiAgICB0dXRvcmlhbF90b2dnbGUoKSB7XG4gICAgICAgIGlmIChwcm9wLnR1dG9yaWFsLm9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxfY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxfb3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHR1dG9yaWFsX2dldFxuICAgICAqL1xuICAgIHR1dG9yaWFsX2dldChzdGVwID0gbnVsbCkge1xuICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgIHN0ZXAgPSBwcm9wLnR1dG9yaWFsLnN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcC50dXRvcmlhbC5zdGVwc1tzdGVwXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHR1dG9yaWFsX21vdmVcbiAgICAgKi9cbiAgICB0dXRvcmlhbF9tb3ZlKCkge1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy50dXRvcmlhbF9nZXQoKTtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IFszMCwgMTBdO1xuICAgICAgICBjb25zdCBsZWZ0ID0gc3RlcC5wb3NpdGlvblswXSAqICgkKHdpbmRvdykud2lkdGgoKSAtIHRoaXMuJHR1dG9yaWFsVmlldy5vdXRlcldpZHRoKCkgLSBwYWRkaW5nWzBdKTtcbiAgICAgICAgbGV0IHRvcCA9IHN0ZXAucG9zaXRpb25bMV0gKiAoJCh3aW5kb3cpLmhlaWdodCgpKTtcbiAgICAgICAgdG9wIC09ICh0aGlzLiR0dXRvcmlhbFZpZXcub3V0ZXJIZWlnaHQoKSAtIHBhZGRpbmdbMV0pO1xuXG4gICAgLy8gIGxlZnQgKz0gc3RlcC5wYWRkaW5nWzBdO1xuICAgIC8vICB0b3AgICs9IHN0ZXAucGFkZGluZ1sxXTtcblxuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcub2Zmc2V0KHtcbiAgICAgICAgICAgIHRvcDogcm91bmQodG9wKSxcbiAgICAgICAgICAgIGxlZnQ6IHJvdW5kKGxlZnQpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdHV0b3JpYWxfc3RlcFxuICAgICAqL1xuICAgIHR1dG9yaWFsX3N0ZXAob3B0aW9ucykge1xuICAgICAgICBwcm9wLnR1dG9yaWFsLnN0ZXBzLnB1c2gobmV3IFR1dG9yaWFsU3RlcChvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCB0dXRvcmlhbF91cGRhdGVfY29udGVudFxuICAgICAqL1xuICAgIHR1dG9yaWFsX3VwZGF0ZV9jb250ZW50KCkge1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy50dXRvcmlhbF9nZXQoKTtcblxuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcuZmluZCgnaDEnKS5odG1sKHN0ZXAudGl0bGUpO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcuZmluZCgnbWFpbicpLmh0bWwoc3RlcC5nZXRUZXh0KCkpO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcucmVtb3ZlQ2xhc3MoJ2xlZnQgcmlnaHQnKTtcblxuICAgICAgICBpZiAoc3RlcC5zaWRlID09PSBTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5MRUZUKSB7XG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFZpZXcuYWRkQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuTEVGVCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcC5zaWRlID09PSBTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5SSUdIVCkge1xuICAgICAgICAgICAgdGhpcy4kdHV0b3JpYWxWaWV3LmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLlJJR0hUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfbW92ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdHV0b3JpYWxfb3BlblxuICAgICAqL1xuICAgIHR1dG9yaWFsX29wZW4oKSB7XG4gICAgICAgIHByb3AudHV0b3JpYWwub3BlbiA9IHRydWU7XG5cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxWaWV3LmFkZENsYXNzKFNFTEVDVE9SUy5DTEFTU05BTUVTLk9QRU4pO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFRvZ2dsZS5hZGRDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5BQ1RJVkUpO1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFRvZ2dsZS5wcm9wKCd0aXRsZScsICdDbG9zZSB0dXRvcmlhbCcpO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfdXBkYXRlX2NvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHR1dG9yaWFsX2Nsb3NlXG4gICAgICovXG4gICAgdHV0b3JpYWxfY2xvc2UoKSB7XG4gICAgICAgIHByb3AudHV0b3JpYWwub3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuJHR1dG9yaWFsVmlldy5yZW1vdmVDbGFzcyhTRUxFQ1RPUlMuQ0xBU1NOQU1FUy5PUEVOKTtcbiAgICAgICAgdGhpcy4kdHV0b3JpYWxUb2dnbGUucmVtb3ZlQ2xhc3MoU0VMRUNUT1JTLkNMQVNTTkFNRVMuQUNUSVZFKTtcbiAgICAgICAgdGhpcy4kdHV0b3JpYWxUb2dnbGUucHJvcCgndGl0bGUnLCAnT3BlbiB0dXRvcmlhbCcpO1xuXG4gICAgICAgIHRoaXMudHV0b3JpYWxfbW92ZSgpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gbmV2ZXIgZ2V0cyBjYWxsZWQgaW4gdGhpcyBmaWxlXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCB0dXRvcmlhbF9jb21wbGV0ZVxuICAgICAqL1xuICAgIHR1dG9yaWFsX2NvbXBsZXRlKCkge1xuICAgICAgICBpZiAoIV9oYXMobG9jYWxTdG9yYWdlLCBTVE9SQUdFX0tFWS5GSVJTVF9SVU5fVElNRSkpIHtcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxfb3BlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlW1NUT1JBR0VfS0VZLkZJUlNUX1JVTl9USU1FXSA9IHRpbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHR1dG9yaWFsX25leHRcbiAgICAgKi9cbiAgICB0dXRvcmlhbF9uZXh0KCkge1xuICAgICAgICBpZiAocHJvcC50dXRvcmlhbC5zdGVwID09PSBwcm9wLnR1dG9yaWFsLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMudHV0b3JpYWxfY2xvc2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcC50dXRvcmlhbC5zdGVwID0gY2xhbXAoMCwgcHJvcC50dXRvcmlhbC5zdGVwICsgMSwgcHJvcC50dXRvcmlhbC5zdGVwcy5sZW5ndGggLSAxKTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3VwZGF0ZV9jb250ZW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCB0dXRvcmlhbF9wcmV2XG4gICAgICovXG4gICAgdHV0b3JpYWxfcHJldigpIHtcbiAgICAgICAgcHJvcC50dXRvcmlhbC5zdGVwID0gY2xhbXAoMCwgcHJvcC50dXRvcmlhbC5zdGVwIC0gMSwgcHJvcC50dXRvcmlhbC5zdGVwcy5sZW5ndGggLSAxKTtcblxuICAgICAgICB0aGlzLnR1dG9yaWFsX3VwZGF0ZV9jb250ZW50KCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBuZXZlciBnZXRzIGNhbGxlZCBpbiB0aGlzIGZpbGVcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHR1dG9yaWFsX3Jlc2l6ZVxuICAgICAqL1xuICAgIHR1dG9yaWFsX3Jlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy50dXRvcmlhbF9tb3ZlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IF9oYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgeyByYWRpb19uYW1lcyB9IGZyb20gJy4vdXRpbGl0aWVzL3JhZGlvVXRpbGl0aWVzJztcbmltcG9ydCB7IExPRyB9IGZyb20gJy4vY29uc3RhbnRzL2xvZ0xldmVsJztcblxuLyoqXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBjb250YWluZWQgaW4gdGhpcyBmaWxlIHNob3VsZCBiZSBtaWdyYXRlZCBvdmVyIHRvIHRoZSBgbWF0aC9gXG4gKiBmaWxlcyBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICpcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxsIGF0dGFjaGVkIHRvIHRoZSBgd2luZG93YCBhbmQgYXJlIGdsb2JhbCB0byB0aGVcbiAqIGVudGlyZSBhcHAuIFRoaXMgaXMgYSBwcm9ibGVtIGJlY2F1c2UgaXQgcG9sdXRlcyB0aGUgZ2xvYmFsIG5hbWVzcGFjZSxcbiAqIGFuZCBmaWxlcyB0aGF0IGRvbid0IG5lZWQgaXQgaGF2ZSBhY2Nlc3MgdG8gaXQuIFRoZXNlIGZ1bmN0aW9ucyBzaG91bGQgYmUgaW1wb3J0ZWRcbiAqIG9ubHkgYXMgbmVlZGVkLlxuICpcbiAqIFRoZXNlIGZ1bmN0aW9ucyBzaG91bGQgYWxzbyBoYXZlIGNvcnJlc3BvbmRpbmcgdGVzdHMuXG4gKlxuICovXG5cbndpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG5cbi8qZXNsaW50LWRpc2FibGUqL1xuLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBsb2Rhc2ggX2Nsb25lKClcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmIChudWxsID09IG9iaiB8fCAnb2JqZWN0JyAhPSB0eXBlb2Ygb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbGV0IGNvcHkgPSBvYmouY29uc3RydWN0b3IoKTtcbiAgICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgICAgICBpZiAoX2hhcyhvYmosIGF0dHIpKSB7XG4gICAgICAgICAgICBjb3B5W2F0dHJdID0gb2JqW2F0dHJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG4vLyBTdHJpbmcgcmVwZXRpdGlvbiBjb3BpZWQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3JlcGVhdCcpKSB7XG4gICAgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gdGhpcy52YWx1ZU9mKCk7XG5cbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvdW50ICYgMSkgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgICAgICAgICBjb3VudCA+Pj0gMSwgcGF0dGVybiArPSBwYXR0ZXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHBhdHRlcm47XG4gICAgfTtcbn1cblxuLyoqXG4gKiBOZWNlc3NhcnkgZm9yIEludGVybmV0IEV4cGxvcmVyIDExIChJRTExKSB0byBub3QgZGllIHdoaWxlIHVzaW5nIFN0cmluZy5mcm9tQ29kZVBvaW50KClcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbm90IG5hdGl2ZWx5IGF2YWlsYWJsZSBpbiBJRTExLCBhcyBub3RlZCBvbiB0aGlzIE1TRE4gcGFnZTpcbiAqIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG44OTA2MzAodj12cy45NCkuYXNweFxuICpcbiAqIEFwcGFyZW50bHksIGl0IGlzIGZpbmUgd2l0aCBwcmUtV2luOC4xIE1TIEVkZ2UgMTEsIGJ1dCBuZXZlciBva2F5IGluIElFLlxuICogSGVyZSwgdGhlIGZ1bmN0aW9uIGlzIGFkZGVkIHRvIHRoZSBTdHJpbmcgcHJvdG90eXBlIHRvIG1ha2UgbGF0ZXIgY29kZSB1c2FibGUuXG4gKlxuICogU29sdXRpb24gZnJvbTogaHR0cDovL3hhaGxlZS5pbmZvL2pzL2pzX3VuaWNvZGVfY29kZV9wb2ludC5odG1sXG4qL1xuaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIC8vIEVTNiBVbmljb2RlIFNoaW1zIDAuMSAsIMKpIDIwMTIgU3RldmVuIExldml0aGFuICwgTUlUIExpY2Vuc2VcbiAgICBTdHJpbmcuZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICAgIGxldCBwb2ludDtcbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgbGV0IHVuaXRzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIG9mZnNldCA9IHBvaW50IC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHVuaXRzID0gcG9pbnQgPiAweEZGRkYgPyBbMHhEODAwICsgKG9mZnNldCA+PiAxMCksIDB4REMwMCArIChvZmZzZXQgJiAweDNGRildIDogW3BvaW50XTtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1bml0cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG59XG5cbmNvbnN0IGxvZyA9IChtZXNzYWdlLCBsZXZlbCA9IExPRy5JTkZPKSA9PiB7XG4gICAgY29uc3QgbG9nU3RyaW5ncyA9IHtcbiAgICAgICAgMDogJ0RFQlVHJyxcbiAgICAgICAgMTogJ0lORk8nLFxuICAgICAgICAyOiAnV0FSTicsXG4gICAgICAgIDM6ICdFUlJPUicsXG4gICAgICAgIDQ6ICdGQVRBTCdcbiAgICB9O1xuXG4gICAgaWYgKHByb3AubG9nIDw9IGxldmVsKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBgWyAke2xvZ1N0cmluZ3NbbGV2ZWxdfSBdYDtcblxuICAgICAgICBpZiAobGV2ZWwgPj0gTE9HLldBUk5JTkcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0ZXh0LCBtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRleHQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbndpbmRvdy5sb2cgPSBsb2c7XG5cbi8qZXNsaW50LWVuYWJsZSovXG5cbi8vIFRPRE86IGlzIHRoaXMgYmVpbmcgdXNlZD8gYW5kIHdoeSBhcmUgd2UgY2xvbmluZyByYWRpb19uYW1lcyBoZXJlP1xuY29uc3QgcmFkaW9fcnVud2F5X25hbWVzID0gY2xvbmUocmFkaW9fbmFtZXMpO1xucmFkaW9fcnVud2F5X25hbWVzLmwgPSAnbGVmdCc7XG5yYWRpb19ydW53YXlfbmFtZXMuYyA9ICdjZW50ZXInO1xucmFkaW9fcnVud2F5X25hbWVzLnIgPSAncmlnaHQnO1xuXG4vLyBUT0RPOiByZW5hbWUgbGVmdFBhZFxuLyoqXG4gKiBQcmVwZW5kcyB6ZXJvcyB0byBmcm9udCBvZiBzdHIvbnVtIHRvIG1ha2UgaXQgdGhlIGRlc2lyZWQgd2lkdGhcbiAqL1xuZnVuY3Rpb24gbHBhZChuLCB3aWR0aCkge1xuICAgIGlmIChuLnRvU3RyaW5nKCkubGVuZ3RoID49IHdpZHRoKSB7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IGAwMDAwMDAwMDAwMDAwJHtufWA7XG5cbiAgICByZXR1cm4geC5zdWJzdHIoeC5sZW5ndGggLSB3aWR0aCwgd2lkdGgpO1xufVxuXG4vLyBGSVhNRTogdW51c2VkXG4vLyBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xuLy8gICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG4vLyB9XG4vLyB3aW5kb3cuZW5kc1dpdGggPSBlbmRzV2l0aDtcblxuXG4vLyBUT0RPOiBsb2Rhc2ggX2NvbXBhY3QoKSBtaWdodCBiZSB1c2VmdWwgaGVyZVxuLyoqXG4gKiBTcGxpY2VzIGFsbCBlbXB0eSBlbGVtZW50cyBvdXQgb2YgYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gYXJyYXlfY2xlYW4oYXJyYXksIGRlbGV0ZVZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGRlbGV0ZVZhbHVlKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIFRPRE86IHRoaXMgY2FuIGJlIGRvbmUgd2l0aCAucmVkdWNlKClcbi8qKlxuICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCBudW1lcmljYWwgdmFsdWVzIGluIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBhcnJheV9zdW0oYXJyYXkpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBwYXJzZUZsb2F0KGFycmF5W2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG59XG5cbndpbmRvdy5jbG9uZSA9IGNsb25lO1xuLy8gd2luZG93LmRpc3RFdWNsaWQgPSBkaXN0RXVjbGlkO1xud2luZG93LmxwYWQgPSBscGFkO1xud2luZG93LmFycmF5X2NsZWFuID0gYXJyYXlfY2xlYW47XG53aW5kb3cuYXJyYXlfc3VtID0gYXJyYXlfc3VtO1xuIiwiaW1wb3J0IF9pc0FycmF5IGZyb20gJ2xvZGFzaC9pc0FycmF5JztcblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zbGF0ZSBhIHVuaWNvZGUgY2hhcmFjdGVyIGludG8gYSByZWFkYWJsZSBzdHJpbmcgdmFsdWVcbiAqXG4gKiBAbWV0aG9kIHVuaWNvZGVUb1N0cmluZ1xuICogQHBhcmFtIGNoYXIge2NoYXJhY3RlckNvZGV9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCB1bmljb2RlVG9TdHJpbmcgPSAoY2hhcikgPT4gYFxcXFx1JHtjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9YDtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIGNob29zZVxuICovXG5leHBvcnQgY29uc3QgY2hvb3NlID0gKGwpID0+IHtcbiAgICBjb25zdCByYW5kb21JbmRleEZyb21MZW5ndGggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gbFtyYW5kb21JbmRleEZyb21MZW5ndGhdO1xufTtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIGNob29zZV93ZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGNob29zZV93ZWlnaHQgPSAobCkgPT4ge1xuICAgIGlmIChsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFfaXNBcnJheShsWzBdKSkge1xuICAgICAgICByZXR1cm4gY2hvb3NlKGwpO1xuICAgIH1cblxuICAgIC8vIGwgPSBbW2l0ZW0sIHdlaWdodF0sIFtpdGVtLCB3ZWlnaHRdIC4uLiBdO1xuICAgIGxldCB3ZWlnaHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB3ZWlnaHQgKz0gbFtpXVsxXTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5kb21XZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogd2VpZ2h0O1xuICAgIHdlaWdodCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2VpZ2h0ICs9IGxbaV1bMV07XG5cbiAgICAgICAgaWYgKHdlaWdodCA+IHJhbmRvbVdlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGxbaV1bMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnT0hTSElUJyk7XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCJpbXBvcnQgX2Nsb25lIGZyb20gJ2xvZGFzaC9jbG9uZSc7XG5pbXBvcnQgX2NvbXBhY3QgZnJvbSAnbG9kYXNoL2NvbXBhY3QnO1xuaW1wb3J0IF9tYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyB0YXUgfSBmcm9tICcuLi9tYXRoL2NpcmNsZSc7XG5cbi8qKlxuICogQHByb3BlcnR5IENBUkRJTkFMX0RJUkVDVElPTlxuICogQHR5cGUge0FycmF5fVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IENBUkRJTkFMX0RJUkVDVElPTiA9IFtcbiAgICAnTicsXG4gICAgJ05FJyxcbiAgICAnRScsXG4gICAgJ1NFJyxcbiAgICAnUycsXG4gICAgJ1NXJyxcbiAgICAnVycsXG4gICAgJ05XJyxcbiAgICAnTidcbl07XG5cbi8qKlxuICogQHByb3BlcnR5IHJhZGlvX25hbWVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCByYWRpb19uYW1lcyA9IHtcbiAgICAwOiAnemVybycsXG4gICAgMTogJ29uZScsXG4gICAgMjogJ3R3bycsXG4gICAgMzogJ3RocmVlJyxcbiAgICA0OiAnZm91cicsXG4gICAgNTogJ2ZpdmUnLFxuICAgIDY6ICdzaXgnLFxuICAgIDc6ICdzZXZlbicsXG4gICAgODogJ2VpZ2h0JyxcbiAgICA5OiAnbmluZXInLFxuICAgIDEwOiAndGVuJyxcbiAgICAxMTogJ2VsZXZlbicsXG4gICAgMTI6ICd0d2VsdmUnLFxuICAgIDEzOiAndGhpcnRlZW4nLFxuICAgIDE0OiAnZm91cnRlZW4nLFxuICAgIDE1OiAnZmlmdGVlbicsXG4gICAgMTY6ICdzaXh0ZWVuJyxcbiAgICAxNzogJ3NldmVudGVlbicsXG4gICAgMTg6ICdlaWdodGVlbicsXG4gICAgMTk6ICduaW5ldGVlbicsXG4gICAgMjA6ICd0d2VudHknLFxuICAgIDMwOiAndGhpcnR5JyxcbiAgICA0MDogJ2ZvdXJ0eScsXG4gICAgNTA6ICdmaWZ0eScsXG4gICAgNjA6ICdzaXh0eScsXG4gICAgNzA6ICdzZXZlbnR5JyxcbiAgICA4MDogJ2VpZ2h0eScsXG4gICAgOTA6ICduaW5ldHknLFxuICAgIGE6ICdhbHBoYScsXG4gICAgYjogJ2JyYXZvJyxcbiAgICBjOiAnY2hhcmxpZScsXG4gICAgZDogJ2RlbHRhJyxcbiAgICBlOiAnZWNobycsXG4gICAgZjogJ2ZveHRyb3QnLFxuICAgIGc6ICdnb2xmJyxcbiAgICBoOiAnaG90ZWwnLFxuICAgIGk6ICdpbmRpYScsXG4gICAgajogJ2p1bGlldCcsXG4gICAgazogJ2tpbG8nLFxuICAgIGw6ICdsaW1hJyxcbiAgICBtOiAnbWlrZScsXG4gICAgbjogJ25vdmVtYmVyJyxcbiAgICBvOiAnb3NjYXInLFxuICAgIHA6ICdwYXBhJyxcbiAgICBxOiAncXVlYmVjJyxcbiAgICByOiAncm9tZW8nLFxuICAgIHM6ICdzaWVycmEnLFxuICAgIHQ6ICd0YW5nbycsXG4gICAgdTogJ3VuaWZvcm0nLFxuICAgIHY6ICd2aWN0b3InLFxuICAgIHc6ICd3aGlza2V5JyxcbiAgICB4OiAneC1yYXknLFxuICAgIHk6ICd5YW5rZWUnLFxuICAgIHo6ICd6dWx1JyxcbiAgICAnLSc6ICdkYXNoJyxcbiAgICAnLic6ICdwb2ludCdcbn07XG5cbi8vIFRPRE86IHRoaXMgYW5kIENBUkRJTkFMX0RJUkVDVElPTiBzZWVtIHRvIGJlIGR1cGxpY2F0aW5nIGxvZ2ljLiBsb29rIGludG8gc21vb3RoaW5nIHRoYXQgb3V0IGJ5IHVzaW5nXG4vLyBqdXN0IHRoaXMgZW51bSBhbmQgYHRvVXBwZXJDYXNlKClgIHdoZXJlIG5lY2Vzc2FyeS5cbi8qKlxuICogQHByb3BlcnR5IHJhZGlvX2NhcmRpbmFsRGlyX25hbWVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGZpbmFsXG4gKi9cbmV4cG9ydCBjb25zdCByYWRpb19jYXJkaW5hbERpcl9uYW1lcyA9IHtcbiAgICBuOiAnbm9ydGgnLFxuICAgIG53OiAnbm9ydGh3ZXN0JyxcbiAgICB3OiAnd2VzdCcsXG4gICAgc3c6ICdzb3V0aHdlc3QnLFxuICAgIHM6ICdzb3V0aCcsXG4gICAgc2U6ICdzb3V0aGVhc3QnLFxuICAgIGU6ICdlYXN0JyxcbiAgICBuZTogJ25vcnRoZWFzdCdcbn07XG5cbi8vIFRPRE86IHByb2JhYmx5IGRvIHRoaXMgd2l0aCBPYmplY3QuYXNzaWduXG5leHBvcnQgY29uc3QgcmFkaW9fcnVud2F5X25hbWVzID0gX2Nsb25lKHJhZGlvX25hbWVzKTtcbnJhZGlvX3J1bndheV9uYW1lcy5sID0gJ2xlZnQnO1xucmFkaW9fcnVud2F5X25hbWVzLmMgPSAnY2VudGVyJztcbnJhZGlvX3J1bndheV9uYW1lcy5yID0gJ3JpZ2h0JztcblxuLy8gVE9ETzogaG93IGlzIHRoaXMgZGlmZmVyZW50IGZyb20gbHBhZD9cbi8vIE5PVCBJTiBVU0Vcbi8qKlxuICogRm9yY2UgYSBudW1iZXIgdG8gYSBzdHJpbmcgd2l0aCBhIHNwZWNpZmljICMgb2YgZGlnaXRzXG4gKlxuICogSWYgdGhlIHJvdW5kZWQgaW50ZWdlciBoYXMgbW9yZSBkaWdpdHMgdGhhbiByZXF1ZXN0ZWQsIGl0IHdpbGwgYmUgcmV0dXJuZWRcbiAqIGFueXdheSwgYXMgY2hvcHBpbmcgdGhlbSBvZmYgdGhlIGVuZCB3b3VsZCBjaGFuZ2UgdGhlIHZhbHVlIGJ5IG9yZGVycyBvZlxuICogbWFnbml0dWRlLCB3aGljaCBpcyBhbG1vc3QgZGVmaW5pdGVseSBnb2luZyB0byBiZSB1bmRlc2lyYWJsZS5cbiAqXG4gKiBAcGFyYW0gbnVtYmVyXG4gKiBAcGFyYW0gZGlnaXRzXG4gKiBAdHJ1bmNhdGUge2Jvb2xlYW59XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHdpdGggbGVhZGluZyB6ZXJvcyB0byByZWFjaCAnZGlnaXRzJyBwbGFjZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGRpZ2l0c19pbnRlZ2VyID0gKG51bWJlciwgZGlnaXRzLCB0cnVuY2F0ZSA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKHRydW5jYXRlKSB7XG4gICAgICAgIG51bWJlciA9IE1hdGguZmxvb3IobnVtYmVyKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIubGVuZ3RoID4gZGlnaXRzKSB7XG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLy8gYWRkIGxlYWRpbmcgemVyb3NcbiAgICB3aGlsZSAobnVtYmVyLmxlbmd0aCA8IGRpZ2l0cykge1xuICAgICAgICBudW1iZXIgPSBgMCR7bnVtYmVyfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bWJlcjtcbn07XG5cbi8qKlxuICogUm91bmQgYSBudW1iZXIgdG8gYSBzcGVjaWZpYyAjIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbFxuICpcbiAqIEFsc28gc3VwcG9ydHMgbmVnYXRpdmUgZGlnaXRzLiBFeDogJy0yJyB3b3VsZCBkbyA1NDEuMjQ2IC0tPiA1MDBcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gKG9wdGlvbmFsKSBGb3JjZXMgcHJlc2VuY2Ugb2YgdHJhaWxpbmcgemVyb3MuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgTXVzdCBiZSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCAnMycgdG8gYmUgYWJsZSB0byBnbyB0byAnMy4wJywgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgJzMyLjE2ODQyMCcgdG8gbm90IGJlIHNxdWlzaGVkIHRvICczMi4xNjg0MicuIElmIHRydWUsIGZ4biB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgc3RyaW5nLCBiZWNhdXNlIG90aGVyd2lzZSwganMgcmVtb3ZlcyBhbGwgdHJhaWxpbmcgemVyb3MuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRydW5jYXRlIC0gKG9wdGlvbmFsKSBTZWxlY3RzIHNob3J0ZW5pbmcgbWV0aG9kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRydW5jYXRlOiAndHJ1ZScsIHRvIHJvdW5kOiAnZmFsc2UnIChkZWZhdWx0KVxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgIGlmICFmb3JjZVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgIGlmIGZvcmNlXG4gKi9cbmV4cG9ydCBjb25zdCBkaWdpdHNfZGVjaW1hbCA9IChudW1iZXIsIGRpZ2l0cywgZm9yY2UsIHRydW5jYXRlKSA9PiB7XG4gICAgY29uc3Qgc2hvcnRlbiA9ICh0cnVuY2F0ZSkgPyBNYXRoLmZsb29yIDogTWF0aC5yb3VuZDtcblxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuIHNob3J0ZW4obnVtYmVyICogTWF0aC5wb3coMTAsIGRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgbmVlZHMgZXh0cmEgdHJhaWxpbmcgemVyb3NcbiAgICBpZiAoZGlnaXRzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIChzaG9ydGVuKG51bWJlciAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG51bWJlcltpXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGluZ0RpZ2l0cyA9IG51bWJlci5sZW5ndGggLSAoaSArIDEpO1xuXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdEaWdpdHMgPT09IGRpZ2l0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhaWxpbmdEaWdpdHMgPCBkaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgQXJyYXkoZGlnaXRzIC0gdHJhaWxpbmdEaWdpdHMgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWlsaW5nRGlnaXRzID4gZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIuc3Vic3RyKDAsIG51bWJlci5sZW5ndGggLSAodHJhaWxpbmdEaWdpdHMgLSBkaWdpdHMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBudW1iZXIubGVuZ3RoIC0gKHRyYWlsaW5nRGlnaXRzIC0gZGlnaXRzICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydDEgPSBudW1iZXIuc3Vic3RyKDAsIGxlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydDIgPSAoZGlnaXRzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgICAgIDogc2hvcnRlbihwYXJzZUludChudW1iZXIuc3Vic3RyKGxlbiwgMiksIDEwKSAvIDEwKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxICsgcGFydDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0R3JvdXBpbmdcbiAqIEBwYXJhbSBncm91cGFibGUge2FycmF5fVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZ2V0R3JvdXBpbmcgPSAoZ3JvdXBhYmxlKSA9PiB7XG4gICAgY29uc3QgZGlnaXQxID0gZ3JvdXBhYmxlWzBdO1xuICAgIGNvbnN0IGRpZ2l0MiA9IGdyb3VwYWJsZVsxXTtcblxuICAgIGlmIChkaWdpdDEgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZ2l0MiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdodW5kcmVkJztcbiAgICAgICAgfVxuICAgICAgICAvLyBqdXN0IGRpZ2l0cyAoZWcgJ3plcm8gc2V2ZW4nKVxuICAgICAgICByZXR1cm4gYCR7cmFkaW9fbmFtZXNbZGlnaXQxXX0gJHtyYWRpb19uYW1lc1tkaWdpdDJdfWA7XG4gICAgfSBlbHNlIGlmIChkaWdpdDEgPT09IDEpIHtcbiAgICAgICAgLy8gZXhhY3QgbnVtYmVyIChlZyAnc2V2ZW50ZWVuJylcbiAgICAgICAgcmV0dXJuIHJhZGlvX25hbWVzW2dyb3VwYWJsZV07XG4gICAgfSBlbHNlIGlmIChkaWdpdDEgPj0gMikge1xuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gYCR7ZGlnaXQxfTBgO1xuXG4gICAgICAgIGlmIChkaWdpdDIgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkICdmaXZlIHR3ZW50eSB6ZXJvJ1xuICAgICAgICAgICAgcmV0dXJuIHJhZGlvX25hbWVzW2ZpcnN0RGlnaXRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbWJvIG51bWJlciAoZWcgJ2ZpZnR5IG9uZScpXG4gICAgICAgIHJldHVybiBgJHtyYWRpb19uYW1lc1tmaXJzdERpZ2l0XX0gJHtyYWRpb19uYW1lc1tkaWdpdDJdfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3JhZGlvX25hbWVzW2RpZ2l0MV19ICR7cmFkaW9fbmFtZXNbZGlnaXQyXX1gO1xufTtcblxuLy8gVE9ETzogdGhpcyBuZWVkcyB0byBiZSBzaW1wbGlmaWVkXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gZ3JvdXBOdW1iZXJzXG4gKiBAcGFyYW0gY2FsbHNpZ24ge3N0cmluZ31cbiAqIEBwYXJhbSBhaXJsaW5lIHtzdHJpbmd9IChvcHRpb25hbClcbiAqIEByZXR1cm5cbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwTnVtYmVycyA9IChjYWxsc2lnbiwgYWlybGluZSkgPT4ge1xuICAgIGlmICghL15cXGQrJC8udGVzdChjYWxsc2lnbikpIHtcbiAgICAgICAgLy8gR0EsIGVnICcxMTdLUycgPSAnb25lLW9uZS1zZXZlbi1raWxvLXNpZXJyYScpXG4gICAgICAgIGlmIChhaXJsaW5lID09PSAnTm92ZW1iZXInKSB7XG4gICAgICAgICAgICAvLyBjYWxsc2lnbiBcIk5vdmVtYmVyXCJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGNhbGxzaWduKSB7XG4gICAgICAgICAgICAgICAgLy8gb25lIGFmdGVyIGFub3RoZXIgKGVnICdvbmUgb25lIHNldmVuIGtpbG8gc2llcnJhJylcbiAgICAgICAgICAgICAgICBzLnB1c2gocmFkaW9fbmFtZXNbY2FsbHNpZ25ba11dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHMuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWlybGluZSBncm91cGVkLCBlZyAnMzExMEEnID0gJ3RoaXJ0eS1vbmUtdGVuLWFscGhhJ1xuICAgICAgICAvLyBkaXZpZGUgY2FsbHNpZ24gaW50byBhbHBoYS9udW1lcmljIHNlY3Rpb25zXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBjcyA9IGNhbGxzaWduO1xuICAgICAgICBsZXQgdGhpc0lzRGlnaXQ7XG4gICAgICAgIGxldCBpbmRleCA9IGNzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBsYXN0V2FzRGlnaXQgPSAhaXNOYU4ocGFyc2VJbnQoY3NbaW5kZXhdLCAxMCkpO1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzSXNEaWdpdCA9ICFpc05hTihwYXJzZUludChjc1tpbmRleF0sIDEwKSk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzSXNEaWdpdCA9PT0gbGFzdFdhc0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB0aGlzSXNEaWdpdCA9ICFpc05hTihwYXJzZUludChjc1tpbmRleF0sIDEwKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlY3Rpb25zLnVuc2hpZnQoY3Muc3Vic3RyKGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgY3MgPSBjcy5zdWJzdHIoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGxhc3RXYXNEaWdpdCA9IHRoaXNJc0RpZ2l0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgd29yZHMsIHNlY3Rpb24gYnkgc2VjdGlvblxuICAgICAgICBjb25zdCBzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHNlY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VJbnQoc2VjdGlvbnNbaV0sIDEwKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBhbHBoYSBzZWN0aW9uXG4gICAgICAgICAgICAgICAgcy5wdXNoKHJhZGlvX3NwZWxsT3V0KHNlY3Rpb25zW2ldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgc2VjdGlvblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VjdGlvbnNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaChzZWN0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wdXNoKHJhZGlvX25hbWVzW3NlY3Rpb25zW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wdXNoKGdldEdyb3VwaW5nKHNlY3Rpb25zW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wdXNoKGAke3JhZGlvX25hbWVzW3NlY3Rpb25zW2ldWzBdXX0gJHtnZXRHcm91cGluZyhzZWN0aW9uc1tpXS5zdWJzdHIoMSkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaChgJHtnZXRHcm91cGluZyhzZWN0aW9uc1tpXS5zdWJzdHIoMCwgMikpfSAke2dldEdyb3VwaW5nKHNlY3Rpb25zW2ldLnN1YnN0cigyKSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaChyYWRpb19zcGVsbE91dChzZWN0aW9uc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHMuam9pbignICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FOiB0aGlzIGJsb2NrIGlzIHVucmVhY2hhYmxlXG4gICAgICAgIHN3aXRjaCAoY2FsbHNpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxzaWduOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkaW9fbmFtZXNbY2FsbHNpZ25dOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0R3JvdXBpbmcoY2FsbHNpZ24pOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cmFkaW9fbmFtZXNbY2FsbHNpZ25bMF1dfSAke2dldEdyb3VwaW5nKGNhbGxzaWduLnN1YnN0cigxKSl9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Z2V0R3JvdXBpbmcoY2FsbHNpZ24uc3Vic3RyKDAsIDIpKX0gJHtnZXRHcm91cGluZyhjYWxsc2lnbi5zdWJzdHIoMikpfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsc2lnbjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICpcbiAqIEBmdW50aW9uIHJhZGlvX3J1bndheVxuICogQHBhcmFtIGlucHV0IHtzdHJpbmd9XG4gKiBAcmV0dXJuXG4gKi9cbmV4cG9ydCBjb25zdCByYWRpb19ydW53YXkgPSAoaW5wdXQpID0+IHtcbiAgICBpbnB1dCA9IGAke2lucHV0fSBgO1xuICAgIGlucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcblxuICAgIHJldHVybiBfY29tcGFjdChfbWFwKGlucHV0LCAobGV0dGVyT3JOdW1iZXIsIGkpID0+IHJhZGlvX3J1bndheV9uYW1lc1tpbnB1dFtpXV0pKS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gcmFkaW9faGVhZGluZ1xuICogQHBhcmFtIGhlYWRpbmcge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJhZGlvX2hlYWRpbmcgPSAoaGVhZGluZykgPT4ge1xuICAgIGNvbnN0IHN0ciA9IGhlYWRpbmcudG9TdHJpbmcoKTtcblxuICAgIHN3aXRjaCAoc3RyLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYHplcm8gemVybyAke3JhZGlvX25hbWVzW3N0cl19YDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGB6ZXJvICR7cmFkaW9fbmFtZXNbc3RyWzBdXX0gJHtyYWRpb19uYW1lc1tzdHJbMV1dfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCR7cmFkaW9fbmFtZXNbc3RyWzBdXX0gJHtyYWRpb19uYW1lc1tzdHJbMV1dfSAke3JhZGlvX25hbWVzW3N0clsyXV19YDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGluZztcbn07XG5cbi8qKlxuICpcbiAqIEBmdW5jdGlvbiByYWRpb19zcGVsbE91dFxuICogQHBhcmFtIGFscGhhbnVtZXJpY1xuICogQHJldHVyblxuICovXG5leHBvcnQgY29uc3QgcmFkaW9fc3BlbGxPdXQgPSAoYWxwaGFudW1lcmljKSA9PiB7XG4gICAgY29uc3Qgc3RyID0gYWxwaGFudW1lcmljLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgYXJyID0gW107XG5cbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogY2hhbmdlIHRvIF9tYXAoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKHJhZGlvX25hbWVzW3N0cltpXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIuam9pbignICcpO1xufTtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIHJhZGlvX2FsdGl0dWRlXG4gKiBAcGFyYW0gYWx0aXR1ZGVcbiAqIEByZXR1cm5cbiAqL1xuZXhwb3J0IGNvbnN0IHJhZGlvX2FsdGl0dWRlID0gKGFsdGl0dWRlKSA9PiB7XG4gICAgY29uc3QgYWx0X3MgPSBhbHRpdHVkZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHMgPSBbXTtcblxuICAgIC8vIFRPRE8gY2FuIHRoaXMgYmxvY2sgYmUgc2ltcGxpZmllZD9cbiAgICBpZiAoYWx0aXR1ZGUgPj0gMTgwMDApIHtcbiAgICAgICAgcy5wdXNoKCdmbGlnaHQgbGV2ZWwnLCByYWRpb19uYW1lc1thbHRfc1swXV0sIHJhZGlvX25hbWVzW2FsdF9zWzFdXSwgcmFkaW9fbmFtZXNbYWx0X3NbMl1dKTtcbiAgICB9IGVsc2UgaWYgKGFsdGl0dWRlID49IDEwMDAwKSB7XG4gICAgICAgIHMucHVzaChyYWRpb19uYW1lc1thbHRfc1swXV0sIHJhZGlvX25hbWVzW2FsdF9zWzFdXSwgJ3Rob3VzYW5kJyk7XG5cbiAgICAgICAgaWYgKCEoYWx0aXR1ZGUgJSAoTWF0aC5mbG9vcihhbHRpdHVkZSAvIDEwMDApICogMTAwMCkgPT09IDApKSB7XG4gICAgICAgICAgICBzLnB1c2gocmFkaW9fbmFtZXNbYWx0X3NbMl1dLCAnaHVuZHJlZCcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRpdHVkZSA+PSAxMDAwKSB7XG4gICAgICAgIHMucHVzaChyYWRpb19uYW1lc1thbHRfc1swXV0sICd0aG91c2FuZCcpO1xuXG4gICAgICAgIGlmICghKGFsdGl0dWRlICUgKE1hdGguZmxvb3IoYWx0aXR1ZGUgLyAxMDAwKSAqIDEwMDApID09PSAwKSkge1xuICAgICAgICAgICAgcy5wdXNoKHJhZGlvX25hbWVzW2FsdF9zWzFdXSwgJ2h1bmRyZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0aXR1ZGUgPj0gMTAwKSB7XG4gICAgICAgIHMucHVzaChyYWRpb19uYW1lc1thbHRfc1swXV0sICdodW5kcmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFsdGl0dWRlO1xuICAgIH1cblxuICAgIHJldHVybiBzLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICpcbiAqIEBmdW5jdGlvbiByYWRpb190cmVuZFxuICogQHBhcmFtIGNhdGVnb3J5XG4gKiBAcGFyYW0gbWVhc3VyZWRcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJhZGlvX3RyZW5kID0gKGNhdGVnb3J5LCBtZWFzdXJlZCwgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgQ0FURUdPUklFUyA9IHtcbiAgICAgICAgYWx0aXR1ZGU6IFsnZGVzY2VuZCBhbmQgbWFpbnRhaW4nLCAnY2xpbWIgYW5kIG1haW50YWluJywgJ21haW50YWluJ10sXG4gICAgICAgIHNwZWVkOiBbJ3JlZHVjZSBzcGVlZCB0bycsICdpbmNyZWFzZSBzcGVlZCB0bycsICdtYWludGFpbiBwcmVzZW50IHNwZWVkIG9mJ11cbiAgICB9O1xuXG4gICAgaWYgKG1lYXN1cmVkID4gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBDQVRFR09SSUVTW2NhdGVnb3J5XVswXTtcbiAgICB9XG5cbiAgICBpZiAobWVhc3VyZWQgPCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIENBVEVHT1JJRVNbY2F0ZWdvcnldWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBDQVRFR09SSUVTW2NhdGVnb3J5XVsyXTtcbn07XG5cbi8qKlxuICpcbiAqIEBmdW5jdGlvbiBnZXRDYXJkaW5hbERpcmVjdGlvblxuICogQHBhcmFtIGFuZ2xlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDYXJkaW5hbERpcmVjdGlvbiA9IChhbmdsZSkgPT4ge1xuICAgIHJldHVybiBDQVJESU5BTF9ESVJFQ1RJT05bcm91bmQoYW5nbGUgLyB0YXUoKSAqIDgpXTtcbn07XG4iLCIvKipcbiAqIEBwcm9wZXJ0eSBUSU1FX1NFQ09ORFNfT0ZGU0VUXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IFRJTUVfU0VDT05EU19PRkZTRVQgPSAwLjAwMTtcblxuLy8gVE9ETzogcmVuYW1lIGZ1bmN0aW9uXG4vKipcbiAqIEBmdW5jdGlvbiB0aW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAqIFRJTUVfU0VDT05EU19PRkZTRVQ7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBjYWxjdWxhdGVEZWx0YVRpbWVcbiAqIEBwYXJhbSAge251bWJlcn0gbGFzdEZyYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVEZWx0YVRpbWUgPSAobGFzdEZyYW1lKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWluKHRpbWUoKSAtIGxhc3RGcmFtZSwgMSAvIDIwKTtcbn07XG4iLCJpbXBvcnQgX2luY2x1ZGVzIGZyb20gJ2xvZGFzaC9pbmNsdWRlcyc7XG5pbXBvcnQgX2lzTnVtYmVyIGZyb20gJ2xvZGFzaC9pc051bWJlcic7XG5pbXBvcnQgX3N0YXJ0c1dpdGggZnJvbSAnbG9kYXNoL3N0YXJ0c1dpdGgnO1xuaW1wb3J0IHsgdGF1IH0gZnJvbSAnLi4vbWF0aC9jaXJjbGUnO1xuaW1wb3J0IHsgcm91bmQsIG1vZCB9IGZyb20gJy4uL21hdGgvY29yZSc7XG5pbXBvcnQgeyBUSU1FLCBSRUdFWCB9IGZyb20gJy4uL2NvbnN0YW50cy9nbG9iYWxDb25zdGFudHMnO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBERUNJTUFMX1JBRElYXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGZpbmFsXG4gKi9cbmNvbnN0IERFQ0lNQUxfUkFESVggPSAxMDtcblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gaXRzIG93biBmaWxlIG9uY2UgaXQgaGFzIGJlZW4gZmlsbGVkIGluIGEgbGl0dGxlIG1vcmVcbi8qKlxuICogQHByb3BlcnR5IFVOSVRfQ09OVkVSU0lPTl9DT05TVEFOVFNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBVTklUX0NPTlZFUlNJT05fQ09OU1RBTlRTID0ge1xuICAgIC8qKlxuICAgICAqIG5hdXRpY2FsIG1pbGUgcGVyIGtpbG9tZXRlciByYXRpb1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IE5NX0tNXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBOTV9LTTogMS44NTIsXG4gICAgLyoqXG4gICAgICogTWV0ZXJzIHRvIGZlZXQgcmF0aW9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNX0ZUXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBNX0ZUOiAwLjMwNDgsXG4gICAgLyoqXG4gICAgICoga2lsb21ldGVyIHBlciBmb290IHJhdGlvXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgS01fRlRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIEtNX0ZUOiAwLjAwMDMwNDgsXG4gICAgLyoqXG4gICAgICoga25vdHMgcGVyIG0vcyByYXRpb1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IEtOX01TXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBLTl9NUzogMC41MTQ0NDQ0NCxcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgdXNlZCB0byBvYnRhaW4gZmVldCBmcm9tIGEgZmxpZ2h0IGxldmVsIG51bWJlclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEZMX1RPX0ZUX01VTFRJUExJRVJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIEZMX1RPX0ZUX01VTFRJUExJRVI6IDEwMFxufTtcblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gaXRzIG93biBmaWxlIG9uY2UgaXQgaGFzIGJlZW4gZmlsbGVkIGluIGEgbGl0dGxlIG1vcmVcbi8qKlxuICogQHByb3BlcnR5IE5VTUJFUl9DT05TVEFOVFNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAZmluYWxcbiAqL1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9DT05TVEFOVFMgPSB7XG4gICAgLyoqXG4gICAgICogRGVncmVlcyBpbiBhIGNpcmNsZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEZVTExfQ0lSQ0xFX0RFR1JFRVNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIEZVTExfQ0lSQ0xFX0RFR1JFRVM6IDM2MFxufTtcblxuLyoqXG4gKiBuYXV0aWNhbCBtaWxlcyAtLT4ga2lsb21ldGVyc1xuICpcbiAqIEBmdW5jdGlvbiBrbVxuICogQHBhcmFtIG5tIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBrbSA9IChubSA9IDApID0+IHtcbiAgICByZXR1cm4gbm0gKiBVTklUX0NPTlZFUlNJT05fQ09OU1RBTlRTLk5NX0tNO1xufTtcblxuLyoqXG4gKiBraWxvbWV0ZXJzIC0tPiBuYXV0aWNhbCBtaWxlc1xuICpcbiAqIEBmdW5jdGlvbiBubVxuICogQHBhcmFtIGtpbG9tZXRlcnMge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IG5tID0gKGtpbG9tZXRlcnMgPSAwKSA9PiB7XG4gICAgcmV0dXJuIGtpbG9tZXRlcnMgLyBVTklUX0NPTlZFUlNJT05fQ09OU1RBTlRTLk5NX0tNO1xufTtcblxuLyoqXG4gKiBtZXRlcnMgLT4gZmVldFxuICpcbiAqIEBmdW5jdGlvbiBtX2Z0XG4gKiBAcGFyYW0ge251bWJlcn0gW21ldGVycz0wXVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbV9mdCA9IChtZXRlcnMgPSAwKSA9PiB7XG4gICAgcmV0dXJuIG1ldGVycyAvIFVOSVRfQ09OVkVSU0lPTl9DT05TVEFOVFMuTV9GVDtcbn07XG5cbi8qKlxuICoga2lsb21ldGVycyAtLT4gZmVldFxuICpcbiAqIEBmdW5jdGlvbiBrbV9mdFxuICogQHBhcmFtIGtpbG9tZXRlcnMge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGttX2Z0ID0gKGtpbG9tZXRlcnMgPSAwKSA9PiB7XG4gICAgcmV0dXJuIGtpbG9tZXRlcnMgLyBVTklUX0NPTlZFUlNJT05fQ09OU1RBTlRTLktNX0ZUO1xufTtcblxuLyoqXG4gKiBmZWV0IC0tPiBraWxvbWV0ZXJzXG4gKlxuICogQGZ1bmN0aW9uIGZ0X2ttXG4gKiBAcGFyYW0gbm0ge251bWJlcn1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZ0X2ttID0gKGZ0ID0gMCkgPT4ge1xuICAgIHJldHVybiBmdCAqIFVOSVRfQ09OVkVSU0lPTl9DT05TVEFOVFMuS01fRlQ7XG59O1xuXG4vKipcbiAqIGtub3RzIHRvIG0vc1xuICpcbiAqIEBmdW5jdGlvbiBrbl9tc1xuICogQHBhcmFtIGtuIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBrbl9tcyA9IChrbiA9IDApID0+IHtcbiAgICByZXR1cm4ga24gKiBVTklUX0NPTlZFUlNJT05fQ09OU1RBTlRTLktOX01TO1xufTtcblxuLyoqXG4gKiBjb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xuICpcbiAqIEBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzXG4gKiBAcGFyYW0gcmFkaWFucyB7bnVtYmVyfVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcmFkaWFuc1RvRGVncmVlcyA9IChyYWRpYW5zKSA9PiB7XG4gICAgcmV0dXJuIChyYWRpYW5zIC8gKHRhdSgpKSkgKiBOVU1CRVJfQ09OU1RBTlRTLkZVTExfQ0lSQ0xFX0RFR1JFRVM7XG59O1xuXG4vKipcbiAqIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gKlxuICogQGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnNcbiAqIEBwYXJhbSBkZWdyZWVzIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWdyZWVzVG9SYWRpYW5zID0gKGRlZ3JlZXMpID0+IHtcbiAgICByZXR1cm4gKGRlZ3JlZXMgLyBOVU1CRVJfQ09OU1RBTlRTLkZVTExfQ0lSQ0xFX0RFR1JFRVMpICogKHRhdSgpKTtcbn07XG5cbi8qKlxuICogTk9UIElOIFVTRVxuICogY29udmVydCBwaXhlbHMgdG8ga2lsb21ldGVycyBhdCB0aGUgY3VycmVudCBzY2FsZVxuICpcbiAqIEBmdW5jdGlvbiBweF90b19rbVxuICogQHBhcmFtICB7bnVtYmVyfSBwaXhlbHNcbiAqIEBwYXJhbSAge251bWJlcn0gc2NhbGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHB4X3RvX2ttID0gKHBpeGVscywgc2NhbGUpID0+IHtcbiAgICByZXR1cm4gcGl4ZWxzIC8gc2NhbGU7XG59O1xuXG4vKipcbiAqIE5PVCBJTiBVU0VcbiAqIGNvbnZlcnQga2lsb21ldGVycyB0byBwaXhlbHMgYXQgdGhlIGN1cnJlbnQgc2NhbGVcbiAqXG4gKiBAZnVuY3Rpb24ga21fdG9fcHhcbiAqIEBwYXJhbSAge251bWJlcn0ga2lsb21ldGVyc1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qga21fdG9fcHggPSAoa2lsb21ldGVycywgc2NhbGUpID0+IHtcbiAgICByZXR1cm4ga2lsb21ldGVycyAqIHNjYWxlO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY29udmVydE1pbnV0ZXNUb1NlY29uZHNcbiAqIEBwYXJhbSBtaW51dGVzIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0TWludXRlc1RvU2Vjb25kcyA9IChtaW51dGVzKSA9PiBtaW51dGVzICogNjA7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb252ZXJ0IGEgbnVtYmVyIHRvIHRob3VzYW5kcy5cbiAqXG4gKiBHaXZlbiBhIGZsaWdodGxldmVsIEZMMTgwLCB0aGlzIGZ1bmN0aW9uIG91dHB1dHMgMTgsMDAwXG4gKlxuICogQGZ1bmN0aW9uIGNvdmVydFRvVGhvdXNhbmRzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0VG9UaG91c2FuZHMgPSAodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlLCBERUNJTUFMX1JBRElYKSAqIFVOSVRfQ09OVkVSU0lPTl9DT05TVEFOVFMuRkxfVE9fRlRfTVVMVElQTElFUjtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXJcbiAqXG4gKiBUaGUgaW1wbGVtZW50b3Igd2lsbCBoYXZlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBgcGFyc2VJbnRgIHJldHVybnMgYE5hTmBcbiAqXG4gKiBAZnVuY3Rpb24gY29udmVydFN0cmluZ1RvTnVtYmVyXG4gKiBAcGFyYW0gIHZhbHVlIHtzdHJpbmd8Kn1cbiAqIEByZXR1cm4ge251bWJlcnxOYU59XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0U3RyaW5nVG9OdW1iZXIgPSAodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlLCBERUNJTUFMX1JBRElYKTtcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIGhlYWRpbmdfdG9fc3RyaW5nXG4gKiBAcGFyYW0gaGVhZGluZyB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgaGVhZGluZ190b19zdHJpbmcgPSAoaGVhZGluZykgPT4ge1xuICAgIGhlYWRpbmcgPSByb3VuZChtb2QocmFkaWFuc1RvRGVncmVlcyhoZWFkaW5nKSwgMzYwKSkudG9TdHJpbmcoKTtcblxuICAgIGlmIChoZWFkaW5nID09PSAnMCcpIHtcbiAgICAgICAgaGVhZGluZyA9ICczNjAnO1xuICAgIH1cblxuICAgIGlmIChoZWFkaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBoZWFkaW5nID0gYDAwJHtoZWFkaW5nfWA7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRpbmcubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGhlYWRpbmcgPSBgMCR7aGVhZGluZ31gO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkaW5nO1xufTtcblxuLyoqXG4gKiBBY2NlcHQgYSBsYXQvbG9uZyBjb29yZGluYXRlIGFuZCByZXR1cm4gYSB2YWx1ZSBpbiBkZWNpbWFsIG5vdGF0aW9uXG4gKlxuICogTGF0aXR1ZGUgYW5kIExvbmdpdHVkZSBudW1iZXJzIG1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqICAgRGVjaW1hbCBkZWdyZWVzIC0gJ040Ny4xMTIzODgxMTInXG4gKiAgIERlY2ltYWwgbWludXRlcyAtICdOMzhkMzguMTA5ODA4J1xuICogICBEZWNpbWFsIHNlY29uZHMgLSAnTjU4ZDI3bTEyLjEzOCdcbiAqXG4gKiBAZnVuY3Rpb24gcGFyc2VDb29yZGluYXRlXG4gKiBAcGFyYW0gY29vcmRpbmF0ZSB7c3RyaW5nfVxuICogQHJldHVybiB0cmFuc2Zvcm1lZENvb3JkaW5hdGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlQ29vcmRpbmF0ZSA9IChjb29yZGluYXRlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBSRUdFWC5MQVRfTE9ORy5leGVjKGNvb3JkaW5hdGUpO1xuXG4gICAgLy8gSWYgY29vcmRpbmF0ZSBhbHJlYWR5IGluIFdHUzg0IEVTUEc6NDMyNiBmb3JtICgnMzkuNDI3NjE4LCAtNzUuMjk2MDExJyksIGp1c3QgcmV0dXJuIGl0IGFzLWlzXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfVxuXG4gICAgY29uc3QgZGVncmVlcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xuICAgIGxldCBtaW51dGVzID0gMDtcbiAgICBsZXQgc2Vjb25kcyA9IDA7XG5cbiAgICAvLyBHYXRoZXIgbWludXRlcy9zZWNvbmRzIGFzIGRlY2ltYWwgb2YgYSBkZWdyZWUsIGlmIGF2YWlsYWJsZVxuICAgIGlmIChtYXRjaFs1XSAhPSBudWxsKSB7XG4gICAgICAgIG1pbnV0ZXMgPSAocGFyc2VGbG9hdChtYXRjaFs1XSkgKiBUSU1FLk9ORV9NSU5VVEVfSU5fSE9VUlMpO1xuXG4gICAgICAgIGlmIChtYXRjaFs4XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWNvbmRzID0gKHBhcnNlRmxvYXQobWF0Y2hbOF0pICogVElNRS5PTkVfU0VDT05EX0lOX0hPVVJTKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkZWNpbWFsRGVncmVlcyA9IGRlZ3JlZXMgKyBtaW51dGVzICsgc2Vjb25kcztcblxuICAgIC8vIEFwcGx5IG5lZ2F0aXZlIHRvIHZhbHVlIGlmIGNvb3JkaW5hdGUgaXMgXCJTb3V0aFwiIG9yIFwiV2VzdFwiXG4gICAgaWYgKFJFR0VYLlNXLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgICAgIGRlY2ltYWxEZWdyZWVzICo9IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNpbWFsRGVncmVlcztcbn07XG5cbi8qKlxuICogQWNjZXB0IGEgc3RyaW5nIGVsZXZhdGlvbiBhbmQgcmV0dXJuIGEgbnVtYmVyIHJlcHJlc2VudGluZyBlbGV2YXRpb24gaW4gZnQuXG4gKlxuICogQGZ1bmN0aW9uIHBhcnNlRWxldmF0aW9uXG4gKiBAcGFyYW0gZWxldmF0aW9uIHtzdHJpbmd9ICAgIGV4OiAxMy40ZnQsIDNtLCA1ZnRcbiAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgZWxldmF0aW9uIGluIGZlZXRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRWxldmF0aW9uID0gKGVsZXZhdGlvbikgPT4ge1xuICAgIC8vIFRPRE86IG1vdmUgdG8gbWFzdGVyIFJFR0VYIGNvbnN0YW50XG4gICAgLy8gdGhpcyByZWdleCB3aWxsIGNhdGNoIHRoZSBmb2xsb3dpbmc6IGAtYCwgYG1gLCBgZnRgLCBgSW5maW5pdHlgLCBhbmQgaXMgdXNlZCB0byBleHRyYWN0IGEgbnVtYmVyXG4gICAgLy8gZnJvbSBhIHN0cmluZyBjb250YWluaW5nIHRoZXNlIHN5bWJvbHMuXG4gICAgY29uc3QgUkVHRVggPSAvKC0pfChtfGZ0fEluZmluaXR5KS9naTtcblxuICAgIC8vIGlmIGl0cyBhIG51bWJlciwgd2UncmUgZG9uZSBoZXJlLlxuICAgIC8vIFRoaXMgd2lsbCBjYXRjaCB3aG9sZSBudW1iZXJzLCBmbG9hdHMsIEluZmluaXR5IGFuZCAtSW5maW5pdHkuXG4gICAgLy8gVGhpcyBjaGVja3MgaWYgc3RyaW5ncyBhcmUgZ2l2ZW4gd2lsbCBza2lwIHRoZSByZWdleCBhbmQgZXhpdCBlYXJseVxuICAgIC8vIEFsc28gc3RvcHMgdGhlIGZ1bmN0aW9uIGZyb20gcmV0dXJuaW5nIE5hTlxuICAgIGlmIChfaXNOdW1iZXIoZWxldmF0aW9uKSB8fCBlbGV2YXRpb24gPT09ICdJbmZpbml0eScgfHwgZWxldmF0aW9uID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbGV2YXRpb24pO1xuICAgIH1cblxuICAgIGxldCBwYXJzZWRFbGV2YXRpb24gPSBlbGV2YXRpb24ucmVwbGFjZShSRUdFWCwgJycpO1xuICAgIGNvbnN0IGVsZXZhdGlvblVuaXQgPSBlbGV2YXRpb24ubWF0Y2goUkVHRVgpO1xuXG4gICAgLy8gaWYgaXRzIGluIG1ldGVycywgY29udmVydCBpdCB0byBmZWV0XG4gICAgaWYgKF9pbmNsdWRlcyhlbGV2YXRpb25Vbml0LCAnbScpKSB7XG4gICAgICAgIHBhcnNlZEVsZXZhdGlvbiA9IG1fZnQocGFyc2VkRWxldmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBjYW1lIGluIGFzIGEgbmVnYXRpdmUgbnVtYmVyLHJldHVybiBpdCBhcyBhIG5lZ2F0aXZlIG51bWJlclxuICAgIGlmIChfc3RhcnRzV2l0aChlbGV2YXRpb24sICctJykpIHtcbiAgICAgICAgcGFyc2VkRWxldmF0aW9uICo9IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZEVsZXZhdGlvbik7XG59O1xuXG4iXX0=